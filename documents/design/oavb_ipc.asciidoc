= Interprocess Communication Recommendations for AVB/TSN
Andrew Elder
v0.1

== Introduction

The AVB/TSN software stack is comprised of a number of modules that implement protocol stacks specified by IEEE standards. Each of these protocols implement an  network facing interface and an application facing interface. The required application facing interface is described in some detail in http://avnu.org/wp-content/uploads/2014/05/AVnu_SWAPIs_v1.0.pdf[AVB Software Interfaces and Endpoint Architecture Guidelines]. Since a module running a particular protocol may be a standalone execution unit (for example a Linux daemon), an interprocess communication method is required to interface to the execution unit.

For portability reasons it is recommended to separate the implementation of the interprocess communication method as much as possible from the logic of the protocol implementation. This applies to both an application that is interfacing to an AVB/TSN module and the implementation of the AVB/TSN module itself.

Throughout this document the following terminology will be used.

Blocking call::
  Blocking means that the thread of execution is interrupted at some point to wait for an event of some type before completing.

Non-blocking call::
  Non-blocking means that the thread of execution completes the call without interruption.

Synchronous call::
  The call completes and return status information is available immediately because it was returned when the call returned. Also the calling application knows that all requested operations have been completed when the call returns.

Asynchronous call::
  The call completes but return status information is returned on by way of a different mechanism. The calling application does not know that requested operations have been completed and must rely on an alternative notification communication mechanism to confirm successful completion of requested operations.


== Sychronous Communication Interfaces

For the purposes of this document the following straw-man application interfaces are described:

.Straw-man Interfaces
[source,c/c++]
----

/*
 * An example showing setting of parameter XYZ.
 * /param setting The new value of XYZ.
 * /return 0 on success, otherwise a defined error code.
 */
int AVBTSN_SetXYZ(uint32_t setting);


/*
 * An example showing a command that requires multiple parameters.
 * /param stream_id The stream_id used by commanXYZ.
 * /param vlan The vlan used by commanXYZ.
 * /return 0 on success, otherwise a defined error code.
 */
int AVBTSN_CommandXYZ(uint64_t stream_id, uint32_t vlan);


----

where the AVBTSN portion of the function name would be replaced by the name of the IEEE AVB/TSN protocol module that is being targeted.

The synchonous communication interface is exposed by the module itself.

.... more text about this being usable for single .exe implementation

.... text to talk about #defining error codes

.... text about this being the public interface to the module and that async communication is implemented as a layer on top of this interface.


== Asynchronous Communication Interfaces

The asynchronous communication interface sits on top of the synchronous communication interface. It includes features to support error reporting, even though the errors may be handled by a different execution thread, or at a later time.

If application blocking to wait for a command to complete is desired, this can also be supported.  


=== Communication Stack Abstraction

This section outlines abstraction requirements for multiple layers. The layers that will be described here are represented in the following table.

[width="85%",options="header"]
|=======
|Layer |Description
|Application |Call APIs for AVB/TSN module
|Packing |Takes parameters from API calls and packs them for "transport"
|Communication |Send packed parameters
|Channel |Transfer information from source to destination
|Communication |Receive packed parameters
|Unpacking |Unpacks information from channel
|Module |This is the layer with equivalent calls to the top Application layer
|=======

==== Application Layer

The application layer requires a simple interface that has parameters that closely match those supported by the underlying module implementation. However, since the context for an underlying communication layer is required, an additional IPC context parameter must be added to the application's calling interface. The example straw-man interface now becomes:

.Straw-man Interfaces for External Application
[source,c/c++]
----
/*
 * An example showing setting of parameter XYZ.
 * /param ipc_context The interprocess communication context that was returned from an create_call. This contains information for the communication channel that is in use.
 * /param this_call_context This variable is used by the application to track the call status return. Upon completion of the call it is returned to the application. A recommended use for the this_call_conext would be for the calling application to allocate a structure that contains details of the command being called. A non-blocking implementation will return this pointer when the call status is returned and the application can decide on the appropriate action to take at that time.
 * /param setting The new value of XYZ.
 * /return 0 on success, otherwise a defined error code.
 */
void AVBTSN_SetParam(void *ipc_context, void *this_call_context, uint32_t param);

----

==== Packing Layer

The marshalling layer is responsible for encoding parameters into a defined structure for passing through the communication layer. The structure will include a field that defines what the structure contains and how large it is. This is so as to support routing the information to the correct synchronous call once the structure has passed over the communication channel. The packed layout should be in a standalone header file so that both the packing/send module and the unpacking/receiver module can reference that same layout specification.


.Straw-man packed structure layout example
[source,c/c++]
----

#define AVBTSN_COMMAND_SET_XYZ 1
#define AVBTSN_COMMAND_START 2

struct avbtsn_packing_header {
	uint32_t size;
	uint32_t command;
	void *this_call_context;
};

struct avbtsn_packing_command_set_xyz {
	struct avbtsn_packing_header header;
	int param;
};

struct avbtsn_packing_command_start {
	struct avbtsn_packing_header header;
	uint64_t streamID;
	uint32_t vlan;
};

----

Upon calling from the application, the packing layer performs the following operations
 1. allocates the correctly sized packing structure
 1. fills in the header size, command and this_call_context fields
 1. fills in call specific parameters and submits the data to the communication layer

After the application has sent a command it should call the communication layer again to recieve a response. This call could be via a explicit call, or in the case of single threaded application design a poll/WaitForMultipleObjects loop would handle an event for the receive socket/handle that indicates a packet of information containing the call response is ready to be processed.


==== Abstract Communication Layer

The communication layer has interfaces to open, close, send and receive data. The exact mechanisms for any of these functions depends on the concrete implementation which could cover Linux domain sockets, UDP, shared memory pipe, shared memory structures or any other implementation.

[source,c/c++]
----
struct oavb_ipc {
	void *private;
	int (*close)(struct oavb_ipc *ipc, void *flags);
	int (*open) (struct oavb_ipc *ipc, void *flags);
	int (*bind) (struct oavb_ipc *ipc, void *flags);
	int (*recv) (struct oavb_ipc *ipc, void *buf, int buflen);
	int (*send) (struct oavb_ipc *ipc, void *buf, int buflen);
	void (*free) (struct oavb_ipc *ipc);
#if defined __linux__
	int (*get_fd) (struct oavb_ipc *ipc);
#endif
};
----

==== Unpacking Layer

==== Module Interface Layer





