\hypertarget{class_memory_leak_detector}{}\section{Memory\+Leak\+Detector 클래스 참조}
\label{class_memory_leak_detector}\index{Memory\+Leak\+Detector@{Memory\+Leak\+Detector}}


{\ttfamily \#include $<$Memory\+Leak\+Detector.\+h$>$}



Memory\+Leak\+Detector에 대한 상속 다이어그램 \+: 
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=550pt]{class_memory_leak_detector__inherit__graph}
\end{center}
\end{figure}


Memory\+Leak\+Detector에 대한 협력 다이어그램\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=550pt]{class_memory_leak_detector__coll__graph}
\end{center}
\end{figure}
\subsection*{Public 타입}
\begin{DoxyCompactItemize}
\item 
enum \{ \hyperlink{class_memory_leak_detector_a81929fb3d21206b62f55bcb744f71d5da5220cc4ba0bebf171c9984d05561bcc2}{memory\+\_\+corruption\+\_\+buffer\+\_\+size} = 3
 \}
\end{DoxyCompactItemize}
\subsection*{Public 멤버 함수}
\begin{DoxyCompactItemize}
\item 
\hyperlink{class_memory_leak_detector_adce0cc8ded968fc3af6035ed9aebe949}{Memory\+Leak\+Detector} (\hyperlink{class_memory_leak_failure}{Memory\+Leak\+Failure} $\ast$reporter)
\item 
virtual \hyperlink{class_memory_leak_detector_aee92c9e1fa761a77145ad0b7b3b4e8e7}{$\sim$\+Memory\+Leak\+Detector} ()
\item 
void \hyperlink{class_memory_leak_detector_a486f22824bd83c5308a0d70ffac6f758}{enable} ()
\item 
void \hyperlink{class_memory_leak_detector_a8cfbbe53c1cf6e3054736daea3044c0f}{disable} ()
\item 
void \hyperlink{class_memory_leak_detector_a87bbe373712386442509ec83e9444021}{disable\+Allocation\+Type\+Checking} ()
\item 
void \hyperlink{class_memory_leak_detector_a4ef0d2380dbe5ecfa77d2d477d9047e9}{enable\+Allocation\+Type\+Checking} ()
\item 
void \hyperlink{class_memory_leak_detector_ae912c5ee9034b76f13f1c9dbab55e512}{start\+Checking} ()
\item 
void \hyperlink{class_memory_leak_detector_a9e85551d474d895ba8852b8e56481c7c}{stop\+Checking} ()
\item 
const char $\ast$ \hyperlink{class_memory_leak_detector_acc70330c27080c4b09b96342929dc9ca}{report} (\hyperlink{_memory_leak_detector_8h_ab248e6cc6c6699b88b002286d8a3ed76}{Mem\+Leak\+Period} period)
\item 
void \hyperlink{class_memory_leak_detector_a6db202697cf20e8d84748b129c403545}{mark\+Checking\+Period\+Leaks\+As\+Non\+Checking\+Period} ()
\item 
int \hyperlink{class_memory_leak_detector_a7b0c5d9c4d678d6e0081802416660803}{total\+Memory\+Leaks} (\hyperlink{_memory_leak_detector_8h_ab248e6cc6c6699b88b002286d8a3ed76}{Mem\+Leak\+Period} period)
\item 
void \hyperlink{class_memory_leak_detector_a6c18f981e1c2139528a10aa573ffeaa9}{clear\+All\+Accounting} (\hyperlink{_memory_leak_detector_8h_ab248e6cc6c6699b88b002286d8a3ed76}{Mem\+Leak\+Period} period)
\item 
char $\ast$ \hyperlink{class_memory_leak_detector_a15c9b9fb87d6e63d8972f03e25fb3cf5}{alloc\+Memory} (\hyperlink{class_test_memory_allocator}{Test\+Memory\+Allocator} $\ast$\hyperlink{_memory_leak_warning_test_8cpp_a83fc2e9b9142613f7df2bcc3ff8292bc}{allocator}, size\+\_\+t \hyperlink{gst__avb__playbin_8c_a439227feff9d7f55384e8780cfc2eb82}{size}, \hyperlink{avb__gptp_8h_af6a258d8f3ee5206d682d799316314b1}{bool} allocat\+Nodes\+Seperately=\hyperlink{avb__gptp_8h_af6a258d8f3ee5206d682d799316314b1ae9de385ef6fe9bf3360d1038396b884c}{false})
\item 
char $\ast$ \hyperlink{class_memory_leak_detector_ace7838f234f5dea076a6ab2528a66164}{alloc\+Memory} (\hyperlink{class_test_memory_allocator}{Test\+Memory\+Allocator} $\ast$\hyperlink{_memory_leak_warning_test_8cpp_a83fc2e9b9142613f7df2bcc3ff8292bc}{allocator}, size\+\_\+t \hyperlink{gst__avb__playbin_8c_a439227feff9d7f55384e8780cfc2eb82}{size}, const char $\ast$file, int line, \hyperlink{avb__gptp_8h_af6a258d8f3ee5206d682d799316314b1}{bool} allocat\+Nodes\+Seperately=\hyperlink{avb__gptp_8h_af6a258d8f3ee5206d682d799316314b1ae9de385ef6fe9bf3360d1038396b884c}{false})
\item 
void \hyperlink{class_memory_leak_detector_a1526d6f241a7f41eaeae20fd2c712873}{dealloc\+Memory} (\hyperlink{class_test_memory_allocator}{Test\+Memory\+Allocator} $\ast$\hyperlink{_memory_leak_warning_test_8cpp_a83fc2e9b9142613f7df2bcc3ff8292bc}{allocator}, void $\ast$memory, \hyperlink{avb__gptp_8h_af6a258d8f3ee5206d682d799316314b1}{bool} allocat\+Nodes\+Seperately=\hyperlink{avb__gptp_8h_af6a258d8f3ee5206d682d799316314b1ae9de385ef6fe9bf3360d1038396b884c}{false})
\item 
void \hyperlink{class_memory_leak_detector_a235bec7842c694f869f6edbf131a6c55}{dealloc\+Memory} (\hyperlink{class_test_memory_allocator}{Test\+Memory\+Allocator} $\ast$\hyperlink{_memory_leak_warning_test_8cpp_a83fc2e9b9142613f7df2bcc3ff8292bc}{allocator}, void $\ast$memory, const char $\ast$file, int line, \hyperlink{avb__gptp_8h_af6a258d8f3ee5206d682d799316314b1}{bool} allocat\+Nodes\+Seperately=\hyperlink{avb__gptp_8h_af6a258d8f3ee5206d682d799316314b1ae9de385ef6fe9bf3360d1038396b884c}{false})
\item 
char $\ast$ \hyperlink{class_memory_leak_detector_a6aded764a2297f52a104b75eae2d4b5c}{realloc\+Memory} (\hyperlink{class_test_memory_allocator}{Test\+Memory\+Allocator} $\ast$\hyperlink{_memory_leak_warning_test_8cpp_a83fc2e9b9142613f7df2bcc3ff8292bc}{allocator}, char $\ast$memory, size\+\_\+t \hyperlink{gst__avb__playbin_8c_a439227feff9d7f55384e8780cfc2eb82}{size}, const char $\ast$file, int line, \hyperlink{avb__gptp_8h_af6a258d8f3ee5206d682d799316314b1}{bool} allocat\+Nodes\+Seperately=\hyperlink{avb__gptp_8h_af6a258d8f3ee5206d682d799316314b1ae9de385ef6fe9bf3360d1038396b884c}{false})
\item 
void \hyperlink{class_memory_leak_detector_a1b924f98e6bf1203714985e0b0c3de5d}{invalidate\+Memory} (char $\ast$memory)
\item 
void \hyperlink{class_memory_leak_detector_ac17764ba8c2ced15cbbbca1731f6b21e}{remove\+Memory\+Leak\+Information\+Without\+Checking\+Or\+Deallocating\+The\+Memory\+But\+Deallocating\+The\+Account\+Information} (\hyperlink{class_test_memory_allocator}{Test\+Memory\+Allocator} $\ast$\hyperlink{_memory_leak_warning_test_8cpp_a83fc2e9b9142613f7df2bcc3ff8292bc}{allocator}, void $\ast$memory, \hyperlink{avb__gptp_8h_af6a258d8f3ee5206d682d799316314b1}{bool} allocat\+Nodes\+Seperately)
\item 
unsigned \hyperlink{class_memory_leak_detector_a774a54e55a1203f145f722609ae18317}{get\+Current\+Allocation\+Number} ()
\item 
\hyperlink{class_simple_mutex}{Simple\+Mutex} $\ast$ \hyperlink{class_memory_leak_detector_a19d27cb7dd06173cc88f58543bfe3020}{get\+Mutex} (void)
\end{DoxyCompactItemize}
\subsection*{Private 멤버 함수}
\begin{DoxyCompactItemize}
\item 
char $\ast$ \hyperlink{class_memory_leak_detector_a9f85c6601d58ad9a888439e5834ae237}{allocate\+Memory\+With\+Accounting\+Information} (\hyperlink{class_test_memory_allocator}{Test\+Memory\+Allocator} $\ast$\hyperlink{_memory_leak_warning_test_8cpp_a83fc2e9b9142613f7df2bcc3ff8292bc}{allocator}, size\+\_\+t \hyperlink{gst__avb__playbin_8c_a439227feff9d7f55384e8780cfc2eb82}{size}, const char $\ast$file, int line, \hyperlink{avb__gptp_8h_af6a258d8f3ee5206d682d799316314b1}{bool} allocat\+Nodes\+Seperately)
\item 
char $\ast$ \hyperlink{class_memory_leak_detector_a862b3c60768aa68ba86dd124a658266a}{reallocate\+Memory\+With\+Accounting\+Information} (\hyperlink{class_test_memory_allocator}{Test\+Memory\+Allocator} $\ast$\hyperlink{_memory_leak_warning_test_8cpp_a83fc2e9b9142613f7df2bcc3ff8292bc}{allocator}, char $\ast$memory, size\+\_\+t \hyperlink{gst__avb__playbin_8c_a439227feff9d7f55384e8780cfc2eb82}{size}, const char $\ast$file, int line, \hyperlink{avb__gptp_8h_af6a258d8f3ee5206d682d799316314b1}{bool} allocat\+Nodes\+Seperately)
\item 
\hyperlink{struct_memory_leak_detector_node}{Memory\+Leak\+Detector\+Node} $\ast$ \hyperlink{class_memory_leak_detector_a7ee2afe61a37ef68a82228bd91643442}{create\+Memory\+Leak\+Accounting\+Information} (\hyperlink{class_test_memory_allocator}{Test\+Memory\+Allocator} $\ast$\hyperlink{_memory_leak_warning_test_8cpp_a83fc2e9b9142613f7df2bcc3ff8292bc}{allocator}, size\+\_\+t \hyperlink{gst__avb__playbin_8c_a439227feff9d7f55384e8780cfc2eb82}{size}, char $\ast$memory, \hyperlink{avb__gptp_8h_af6a258d8f3ee5206d682d799316314b1}{bool} allocat\+Nodes\+Seperately)
\item 
\hyperlink{avb__gptp_8h_af6a258d8f3ee5206d682d799316314b1}{bool} \hyperlink{class_memory_leak_detector_aeb6f1872936e5c8b25300897c8d81096}{valid\+Memory\+Corruption\+Information} (char $\ast$memory)
\item 
\hyperlink{avb__gptp_8h_af6a258d8f3ee5206d682d799316314b1}{bool} \hyperlink{class_memory_leak_detector_acf1c0e015e90cc0ebe2b41cc1b4212b8}{matching\+Allocation} (\hyperlink{class_test_memory_allocator}{Test\+Memory\+Allocator} $\ast$alloc\+\_\+allocator, \hyperlink{class_test_memory_allocator}{Test\+Memory\+Allocator} $\ast$free\+\_\+allocator)
\item 
void \hyperlink{class_memory_leak_detector_ad65311ebd24859da19c751e2e42e796f}{store\+Leak\+Information} (\hyperlink{struct_memory_leak_detector_node}{Memory\+Leak\+Detector\+Node} $\ast$node, char $\ast$new\+\_\+memory, size\+\_\+t \hyperlink{gst__avb__playbin_8c_a439227feff9d7f55384e8780cfc2eb82}{size}, \hyperlink{class_test_memory_allocator}{Test\+Memory\+Allocator} $\ast$\hyperlink{_memory_leak_warning_test_8cpp_a83fc2e9b9142613f7df2bcc3ff8292bc}{allocator}, const char $\ast$file, int line)
\item 
void \hyperlink{class_memory_leak_detector_a4a0939ba826695d9def779d703dcb93f}{Construct\+Memory\+Leak\+Report} (\hyperlink{_memory_leak_detector_8h_ab248e6cc6c6699b88b002286d8a3ed76}{Mem\+Leak\+Period} period)
\item 
size\+\_\+t \hyperlink{class_memory_leak_detector_a76ae083bcac4cbedfca13eeee9876b10}{size\+Of\+Memory\+With\+Corruption\+Info} (size\+\_\+t \hyperlink{gst__avb__playbin_8c_a439227feff9d7f55384e8780cfc2eb82}{size})
\item 
\hyperlink{struct_memory_leak_detector_node}{Memory\+Leak\+Detector\+Node} $\ast$ \hyperlink{class_memory_leak_detector_aa0753191c429f0e32e527693767e3cb2}{get\+Node\+From\+Memory\+Pointer} (char $\ast$memory, size\+\_\+t \hyperlink{gst__avb__playbin_8c_a439227feff9d7f55384e8780cfc2eb82}{size})
\item 
char $\ast$ \hyperlink{class_memory_leak_detector_aa670d663e64a85135a23f26c124e5bd7}{reallocate\+Memory\+And\+Leak\+Information} (\hyperlink{class_test_memory_allocator}{Test\+Memory\+Allocator} $\ast$\hyperlink{_memory_leak_warning_test_8cpp_a83fc2e9b9142613f7df2bcc3ff8292bc}{allocator}, char $\ast$memory, size\+\_\+t \hyperlink{gst__avb__playbin_8c_a439227feff9d7f55384e8780cfc2eb82}{size}, const char $\ast$file, int line, \hyperlink{avb__gptp_8h_af6a258d8f3ee5206d682d799316314b1}{bool} allocat\+Nodes\+Seperately)
\item 
void \hyperlink{class_memory_leak_detector_a1589a2a78f1b6ddd3f2466902abad2fe}{add\+Memory\+Corruption\+Information} (char $\ast$memory)
\item 
void \hyperlink{class_memory_leak_detector_ae260d75b307f341763273c1e99a11c1d}{check\+For\+Corruption} (\hyperlink{struct_memory_leak_detector_node}{Memory\+Leak\+Detector\+Node} $\ast$node, const char $\ast$file, int line, \hyperlink{class_test_memory_allocator}{Test\+Memory\+Allocator} $\ast$\hyperlink{_memory_leak_warning_test_8cpp_a83fc2e9b9142613f7df2bcc3ff8292bc}{allocator}, \hyperlink{avb__gptp_8h_af6a258d8f3ee5206d682d799316314b1}{bool} allocate\+Nodes\+Seperately)
\end{DoxyCompactItemize}
\subsection*{Private 속성}
\begin{DoxyCompactItemize}
\item 
\hyperlink{class_memory_leak_failure}{Memory\+Leak\+Failure} $\ast$ \hyperlink{class_memory_leak_detector_a632df6e6476c93d9c58a104a17e155d9}{reporter\+\_\+}
\item 
\hyperlink{_memory_leak_detector_8h_ab248e6cc6c6699b88b002286d8a3ed76}{Mem\+Leak\+Period} \hyperlink{class_memory_leak_detector_af82b746b32f3ce3919db77a6985bab42}{current\+\_\+period\+\_\+}
\item 
\hyperlink{class_memory_leak_output_string_buffer}{Memory\+Leak\+Output\+String\+Buffer} \hyperlink{class_memory_leak_detector_a7d0b175420d83f9ee397b398ae14ac75}{output\+Buffer\+\_\+}
\item 
\hyperlink{struct_memory_leak_detector_table}{Memory\+Leak\+Detector\+Table} \hyperlink{class_memory_leak_detector_abee17cabbc59ef23d6f51027208a100c}{memory\+Table\+\_\+}
\item 
\hyperlink{avb__gptp_8h_af6a258d8f3ee5206d682d799316314b1}{bool} \hyperlink{class_memory_leak_detector_a9355cba4a5dcc00a72553874773d209e}{do\+Allocation\+Type\+Checking\+\_\+}
\item 
unsigned \hyperlink{class_memory_leak_detector_a848e960c1d67dbe545416e2541663260}{allocation\+Sequence\+Number\+\_\+}
\item 
\hyperlink{class_simple_mutex}{Simple\+Mutex} $\ast$ \hyperlink{class_memory_leak_detector_ab92d2f1606fbc62f3c4d5184d735dd04}{mutex\+\_\+}
\end{DoxyCompactItemize}


\subsection{상세한 설명}


Memory\+Leak\+Detector.\+h 파일의 188 번째 라인에서 정의되었습니다.



\subsection{멤버 열거형 문서화}
\subsubsection[{\texorpdfstring{anonymous enum}{anonymous enum}}]{\setlength{\rightskip}{0pt plus 5cm}anonymous enum}\hypertarget{class_memory_leak_detector_a81929fb3d21206b62f55bcb744f71d5d}{}\label{class_memory_leak_detector_a81929fb3d21206b62f55bcb744f71d5d}
\begin{Desc}
\item[열거형 멤버]\par
\begin{description}
\index{memory\+\_\+corruption\+\_\+buffer\+\_\+size@{memory\+\_\+corruption\+\_\+buffer\+\_\+size}!Memory\+Leak\+Detector@{Memory\+Leak\+Detector}}\index{Memory\+Leak\+Detector@{Memory\+Leak\+Detector}!memory\+\_\+corruption\+\_\+buffer\+\_\+size@{memory\+\_\+corruption\+\_\+buffer\+\_\+size}}\item[{\em 
memory\+\_\+corruption\+\_\+buffer\+\_\+size\hypertarget{class_memory_leak_detector_a81929fb3d21206b62f55bcb744f71d5da5220cc4ba0bebf171c9984d05561bcc2}{}\label{class_memory_leak_detector_a81929fb3d21206b62f55bcb744f71d5da5220cc4ba0bebf171c9984d05561bcc2}
}]\end{description}
\end{Desc}


Memory\+Leak\+Detector.\+h 파일의 217 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
218     \{
219         \hyperlink{class_memory_leak_detector_a81929fb3d21206b62f55bcb744f71d5da5220cc4ba0bebf171c9984d05561bcc2}{memory\_corruption\_buffer\_size} = 3
220     \};
\end{DoxyCode}


\subsection{생성자 \& 소멸자 문서화}
\index{Memory\+Leak\+Detector@{Memory\+Leak\+Detector}!Memory\+Leak\+Detector@{Memory\+Leak\+Detector}}
\index{Memory\+Leak\+Detector@{Memory\+Leak\+Detector}!Memory\+Leak\+Detector@{Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{Memory\+Leak\+Detector(\+Memory\+Leak\+Failure $\ast$reporter)}{MemoryLeakDetector(MemoryLeakFailure *reporter)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Memory\+Leak\+Detector} (
\begin{DoxyParamCaption}
\item[{{\bf Memory\+Leak\+Failure} $\ast$}]{reporter}
\end{DoxyParamCaption}
)}\hypertarget{class_memory_leak_detector_adce0cc8ded968fc3af6035ed9aebe949}{}\label{class_memory_leak_detector_adce0cc8ded968fc3af6035ed9aebe949}


Memory\+Leak\+Detector.\+cpp 파일의 419 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
420 \{
421     \hyperlink{class_memory_leak_detector_a9355cba4a5dcc00a72553874773d209e}{doAllocationTypeChecking\_} = \textcolor{keyword}{true};
422     \hyperlink{class_memory_leak_detector_a848e960c1d67dbe545416e2541663260}{allocationSequenceNumber\_} = 1;
423     \hyperlink{class_memory_leak_detector_af82b746b32f3ce3919db77a6985bab42}{current\_period\_} = \hyperlink{_memory_leak_detector_8h_ab248e6cc6c6699b88b002286d8a3ed76a486ca2e142f018cbf5f8f6b5561b4c48}{mem\_leak\_period\_disabled};
424     \hyperlink{class_memory_leak_detector_a632df6e6476c93d9c58a104a17e155d9}{reporter\_} = reporter;
425     \hyperlink{class_memory_leak_detector_ab92d2f1606fbc62f3c4d5184d735dd04}{mutex\_} = \textcolor{keyword}{new} \hyperlink{class_simple_mutex}{SimpleMutex};
426 \}
\end{DoxyCode}
\index{Memory\+Leak\+Detector@{Memory\+Leak\+Detector}!````~Memory\+Leak\+Detector@{$\sim$\+Memory\+Leak\+Detector}}
\index{````~Memory\+Leak\+Detector@{$\sim$\+Memory\+Leak\+Detector}!Memory\+Leak\+Detector@{Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{$\sim$\+Memory\+Leak\+Detector()}{~MemoryLeakDetector()}}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf Memory\+Leak\+Detector} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{class_memory_leak_detector_aee92c9e1fa761a77145ad0b7b3b4e8e7}{}\label{class_memory_leak_detector_aee92c9e1fa761a77145ad0b7b3b4e8e7}


Memory\+Leak\+Detector.\+cpp 파일의 428 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
429 \{
430     \textcolor{keywordflow}{if} (\hyperlink{class_memory_leak_detector_ab92d2f1606fbc62f3c4d5184d735dd04}{mutex\_})
431     \{
432         \textcolor{keyword}{delete} \hyperlink{class_memory_leak_detector_ab92d2f1606fbc62f3c4d5184d735dd04}{mutex\_};
433     \}
434 \}
\end{DoxyCode}


\subsection{멤버 함수 문서화}
\index{Memory\+Leak\+Detector@{Memory\+Leak\+Detector}!add\+Memory\+Corruption\+Information@{add\+Memory\+Corruption\+Information}}
\index{add\+Memory\+Corruption\+Information@{add\+Memory\+Corruption\+Information}!Memory\+Leak\+Detector@{Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{add\+Memory\+Corruption\+Information(char $\ast$memory)}{addMemoryCorruptionInformation(char *memory)}}]{\setlength{\rightskip}{0pt plus 5cm}void add\+Memory\+Corruption\+Information (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{memory}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_memory_leak_detector_a1589a2a78f1b6ddd3f2466902abad2fe}{}\label{class_memory_leak_detector_a1589a2a78f1b6ddd3f2466902abad2fe}


Memory\+Leak\+Detector.\+cpp 파일의 521 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
522 \{
523     memory[0] = \textcolor{charliteral}{'B'};
524     memory[1] = \textcolor{charliteral}{'A'};
525     memory[2] = \textcolor{charliteral}{'S'};
526 \}
\end{DoxyCode}
\index{Memory\+Leak\+Detector@{Memory\+Leak\+Detector}!allocate\+Memory\+With\+Accounting\+Information@{allocate\+Memory\+With\+Accounting\+Information}}
\index{allocate\+Memory\+With\+Accounting\+Information@{allocate\+Memory\+With\+Accounting\+Information}!Memory\+Leak\+Detector@{Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{allocate\+Memory\+With\+Accounting\+Information(\+Test\+Memory\+Allocator $\ast$allocator, size\+\_\+t size, const char $\ast$file, int line, bool allocat\+Nodes\+Seperately)}{allocateMemoryWithAccountingInformation(TestMemoryAllocator *allocator, size_t size, const char *file, int line, bool allocatNodesSeperately)}}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$ allocate\+Memory\+With\+Accounting\+Information (
\begin{DoxyParamCaption}
\item[{{\bf Test\+Memory\+Allocator} $\ast$}]{allocator, }
\item[{size\+\_\+t}]{size, }
\item[{const char $\ast$}]{file, }
\item[{int}]{line, }
\item[{{\bf bool}}]{allocat\+Nodes\+Seperately}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_memory_leak_detector_a9f85c6601d58ad9a888439e5834ae237}{}\label{class_memory_leak_detector_a9f85c6601d58ad9a888439e5834ae237}


Memory\+Leak\+Detector.\+cpp 파일의 555 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
556 \{
557     \textcolor{keywordflow}{if} (allocatNodesSeperately) \textcolor{keywordflow}{return} allocator->\hyperlink{class_test_memory_allocator_a2ebbde51a1d514c74e9e2a09a21b0624}{alloc\_memory}(
      \hyperlink{class_memory_leak_detector_a76ae083bcac4cbedfca13eeee9876b10}{sizeOfMemoryWithCorruptionInfo}(\hyperlink{gst__avb__playbin_8c_a439227feff9d7f55384e8780cfc2eb82}{size}), file, line);
558     \textcolor{keywordflow}{else} \textcolor{keywordflow}{return} allocator->\hyperlink{class_test_memory_allocator_a2ebbde51a1d514c74e9e2a09a21b0624}{alloc\_memory}(
      \hyperlink{class_memory_leak_detector_a76ae083bcac4cbedfca13eeee9876b10}{sizeOfMemoryWithCorruptionInfo}(\hyperlink{gst__avb__playbin_8c_a439227feff9d7f55384e8780cfc2eb82}{size}) + \textcolor{keyword}{sizeof}(
      \hyperlink{struct_memory_leak_detector_node}{MemoryLeakDetectorNode}), file, line);
559 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_memory_leak_detector_a9f85c6601d58ad9a888439e5834ae237_cgraph}
\end{center}
\end{figure}


\index{Memory\+Leak\+Detector@{Memory\+Leak\+Detector}!alloc\+Memory@{alloc\+Memory}}
\index{alloc\+Memory@{alloc\+Memory}!Memory\+Leak\+Detector@{Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{alloc\+Memory(\+Test\+Memory\+Allocator $\ast$allocator, size\+\_\+t size, bool allocat\+Nodes\+Seperately=false)}{allocMemory(TestMemoryAllocator *allocator, size_t size, bool allocatNodesSeperately=false)}}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$ alloc\+Memory (
\begin{DoxyParamCaption}
\item[{{\bf Test\+Memory\+Allocator} $\ast$}]{allocator, }
\item[{size\+\_\+t}]{size, }
\item[{{\bf bool}}]{allocat\+Nodes\+Seperately = {\ttfamily {\bf false}}}
\end{DoxyParamCaption}
)}\hypertarget{class_memory_leak_detector_a15c9b9fb87d6e63d8972f03e25fb3cf5}{}\label{class_memory_leak_detector_a15c9b9fb87d6e63d8972f03e25fb3cf5}


Memory\+Leak\+Detector.\+cpp 파일의 550 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
551 \{
552     \textcolor{keywordflow}{return} \hyperlink{class_memory_leak_detector_a15c9b9fb87d6e63d8972f03e25fb3cf5}{allocMemory}(allocator, \hyperlink{gst__avb__playbin_8c_a439227feff9d7f55384e8780cfc2eb82}{size}, \hyperlink{_memory_leak_detector_8cpp_ac1ae4add974b9cfc6b5aaf8a578f01ab}{UNKNOWN}, 0, allocatNodesSeperately);
553 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_memory_leak_detector_a15c9b9fb87d6e63d8972f03e25fb3cf5_icgraph}
\end{center}
\end{figure}


\index{Memory\+Leak\+Detector@{Memory\+Leak\+Detector}!alloc\+Memory@{alloc\+Memory}}
\index{alloc\+Memory@{alloc\+Memory}!Memory\+Leak\+Detector@{Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{alloc\+Memory(\+Test\+Memory\+Allocator $\ast$allocator, size\+\_\+t size, const char $\ast$file, int line, bool allocat\+Nodes\+Seperately=false)}{allocMemory(TestMemoryAllocator *allocator, size_t size, const char *file, int line, bool allocatNodesSeperately=false)}}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$ alloc\+Memory (
\begin{DoxyParamCaption}
\item[{{\bf Test\+Memory\+Allocator} $\ast$}]{allocator, }
\item[{size\+\_\+t}]{size, }
\item[{const char $\ast$}]{file, }
\item[{int}]{line, }
\item[{{\bf bool}}]{allocat\+Nodes\+Seperately = {\ttfamily {\bf false}}}
\end{DoxyParamCaption}
)}\hypertarget{class_memory_leak_detector_ace7838f234f5dea076a6ab2528a66164}{}\label{class_memory_leak_detector_ace7838f234f5dea076a6ab2528a66164}


Memory\+Leak\+Detector.\+cpp 파일의 573 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
574 \{
575     \textcolor{comment}{/* With malloc, it is harder to guarantee that the allocator free is called.}
576 \textcolor{comment}{     * This is because operator new is overloaded via linker symbols, but malloc just via #defines.}
577 \textcolor{comment}{     * If the same allocation is used and the wrong free is called, it will deallocate the memory leak
       information}
578 \textcolor{comment}{     * without the memory leak detector ever noticing it!}
579 \textcolor{comment}{     * So, for malloc, we'll allocate the memory separately so we can detect this and give a proper error.}
580 \textcolor{comment}{     */}
581 
582     \textcolor{keywordtype}{char}* memory = \hyperlink{class_memory_leak_detector_a9f85c6601d58ad9a888439e5834ae237}{allocateMemoryWithAccountingInformation}(allocator
      , \hyperlink{gst__avb__playbin_8c_a439227feff9d7f55384e8780cfc2eb82}{size}, file, line, allocatNodesSeperately);
583     \textcolor{keywordflow}{if} (memory == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}) \textcolor{keywordflow}{return} \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
584     \hyperlink{struct_memory_leak_detector_node}{MemoryLeakDetectorNode}* node = 
      \hyperlink{class_memory_leak_detector_a7ee2afe61a37ef68a82228bd91643442}{createMemoryLeakAccountingInformation}(allocator, 
      \hyperlink{gst__avb__playbin_8c_a439227feff9d7f55384e8780cfc2eb82}{size}, memory, allocatNodesSeperately);
585 
586     \hyperlink{class_memory_leak_detector_ad65311ebd24859da19c751e2e42e796f}{storeLeakInformation}(node, memory, \hyperlink{gst__avb__playbin_8c_a439227feff9d7f55384e8780cfc2eb82}{size}, allocator, file, line);
587     \textcolor{keywordflow}{return} node->\hyperlink{struct_memory_leak_detector_node_a6cdb5ad30702010eaf86e4e5f26defce}{memory\_};
588 \}
\end{DoxyCode}
\index{Memory\+Leak\+Detector@{Memory\+Leak\+Detector}!check\+For\+Corruption@{check\+For\+Corruption}}
\index{check\+For\+Corruption@{check\+For\+Corruption}!Memory\+Leak\+Detector@{Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{check\+For\+Corruption(\+Memory\+Leak\+Detector\+Node $\ast$node, const char $\ast$file, int line, Test\+Memory\+Allocator $\ast$allocator, bool allocate\+Nodes\+Seperately)}{checkForCorruption(MemoryLeakDetectorNode *node, const char *file, int line, TestMemoryAllocator *allocator, bool allocateNodesSeperately)}}]{\setlength{\rightskip}{0pt plus 5cm}void check\+For\+Corruption (
\begin{DoxyParamCaption}
\item[{{\bf Memory\+Leak\+Detector\+Node} $\ast$}]{node, }
\item[{const char $\ast$}]{file, }
\item[{int}]{line, }
\item[{{\bf Test\+Memory\+Allocator} $\ast$}]{allocator, }
\item[{{\bf bool}}]{allocate\+Nodes\+Seperately}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_memory_leak_detector_ae260d75b307f341763273c1e99a11c1d}{}\label{class_memory_leak_detector_ae260d75b307f341763273c1e99a11c1d}


Memory\+Leak\+Detector.\+cpp 파일의 540 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
541 \{
542     \textcolor{keywordflow}{if} (!\hyperlink{class_memory_leak_detector_acf1c0e015e90cc0ebe2b41cc1b4212b8}{matchingAllocation}(node->\hyperlink{struct_memory_leak_detector_node_a12122107c5adfce5f08568d080ad411a}{allocator\_}, allocator))
543         \hyperlink{class_memory_leak_detector_a7d0b175420d83f9ee397b398ae14ac75}{outputBuffer\_}.\hyperlink{class_memory_leak_output_string_buffer_a94baa48406f230991c764abd1cf3a904}{reportAllocationDeallocationMismatchFailure}
      (node, file, line, allocator, \hyperlink{class_memory_leak_detector_a632df6e6476c93d9c58a104a17e155d9}{reporter\_});
544     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!\hyperlink{class_memory_leak_detector_aeb6f1872936e5c8b25300897c8d81096}{validMemoryCorruptionInformation}(node->
      \hyperlink{struct_memory_leak_detector_node_a6cdb5ad30702010eaf86e4e5f26defce}{memory\_} + node->\hyperlink{struct_memory_leak_detector_node_a5f31775800bbb46b35b5791def1f3acc}{size\_}))
545         \hyperlink{class_memory_leak_detector_a7d0b175420d83f9ee397b398ae14ac75}{outputBuffer\_}.\hyperlink{class_memory_leak_output_string_buffer_a14efcbb890531b638e1ff5e6a21e485a}{reportMemoryCorruptionFailure}(node, file, 
      line, allocator, \hyperlink{class_memory_leak_detector_a632df6e6476c93d9c58a104a17e155d9}{reporter\_});
546     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (allocateNodesSeperately)
547         allocator->\hyperlink{class_test_memory_allocator_a10f2958f3b7378256e933896ccc93df0}{freeMemoryLeakNode}((\textcolor{keywordtype}{char}*) node);
548 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_memory_leak_detector_ae260d75b307f341763273c1e99a11c1d_cgraph}
\end{center}
\end{figure}


\index{Memory\+Leak\+Detector@{Memory\+Leak\+Detector}!clear\+All\+Accounting@{clear\+All\+Accounting}}
\index{clear\+All\+Accounting@{clear\+All\+Accounting}!Memory\+Leak\+Detector@{Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{clear\+All\+Accounting(\+Mem\+Leak\+Period period)}{clearAllAccounting(MemLeakPeriod period)}}]{\setlength{\rightskip}{0pt plus 5cm}void clear\+All\+Accounting (
\begin{DoxyParamCaption}
\item[{{\bf Mem\+Leak\+Period}}]{period}
\end{DoxyParamCaption}
)}\hypertarget{class_memory_leak_detector_a6c18f981e1c2139528a10aa573ffeaa9}{}\label{class_memory_leak_detector_a6c18f981e1c2139528a10aa573ffeaa9}


Memory\+Leak\+Detector.\+cpp 파일의 436 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
437 \{
438     \hyperlink{class_memory_leak_detector_abee17cabbc59ef23d6f51027208a100c}{memoryTable\_}.\hyperlink{struct_memory_leak_detector_table_a6c18f981e1c2139528a10aa573ffeaa9}{clearAllAccounting}(period);
439 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=256pt]{class_memory_leak_detector_a6c18f981e1c2139528a10aa573ffeaa9_icgraph}
\end{center}
\end{figure}


\index{Memory\+Leak\+Detector@{Memory\+Leak\+Detector}!Construct\+Memory\+Leak\+Report@{Construct\+Memory\+Leak\+Report}}
\index{Construct\+Memory\+Leak\+Report@{Construct\+Memory\+Leak\+Report}!Memory\+Leak\+Detector@{Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{Construct\+Memory\+Leak\+Report(\+Mem\+Leak\+Period period)}{ConstructMemoryLeakReport(MemLeakPeriod period)}}]{\setlength{\rightskip}{0pt plus 5cm}void Construct\+Memory\+Leak\+Report (
\begin{DoxyParamCaption}
\item[{{\bf Mem\+Leak\+Period}}]{period}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_memory_leak_detector_a4a0939ba826695d9def779d703dcb93f}{}\label{class_memory_leak_detector_a4a0939ba826695d9def779d703dcb93f}


Memory\+Leak\+Detector.\+cpp 파일의 629 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
630 \{
631     \hyperlink{struct_memory_leak_detector_node}{MemoryLeakDetectorNode}* leak = \hyperlink{class_memory_leak_detector_abee17cabbc59ef23d6f51027208a100c}{memoryTable\_}.
      \hyperlink{struct_memory_leak_detector_table_a1b95cd1a5e8372a8f795f2d3387ae065}{getFirstLeak}(period);
632 
633     \hyperlink{class_memory_leak_detector_a7d0b175420d83f9ee397b398ae14ac75}{outputBuffer\_}.\hyperlink{class_memory_leak_output_string_buffer_a99cb7722b04d6e0539701d105c08af23}{startMemoryLeakReporting}();
634 
635     \textcolor{keywordflow}{while} (leak) \{
636         \hyperlink{class_memory_leak_detector_a7d0b175420d83f9ee397b398ae14ac75}{outputBuffer\_}.\hyperlink{class_memory_leak_output_string_buffer_a93f881f339b50ea69b8cd7b543e15377}{reportMemoryLeak}(leak);
637         leak = \hyperlink{class_memory_leak_detector_abee17cabbc59ef23d6f51027208a100c}{memoryTable\_}.\hyperlink{struct_memory_leak_detector_table_a4aafc8945d8152ee287b651ffd2ede97}{getNextLeak}(leak, period);
638     \}
639 
640     \hyperlink{class_memory_leak_detector_a7d0b175420d83f9ee397b398ae14ac75}{outputBuffer\_}.\hyperlink{class_memory_leak_output_string_buffer_a25142db8cabaf786bf4e41baa0bcc417}{stopMemoryLeakReporting}();
641 \}
\end{DoxyCode}
\index{Memory\+Leak\+Detector@{Memory\+Leak\+Detector}!create\+Memory\+Leak\+Accounting\+Information@{create\+Memory\+Leak\+Accounting\+Information}}
\index{create\+Memory\+Leak\+Accounting\+Information@{create\+Memory\+Leak\+Accounting\+Information}!Memory\+Leak\+Detector@{Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{create\+Memory\+Leak\+Accounting\+Information(\+Test\+Memory\+Allocator $\ast$allocator, size\+\_\+t size, char $\ast$memory, bool allocat\+Nodes\+Seperately)}{createMemoryLeakAccountingInformation(TestMemoryAllocator *allocator, size_t size, char *memory, bool allocatNodesSeperately)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Memory\+Leak\+Detector\+Node} $\ast$ create\+Memory\+Leak\+Accounting\+Information (
\begin{DoxyParamCaption}
\item[{{\bf Test\+Memory\+Allocator} $\ast$}]{allocator, }
\item[{size\+\_\+t}]{size, }
\item[{char $\ast$}]{memory, }
\item[{{\bf bool}}]{allocat\+Nodes\+Seperately}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_memory_leak_detector_a7ee2afe61a37ef68a82228bd91643442}{}\label{class_memory_leak_detector_a7ee2afe61a37ef68a82228bd91643442}


Memory\+Leak\+Detector.\+cpp 파일의 567 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
568 \{
569     \textcolor{keywordflow}{if} (allocatNodesSeperately) \textcolor{keywordflow}{return} (\hyperlink{struct_memory_leak_detector_node}{MemoryLeakDetectorNode}*) (\textcolor{keywordtype}{void}*) allocator->
      \hyperlink{class_test_memory_allocator_a1a786ad58b46528e82235a14fa667c1d}{allocMemoryLeakNode}(\textcolor{keyword}{sizeof}(\hyperlink{struct_memory_leak_detector_node}{MemoryLeakDetectorNode}));
570     \textcolor{keywordflow}{else} \textcolor{keywordflow}{return} \hyperlink{class_memory_leak_detector_aa0753191c429f0e32e527693767e3cb2}{getNodeFromMemoryPointer}(memory, \hyperlink{gst__avb__playbin_8c_a439227feff9d7f55384e8780cfc2eb82}{size});
571 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_memory_leak_detector_a7ee2afe61a37ef68a82228bd91643442_cgraph}
\end{center}
\end{figure}


\index{Memory\+Leak\+Detector@{Memory\+Leak\+Detector}!dealloc\+Memory@{dealloc\+Memory}}
\index{dealloc\+Memory@{dealloc\+Memory}!Memory\+Leak\+Detector@{Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{dealloc\+Memory(\+Test\+Memory\+Allocator $\ast$allocator, void $\ast$memory, bool allocat\+Nodes\+Seperately=false)}{deallocMemory(TestMemoryAllocator *allocator, void *memory, bool allocatNodesSeperately=false)}}]{\setlength{\rightskip}{0pt plus 5cm}void dealloc\+Memory (
\begin{DoxyParamCaption}
\item[{{\bf Test\+Memory\+Allocator} $\ast$}]{allocator, }
\item[{void $\ast$}]{memory, }
\item[{{\bf bool}}]{allocat\+Nodes\+Seperately = {\ttfamily {\bf false}}}
\end{DoxyParamCaption}
)}\hypertarget{class_memory_leak_detector_a1526d6f241a7f41eaeae20fd2c712873}{}\label{class_memory_leak_detector_a1526d6f241a7f41eaeae20fd2c712873}


Memory\+Leak\+Detector.\+cpp 파일의 611 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
612 \{
613     \hyperlink{class_memory_leak_detector_a1526d6f241a7f41eaeae20fd2c712873}{deallocMemory}(allocator, (\textcolor{keywordtype}{char}*) memory, \hyperlink{_memory_leak_detector_8cpp_ac1ae4add974b9cfc6b5aaf8a578f01ab}{UNKNOWN}, 0, allocatNodesSeperately);
614 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_memory_leak_detector_a1526d6f241a7f41eaeae20fd2c712873_icgraph}
\end{center}
\end{figure}


\index{Memory\+Leak\+Detector@{Memory\+Leak\+Detector}!dealloc\+Memory@{dealloc\+Memory}}
\index{dealloc\+Memory@{dealloc\+Memory}!Memory\+Leak\+Detector@{Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{dealloc\+Memory(\+Test\+Memory\+Allocator $\ast$allocator, void $\ast$memory, const char $\ast$file, int line, bool allocat\+Nodes\+Seperately=false)}{deallocMemory(TestMemoryAllocator *allocator, void *memory, const char *file, int line, bool allocatNodesSeperately=false)}}]{\setlength{\rightskip}{0pt plus 5cm}void dealloc\+Memory (
\begin{DoxyParamCaption}
\item[{{\bf Test\+Memory\+Allocator} $\ast$}]{allocator, }
\item[{void $\ast$}]{memory, }
\item[{const char $\ast$}]{file, }
\item[{int}]{line, }
\item[{{\bf bool}}]{allocat\+Nodes\+Seperately = {\ttfamily {\bf false}}}
\end{DoxyParamCaption}
)}\hypertarget{class_memory_leak_detector_a235bec7842c694f869f6edbf131a6c55}{}\label{class_memory_leak_detector_a235bec7842c694f869f6edbf131a6c55}


Memory\+Leak\+Detector.\+cpp 파일의 596 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
597 \{
598     \textcolor{keywordflow}{if} (memory == 0) \textcolor{keywordflow}{return};
599 
600     \hyperlink{struct_memory_leak_detector_node}{MemoryLeakDetectorNode}* node = \hyperlink{class_memory_leak_detector_abee17cabbc59ef23d6f51027208a100c}{memoryTable\_}.
      \hyperlink{struct_memory_leak_detector_table_aaa0452383ce806d8a7248cb567813f84}{removeNode}((\textcolor{keywordtype}{char}*) memory);
601     \textcolor{keywordflow}{if} (node == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}) \{
602         \hyperlink{class_memory_leak_detector_a7d0b175420d83f9ee397b398ae14ac75}{outputBuffer\_}.\hyperlink{class_memory_leak_output_string_buffer_a0061b779a33beb2d8c87eb915b20309a}{reportDeallocateNonAllocatedMemoryFailure}
      (file, line, allocator, \hyperlink{class_memory_leak_detector_a632df6e6476c93d9c58a104a17e155d9}{reporter\_});
603         \textcolor{keywordflow}{return};
604     \}
605     \textcolor{keywordflow}{if} (!allocator->\hyperlink{class_test_memory_allocator_ae26c82159ce24eb59770352585b402fd}{hasBeenDestroyed}()) \{
606         \hyperlink{class_memory_leak_detector_ae260d75b307f341763273c1e99a11c1d}{checkForCorruption}(node, file, line, allocator, allocatNodesSeperately);
607         allocator->\hyperlink{class_test_memory_allocator_a529ac9813d3b0836ce0b964449942534}{free\_memory}((\textcolor{keywordtype}{char}*) memory, file, line);
608     \}
609 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=309pt]{class_memory_leak_detector_a235bec7842c694f869f6edbf131a6c55_cgraph}
\end{center}
\end{figure}


\index{Memory\+Leak\+Detector@{Memory\+Leak\+Detector}!disable@{disable}}
\index{disable@{disable}!Memory\+Leak\+Detector@{Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{disable()}{disable()}}]{\setlength{\rightskip}{0pt plus 5cm}void disable (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{class_memory_leak_detector_a8cfbbe53c1cf6e3054736daea3044c0f}{}\label{class_memory_leak_detector_a8cfbbe53c1cf6e3054736daea3044c0f}


Memory\+Leak\+Detector.\+cpp 파일의 457 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
458 \{
459     \hyperlink{class_memory_leak_detector_af82b746b32f3ce3919db77a6985bab42}{current\_period\_} = \hyperlink{_memory_leak_detector_8h_ab248e6cc6c6699b88b002286d8a3ed76a486ca2e142f018cbf5f8f6b5561b4c48}{mem\_leak\_period\_disabled};
460 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=205pt]{class_memory_leak_detector_a8cfbbe53c1cf6e3054736daea3044c0f_icgraph}
\end{center}
\end{figure}


\index{Memory\+Leak\+Detector@{Memory\+Leak\+Detector}!disable\+Allocation\+Type\+Checking@{disable\+Allocation\+Type\+Checking}}
\index{disable\+Allocation\+Type\+Checking@{disable\+Allocation\+Type\+Checking}!Memory\+Leak\+Detector@{Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{disable\+Allocation\+Type\+Checking()}{disableAllocationTypeChecking()}}]{\setlength{\rightskip}{0pt plus 5cm}void disable\+Allocation\+Type\+Checking (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{class_memory_leak_detector_a87bbe373712386442509ec83e9444021}{}\label{class_memory_leak_detector_a87bbe373712386442509ec83e9444021}


Memory\+Leak\+Detector.\+cpp 파일의 462 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
463 \{
464     \hyperlink{class_memory_leak_detector_a9355cba4a5dcc00a72553874773d209e}{doAllocationTypeChecking\_} = \textcolor{keyword}{false};
465 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=311pt]{class_memory_leak_detector_a87bbe373712386442509ec83e9444021_icgraph}
\end{center}
\end{figure}


\index{Memory\+Leak\+Detector@{Memory\+Leak\+Detector}!enable@{enable}}
\index{enable@{enable}!Memory\+Leak\+Detector@{Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{enable()}{enable()}}]{\setlength{\rightskip}{0pt plus 5cm}void enable (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{class_memory_leak_detector_a486f22824bd83c5308a0d70ffac6f758}{}\label{class_memory_leak_detector_a486f22824bd83c5308a0d70ffac6f758}


Memory\+Leak\+Detector.\+cpp 파일의 452 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
453 \{
454     \hyperlink{class_memory_leak_detector_af82b746b32f3ce3919db77a6985bab42}{current\_period\_} = \hyperlink{_memory_leak_detector_8h_ab248e6cc6c6699b88b002286d8a3ed76af44afdfdc843b0c299b8b0a9585a0f32}{mem\_leak\_period\_enabled};
455 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=303pt]{class_memory_leak_detector_a486f22824bd83c5308a0d70ffac6f758_icgraph}
\end{center}
\end{figure}


\index{Memory\+Leak\+Detector@{Memory\+Leak\+Detector}!enable\+Allocation\+Type\+Checking@{enable\+Allocation\+Type\+Checking}}
\index{enable\+Allocation\+Type\+Checking@{enable\+Allocation\+Type\+Checking}!Memory\+Leak\+Detector@{Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{enable\+Allocation\+Type\+Checking()}{enableAllocationTypeChecking()}}]{\setlength{\rightskip}{0pt plus 5cm}void enable\+Allocation\+Type\+Checking (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{class_memory_leak_detector_a4ef0d2380dbe5ecfa77d2d477d9047e9}{}\label{class_memory_leak_detector_a4ef0d2380dbe5ecfa77d2d477d9047e9}


Memory\+Leak\+Detector.\+cpp 파일의 467 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
468 \{
469     \hyperlink{class_memory_leak_detector_a9355cba4a5dcc00a72553874773d209e}{doAllocationTypeChecking\_} = \textcolor{keyword}{true};
470 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=309pt]{class_memory_leak_detector_a4ef0d2380dbe5ecfa77d2d477d9047e9_icgraph}
\end{center}
\end{figure}


\index{Memory\+Leak\+Detector@{Memory\+Leak\+Detector}!get\+Current\+Allocation\+Number@{get\+Current\+Allocation\+Number}}
\index{get\+Current\+Allocation\+Number@{get\+Current\+Allocation\+Number}!Memory\+Leak\+Detector@{Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{get\+Current\+Allocation\+Number()}{getCurrentAllocationNumber()}}]{\setlength{\rightskip}{0pt plus 5cm}unsigned get\+Current\+Allocation\+Number (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{class_memory_leak_detector_a774a54e55a1203f145f722609ae18317}{}\label{class_memory_leak_detector_a774a54e55a1203f145f722609ae18317}


Memory\+Leak\+Detector.\+cpp 파일의 472 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
473 \{
474     \textcolor{keywordflow}{return} \hyperlink{class_memory_leak_detector_a848e960c1d67dbe545416e2541663260}{allocationSequenceNumber\_};
475 \}
\end{DoxyCode}
\index{Memory\+Leak\+Detector@{Memory\+Leak\+Detector}!get\+Mutex@{get\+Mutex}}
\index{get\+Mutex@{get\+Mutex}!Memory\+Leak\+Detector@{Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{get\+Mutex(void)}{getMutex(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Simple\+Mutex} $\ast$ get\+Mutex (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{class_memory_leak_detector_a19d27cb7dd06173cc88f58543bfe3020}{}\label{class_memory_leak_detector_a19d27cb7dd06173cc88f58543bfe3020}


Memory\+Leak\+Detector.\+cpp 파일의 477 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
478 \{
479     \textcolor{keywordflow}{return} \hyperlink{class_memory_leak_detector_ab92d2f1606fbc62f3c4d5184d735dd04}{mutex\_};
480 \}
\end{DoxyCode}
\index{Memory\+Leak\+Detector@{Memory\+Leak\+Detector}!get\+Node\+From\+Memory\+Pointer@{get\+Node\+From\+Memory\+Pointer}}
\index{get\+Node\+From\+Memory\+Pointer@{get\+Node\+From\+Memory\+Pointer}!Memory\+Leak\+Detector@{Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{get\+Node\+From\+Memory\+Pointer(char $\ast$memory, size\+\_\+t size)}{getNodeFromMemoryPointer(char *memory, size_t size)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Memory\+Leak\+Detector\+Node} $\ast$ get\+Node\+From\+Memory\+Pointer (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{memory, }
\item[{size\+\_\+t}]{size}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_memory_leak_detector_aa0753191c429f0e32e527693767e3cb2}{}\label{class_memory_leak_detector_aa0753191c429f0e32e527693767e3cb2}


Memory\+Leak\+Detector.\+cpp 파일의 492 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
493 \{
494     \textcolor{keywordflow}{return} (\hyperlink{struct_memory_leak_detector_node}{MemoryLeakDetectorNode}*) (\textcolor{keywordtype}{void}*) (memory + 
      \hyperlink{class_memory_leak_detector_a76ae083bcac4cbedfca13eeee9876b10}{sizeOfMemoryWithCorruptionInfo}(memory\_size));
495 \}
\end{DoxyCode}
\index{Memory\+Leak\+Detector@{Memory\+Leak\+Detector}!invalidate\+Memory@{invalidate\+Memory}}
\index{invalidate\+Memory@{invalidate\+Memory}!Memory\+Leak\+Detector@{Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{invalidate\+Memory(char $\ast$memory)}{invalidateMemory(char *memory)}}]{\setlength{\rightskip}{0pt plus 5cm}void invalidate\+Memory (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{memory}
\end{DoxyParamCaption}
)}\hypertarget{class_memory_leak_detector_a1b924f98e6bf1203714985e0b0c3de5d}{}\label{class_memory_leak_detector_a1b924f98e6bf1203714985e0b0c3de5d}


Memory\+Leak\+Detector.\+cpp 파일의 514 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
515 \{
516   \hyperlink{struct_memory_leak_detector_node}{MemoryLeakDetectorNode}* node = \hyperlink{class_memory_leak_detector_abee17cabbc59ef23d6f51027208a100c}{memoryTable\_}.
      \hyperlink{struct_memory_leak_detector_table_aa1655267a6cde38557847aca1e545a77}{retrieveNode}(memory);
517   \textcolor{keywordflow}{if} (node)
518     \hyperlink{_platform_specific_functions__c_8h_af64506f1a244f59ae6d68728a912133d}{PlatformSpecificMemset}(memory, 0xCD, node->\hyperlink{struct_memory_leak_detector_node_a5f31775800bbb46b35b5791def1f3acc}{size\_});
519 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_memory_leak_detector_a1b924f98e6bf1203714985e0b0c3de5d_icgraph}
\end{center}
\end{figure}


\index{Memory\+Leak\+Detector@{Memory\+Leak\+Detector}!mark\+Checking\+Period\+Leaks\+As\+Non\+Checking\+Period@{mark\+Checking\+Period\+Leaks\+As\+Non\+Checking\+Period}}
\index{mark\+Checking\+Period\+Leaks\+As\+Non\+Checking\+Period@{mark\+Checking\+Period\+Leaks\+As\+Non\+Checking\+Period}!Memory\+Leak\+Detector@{Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{mark\+Checking\+Period\+Leaks\+As\+Non\+Checking\+Period()}{markCheckingPeriodLeaksAsNonCheckingPeriod()}}]{\setlength{\rightskip}{0pt plus 5cm}void mark\+Checking\+Period\+Leaks\+As\+Non\+Checking\+Period (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{class_memory_leak_detector_a6db202697cf20e8d84748b129c403545}{}\label{class_memory_leak_detector_a6db202697cf20e8d84748b129c403545}


Memory\+Leak\+Detector.\+cpp 파일의 650 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
651 \{
652     \hyperlink{struct_memory_leak_detector_node}{MemoryLeakDetectorNode}* leak = \hyperlink{class_memory_leak_detector_abee17cabbc59ef23d6f51027208a100c}{memoryTable\_}.
      \hyperlink{struct_memory_leak_detector_table_a1b95cd1a5e8372a8f795f2d3387ae065}{getFirstLeak}(\hyperlink{_memory_leak_detector_8h_ab248e6cc6c6699b88b002286d8a3ed76ad140291a5b8a535af47f9858220f2639}{mem\_leak\_period\_checking});
653     \textcolor{keywordflow}{while} (leak) \{
654         \textcolor{keywordflow}{if} (leak->\hyperlink{struct_memory_leak_detector_node_a4b296dc99cd64623a83ce9027f70e0e7}{period\_} == \hyperlink{_memory_leak_detector_8h_ab248e6cc6c6699b88b002286d8a3ed76ad140291a5b8a535af47f9858220f2639}{mem\_leak\_period\_checking}) leak->
      \hyperlink{struct_memory_leak_detector_node_a4b296dc99cd64623a83ce9027f70e0e7}{period\_} = \hyperlink{_memory_leak_detector_8h_ab248e6cc6c6699b88b002286d8a3ed76af44afdfdc843b0c299b8b0a9585a0f32}{mem\_leak\_period\_enabled};
655         leak = \hyperlink{class_memory_leak_detector_abee17cabbc59ef23d6f51027208a100c}{memoryTable\_}.\hyperlink{struct_memory_leak_detector_table_a4aafc8945d8152ee287b651ffd2ede97}{getNextLeak}(leak, 
      \hyperlink{_memory_leak_detector_8h_ab248e6cc6c6699b88b002286d8a3ed76ad140291a5b8a535af47f9858220f2639}{mem\_leak\_period\_checking});
656     \}
657 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_memory_leak_detector_a6db202697cf20e8d84748b129c403545_icgraph}
\end{center}
\end{figure}


\index{Memory\+Leak\+Detector@{Memory\+Leak\+Detector}!matching\+Allocation@{matching\+Allocation}}
\index{matching\+Allocation@{matching\+Allocation}!Memory\+Leak\+Detector@{Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{matching\+Allocation(\+Test\+Memory\+Allocator $\ast$alloc\+\_\+allocator, Test\+Memory\+Allocator $\ast$free\+\_\+allocator)}{matchingAllocation(TestMemoryAllocator *alloc_allocator, TestMemoryAllocator *free_allocator)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf bool} matching\+Allocation (
\begin{DoxyParamCaption}
\item[{{\bf Test\+Memory\+Allocator} $\ast$}]{alloc\+\_\+allocator, }
\item[{{\bf Test\+Memory\+Allocator} $\ast$}]{free\+\_\+allocator}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_memory_leak_detector_acf1c0e015e90cc0ebe2b41cc1b4212b8}{}\label{class_memory_leak_detector_acf1c0e015e90cc0ebe2b41cc1b4212b8}


Memory\+Leak\+Detector.\+cpp 파일의 533 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
534 \{
535     \textcolor{keywordflow}{if} (alloc\_allocator == free\_allocator) \textcolor{keywordflow}{return} \textcolor{keyword}{true};
536     \textcolor{keywordflow}{if} (!\hyperlink{class_memory_leak_detector_a9355cba4a5dcc00a72553874773d209e}{doAllocationTypeChecking\_}) \textcolor{keywordflow}{return} \textcolor{keyword}{true};
537     \textcolor{keywordflow}{return} free\_allocator->\hyperlink{class_test_memory_allocator_a3d6a5cc2f6b7a38b3f1d3e0567bf4f93}{isOfEqualType}(alloc\_allocator);
538 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_memory_leak_detector_acf1c0e015e90cc0ebe2b41cc1b4212b8_cgraph}
\end{center}
\end{figure}


\index{Memory\+Leak\+Detector@{Memory\+Leak\+Detector}!reallocate\+Memory\+And\+Leak\+Information@{reallocate\+Memory\+And\+Leak\+Information}}
\index{reallocate\+Memory\+And\+Leak\+Information@{reallocate\+Memory\+And\+Leak\+Information}!Memory\+Leak\+Detector@{Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{reallocate\+Memory\+And\+Leak\+Information(\+Test\+Memory\+Allocator $\ast$allocator, char $\ast$memory, size\+\_\+t size, const char $\ast$file, int line, bool allocat\+Nodes\+Seperately)}{reallocateMemoryAndLeakInformation(TestMemoryAllocator *allocator, char *memory, size_t size, const char *file, int line, bool allocatNodesSeperately)}}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$ reallocate\+Memory\+And\+Leak\+Information (
\begin{DoxyParamCaption}
\item[{{\bf Test\+Memory\+Allocator} $\ast$}]{allocator, }
\item[{char $\ast$}]{memory, }
\item[{size\+\_\+t}]{size, }
\item[{const char $\ast$}]{file, }
\item[{int}]{line, }
\item[{{\bf bool}}]{allocat\+Nodes\+Seperately}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_memory_leak_detector_aa670d663e64a85135a23f26c124e5bd7}{}\label{class_memory_leak_detector_aa670d663e64a85135a23f26c124e5bd7}


Memory\+Leak\+Detector.\+cpp 파일의 504 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
505 \{
506     \textcolor{keywordtype}{char}* new\_memory = \hyperlink{class_memory_leak_detector_a862b3c60768aa68ba86dd124a658266a}{reallocateMemoryWithAccountingInformation}(
      allocator, memory, \hyperlink{gst__avb__playbin_8c_a439227feff9d7f55384e8780cfc2eb82}{size}, file, line, allocatNodesSeperately);
507     \textcolor{keywordflow}{if} (new\_memory == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}) \textcolor{keywordflow}{return} \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
508 
509     \hyperlink{struct_memory_leak_detector_node}{MemoryLeakDetectorNode} *node = 
      \hyperlink{class_memory_leak_detector_a7ee2afe61a37ef68a82228bd91643442}{createMemoryLeakAccountingInformation}(allocator, 
      \hyperlink{gst__avb__playbin_8c_a439227feff9d7f55384e8780cfc2eb82}{size}, new\_memory, allocatNodesSeperately);
510     \hyperlink{class_memory_leak_detector_ad65311ebd24859da19c751e2e42e796f}{storeLeakInformation}(node, new\_memory, \hyperlink{gst__avb__playbin_8c_a439227feff9d7f55384e8780cfc2eb82}{size}, allocator, file, line);
511     \textcolor{keywordflow}{return} node->\hyperlink{struct_memory_leak_detector_node_a6cdb5ad30702010eaf86e4e5f26defce}{memory\_};
512 \}
\end{DoxyCode}
\index{Memory\+Leak\+Detector@{Memory\+Leak\+Detector}!reallocate\+Memory\+With\+Accounting\+Information@{reallocate\+Memory\+With\+Accounting\+Information}}
\index{reallocate\+Memory\+With\+Accounting\+Information@{reallocate\+Memory\+With\+Accounting\+Information}!Memory\+Leak\+Detector@{Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{reallocate\+Memory\+With\+Accounting\+Information(\+Test\+Memory\+Allocator $\ast$allocator, char $\ast$memory, size\+\_\+t size, const char $\ast$file, int line, bool allocat\+Nodes\+Seperately)}{reallocateMemoryWithAccountingInformation(TestMemoryAllocator *allocator, char *memory, size_t size, const char *file, int line, bool allocatNodesSeperately)}}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$ reallocate\+Memory\+With\+Accounting\+Information (
\begin{DoxyParamCaption}
\item[{{\bf Test\+Memory\+Allocator} $\ast$}]{allocator, }
\item[{char $\ast$}]{memory, }
\item[{size\+\_\+t}]{size, }
\item[{const char $\ast$}]{file, }
\item[{int}]{line, }
\item[{{\bf bool}}]{allocat\+Nodes\+Seperately}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_memory_leak_detector_a862b3c60768aa68ba86dd124a658266a}{}\label{class_memory_leak_detector_a862b3c60768aa68ba86dd124a658266a}


Memory\+Leak\+Detector.\+cpp 파일의 561 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
562 \{
563     \textcolor{keywordflow}{if} (allocatNodesSeperately) \textcolor{keywordflow}{return} (\textcolor{keywordtype}{char}*) \hyperlink{_platform_specific_functions__c_8h_a88c88cdd66504c42256c03763b9454b5}{PlatformSpecificRealloc}(memory, 
      \hyperlink{class_memory_leak_detector_a76ae083bcac4cbedfca13eeee9876b10}{sizeOfMemoryWithCorruptionInfo}(\hyperlink{gst__avb__playbin_8c_a439227feff9d7f55384e8780cfc2eb82}{size}));
564     \textcolor{keywordflow}{else} \textcolor{keywordflow}{return} (\textcolor{keywordtype}{char}*) \hyperlink{_platform_specific_functions__c_8h_a88c88cdd66504c42256c03763b9454b5}{PlatformSpecificRealloc}(memory, 
      \hyperlink{class_memory_leak_detector_a76ae083bcac4cbedfca13eeee9876b10}{sizeOfMemoryWithCorruptionInfo}(\hyperlink{gst__avb__playbin_8c_a439227feff9d7f55384e8780cfc2eb82}{size}) + \textcolor{keyword}{sizeof}(
      \hyperlink{struct_memory_leak_detector_node}{MemoryLeakDetectorNode}));
565 \}
\end{DoxyCode}
\index{Memory\+Leak\+Detector@{Memory\+Leak\+Detector}!realloc\+Memory@{realloc\+Memory}}
\index{realloc\+Memory@{realloc\+Memory}!Memory\+Leak\+Detector@{Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{realloc\+Memory(\+Test\+Memory\+Allocator $\ast$allocator, char $\ast$memory, size\+\_\+t size, const char $\ast$file, int line, bool allocat\+Nodes\+Seperately=false)}{reallocMemory(TestMemoryAllocator *allocator, char *memory, size_t size, const char *file, int line, bool allocatNodesSeperately=false)}}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$ realloc\+Memory (
\begin{DoxyParamCaption}
\item[{{\bf Test\+Memory\+Allocator} $\ast$}]{allocator, }
\item[{char $\ast$}]{memory, }
\item[{size\+\_\+t}]{size, }
\item[{const char $\ast$}]{file, }
\item[{int}]{line, }
\item[{{\bf bool}}]{allocat\+Nodes\+Seperately = {\ttfamily {\bf false}}}
\end{DoxyParamCaption}
)}\hypertarget{class_memory_leak_detector_a6aded764a2297f52a104b75eae2d4b5c}{}\label{class_memory_leak_detector_a6aded764a2297f52a104b75eae2d4b5c}


Memory\+Leak\+Detector.\+cpp 파일의 616 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
617 \{
618     \textcolor{keywordflow}{if} (memory) \{
619         \hyperlink{struct_memory_leak_detector_node}{MemoryLeakDetectorNode}* node = \hyperlink{class_memory_leak_detector_abee17cabbc59ef23d6f51027208a100c}{memoryTable\_}.
      \hyperlink{struct_memory_leak_detector_table_aaa0452383ce806d8a7248cb567813f84}{removeNode}(memory);
620         \textcolor{keywordflow}{if} (node == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}) \{
621             \hyperlink{class_memory_leak_detector_a7d0b175420d83f9ee397b398ae14ac75}{outputBuffer\_}.\hyperlink{class_memory_leak_output_string_buffer_a0061b779a33beb2d8c87eb915b20309a}{reportDeallocateNonAllocatedMemoryFailure}
      (file, line, allocator, \hyperlink{class_memory_leak_detector_a632df6e6476c93d9c58a104a17e155d9}{reporter\_});
622             \textcolor{keywordflow}{return} \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
623         \}
624         \hyperlink{class_memory_leak_detector_ae260d75b307f341763273c1e99a11c1d}{checkForCorruption}(node, file, line, allocator, allocatNodesSeperately);
625     \}
626     \textcolor{keywordflow}{return} \hyperlink{class_memory_leak_detector_aa670d663e64a85135a23f26c124e5bd7}{reallocateMemoryAndLeakInformation}(allocator, memory, 
      \hyperlink{gst__avb__playbin_8c_a439227feff9d7f55384e8780cfc2eb82}{size}, file, line, allocatNodesSeperately);
627 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=238pt]{class_memory_leak_detector_a6aded764a2297f52a104b75eae2d4b5c_icgraph}
\end{center}
\end{figure}


\index{Memory\+Leak\+Detector@{Memory\+Leak\+Detector}!remove\+Memory\+Leak\+Information\+Without\+Checking\+Or\+Deallocating\+The\+Memory\+But\+Deallocating\+The\+Account\+Information@{remove\+Memory\+Leak\+Information\+Without\+Checking\+Or\+Deallocating\+The\+Memory\+But\+Deallocating\+The\+Account\+Information}}
\index{remove\+Memory\+Leak\+Information\+Without\+Checking\+Or\+Deallocating\+The\+Memory\+But\+Deallocating\+The\+Account\+Information@{remove\+Memory\+Leak\+Information\+Without\+Checking\+Or\+Deallocating\+The\+Memory\+But\+Deallocating\+The\+Account\+Information}!Memory\+Leak\+Detector@{Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{remove\+Memory\+Leak\+Information\+Without\+Checking\+Or\+Deallocating\+The\+Memory\+But\+Deallocating\+The\+Account\+Information(\+Test\+Memory\+Allocator $\ast$allocator, void $\ast$memory, bool allocat\+Nodes\+Seperately)}{removeMemoryLeakInformationWithoutCheckingOrDeallocatingTheMemoryButDeallocatingTheAccountInformation(TestMemoryAllocator *allocator, void *memory, bool allocatNodesSeperately)}}]{\setlength{\rightskip}{0pt plus 5cm}void remove\+Memory\+Leak\+Information\+Without\+Checking\+Or\+Deallocating\+The\+Memory\+But\+Deallocating\+The\+Account\+Information (
\begin{DoxyParamCaption}
\item[{{\bf Test\+Memory\+Allocator} $\ast$}]{allocator, }
\item[{void $\ast$}]{memory, }
\item[{{\bf bool}}]{allocat\+Nodes\+Seperately}
\end{DoxyParamCaption}
)}\hypertarget{class_memory_leak_detector_ac17764ba8c2ced15cbbbca1731f6b21e}{}\label{class_memory_leak_detector_ac17764ba8c2ced15cbbbca1731f6b21e}


Memory\+Leak\+Detector.\+cpp 파일의 590 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
591 \{
592     \hyperlink{struct_memory_leak_detector_node}{MemoryLeakDetectorNode}* node = \hyperlink{class_memory_leak_detector_abee17cabbc59ef23d6f51027208a100c}{memoryTable\_}.
      \hyperlink{struct_memory_leak_detector_table_aaa0452383ce806d8a7248cb567813f84}{removeNode}((\textcolor{keywordtype}{char}*) memory);
593     \textcolor{keywordflow}{if} (allocatNodesSeperately) allocator->\hyperlink{class_test_memory_allocator_a10f2958f3b7378256e933896ccc93df0}{freeMemoryLeakNode}( (\textcolor{keywordtype}{char}*) node);
594 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_memory_leak_detector_ac17764ba8c2ced15cbbbca1731f6b21e_cgraph}
\end{center}
\end{figure}


\index{Memory\+Leak\+Detector@{Memory\+Leak\+Detector}!report@{report}}
\index{report@{report}!Memory\+Leak\+Detector@{Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{report(\+Mem\+Leak\+Period period)}{report(MemLeakPeriod period)}}]{\setlength{\rightskip}{0pt plus 5cm}const char $\ast$ report (
\begin{DoxyParamCaption}
\item[{{\bf Mem\+Leak\+Period}}]{period}
\end{DoxyParamCaption}
)}\hypertarget{class_memory_leak_detector_acc70330c27080c4b09b96342929dc9ca}{}\label{class_memory_leak_detector_acc70330c27080c4b09b96342929dc9ca}


Memory\+Leak\+Detector.\+cpp 파일의 643 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
644 \{
645     \hyperlink{class_memory_leak_detector_a4a0939ba826695d9def779d703dcb93f}{ConstructMemoryLeakReport}(period);
646 
647     \textcolor{keywordflow}{return} \hyperlink{class_memory_leak_detector_a7d0b175420d83f9ee397b398ae14ac75}{outputBuffer\_}.\hyperlink{class_memory_leak_output_string_buffer_ac4969471df03a7a438bd99bfe61a0d5e}{toString}();
648 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=255pt]{class_memory_leak_detector_acc70330c27080c4b09b96342929dc9ca_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_memory_leak_detector_acc70330c27080c4b09b96342929dc9ca_icgraph}
\end{center}
\end{figure}


\index{Memory\+Leak\+Detector@{Memory\+Leak\+Detector}!size\+Of\+Memory\+With\+Corruption\+Info@{size\+Of\+Memory\+With\+Corruption\+Info}}
\index{size\+Of\+Memory\+With\+Corruption\+Info@{size\+Of\+Memory\+With\+Corruption\+Info}!Memory\+Leak\+Detector@{Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{size\+Of\+Memory\+With\+Corruption\+Info(size\+\_\+t size)}{sizeOfMemoryWithCorruptionInfo(size_t size)}}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t size\+Of\+Memory\+With\+Corruption\+Info (
\begin{DoxyParamCaption}
\item[{size\+\_\+t}]{size}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_memory_leak_detector_a76ae083bcac4cbedfca13eeee9876b10}{}\label{class_memory_leak_detector_a76ae083bcac4cbedfca13eeee9876b10}


Memory\+Leak\+Detector.\+cpp 파일의 487 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
488 \{
489     \textcolor{keywordflow}{return} \hyperlink{_memory_leak_detector_8cpp_a1994704628ccab107b88b6219782f50b}{calculateVoidPointerAlignedSize}(\hyperlink{gst__avb__playbin_8c_a439227feff9d7f55384e8780cfc2eb82}{size} + 
      \hyperlink{class_memory_leak_detector_a81929fb3d21206b62f55bcb744f71d5da5220cc4ba0bebf171c9984d05561bcc2}{memory\_corruption\_buffer\_size});
490 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_memory_leak_detector_a76ae083bcac4cbedfca13eeee9876b10_cgraph}
\end{center}
\end{figure}


\index{Memory\+Leak\+Detector@{Memory\+Leak\+Detector}!start\+Checking@{start\+Checking}}
\index{start\+Checking@{start\+Checking}!Memory\+Leak\+Detector@{Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{start\+Checking()}{startChecking()}}]{\setlength{\rightskip}{0pt plus 5cm}void start\+Checking (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{class_memory_leak_detector_ae912c5ee9034b76f13f1c9dbab55e512}{}\label{class_memory_leak_detector_ae912c5ee9034b76f13f1c9dbab55e512}


Memory\+Leak\+Detector.\+cpp 파일의 441 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
442 \{
443     \hyperlink{class_memory_leak_detector_a7d0b175420d83f9ee397b398ae14ac75}{outputBuffer\_}.\hyperlink{class_memory_leak_output_string_buffer_ac8bb3912a3ce86b15842e79d0b421204}{clear}();
444     \hyperlink{class_memory_leak_detector_af82b746b32f3ce3919db77a6985bab42}{current\_period\_} = \hyperlink{_memory_leak_detector_8h_ab248e6cc6c6699b88b002286d8a3ed76ad140291a5b8a535af47f9858220f2639}{mem\_leak\_period\_checking};
445 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=291pt]{class_memory_leak_detector_ae912c5ee9034b76f13f1c9dbab55e512_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=329pt]{class_memory_leak_detector_ae912c5ee9034b76f13f1c9dbab55e512_icgraph}
\end{center}
\end{figure}


\index{Memory\+Leak\+Detector@{Memory\+Leak\+Detector}!stop\+Checking@{stop\+Checking}}
\index{stop\+Checking@{stop\+Checking}!Memory\+Leak\+Detector@{Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{stop\+Checking()}{stopChecking()}}]{\setlength{\rightskip}{0pt plus 5cm}void stop\+Checking (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{class_memory_leak_detector_a9e85551d474d895ba8852b8e56481c7c}{}\label{class_memory_leak_detector_a9e85551d474d895ba8852b8e56481c7c}


Memory\+Leak\+Detector.\+cpp 파일의 447 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
448 \{
449     \hyperlink{class_memory_leak_detector_af82b746b32f3ce3919db77a6985bab42}{current\_period\_} = \hyperlink{_memory_leak_detector_8h_ab248e6cc6c6699b88b002286d8a3ed76af44afdfdc843b0c299b8b0a9585a0f32}{mem\_leak\_period\_enabled};
450 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=329pt]{class_memory_leak_detector_a9e85551d474d895ba8852b8e56481c7c_icgraph}
\end{center}
\end{figure}


\index{Memory\+Leak\+Detector@{Memory\+Leak\+Detector}!store\+Leak\+Information@{store\+Leak\+Information}}
\index{store\+Leak\+Information@{store\+Leak\+Information}!Memory\+Leak\+Detector@{Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{store\+Leak\+Information(\+Memory\+Leak\+Detector\+Node $\ast$node, char $\ast$new\+\_\+memory, size\+\_\+t size, Test\+Memory\+Allocator $\ast$allocator, const char $\ast$file, int line)}{storeLeakInformation(MemoryLeakDetectorNode *node, char *new_memory, size_t size, TestMemoryAllocator *allocator, const char *file, int line)}}]{\setlength{\rightskip}{0pt plus 5cm}void store\+Leak\+Information (
\begin{DoxyParamCaption}
\item[{{\bf Memory\+Leak\+Detector\+Node} $\ast$}]{node, }
\item[{char $\ast$}]{new\+\_\+memory, }
\item[{size\+\_\+t}]{size, }
\item[{{\bf Test\+Memory\+Allocator} $\ast$}]{allocator, }
\item[{const char $\ast$}]{file, }
\item[{int}]{line}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_memory_leak_detector_ad65311ebd24859da19c751e2e42e796f}{}\label{class_memory_leak_detector_ad65311ebd24859da19c751e2e42e796f}


Memory\+Leak\+Detector.\+cpp 파일의 497 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
498 \{
499     node->\hyperlink{struct_memory_leak_detector_node_aabfd3c84a772881892c1d9e48fa11b7b}{init}(new\_memory, \hyperlink{class_memory_leak_detector_a848e960c1d67dbe545416e2541663260}{allocationSequenceNumber\_}++, 
      \hyperlink{gst__avb__playbin_8c_a439227feff9d7f55384e8780cfc2eb82}{size}, allocator, \hyperlink{class_memory_leak_detector_af82b746b32f3ce3919db77a6985bab42}{current\_period\_}, file, line);
500     \hyperlink{class_memory_leak_detector_a1589a2a78f1b6ddd3f2466902abad2fe}{addMemoryCorruptionInformation}(node->\hyperlink{struct_memory_leak_detector_node_a6cdb5ad30702010eaf86e4e5f26defce}{memory\_} + node->
      \hyperlink{struct_memory_leak_detector_node_a5f31775800bbb46b35b5791def1f3acc}{size\_});
501     \hyperlink{class_memory_leak_detector_abee17cabbc59ef23d6f51027208a100c}{memoryTable\_}.\hyperlink{struct_memory_leak_detector_table_a78f2e89c0db3e4216dcd2061d70dea84}{addNewNode}(node);
502 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_memory_leak_detector_ad65311ebd24859da19c751e2e42e796f_cgraph}
\end{center}
\end{figure}


\index{Memory\+Leak\+Detector@{Memory\+Leak\+Detector}!total\+Memory\+Leaks@{total\+Memory\+Leaks}}
\index{total\+Memory\+Leaks@{total\+Memory\+Leaks}!Memory\+Leak\+Detector@{Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{total\+Memory\+Leaks(\+Mem\+Leak\+Period period)}{totalMemoryLeaks(MemLeakPeriod period)}}]{\setlength{\rightskip}{0pt plus 5cm}int total\+Memory\+Leaks (
\begin{DoxyParamCaption}
\item[{{\bf Mem\+Leak\+Period}}]{period}
\end{DoxyParamCaption}
)}\hypertarget{class_memory_leak_detector_a7b0c5d9c4d678d6e0081802416660803}{}\label{class_memory_leak_detector_a7b0c5d9c4d678d6e0081802416660803}


Memory\+Leak\+Detector.\+cpp 파일의 659 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
660 \{
661     \textcolor{keywordflow}{return} \hyperlink{class_memory_leak_detector_abee17cabbc59ef23d6f51027208a100c}{memoryTable\_}.\hyperlink{struct_memory_leak_detector_table_ae203c76563a188474a816e4ef8d8aa06}{getTotalLeaks}(period);
662 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_memory_leak_detector_a7b0c5d9c4d678d6e0081802416660803_icgraph}
\end{center}
\end{figure}


\index{Memory\+Leak\+Detector@{Memory\+Leak\+Detector}!valid\+Memory\+Corruption\+Information@{valid\+Memory\+Corruption\+Information}}
\index{valid\+Memory\+Corruption\+Information@{valid\+Memory\+Corruption\+Information}!Memory\+Leak\+Detector@{Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{valid\+Memory\+Corruption\+Information(char $\ast$memory)}{validMemoryCorruptionInformation(char *memory)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf bool} valid\+Memory\+Corruption\+Information (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{memory}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_memory_leak_detector_aeb6f1872936e5c8b25300897c8d81096}{}\label{class_memory_leak_detector_aeb6f1872936e5c8b25300897c8d81096}


Memory\+Leak\+Detector.\+cpp 파일의 528 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
529 \{
530     \textcolor{keywordflow}{return} memory[0] == \textcolor{charliteral}{'B'} && memory[1] == \textcolor{charliteral}{'A'} && memory[2] == \textcolor{charliteral}{'S'};
531 \}
\end{DoxyCode}


\subsection{필드 문서화}
\index{Memory\+Leak\+Detector@{Memory\+Leak\+Detector}!allocation\+Sequence\+Number\+\_\+@{allocation\+Sequence\+Number\+\_\+}}
\index{allocation\+Sequence\+Number\+\_\+@{allocation\+Sequence\+Number\+\_\+}!Memory\+Leak\+Detector@{Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{allocation\+Sequence\+Number\+\_\+}{allocationSequenceNumber_}}]{\setlength{\rightskip}{0pt plus 5cm}unsigned allocation\+Sequence\+Number\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_memory_leak_detector_a848e960c1d67dbe545416e2541663260}{}\label{class_memory_leak_detector_a848e960c1d67dbe545416e2541663260}


Memory\+Leak\+Detector.\+h 파일의 231 번째 라인에서 정의되었습니다.

\index{Memory\+Leak\+Detector@{Memory\+Leak\+Detector}!current\+\_\+period\+\_\+@{current\+\_\+period\+\_\+}}
\index{current\+\_\+period\+\_\+@{current\+\_\+period\+\_\+}!Memory\+Leak\+Detector@{Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{current\+\_\+period\+\_\+}{current_period_}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Mem\+Leak\+Period} current\+\_\+period\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_memory_leak_detector_af82b746b32f3ce3919db77a6985bab42}{}\label{class_memory_leak_detector_af82b746b32f3ce3919db77a6985bab42}


Memory\+Leak\+Detector.\+h 파일의 227 번째 라인에서 정의되었습니다.

\index{Memory\+Leak\+Detector@{Memory\+Leak\+Detector}!do\+Allocation\+Type\+Checking\+\_\+@{do\+Allocation\+Type\+Checking\+\_\+}}
\index{do\+Allocation\+Type\+Checking\+\_\+@{do\+Allocation\+Type\+Checking\+\_\+}!Memory\+Leak\+Detector@{Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{do\+Allocation\+Type\+Checking\+\_\+}{doAllocationTypeChecking_}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf bool} do\+Allocation\+Type\+Checking\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_memory_leak_detector_a9355cba4a5dcc00a72553874773d209e}{}\label{class_memory_leak_detector_a9355cba4a5dcc00a72553874773d209e}


Memory\+Leak\+Detector.\+h 파일의 230 번째 라인에서 정의되었습니다.

\index{Memory\+Leak\+Detector@{Memory\+Leak\+Detector}!memory\+Table\+\_\+@{memory\+Table\+\_\+}}
\index{memory\+Table\+\_\+@{memory\+Table\+\_\+}!Memory\+Leak\+Detector@{Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{memory\+Table\+\_\+}{memoryTable_}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Memory\+Leak\+Detector\+Table} memory\+Table\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_memory_leak_detector_abee17cabbc59ef23d6f51027208a100c}{}\label{class_memory_leak_detector_abee17cabbc59ef23d6f51027208a100c}


Memory\+Leak\+Detector.\+h 파일의 229 번째 라인에서 정의되었습니다.

\index{Memory\+Leak\+Detector@{Memory\+Leak\+Detector}!mutex\+\_\+@{mutex\+\_\+}}
\index{mutex\+\_\+@{mutex\+\_\+}!Memory\+Leak\+Detector@{Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{mutex\+\_\+}{mutex_}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Simple\+Mutex}$\ast$ mutex\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_memory_leak_detector_ab92d2f1606fbc62f3c4d5184d735dd04}{}\label{class_memory_leak_detector_ab92d2f1606fbc62f3c4d5184d735dd04}


Memory\+Leak\+Detector.\+h 파일의 232 번째 라인에서 정의되었습니다.

\index{Memory\+Leak\+Detector@{Memory\+Leak\+Detector}!output\+Buffer\+\_\+@{output\+Buffer\+\_\+}}
\index{output\+Buffer\+\_\+@{output\+Buffer\+\_\+}!Memory\+Leak\+Detector@{Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{output\+Buffer\+\_\+}{outputBuffer_}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Memory\+Leak\+Output\+String\+Buffer} output\+Buffer\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_memory_leak_detector_a7d0b175420d83f9ee397b398ae14ac75}{}\label{class_memory_leak_detector_a7d0b175420d83f9ee397b398ae14ac75}


Memory\+Leak\+Detector.\+h 파일의 228 번째 라인에서 정의되었습니다.

\index{Memory\+Leak\+Detector@{Memory\+Leak\+Detector}!reporter\+\_\+@{reporter\+\_\+}}
\index{reporter\+\_\+@{reporter\+\_\+}!Memory\+Leak\+Detector@{Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{reporter\+\_\+}{reporter_}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Memory\+Leak\+Failure}$\ast$ reporter\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_memory_leak_detector_a632df6e6476c93d9c58a104a17e155d9}{}\label{class_memory_leak_detector_a632df6e6476c93d9c58a104a17e155d9}


Memory\+Leak\+Detector.\+h 파일의 226 번째 라인에서 정의되었습니다.



이 클래스에 대한 문서화 페이지는 다음의 파일들로부터 생성되었습니다.\+:\begin{DoxyCompactItemize}
\item 
thirdparty/cpputest/include/\+Cpp\+U\+Test/\hyperlink{_memory_leak_detector_8h}{Memory\+Leak\+Detector.\+h}\item 
thirdparty/cpputest/src/\+Cpp\+U\+Test/\hyperlink{_memory_leak_detector_8cpp}{Memory\+Leak\+Detector.\+cpp}\end{DoxyCompactItemize}
