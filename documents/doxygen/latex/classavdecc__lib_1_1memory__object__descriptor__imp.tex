\hypertarget{classavdecc__lib_1_1memory__object__descriptor__imp}{}\section{memory\+\_\+object\+\_\+descriptor\+\_\+imp 클래스 참조}
\label{classavdecc__lib_1_1memory__object__descriptor__imp}\index{memory\+\_\+object\+\_\+descriptor\+\_\+imp@{memory\+\_\+object\+\_\+descriptor\+\_\+imp}}


{\ttfamily \#include $<$memory\+\_\+object\+\_\+descriptor\+\_\+imp.\+h$>$}



memory\+\_\+object\+\_\+descriptor\+\_\+imp에 대한 상속 다이어그램 \+: 
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=550pt]{classavdecc__lib_1_1memory__object__descriptor__imp__inherit__graph}
\end{center}
\end{figure}


memory\+\_\+object\+\_\+descriptor\+\_\+imp에 대한 협력 다이어그램\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=550pt]{classavdecc__lib_1_1memory__object__descriptor__imp__coll__graph}
\end{center}
\end{figure}
\subsection*{Public 멤버 함수}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classavdecc__lib_1_1memory__object__descriptor__imp_acf564de0c13b0a5be80adb04d7b96305}{memory\+\_\+object\+\_\+descriptor\+\_\+imp} (\hyperlink{classavdecc__lib_1_1end__station__imp}{end\+\_\+station\+\_\+imp} $\ast$end\+\_\+station\+\_\+obj, const \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} $\ast$\hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, ssize\+\_\+t pos, size\+\_\+t frame\+\_\+len)
\item 
virtual \hyperlink{classavdecc__lib_1_1memory__object__descriptor__imp_ac5e76114270ef56b9018de4f826e42a7}{$\sim$memory\+\_\+object\+\_\+descriptor\+\_\+imp} ()
\item 
\hyperlink{classavdecc__lib_1_1memory__object__descriptor__response}{memory\+\_\+object\+\_\+descriptor\+\_\+response} $\ast$S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1memory__object__descriptor__imp_a08904513dd93a4e8af3c8bd3f03dae4d}{get\+\_\+memory\+\_\+object\+\_\+response} ()
\item 
int S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1memory__object__descriptor__imp_aa2bf4467e8b82b1d4576d50fd4ad1923}{start\+\_\+operation\+\_\+cmd} (void $\ast$notification\+\_\+id, uint16\+\_\+t operation\+\_\+type)
\item 
int \hyperlink{classavdecc__lib_1_1memory__object__descriptor__imp_afac474ba080005fc6eeb6fb8ebae4d96}{proc\+\_\+start\+\_\+operation\+\_\+resp} (void $\ast$\&notification\+\_\+id, const \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} $\ast$\hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, size\+\_\+t frame\+\_\+len, int \&status, uint16\+\_\+t \&operation\+\_\+id, uint16\+\_\+t \&operation\+\_\+type)
\item 
int \hyperlink{classavdecc__lib_1_1memory__object__descriptor__imp_a7c108e43d954d43c7f53400a86c53354}{proc\+\_\+operation\+\_\+status\+\_\+resp} (void $\ast$\&notification\+\_\+id, const \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} $\ast$\hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, size\+\_\+t frame\+\_\+len, int \&status, uint16\+\_\+t \&operation\+\_\+id, \hyperlink{avb__gptp_8h_af6a258d8f3ee5206d682d799316314b1}{bool} \&is\+\_\+operation\+\_\+id\+\_\+valid)
\item 
virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI uint16\+\_\+t S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base_a5112b70022171063ec5d3242bee9910e}{descriptor\+\_\+type} () const =0
\item 
virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI uint16\+\_\+t S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base_a7eed5583bffdf72d89021b188648c1b5}{descriptor\+\_\+index} () const =0
\item 
virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI size\+\_\+t S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base_ab1edf4996377ed957088a7b3b16aca7d}{field\+\_\+count} () const =0
\item 
virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI \hyperlink{classavdecc__lib_1_1descriptor__field}{descriptor\+\_\+field} $\ast$S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base_aa3716832eed0b6f6dcfba358c5d2c601}{field} (size\+\_\+t index) const =0
\item 
virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI uint16\+\_\+t S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base_a1fb9de45567df344090a1407aa6b775f}{localized\+\_\+description} ()=0
\item 
virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI \hyperlink{parse_8c_a6eb1e68cc391dd753bc8ce896dbb8315}{uint32\+\_\+t} S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base_a42f2a796375edd05c8d29856c018042d}{acquire\+\_\+entity\+\_\+flags} ()=0
\item 
virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI \hyperlink{parse_8c_aec6fcb673ff035718c238c8c9d544c47}{uint64\+\_\+t} S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base_a6480d803970d505ce7a9b429a6eb71bd}{acquire\+\_\+entity\+\_\+owner\+\_\+entity\+\_\+id} ()=0
\item 
virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI \hyperlink{parse_8c_a6eb1e68cc391dd753bc8ce896dbb8315}{uint32\+\_\+t} S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base_a757e66272bba4c52cefa914df8c60bb5}{lock\+\_\+entity\+\_\+flags} ()=0
\item 
virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI \hyperlink{parse_8c_aec6fcb673ff035718c238c8c9d544c47}{uint64\+\_\+t} S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base_a052b47529d0e60ca87894159fcb65e14}{lock\+\_\+entity\+\_\+locked\+\_\+entity\+\_\+id} ()=0
\item 
virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI int S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base_adfd0cf2a51bff7d762b0efc743480c48}{send\+\_\+acquire\+\_\+entity\+\_\+cmd} (void $\ast$notification\+\_\+id, \hyperlink{parse_8c_a6eb1e68cc391dd753bc8ce896dbb8315}{uint32\+\_\+t} acquire\+\_\+entity\+\_\+flag)=0
\item 
virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI int S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base_a1ac1f5c700f4eebd37b7c45498b36bbc}{send\+\_\+lock\+\_\+entity\+\_\+cmd} (void $\ast$notification\+\_\+id, \hyperlink{parse_8c_a6eb1e68cc391dd753bc8ce896dbb8315}{uint32\+\_\+t} lock\+\_\+entity\+\_\+flag)=0
\item 
virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI int S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base_a1618412a9b3d57a12044030b31cfd5a3}{send\+\_\+reboot\+\_\+cmd} (void $\ast$notification\+\_\+id)=0
\item 
virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI int S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base_a6a8c227d7a202f251c689107df7ede0b}{send\+\_\+set\+\_\+name\+\_\+cmd} (void $\ast$notification\+\_\+id, uint16\+\_\+t name\+\_\+index, uint16\+\_\+t config\+\_\+index, const struct \hyperlink{structavdecc__lib_1_1avdecc__lib__name__string64}{avdecc\+\_\+lib\+\_\+name\+\_\+string64} $\ast$new\+\_\+name)=0
\item 
virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI int S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base_a27ba9959456de53a8de18eead74806f7}{send\+\_\+get\+\_\+name\+\_\+cmd} (void $\ast$notification\+\_\+id, uint16\+\_\+t name\+\_\+index, uint16\+\_\+t config\+\_\+index)=0
\item 
virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI \hyperlink{classavdecc__lib_1_1descriptor__response__base}{descriptor\+\_\+response\+\_\+base} $\ast$S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base_ac64e6a5ee8781eeb9c781953e845b1be}{get\+\_\+descriptor\+\_\+response} ()=0
\item 
virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI \hyperlink{classavdecc__lib_1_1descriptor__base__get__name__response}{descriptor\+\_\+base\+\_\+get\+\_\+name\+\_\+response} $\ast$S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base_aba4bf8a81f90f5bf00d5c8b5a7330145}{get\+\_\+name\+\_\+response} ()=0
\item 
uint16\+\_\+t S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base__imp_aefc543029ab093823c3f5b9d84f0ccc4}{descriptor\+\_\+type} () const 
\item 
uint16\+\_\+t S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base__imp_ac23c0a35276c07cfce8c8660700c2135}{descriptor\+\_\+index} () const 
\item 
virtual uint16\+\_\+t S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base__imp_aa94307532fbb37e2f986fee8fec79373}{localized\+\_\+description} ()
\item 
size\+\_\+t S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a9b98d4f427a6c527e9080c938cfa9334}{field\+\_\+count} () const 
\item 
\hyperlink{classavdecc__lib_1_1descriptor__field}{descriptor\+\_\+field} $\ast$S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a5f8127d32e2aa54777ca03bf09e8d7b5}{field} (size\+\_\+t index) const 
\item 
virtual void S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a482fe95208e9e14885e28e73e7be2c49}{replace\+\_\+frame} (const \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} $\ast$\hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, ssize\+\_\+t pos, size\+\_\+t \hyperlink{gst__avb__playbin_8c_a439227feff9d7f55384e8780cfc2eb82}{size})
\item 
virtual void S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a8dbf7d4faedf36ec789d33f228e22039}{replace\+\_\+desc\+\_\+frame} (const \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} $\ast$\hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, ssize\+\_\+t pos, size\+\_\+t \hyperlink{gst__avb__playbin_8c_a439227feff9d7f55384e8780cfc2eb82}{size})
\item 
virtual \hyperlink{parse_8c_a6eb1e68cc391dd753bc8ce896dbb8315}{uint32\+\_\+t} S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2d270d205bcea948cf61311a1f8336c6}{acquire\+\_\+entity\+\_\+flags} ()
\item 
virtual \hyperlink{parse_8c_aec6fcb673ff035718c238c8c9d544c47}{uint64\+\_\+t} S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a507b250a984bb5611d2699cd26d60a51}{acquire\+\_\+entity\+\_\+owner\+\_\+entity\+\_\+id} ()
\item 
virtual \hyperlink{parse_8c_a6eb1e68cc391dd753bc8ce896dbb8315}{uint32\+\_\+t} S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base__imp_afe2564a2a32f83deced28efa17f332e2}{lock\+\_\+entity\+\_\+flags} ()
\item 
virtual \hyperlink{parse_8c_aec6fcb673ff035718c238c8c9d544c47}{uint64\+\_\+t} S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base__imp_aeb8f096d55f82522516cbf00a616246a}{lock\+\_\+entity\+\_\+locked\+\_\+entity\+\_\+id} ()
\item 
virtual int S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base__imp_aea9e3053b75477816c15487d3e9a6f70}{send\+\_\+acquire\+\_\+entity\+\_\+cmd} (void $\ast$notification\+\_\+id, \hyperlink{parse_8c_a6eb1e68cc391dd753bc8ce896dbb8315}{uint32\+\_\+t} acquire\+\_\+entity\+\_\+flag)
\item 
virtual int \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a934de13d0b017574d514ce276180a004}{proc\+\_\+acquire\+\_\+entity\+\_\+resp} (void $\ast$\&notification\+\_\+id, const \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} $\ast$\hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, size\+\_\+t frame\+\_\+len, int \&status)
\item 
int \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a4ee5f42b89a728627bf1340afebc7c82}{default\+\_\+send\+\_\+acquire\+\_\+entity\+\_\+cmd} (\hyperlink{classavdecc__lib_1_1descriptor__base__imp}{descriptor\+\_\+base\+\_\+imp} $\ast$desc\+\_\+base\+\_\+imp\+\_\+ref, void $\ast$notification\+\_\+id, \hyperlink{parse_8c_a6eb1e68cc391dd753bc8ce896dbb8315}{uint32\+\_\+t} acquire\+\_\+entity\+\_\+flag)
\item 
int \hyperlink{classavdecc__lib_1_1descriptor__base__imp_ad248d7d7060e28eb36c8dc37d2653c43}{default\+\_\+proc\+\_\+acquire\+\_\+entity\+\_\+resp} (struct \hyperlink{structjdksavdecc__aem__command__acquire__entity__response}{jdksavdecc\+\_\+aem\+\_\+command\+\_\+acquire\+\_\+entity\+\_\+response} \&aem\+\_\+cmd\+\_\+acquire\+\_\+entity\+\_\+resp, void $\ast$\&notification\+\_\+id, const \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} $\ast$\hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, size\+\_\+t frame\+\_\+len, int \&status)
\item 
virtual int S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a26fd66d8c409502eaa4dba47742ca7fa}{send\+\_\+lock\+\_\+entity\+\_\+cmd} (void $\ast$notification\+\_\+id, \hyperlink{parse_8c_a6eb1e68cc391dd753bc8ce896dbb8315}{uint32\+\_\+t} lock\+\_\+entity\+\_\+flag)
\item 
virtual int \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a6cd2b73ea95b18f07dbdc251140679b0}{proc\+\_\+lock\+\_\+entity\+\_\+resp} (void $\ast$\&notification\+\_\+id, const \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} $\ast$\hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, size\+\_\+t frame\+\_\+len, int \&status)
\item 
int \hyperlink{classavdecc__lib_1_1descriptor__base__imp_af40ac09b84feb7551bf0389a2a5db4ca}{default\+\_\+send\+\_\+lock\+\_\+entity\+\_\+cmd} (\hyperlink{classavdecc__lib_1_1descriptor__base__imp}{descriptor\+\_\+base\+\_\+imp} $\ast$descriptor\+\_\+base\+\_\+imp\+\_\+ref, void $\ast$notification\+\_\+id, \hyperlink{parse_8c_a6eb1e68cc391dd753bc8ce896dbb8315}{uint32\+\_\+t} lock\+\_\+entity\+\_\+flag)
\item 
int \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a3b3582020613e7f60efe96567679be7f}{default\+\_\+proc\+\_\+lock\+\_\+entity\+\_\+resp} (struct \hyperlink{structjdksavdecc__aem__command__lock__entity__response}{jdksavdecc\+\_\+aem\+\_\+command\+\_\+lock\+\_\+entity\+\_\+response} \&aem\+\_\+cmd\+\_\+lock\+\_\+entity\+\_\+resp, void $\ast$\&notification\+\_\+id, const \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} $\ast$\hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, size\+\_\+t frame\+\_\+len, int \&status)
\item 
virtual int S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a7579db44e8e86da0f8f94aa4680df795}{send\+\_\+reboot\+\_\+cmd} (void $\ast$notification\+\_\+id)
\item 
virtual int \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a8b3de398748e8299daf7296964f73c22}{proc\+\_\+reboot\+\_\+resp} (void $\ast$\&notification\+\_\+id, const \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} $\ast$\hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, size\+\_\+t frame\+\_\+len, int \&status)
\item 
int \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a14e3bd11c70e839a0594dc59dffcbf16}{default\+\_\+send\+\_\+reboot\+\_\+cmd} (\hyperlink{classavdecc__lib_1_1descriptor__base__imp}{descriptor\+\_\+base\+\_\+imp} $\ast$descriptor\+\_\+base\+\_\+imp\+\_\+ref, void $\ast$notification\+\_\+id)
\item 
int \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a774dc940e9918a60127b0b021582b32a}{default\+\_\+proc\+\_\+reboot\+\_\+resp} (struct \hyperlink{structjdksavdecc__aem__command__reboot__response}{jdksavdecc\+\_\+aem\+\_\+command\+\_\+reboot\+\_\+response} \&aem\+\_\+cmd\+\_\+reboot\+\_\+resp, void $\ast$\&notification\+\_\+id, const \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} $\ast$\hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, size\+\_\+t frame\+\_\+len, int \&status)
\item 
virtual int S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base__imp_af0bb05af3bf67f2ab0eb522096011592}{send\+\_\+set\+\_\+name\+\_\+cmd} (void $\ast$notification\+\_\+id, uint16\+\_\+t name\+\_\+index, uint16\+\_\+t config\+\_\+index, const struct \hyperlink{structavdecc__lib_1_1avdecc__lib__name__string64}{avdecc\+\_\+lib\+\_\+name\+\_\+string64} $\ast$new\+\_\+name)
\item 
virtual int \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a182c43d9f31980bb74f05956b1323624}{proc\+\_\+set\+\_\+name\+\_\+resp} (void $\ast$\&notification\+\_\+id, const \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} $\ast$\hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, size\+\_\+t frame\+\_\+len, int \&status)
\item 
int \hyperlink{classavdecc__lib_1_1descriptor__base__imp_aed899a0eaaaa06a02569135f844ffce8}{default\+\_\+send\+\_\+set\+\_\+name\+\_\+cmd} (\hyperlink{classavdecc__lib_1_1descriptor__base__imp}{descriptor\+\_\+base\+\_\+imp} $\ast$desc\+\_\+base\+\_\+imp\+\_\+ref, void $\ast$notification\+\_\+id, uint16\+\_\+t name\+\_\+index, uint16\+\_\+t config\+\_\+index, const struct \hyperlink{structavdecc__lib_1_1avdecc__lib__name__string64}{avdecc\+\_\+lib\+\_\+name\+\_\+string64} $\ast$name)
\item 
int \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2f52c3b9a7ad6f490bed0c96a9136bc3}{default\+\_\+proc\+\_\+set\+\_\+name\+\_\+resp} (struct \hyperlink{structjdksavdecc__aem__command__set__name__response}{jdksavdecc\+\_\+aem\+\_\+command\+\_\+set\+\_\+name\+\_\+response} \&aem\+\_\+cmd\+\_\+set\+\_\+name\+\_\+resp, void $\ast$\&notification\+\_\+id, const \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} $\ast$\hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, size\+\_\+t frame\+\_\+len, int \&status)
\item 
virtual int S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a4e8ce103baabbd5fc07deabfb95f791a}{send\+\_\+get\+\_\+name\+\_\+cmd} (void $\ast$notification\+\_\+id, uint16\+\_\+t name\+\_\+index, uint16\+\_\+t config\+\_\+index)
\item 
virtual int \hyperlink{classavdecc__lib_1_1descriptor__base__imp_ac4e290a88039a8e4915f7b9f8738881f}{proc\+\_\+get\+\_\+name\+\_\+resp} (void $\ast$\&notification\+\_\+id, const \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} $\ast$\hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, size\+\_\+t frame\+\_\+len, int \&status)
\item 
int \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a92f2c88d261418872a496a8145800751}{default\+\_\+send\+\_\+get\+\_\+name\+\_\+cmd} (\hyperlink{classavdecc__lib_1_1descriptor__base__imp}{descriptor\+\_\+base\+\_\+imp} $\ast$desc\+\_\+base\+\_\+imp\+\_\+ref, void $\ast$notification\+\_\+id, uint16\+\_\+t name\+\_\+index, uint16\+\_\+t config\+\_\+index)
\item 
int \hyperlink{classavdecc__lib_1_1descriptor__base__imp_acc8b1c1591bd54bc9a2d21d4f0db2e86}{default\+\_\+proc\+\_\+get\+\_\+name\+\_\+resp} (struct \hyperlink{structjdksavdecc__aem__command__get__name__response}{jdksavdecc\+\_\+aem\+\_\+command\+\_\+get\+\_\+name\+\_\+response} \&aem\+\_\+cmd\+\_\+get\+\_\+name\+\_\+resp, void $\ast$\&notification\+\_\+id, const \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} $\ast$\hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, size\+\_\+t frame\+\_\+len, int \&status)
\item 
\hyperlink{classavdecc__lib_1_1descriptor__response__base}{descriptor\+\_\+response\+\_\+base} $\ast$S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a8c64c9df60afbc144cf24eab5a42c009}{get\+\_\+descriptor\+\_\+response} ()
\item 
\hyperlink{classavdecc__lib_1_1descriptor__base__get__name__response}{descriptor\+\_\+base\+\_\+get\+\_\+name\+\_\+response} $\ast$S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base__imp_abf130a286ee3ca9d1f41a7e2abbd0d33}{get\+\_\+name\+\_\+response} ()
\end{DoxyCompactItemize}
\subsection*{데이타 필드}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classavdecc__lib_1_1memory__object__descriptor__response__imp}{memory\+\_\+object\+\_\+descriptor\+\_\+response\+\_\+imp} $\ast$ \hyperlink{classavdecc__lib_1_1memory__object__descriptor__imp_ad06f22b0ac48bb4645e644db866d01cf}{resp}
\end{DoxyCompactItemize}
\subsection*{Protected 속성}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classavdecc__lib_1_1descriptor__response__base__imp}{descriptor\+\_\+response\+\_\+base\+\_\+imp} $\ast$ \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a8b104da8319cda946944548ebb9552f4}{resp\+\_\+base}
\item 
\hyperlink{classavdecc__lib_1_1descriptor__base__get__name__response__imp}{descriptor\+\_\+base\+\_\+get\+\_\+name\+\_\+response\+\_\+imp} $\ast$ \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a7d3a410eb242dc2b7abe9862a1593458}{get\+\_\+name\+\_\+resp}
\item 
\hyperlink{classavdecc__lib_1_1end__station__imp}{end\+\_\+station\+\_\+imp} $\ast$ \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\+\_\+end\+\_\+station\+\_\+imp\+\_\+ref}
\item 
std\+::vector$<$ \hyperlink{classavdecc__lib_1_1descriptor__field__imp}{descriptor\+\_\+field\+\_\+imp} $\ast$ $>$ \hyperlink{classavdecc__lib_1_1descriptor__base__imp_adce67136eb9c66da9c189b730077b9cd}{m\+\_\+fields}
\item 
\hyperlink{classavdecc__lib_1_1response__frame}{response\+\_\+frame} $\ast$ \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2642e3a7c10d38553e7ff4a55e875346}{resp\+\_\+ref}
\item 
uint16\+\_\+t \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a9dada313309522d04f1e52fe887442b4}{desc\+\_\+type}
\item 
uint16\+\_\+t \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2bbd0d8f32f687ca36aaa543c06f764c}{desc\+\_\+index}
\end{DoxyCompactItemize}


\subsection{상세한 설명}


memory\+\_\+object\+\_\+descriptor\+\_\+imp.\+h 파일의 38 번째 라인에서 정의되었습니다.



\subsection{생성자 \& 소멸자 문서화}
\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!memory\+\_\+object\+\_\+descriptor\+\_\+imp@{memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\index{memory\+\_\+object\+\_\+descriptor\+\_\+imp@{memory\+\_\+object\+\_\+descriptor\+\_\+imp}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{memory\+\_\+object\+\_\+descriptor\+\_\+imp(end\+\_\+station\+\_\+imp $\ast$end\+\_\+station\+\_\+obj, const uint8\+\_\+t $\ast$frame, ssize\+\_\+t pos, size\+\_\+t frame\+\_\+len)}{memory_object_descriptor_imp(end_station_imp *end_station_obj, const uint8_t *frame, ssize_t pos, size_t frame_len)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf memory\+\_\+object\+\_\+descriptor\+\_\+imp} (
\begin{DoxyParamCaption}
\item[{{\bf end\+\_\+station\+\_\+imp} $\ast$}]{end\+\_\+station\+\_\+obj, }
\item[{const {\bf uint8\+\_\+t} $\ast$}]{frame, }
\item[{ssize\+\_\+t}]{pos, }
\item[{size\+\_\+t}]{frame\+\_\+len}
\end{DoxyParamCaption}
)}\hypertarget{classavdecc__lib_1_1memory__object__descriptor__imp_acf564de0c13b0a5be80adb04d7b96305}{}\label{classavdecc__lib_1_1memory__object__descriptor__imp_acf564de0c13b0a5be80adb04d7b96305}


memory\+\_\+object\+\_\+descriptor\+\_\+imp.\+cpp 파일의 45 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
45 : \hyperlink{classavdecc__lib_1_1descriptor__base__imp_afce4f89b7126c42e77054b5c76e21fc6}{descriptor\_base\_imp}(end\_station\_obj, \hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, frame\_len, pos) \{\}
\end{DoxyCode}
\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!````~memory\+\_\+object\+\_\+descriptor\+\_\+imp@{$\sim$memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\index{````~memory\+\_\+object\+\_\+descriptor\+\_\+imp@{$\sim$memory\+\_\+object\+\_\+descriptor\+\_\+imp}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{$\sim$memory\+\_\+object\+\_\+descriptor\+\_\+imp()}{~memory_object_descriptor_imp()}}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf memory\+\_\+object\+\_\+descriptor\+\_\+imp} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classavdecc__lib_1_1memory__object__descriptor__imp_ac5e76114270ef56b9018de4f826e42a7}{}\label{classavdecc__lib_1_1memory__object__descriptor__imp_ac5e76114270ef56b9018de4f826e42a7}


memory\+\_\+object\+\_\+descriptor\+\_\+imp.\+cpp 파일의 47 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
47 \{\}
\end{DoxyCode}


\subsection{멤버 함수 문서화}
\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!acquire\+\_\+entity\+\_\+flags@{acquire\+\_\+entity\+\_\+flags}}
\index{acquire\+\_\+entity\+\_\+flags@{acquire\+\_\+entity\+\_\+flags}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{acquire\+\_\+entity\+\_\+flags()=0}{acquire_entity_flags()=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI {\bf uint32\+\_\+t} S\+T\+D\+C\+A\+LL acquire\+\_\+entity\+\_\+flags (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base_a42f2a796375edd05c8d29856c018042d}{}\label{classavdecc__lib_1_1descriptor__base_a42f2a796375edd05c8d29856c018042d}
\begin{DoxyReturn}{반환값}
The flags after sending a A\+C\+Q\+U\+I\+R\+E\+\_\+\+E\+N\+T\+I\+TY command and receiving a response back for the command. 
\end{DoxyReturn}


\hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2d270d205bcea948cf61311a1f8336c6}{descriptor\+\_\+base\+\_\+imp}, \hyperlink{classavdecc__lib_1_1entity__descriptor__imp_a2d270d205bcea948cf61311a1f8336c6}{entity\+\_\+descriptor\+\_\+imp}에서 구현되었습니다.



이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=312pt]{classavdecc__lib_1_1descriptor__base_a42f2a796375edd05c8d29856c018042d_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!acquire\+\_\+entity\+\_\+flags@{acquire\+\_\+entity\+\_\+flags}}
\index{acquire\+\_\+entity\+\_\+flags@{acquire\+\_\+entity\+\_\+flags}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{acquire\+\_\+entity\+\_\+flags()}{acquire_entity_flags()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\+\_\+t} S\+T\+D\+C\+A\+LL acquire\+\_\+entity\+\_\+flags (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_a2d270d205bcea948cf61311a1f8336c6}{}\label{classavdecc__lib_1_1descriptor__base__imp_a2d270d205bcea948cf61311a1f8336c6}
Get the flags after sending a A\+C\+Q\+U\+I\+R\+E\+\_\+\+E\+N\+T\+I\+TY command and receiving a response back for the command. 

\hyperlink{classavdecc__lib_1_1descriptor__base_a42f2a796375edd05c8d29856c018042d}{descriptor\+\_\+base}를 구현.



\hyperlink{classavdecc__lib_1_1entity__descriptor__imp_a2d270d205bcea948cf61311a1f8336c6}{entity\+\_\+descriptor\+\_\+imp}에서 재구현되었습니다.



descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 114 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
115 \{
116     \textcolor{keywordflow}{return} 0;
117 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=255pt]{classavdecc__lib_1_1descriptor__base__imp_a2d270d205bcea948cf61311a1f8336c6_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!acquire\+\_\+entity\+\_\+owner\+\_\+entity\+\_\+id@{acquire\+\_\+entity\+\_\+owner\+\_\+entity\+\_\+id}}
\index{acquire\+\_\+entity\+\_\+owner\+\_\+entity\+\_\+id@{acquire\+\_\+entity\+\_\+owner\+\_\+entity\+\_\+id}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{acquire\+\_\+entity\+\_\+owner\+\_\+entity\+\_\+id()=0}{acquire_entity_owner_entity_id()=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI {\bf uint64\+\_\+t} S\+T\+D\+C\+A\+LL acquire\+\_\+entity\+\_\+owner\+\_\+entity\+\_\+id (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base_a6480d803970d505ce7a9b429a6eb71bd}{}\label{classavdecc__lib_1_1descriptor__base_a6480d803970d505ce7a9b429a6eb71bd}
\begin{DoxyReturn}{반환값}
The owner id after sending a A\+C\+Q\+U\+I\+R\+E\+\_\+\+E\+N\+T\+I\+TY command and receiving a response back for the command. 
\end{DoxyReturn}


\hyperlink{classavdecc__lib_1_1descriptor__base__imp_a507b250a984bb5611d2699cd26d60a51}{descriptor\+\_\+base\+\_\+imp}, \hyperlink{classavdecc__lib_1_1entity__descriptor__imp_a507b250a984bb5611d2699cd26d60a51}{entity\+\_\+descriptor\+\_\+imp}에서 구현되었습니다.



이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=317pt]{classavdecc__lib_1_1descriptor__base_a6480d803970d505ce7a9b429a6eb71bd_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!acquire\+\_\+entity\+\_\+owner\+\_\+entity\+\_\+id@{acquire\+\_\+entity\+\_\+owner\+\_\+entity\+\_\+id}}
\index{acquire\+\_\+entity\+\_\+owner\+\_\+entity\+\_\+id@{acquire\+\_\+entity\+\_\+owner\+\_\+entity\+\_\+id}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{acquire\+\_\+entity\+\_\+owner\+\_\+entity\+\_\+id()}{acquire_entity_owner_entity_id()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint64\+\_\+t} S\+T\+D\+C\+A\+LL acquire\+\_\+entity\+\_\+owner\+\_\+entity\+\_\+id (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_a507b250a984bb5611d2699cd26d60a51}{}\label{classavdecc__lib_1_1descriptor__base__imp_a507b250a984bb5611d2699cd26d60a51}
Get the owner id after sending a A\+C\+Q\+U\+I\+R\+E\+\_\+\+E\+N\+T\+I\+TY command and receiving a response back for the command. 

\hyperlink{classavdecc__lib_1_1descriptor__base_a6480d803970d505ce7a9b429a6eb71bd}{descriptor\+\_\+base}를 구현.



\hyperlink{classavdecc__lib_1_1entity__descriptor__imp_a507b250a984bb5611d2699cd26d60a51}{entity\+\_\+descriptor\+\_\+imp}에서 재구현되었습니다.



descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 119 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
120 \{
121     \textcolor{keywordflow}{return} 0;
122 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=260pt]{classavdecc__lib_1_1descriptor__base__imp_a507b250a984bb5611d2699cd26d60a51_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!default\+\_\+proc\+\_\+acquire\+\_\+entity\+\_\+resp@{default\+\_\+proc\+\_\+acquire\+\_\+entity\+\_\+resp}}
\index{default\+\_\+proc\+\_\+acquire\+\_\+entity\+\_\+resp@{default\+\_\+proc\+\_\+acquire\+\_\+entity\+\_\+resp}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{default\+\_\+proc\+\_\+acquire\+\_\+entity\+\_\+resp(struct jdksavdecc\+\_\+aem\+\_\+command\+\_\+acquire\+\_\+entity\+\_\+response \&aem\+\_\+cmd\+\_\+acquire\+\_\+entity\+\_\+resp, void $\ast$\&notification\+\_\+id, const uint8\+\_\+t $\ast$frame, size\+\_\+t frame\+\_\+len, int \&status)}{default_proc_acquire_entity_resp(struct jdksavdecc_aem_command_acquire_entity_response &aem_cmd_acquire_entity_resp, void *&notification_id, const uint8_t *frame, size_t frame_len, int &status)}}]{\setlength{\rightskip}{0pt plus 5cm}int default\+\_\+proc\+\_\+acquire\+\_\+entity\+\_\+resp (
\begin{DoxyParamCaption}
\item[{struct {\bf jdksavdecc\+\_\+aem\+\_\+command\+\_\+acquire\+\_\+entity\+\_\+response} \&}]{aem\+\_\+cmd\+\_\+acquire\+\_\+entity\+\_\+resp, }
\item[{void $\ast$\&}]{notification\+\_\+id, }
\item[{const {\bf uint8\+\_\+t} $\ast$}]{frame, }
\item[{size\+\_\+t}]{frame\+\_\+len, }
\item[{int \&}]{status}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_ad248d7d7060e28eb36c8dc37d2653c43}{}\label{classavdecc__lib_1_1descriptor__base__imp_ad248d7d7060e28eb36c8dc37d2653c43}


descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 196 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
201 \{
202     \textcolor{keyword}{struct }\hyperlink{structjdksavdecc__frame}{jdksavdecc\_frame} cmd\_frame;
203     ssize\_t aem\_cmd\_acquire\_entity\_resp\_returned;
204     \hyperlink{parse_8c_a6eb1e68cc391dd753bc8ce896dbb8315}{uint32\_t} msg\_type;
205     \textcolor{keywordtype}{bool} u\_field;
206 
207     memcpy(cmd\_frame.payload, \hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, frame\_len);
208 
209     aem\_cmd\_acquire\_entity\_resp\_returned = 
      \hyperlink{group__command__acquire__entity__response_ga2eba02e65645b4bd3367333fe0c99df5}{jdksavdecc\_aem\_command\_acquire\_entity\_response\_read}(&
      aem\_cmd\_acquire\_entity\_resp,
210                                                                                                
      \hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame},
211                                                                                                
      \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE},
212                                                                                                frame\_len);
213 
214     \textcolor{keywordflow}{if} (aem\_cmd\_acquire\_entity\_resp\_returned < 0)
215     \{
216         \hyperlink{namespaceavdecc__lib_acbe3e2a96ae6524943ca532c87a28529}{log\_imp\_ref}->\hyperlink{classavdecc__lib_1_1log_a68139a6297697e4ccebf36ccfd02e44a}{post\_log\_msg}(\hyperlink{namespaceavdecc__lib_a501055c431e6872ef46f252ad13f85cdaf2c4481208273451a6f5c7bb9770ec8a}{LOGGING\_LEVEL\_ERROR}, \textcolor{stringliteral}{"
      aem\_cmd\_acquire\_entity\_resp\_read error\(\backslash\)n"});
217         assert(aem\_cmd\_acquire\_entity\_resp\_returned >= 0);
218         \textcolor{keywordflow}{return} -1;
219     \}
220 
221     msg\_type = aem\_cmd\_acquire\_entity\_resp.\hyperlink{structjdksavdecc__aem__command__acquire__entity__response_ae1e77ccb75ff5021ad923221eab38294}{aem\_header}.\hyperlink{structjdksavdecc__aecpdu__aem_ae8460ae179666e7ce268ed1ef33d0de3}{aecpdu\_header}.
      \hyperlink{structjdksavdecc__aecpdu__common_a314cacb6a61bcf18749030c0b6fb7510}{header}.\hyperlink{structjdksavdecc__aecpdu__common__control__header_aeaaffeace8c23899e558022f62ce6de4}{message\_type};
222     status = aem\_cmd\_acquire\_entity\_resp.\hyperlink{structjdksavdecc__aem__command__acquire__entity__response_ae1e77ccb75ff5021ad923221eab38294}{aem\_header}.\hyperlink{structjdksavdecc__aecpdu__aem_ae8460ae179666e7ce268ed1ef33d0de3}{aecpdu\_header}.
      \hyperlink{structjdksavdecc__aecpdu__common_a314cacb6a61bcf18749030c0b6fb7510}{header}.\hyperlink{structjdksavdecc__aecpdu__common__control__header_ade818037fd6c985038ff29656089758d}{status};
223     u\_field = aem\_cmd\_acquire\_entity\_resp.\hyperlink{structjdksavdecc__aem__command__acquire__entity__response_ae1e77ccb75ff5021ad923221eab38294}{aem\_header}.\hyperlink{structjdksavdecc__aecpdu__aem_a07f7ee802870e9ae75f021832f59a8a9}{command\_type} >> 15 & 0x01; \textcolor{comment}{//
       u\_field = the msb of the uint16\_t command\_type}
224 
225     \hyperlink{namespaceavdecc__lib_a0b1b5aea3c0490f77cbfd9178af5be22}{aecp\_controller\_state\_machine\_ref}->
      \hyperlink{classavdecc__lib_1_1aecp__controller__state__machine_a997abd9786c330a5505e903e6443208e}{update\_inflight\_for\_rcvd\_resp}(notification\_id, msg\_type, u\_field, &cmd\_frame);
226 
227     \textcolor{keywordflow}{return} 0;
228 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_ad248d7d7060e28eb36c8dc37d2653c43_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_ad248d7d7060e28eb36c8dc37d2653c43_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!default\+\_\+proc\+\_\+get\+\_\+name\+\_\+resp@{default\+\_\+proc\+\_\+get\+\_\+name\+\_\+resp}}
\index{default\+\_\+proc\+\_\+get\+\_\+name\+\_\+resp@{default\+\_\+proc\+\_\+get\+\_\+name\+\_\+resp}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{default\+\_\+proc\+\_\+get\+\_\+name\+\_\+resp(struct jdksavdecc\+\_\+aem\+\_\+command\+\_\+get\+\_\+name\+\_\+response \&aem\+\_\+cmd\+\_\+get\+\_\+name\+\_\+resp, void $\ast$\&notification\+\_\+id, const uint8\+\_\+t $\ast$frame, size\+\_\+t frame\+\_\+len, int \&status)}{default_proc_get_name_resp(struct jdksavdecc_aem_command_get_name_response &aem_cmd_get_name_resp, void *&notification_id, const uint8_t *frame, size_t frame_len, int &status)}}]{\setlength{\rightskip}{0pt plus 5cm}int default\+\_\+proc\+\_\+get\+\_\+name\+\_\+resp (
\begin{DoxyParamCaption}
\item[{struct {\bf jdksavdecc\+\_\+aem\+\_\+command\+\_\+get\+\_\+name\+\_\+response} \&}]{aem\+\_\+cmd\+\_\+get\+\_\+name\+\_\+resp, }
\item[{void $\ast$\&}]{notification\+\_\+id, }
\item[{const {\bf uint8\+\_\+t} $\ast$}]{frame, }
\item[{size\+\_\+t}]{frame\+\_\+len, }
\item[{int \&}]{status}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_acc8b1c1591bd54bc9a2d21d4f0db2e86}{}\label{classavdecc__lib_1_1descriptor__base__imp_acc8b1c1591bd54bc9a2d21d4f0db2e86}


descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 582 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
587 \{
588     \textcolor{keyword}{struct }\hyperlink{structjdksavdecc__frame}{jdksavdecc\_frame} cmd\_frame;
589     ssize\_t aem\_cmd\_get\_name\_resp\_returned = 0;
590     \hyperlink{parse_8c_a6eb1e68cc391dd753bc8ce896dbb8315}{uint32\_t} msg\_type = 0;
591     \textcolor{keywordtype}{bool} u\_field = \textcolor{keyword}{false};
592 
593     memcpy(cmd\_frame.payload, \hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, frame\_len);
594 
595     aem\_cmd\_get\_name\_resp\_returned = 
      \hyperlink{group__command__get__name__response_ga0e8ecfaa03d14e2d8ade75cfec4d3bea}{jdksavdecc\_aem\_command\_get\_name\_response\_read}(&
      aem\_cmd\_get\_name\_resp,
596                                                                                    
      \hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame},
597                                                                                    
      \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE},
598                                                                                    frame\_len);
599 
600     \textcolor{keywordflow}{if} (aem\_cmd\_get\_name\_resp\_returned < 0)
601     \{
602         \hyperlink{namespaceavdecc__lib_acbe3e2a96ae6524943ca532c87a28529}{log\_imp\_ref}->\hyperlink{classavdecc__lib_1_1log_a68139a6297697e4ccebf36ccfd02e44a}{post\_log\_msg}(\hyperlink{namespaceavdecc__lib_a501055c431e6872ef46f252ad13f85cdaf2c4481208273451a6f5c7bb9770ec8a}{LOGGING\_LEVEL\_ERROR}, \textcolor{stringliteral}{"
      aem\_cmd\_get\_name\_resp\_read error\(\backslash\)n"});
603         assert(aem\_cmd\_get\_name\_resp\_returned >= 0);
604         \textcolor{keywordflow}{return} -1;
605     \}
606 
607     \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a482fe95208e9e14885e28e73e7be2c49}{replace\_frame}(\hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE}, frame\_len);
608 
609     msg\_type = aem\_cmd\_get\_name\_resp.\hyperlink{structjdksavdecc__aem__command__get__name__response_ae1e77ccb75ff5021ad923221eab38294}{aem\_header}.\hyperlink{structjdksavdecc__aecpdu__aem_ae8460ae179666e7ce268ed1ef33d0de3}{aecpdu\_header}.
      \hyperlink{structjdksavdecc__aecpdu__common_a314cacb6a61bcf18749030c0b6fb7510}{header}.\hyperlink{structjdksavdecc__aecpdu__common__control__header_aeaaffeace8c23899e558022f62ce6de4}{message\_type};
610     status = aem\_cmd\_get\_name\_resp.\hyperlink{structjdksavdecc__aem__command__get__name__response_ae1e77ccb75ff5021ad923221eab38294}{aem\_header}.\hyperlink{structjdksavdecc__aecpdu__aem_ae8460ae179666e7ce268ed1ef33d0de3}{aecpdu\_header}.
      \hyperlink{structjdksavdecc__aecpdu__common_a314cacb6a61bcf18749030c0b6fb7510}{header}.\hyperlink{structjdksavdecc__aecpdu__common__control__header_ade818037fd6c985038ff29656089758d}{status};
611     u\_field = aem\_cmd\_get\_name\_resp.\hyperlink{structjdksavdecc__aem__command__get__name__response_ae1e77ccb75ff5021ad923221eab38294}{aem\_header}.\hyperlink{structjdksavdecc__aecpdu__aem_a07f7ee802870e9ae75f021832f59a8a9}{command\_type} >> 15 & 0x01; \textcolor{comment}{// u\_field
       = the msb of the uint16\_t command\_type}
612 
613     \hyperlink{namespaceavdecc__lib_a0b1b5aea3c0490f77cbfd9178af5be22}{aecp\_controller\_state\_machine\_ref}->
      \hyperlink{classavdecc__lib_1_1aecp__controller__state__machine_a997abd9786c330a5505e903e6443208e}{update\_inflight\_for\_rcvd\_resp}(notification\_id, msg\_type, u\_field, &cmd\_frame);
614 
615     \textcolor{keywordflow}{return} 0;
616 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_acc8b1c1591bd54bc9a2d21d4f0db2e86_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_acc8b1c1591bd54bc9a2d21d4f0db2e86_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!default\+\_\+proc\+\_\+lock\+\_\+entity\+\_\+resp@{default\+\_\+proc\+\_\+lock\+\_\+entity\+\_\+resp}}
\index{default\+\_\+proc\+\_\+lock\+\_\+entity\+\_\+resp@{default\+\_\+proc\+\_\+lock\+\_\+entity\+\_\+resp}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{default\+\_\+proc\+\_\+lock\+\_\+entity\+\_\+resp(struct jdksavdecc\+\_\+aem\+\_\+command\+\_\+lock\+\_\+entity\+\_\+response \&aem\+\_\+cmd\+\_\+lock\+\_\+entity\+\_\+resp, void $\ast$\&notification\+\_\+id, const uint8\+\_\+t $\ast$frame, size\+\_\+t frame\+\_\+len, int \&status)}{default_proc_lock_entity_resp(struct jdksavdecc_aem_command_lock_entity_response &aem_cmd_lock_entity_resp, void *&notification_id, const uint8_t *frame, size_t frame_len, int &status)}}]{\setlength{\rightskip}{0pt plus 5cm}int default\+\_\+proc\+\_\+lock\+\_\+entity\+\_\+resp (
\begin{DoxyParamCaption}
\item[{struct {\bf jdksavdecc\+\_\+aem\+\_\+command\+\_\+lock\+\_\+entity\+\_\+response} \&}]{aem\+\_\+cmd\+\_\+lock\+\_\+entity\+\_\+resp, }
\item[{void $\ast$\&}]{notification\+\_\+id, }
\item[{const {\bf uint8\+\_\+t} $\ast$}]{frame, }
\item[{size\+\_\+t}]{frame\+\_\+len, }
\item[{int \&}]{status}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_a3b3582020613e7f60efe96567679be7f}{}\label{classavdecc__lib_1_1descriptor__base__imp_a3b3582020613e7f60efe96567679be7f}


descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 294 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
299 \{
300     \textcolor{keyword}{struct }\hyperlink{structjdksavdecc__frame}{jdksavdecc\_frame} cmd\_frame;
301     ssize\_t aem\_cmd\_lock\_entity\_resp\_returned = 0;
302     \hyperlink{parse_8c_a6eb1e68cc391dd753bc8ce896dbb8315}{uint32\_t} msg\_type = 0;
303     \textcolor{keywordtype}{bool} u\_field = \textcolor{keyword}{false};
304 
305     memcpy(cmd\_frame.payload, \hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, frame\_len);
306 
307     aem\_cmd\_lock\_entity\_resp\_returned = 
      \hyperlink{group__command__lock__entity__response_gabf8e59d01c0f0088b701f6191dd17b6d}{jdksavdecc\_aem\_command\_lock\_entity\_response\_read}(&
      aem\_cmd\_lock\_entity\_resp,
308                                                                                          
      \hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame},
309                                                                                          
      \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE},
310                                                                                          frame\_len);
311 
312     \textcolor{keywordflow}{if} (aem\_cmd\_lock\_entity\_resp\_returned < 0)
313     \{
314         \hyperlink{namespaceavdecc__lib_acbe3e2a96ae6524943ca532c87a28529}{log\_imp\_ref}->\hyperlink{classavdecc__lib_1_1log_a68139a6297697e4ccebf36ccfd02e44a}{post\_log\_msg}(\hyperlink{namespaceavdecc__lib_a501055c431e6872ef46f252ad13f85cdaf2c4481208273451a6f5c7bb9770ec8a}{LOGGING\_LEVEL\_ERROR}, \textcolor{stringliteral}{"
      aem\_cmd\_lock\_entity\_resp\_read error\(\backslash\)n"});
315         assert(aem\_cmd\_lock\_entity\_resp\_returned >= 0);
316         \textcolor{keywordflow}{return} -1;
317     \}
318 
319     msg\_type = aem\_cmd\_lock\_entity\_resp.\hyperlink{structjdksavdecc__aem__command__lock__entity__response_ae1e77ccb75ff5021ad923221eab38294}{aem\_header}.\hyperlink{structjdksavdecc__aecpdu__aem_ae8460ae179666e7ce268ed1ef33d0de3}{aecpdu\_header}.
      \hyperlink{structjdksavdecc__aecpdu__common_a314cacb6a61bcf18749030c0b6fb7510}{header}.\hyperlink{structjdksavdecc__aecpdu__common__control__header_aeaaffeace8c23899e558022f62ce6de4}{message\_type};
320     status = aem\_cmd\_lock\_entity\_resp.\hyperlink{structjdksavdecc__aem__command__lock__entity__response_ae1e77ccb75ff5021ad923221eab38294}{aem\_header}.\hyperlink{structjdksavdecc__aecpdu__aem_ae8460ae179666e7ce268ed1ef33d0de3}{aecpdu\_header}.
      \hyperlink{structjdksavdecc__aecpdu__common_a314cacb6a61bcf18749030c0b6fb7510}{header}.\hyperlink{structjdksavdecc__aecpdu__common__control__header_ade818037fd6c985038ff29656089758d}{status};
321     u\_field = aem\_cmd\_lock\_entity\_resp.\hyperlink{structjdksavdecc__aem__command__lock__entity__response_ae1e77ccb75ff5021ad923221eab38294}{aem\_header}.\hyperlink{structjdksavdecc__aecpdu__aem_a07f7ee802870e9ae75f021832f59a8a9}{command\_type} >> 15 & 0x01; \textcolor{comment}{//
       u\_field = the msb of the uint16\_t command\_type}
322 
323     \hyperlink{namespaceavdecc__lib_a0b1b5aea3c0490f77cbfd9178af5be22}{aecp\_controller\_state\_machine\_ref}->
      \hyperlink{classavdecc__lib_1_1aecp__controller__state__machine_a997abd9786c330a5505e903e6443208e}{update\_inflight\_for\_rcvd\_resp}(notification\_id, msg\_type, u\_field, &cmd\_frame);
324 
325     \textcolor{keywordflow}{return} 0;
326 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_a3b3582020613e7f60efe96567679be7f_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_a3b3582020613e7f60efe96567679be7f_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!default\+\_\+proc\+\_\+reboot\+\_\+resp@{default\+\_\+proc\+\_\+reboot\+\_\+resp}}
\index{default\+\_\+proc\+\_\+reboot\+\_\+resp@{default\+\_\+proc\+\_\+reboot\+\_\+resp}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{default\+\_\+proc\+\_\+reboot\+\_\+resp(struct jdksavdecc\+\_\+aem\+\_\+command\+\_\+reboot\+\_\+response \&aem\+\_\+cmd\+\_\+reboot\+\_\+resp, void $\ast$\&notification\+\_\+id, const uint8\+\_\+t $\ast$frame, size\+\_\+t frame\+\_\+len, int \&status)}{default_proc_reboot_resp(struct jdksavdecc_aem_command_reboot_response &aem_cmd_reboot_resp, void *&notification_id, const uint8_t *frame, size_t frame_len, int &status)}}]{\setlength{\rightskip}{0pt plus 5cm}int default\+\_\+proc\+\_\+reboot\+\_\+resp (
\begin{DoxyParamCaption}
\item[{struct {\bf jdksavdecc\+\_\+aem\+\_\+command\+\_\+reboot\+\_\+response} \&}]{aem\+\_\+cmd\+\_\+reboot\+\_\+resp, }
\item[{void $\ast$\&}]{notification\+\_\+id, }
\item[{const {\bf uint8\+\_\+t} $\ast$}]{frame, }
\item[{size\+\_\+t}]{frame\+\_\+len, }
\item[{int \&}]{status}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_a774dc940e9918a60127b0b021582b32a}{}\label{classavdecc__lib_1_1descriptor__base__imp_a774dc940e9918a60127b0b021582b32a}


descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 389 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
394 \{
395     \textcolor{keyword}{struct }\hyperlink{structjdksavdecc__frame}{jdksavdecc\_frame} cmd\_frame;
396     \hyperlink{parse_8c_a6eb1e68cc391dd753bc8ce896dbb8315}{uint32\_t} msg\_type = 0;
397     \textcolor{keywordtype}{bool} u\_field = \textcolor{keyword}{false};
398 
399     memcpy(cmd\_frame.payload, \hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, frame\_len);
400 
401     ssize\_t aem\_cmd\_reboot\_resp\_returned = 
      \hyperlink{group__command__reboot__response_ga4c55ee085228ad590101ad2c710834e0}{jdksavdecc\_aem\_command\_reboot\_response\_read}(&aem\_cmd\_reboot\_resp
      ,
402                                                                                        
      \hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame},
403                                                                                        
      \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE},
404                                                                                        frame\_len);
405 
406     \textcolor{keywordflow}{if} (aem\_cmd\_reboot\_resp\_returned < 0)
407     \{
408         \hyperlink{namespaceavdecc__lib_acbe3e2a96ae6524943ca532c87a28529}{log\_imp\_ref}->\hyperlink{classavdecc__lib_1_1log_a68139a6297697e4ccebf36ccfd02e44a}{post\_log\_msg}(\hyperlink{namespaceavdecc__lib_a501055c431e6872ef46f252ad13f85cdaf2c4481208273451a6f5c7bb9770ec8a}{LOGGING\_LEVEL\_ERROR}, \textcolor{stringliteral}{"
      aem\_cmd\_reboot\_resp\_read error\(\backslash\)n"});
409         \textcolor{keywordflow}{return} -1;
410     \}
411 
412     msg\_type = aem\_cmd\_reboot\_resp.\hyperlink{structjdksavdecc__aem__command__reboot__response_ae1e77ccb75ff5021ad923221eab38294}{aem\_header}.\hyperlink{structjdksavdecc__aecpdu__aem_ae8460ae179666e7ce268ed1ef33d0de3}{aecpdu\_header}.
      \hyperlink{structjdksavdecc__aecpdu__common_a314cacb6a61bcf18749030c0b6fb7510}{header}.\hyperlink{structjdksavdecc__aecpdu__common__control__header_aeaaffeace8c23899e558022f62ce6de4}{message\_type};
413     status = aem\_cmd\_reboot\_resp.\hyperlink{structjdksavdecc__aem__command__reboot__response_ae1e77ccb75ff5021ad923221eab38294}{aem\_header}.\hyperlink{structjdksavdecc__aecpdu__aem_ae8460ae179666e7ce268ed1ef33d0de3}{aecpdu\_header}.
      \hyperlink{structjdksavdecc__aecpdu__common_a314cacb6a61bcf18749030c0b6fb7510}{header}.\hyperlink{structjdksavdecc__aecpdu__common__control__header_ade818037fd6c985038ff29656089758d}{status};
414     u\_field = aem\_cmd\_reboot\_resp.\hyperlink{structjdksavdecc__aem__command__reboot__response_ae1e77ccb75ff5021ad923221eab38294}{aem\_header}.\hyperlink{structjdksavdecc__aecpdu__aem_a07f7ee802870e9ae75f021832f59a8a9}{command\_type} >> 15 & 0x01; \textcolor{comment}{// u\_field =
       the msb of the uint16\_t command\_type}
415 
416     \hyperlink{namespaceavdecc__lib_a0b1b5aea3c0490f77cbfd9178af5be22}{aecp\_controller\_state\_machine\_ref}->
      \hyperlink{classavdecc__lib_1_1aecp__controller__state__machine_a997abd9786c330a5505e903e6443208e}{update\_inflight\_for\_rcvd\_resp}(notification\_id, msg\_type, u\_field, &cmd\_frame);
417 
418     \textcolor{keywordflow}{return} 0;
419 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_a774dc940e9918a60127b0b021582b32a_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_a774dc940e9918a60127b0b021582b32a_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!default\+\_\+proc\+\_\+set\+\_\+name\+\_\+resp@{default\+\_\+proc\+\_\+set\+\_\+name\+\_\+resp}}
\index{default\+\_\+proc\+\_\+set\+\_\+name\+\_\+resp@{default\+\_\+proc\+\_\+set\+\_\+name\+\_\+resp}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{default\+\_\+proc\+\_\+set\+\_\+name\+\_\+resp(struct jdksavdecc\+\_\+aem\+\_\+command\+\_\+set\+\_\+name\+\_\+response \&aem\+\_\+cmd\+\_\+set\+\_\+name\+\_\+resp, void $\ast$\&notification\+\_\+id, const uint8\+\_\+t $\ast$frame, size\+\_\+t frame\+\_\+len, int \&status)}{default_proc_set_name_resp(struct jdksavdecc_aem_command_set_name_response &aem_cmd_set_name_resp, void *&notification_id, const uint8_t *frame, size_t frame_len, int &status)}}]{\setlength{\rightskip}{0pt plus 5cm}int default\+\_\+proc\+\_\+set\+\_\+name\+\_\+resp (
\begin{DoxyParamCaption}
\item[{struct {\bf jdksavdecc\+\_\+aem\+\_\+command\+\_\+set\+\_\+name\+\_\+response} \&}]{aem\+\_\+cmd\+\_\+set\+\_\+name\+\_\+resp, }
\item[{void $\ast$\&}]{notification\+\_\+id, }
\item[{const {\bf uint8\+\_\+t} $\ast$}]{frame, }
\item[{size\+\_\+t}]{frame\+\_\+len, }
\item[{int \&}]{status}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_a2f52c3b9a7ad6f490bed0c96a9136bc3}{}\label{classavdecc__lib_1_1descriptor__base__imp_a2f52c3b9a7ad6f490bed0c96a9136bc3}


descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 474 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
479 \{
480     \textcolor{keyword}{struct }\hyperlink{structjdksavdecc__frame}{jdksavdecc\_frame} cmd\_frame;
481     ssize\_t aem\_cmd\_set\_name\_resp\_returned = 0;
482     \hyperlink{parse_8c_a6eb1e68cc391dd753bc8ce896dbb8315}{uint32\_t} msg\_type = 0;
483     \textcolor{keywordtype}{bool} u\_field = \textcolor{keyword}{false};
484     uint16\_t \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a9dada313309522d04f1e52fe887442b4}{desc\_type} = 0;
485     \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t} * \hyperlink{_hello_test_8cpp_a8be6d469a7cd1c8d66cc6d2d1e10c65b}{buffer};
486 
487     memcpy(cmd\_frame.payload, \hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, frame\_len);
488 
489     aem\_cmd\_set\_name\_resp\_returned = 
      \hyperlink{group__command__set__name__response_gaef863bcb2206bfcbd21e95fe8f59869d}{jdksavdecc\_aem\_command\_set\_name\_response\_read}(&
      aem\_cmd\_set\_name\_resp,
490                                                                                    
      \hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame},
491                                                                                    
      \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE},
492                                                                                    frame\_len);
493 
494     \textcolor{keywordflow}{if} (aem\_cmd\_set\_name\_resp\_returned < 0)
495     \{
496         \hyperlink{namespaceavdecc__lib_acbe3e2a96ae6524943ca532c87a28529}{log\_imp\_ref}->\hyperlink{classavdecc__lib_1_1log_a68139a6297697e4ccebf36ccfd02e44a}{post\_log\_msg}(\hyperlink{namespaceavdecc__lib_a501055c431e6872ef46f252ad13f85cdaf2c4481208273451a6f5c7bb9770ec8a}{LOGGING\_LEVEL\_ERROR}, \textcolor{stringliteral}{"
      aem\_cmd\_set\_name\_resp\_read error\(\backslash\)n"});
497         assert(aem\_cmd\_set\_name\_resp\_returned >= 0);
498         \textcolor{keywordflow}{return} -1;
499     \}
500 
501     msg\_type = aem\_cmd\_set\_name\_resp.\hyperlink{structjdksavdecc__aem__command__set__name__response_ae1e77ccb75ff5021ad923221eab38294}{aem\_header}.\hyperlink{structjdksavdecc__aecpdu__aem_ae8460ae179666e7ce268ed1ef33d0de3}{aecpdu\_header}.
      \hyperlink{structjdksavdecc__aecpdu__common_a314cacb6a61bcf18749030c0b6fb7510}{header}.\hyperlink{structjdksavdecc__aecpdu__common__control__header_aeaaffeace8c23899e558022f62ce6de4}{message\_type};
502     status = aem\_cmd\_set\_name\_resp.\hyperlink{structjdksavdecc__aem__command__set__name__response_ae1e77ccb75ff5021ad923221eab38294}{aem\_header}.\hyperlink{structjdksavdecc__aecpdu__aem_ae8460ae179666e7ce268ed1ef33d0de3}{aecpdu\_header}.
      \hyperlink{structjdksavdecc__aecpdu__common_a314cacb6a61bcf18749030c0b6fb7510}{header}.\hyperlink{structjdksavdecc__aecpdu__common__control__header_ade818037fd6c985038ff29656089758d}{status};
503     u\_field = aem\_cmd\_set\_name\_resp.\hyperlink{structjdksavdecc__aem__command__set__name__response_ae1e77ccb75ff5021ad923221eab38294}{aem\_header}.\hyperlink{structjdksavdecc__aecpdu__aem_a07f7ee802870e9ae75f021832f59a8a9}{command\_type} >> 15 & 0x01; \textcolor{comment}{// u\_field
       = the msb of the uint16\_t command\_type}
504 
505     desc\_type = \hyperlink{group__command__set__name__response_ga3a95f51790a717c477cf1729aa02306e}{jdksavdecc\_aem\_command\_set\_name\_response\_get\_descriptor\_type}
      (\hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE});
506 
507     \textcolor{keywordflow}{if} (desc\_type == \hyperlink{namespaceavdecc__lib_ac7b7d227e46bc72b63ee9e9aae15902fac9ebb31a55e5894637f6c3c710ceceaf}{AEM\_DESC\_ENTITY})
508     \{
509         buffer = (\hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t} *)\hyperlink{_memory_leak_detector_malloc_macros_8h_ab8b25cd8f16d4a6552afe4e65c4f082d}{malloc}(\hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2642e3a7c10d38553e7ff4a55e875346}{resp\_ref}->\hyperlink{classavdecc__lib_1_1response__frame_a5302ae13c549f066040ce0e7c7d11ae6}{get\_desc\_size}() * \textcolor{keyword}{sizeof}(
      \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t})); \textcolor{comment}{//fetch current desc frame}
510         memcpy(buffer, \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2642e3a7c10d38553e7ff4a55e875346}{resp\_ref}->\hyperlink{classavdecc__lib_1_1response__frame_a87db6e7ad7e047437cf9c9eaab873626}{get\_desc\_buffer}(), 
      \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2642e3a7c10d38553e7ff4a55e875346}{resp\_ref}->\hyperlink{classavdecc__lib_1_1response__frame_a5302ae13c549f066040ce0e7c7d11ae6}{get\_desc\_size}());
511 
512         \textcolor{keywordflow}{if} (aem\_cmd\_set\_name\_resp.\hyperlink{structjdksavdecc__aem__command__set__name__response_a898a74ada625e0b227dadb02901404e6}{name\_index} == 0) \textcolor{comment}{//entity name}
513         \{
514             \hyperlink{group__descriptor__entity_gad94296ee558e018c5854af962b30b4a5}{jdksavdecc\_descriptor\_entity\_set\_entity\_name}(
      aem\_cmd\_set\_name\_resp.\hyperlink{structjdksavdecc__aem__command__set__name__response_a7e615b51b7768e9b59bfa450051e0f8e}{name}, buffer, \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2642e3a7c10d38553e7ff4a55e875346}{resp\_ref}->\hyperlink{classavdecc__lib_1_1response__frame_a6e6f6cc3d681d41c6de6139ca9cb79d9}{get\_desc\_pos}());
515         \}
516         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (aem\_cmd\_set\_name\_resp.\hyperlink{structjdksavdecc__aem__command__set__name__response_a898a74ada625e0b227dadb02901404e6}{name\_index} == 1) \textcolor{comment}{//group name}
517         \{
518             \hyperlink{group__descriptor__entity_gab440d6d94e09324c658e35852ea54045}{jdksavdecc\_descriptor\_entity\_set\_group\_name}(
      aem\_cmd\_set\_name\_resp.\hyperlink{structjdksavdecc__aem__command__set__name__response_a7e615b51b7768e9b59bfa450051e0f8e}{name}, buffer, \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2642e3a7c10d38553e7ff4a55e875346}{resp\_ref}->\hyperlink{classavdecc__lib_1_1response__frame_a6e6f6cc3d681d41c6de6139ca9cb79d9}{get\_desc\_pos}());
519         \}
520         \textcolor{keywordflow}{else}
521         \{
522             \hyperlink{namespaceavdecc__lib_acbe3e2a96ae6524943ca532c87a28529}{log\_imp\_ref}->\hyperlink{classavdecc__lib_1_1log_a68139a6297697e4ccebf36ccfd02e44a}{post\_log\_msg}(\hyperlink{namespaceavdecc__lib_a501055c431e6872ef46f252ad13f85cdaf2c4481208273451a6f5c7bb9770ec8a}{LOGGING\_LEVEL\_ERROR}, \textcolor{stringliteral}{"
      invalid SET\_NAME name index\(\backslash\)n"});
523         \}
524     \}
525     \textcolor{keywordflow}{else}
526     \{
527         buffer = (\hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t} *)\hyperlink{_memory_leak_detector_malloc_macros_8h_ab8b25cd8f16d4a6552afe4e65c4f082d}{malloc}(\hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2642e3a7c10d38553e7ff4a55e875346}{resp\_ref}->\hyperlink{classavdecc__lib_1_1response__frame_a5302ae13c549f066040ce0e7c7d11ae6}{get\_desc\_size}() * \textcolor{keyword}{sizeof}(
      \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t})); \textcolor{comment}{//fetch current desc frame}
528         memcpy(buffer, \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2642e3a7c10d38553e7ff4a55e875346}{resp\_ref}->\hyperlink{classavdecc__lib_1_1response__frame_a87db6e7ad7e047437cf9c9eaab873626}{get\_desc\_buffer}(), 
      \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2642e3a7c10d38553e7ff4a55e875346}{resp\_ref}->\hyperlink{classavdecc__lib_1_1response__frame_a5302ae13c549f066040ce0e7c7d11ae6}{get\_desc\_size}());
529 
530         \hyperlink{group__command__set__name_ga49b59c695339c3f6e2fcc1f83d6e410f}{jdksavdecc\_aem\_command\_set\_name\_set\_name}(
      aem\_cmd\_set\_name\_resp.\hyperlink{structjdksavdecc__aem__command__set__name__response_a7e615b51b7768e9b59bfa450051e0f8e}{name}, buffer, \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE});
531     \}
532 
533     \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a8dbf7d4faedf36ec789d33f228e22039}{replace\_desc\_frame}(buffer, \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2642e3a7c10d38553e7ff4a55e875346}{resp\_ref}->\hyperlink{classavdecc__lib_1_1response__frame_a6e6f6cc3d681d41c6de6139ca9cb79d9}{get\_desc\_pos}(), 
      \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2642e3a7c10d38553e7ff4a55e875346}{resp\_ref}->\hyperlink{classavdecc__lib_1_1response__frame_a5302ae13c549f066040ce0e7c7d11ae6}{get\_desc\_size}());
534 
535     \hyperlink{namespaceavdecc__lib_a0b1b5aea3c0490f77cbfd9178af5be22}{aecp\_controller\_state\_machine\_ref}->
      \hyperlink{classavdecc__lib_1_1aecp__controller__state__machine_a997abd9786c330a5505e903e6443208e}{update\_inflight\_for\_rcvd\_resp}(notification\_id, msg\_type, u\_field, &cmd\_frame);
536 
537     \hyperlink{_memory_leak_detector_malloc_macros_8h_aa7157aa9480bb73f090dca36776419bf}{free}(buffer);
538     \textcolor{keywordflow}{return} 0;
539 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_a2f52c3b9a7ad6f490bed0c96a9136bc3_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_a2f52c3b9a7ad6f490bed0c96a9136bc3_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!default\+\_\+send\+\_\+acquire\+\_\+entity\+\_\+cmd@{default\+\_\+send\+\_\+acquire\+\_\+entity\+\_\+cmd}}
\index{default\+\_\+send\+\_\+acquire\+\_\+entity\+\_\+cmd@{default\+\_\+send\+\_\+acquire\+\_\+entity\+\_\+cmd}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{default\+\_\+send\+\_\+acquire\+\_\+entity\+\_\+cmd(descriptor\+\_\+base\+\_\+imp $\ast$desc\+\_\+base\+\_\+imp\+\_\+ref, void $\ast$notification\+\_\+id, uint32\+\_\+t acquire\+\_\+entity\+\_\+flag)}{default_send_acquire_entity_cmd(descriptor_base_imp *desc_base_imp_ref, void *notification_id, uint32_t acquire_entity_flag)}}]{\setlength{\rightskip}{0pt plus 5cm}int default\+\_\+send\+\_\+acquire\+\_\+entity\+\_\+cmd (
\begin{DoxyParamCaption}
\item[{{\bf descriptor\+\_\+base\+\_\+imp} $\ast$}]{desc\+\_\+base\+\_\+imp\+\_\+ref, }
\item[{void $\ast$}]{notification\+\_\+id, }
\item[{{\bf uint32\+\_\+t}}]{acquire\+\_\+entity\+\_\+flag}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_a4ee5f42b89a728627bf1340afebc7c82}{}\label{classavdecc__lib_1_1descriptor__base__imp_a4ee5f42b89a728627bf1340afebc7c82}


descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 154 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
155 \{
156     \textcolor{keyword}{struct }\hyperlink{structjdksavdecc__frame}{jdksavdecc\_frame} cmd\_frame;
157     \textcolor{keyword}{struct }\hyperlink{structjdksavdecc__aem__command__acquire__entity}{jdksavdecc\_aem\_command\_acquire\_entity} 
      aem\_cmd\_acquire\_entity;
158     ssize\_t aem\_cmd\_acquire\_entity\_returned;
159 
160     \textcolor{comment}{/***************************************** AECP Common Data *******************************************
      **/}
161     aem\_cmd\_acquire\_entity.\hyperlink{structjdksavdecc__aem__command__acquire__entity_ae1e77ccb75ff5021ad923221eab38294}{aem\_header}.\hyperlink{structjdksavdecc__aecpdu__aem_ae8460ae179666e7ce268ed1ef33d0de3}{aecpdu\_header}.
      \hyperlink{structjdksavdecc__aecpdu__common_affc928ddb4fc62d1d04a775d36e5f2c8}{controller\_entity\_id} = \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\_end\_station\_imp\_ref}->
      \hyperlink{classavdecc__lib_1_1end__station__imp_a471a74540ce6182fad0c17dfd010107e}{get\_adp}()->\hyperlink{classavdecc__lib_1_1adp_a0c0959a46658c0a22e9530334b2912da}{get\_controller\_entity\_id}();
162     \textcolor{comment}{// Fill aem\_cmd\_acquire\_entity.sequence\_id in AEM Controller State Machine}
163     aem\_cmd\_acquire\_entity.aem\_header.command\_type = 
      \hyperlink{group__command_ga74ebee0a0531409bb10f7ce9e1216c04}{JDKSAVDECC\_AEM\_COMMAND\_ACQUIRE\_ENTITY};
164 
165     \textcolor{comment}{/************************* AECP Message Specific Data **************************/}
166     aem\_cmd\_acquire\_entity.aem\_acquire\_flags = acquire\_entity\_flag;
167     \hyperlink{group__eui64_ga6eda4ed21b6f0d526b180ac633eeba69}{jdksavdecc\_eui64\_init}(&aem\_cmd\_acquire\_entity.owner\_entity\_id);
168     aem\_cmd\_acquire\_entity.descriptor\_type = desc\_base\_imp\_ref->descriptor\_type();
169     aem\_cmd\_acquire\_entity.descriptor\_index = desc\_base\_imp\_ref->descriptor\_index();
170 
171     \textcolor{comment}{/**************************** Fill frame payload with AECP data and send the frame ********************
      **/}
172     \hyperlink{namespaceavdecc__lib_a0b1b5aea3c0490f77cbfd9178af5be22}{aecp\_controller\_state\_machine\_ref}->
      \hyperlink{classavdecc__lib_1_1aecp__controller__state__machine_a86ff947c5e6b799cfb877d3767bfa1f9}{ether\_frame\_init}(\hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\_end\_station\_imp\_ref}->
      \hyperlink{classavdecc__lib_1_1end__station__imp_a08e1bd1861b3b8f447ea374a65ac11f9}{mac}(), &cmd\_frame,
173                                                         \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE} + 
      \hyperlink{group__command__acquire__entity_gacd48c850101d4deef27e5c003f1c54cb}{JDKSAVDECC\_AEM\_COMMAND\_ACQUIRE\_ENTITY\_COMMAND\_LEN});
174     aem\_cmd\_acquire\_entity\_returned = 
      \hyperlink{group__command__acquire__entity_ga8f6285801e4769fe5ed789c57306f264}{jdksavdecc\_aem\_command\_acquire\_entity\_write}(&
      aem\_cmd\_acquire\_entity,
175                                                                                   cmd\_frame.payload,
176                                                                                   
      \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE},
177                                                                                   \textcolor{keyword}{sizeof}(cmd\_frame.payload)
      );
178 
179     \textcolor{keywordflow}{if} (aem\_cmd\_acquire\_entity\_returned < 0)
180     \{
181         \hyperlink{namespaceavdecc__lib_acbe3e2a96ae6524943ca532c87a28529}{log\_imp\_ref}->\hyperlink{classavdecc__lib_1_1log_a68139a6297697e4ccebf36ccfd02e44a}{post\_log\_msg}(\hyperlink{namespaceavdecc__lib_a501055c431e6872ef46f252ad13f85cdaf2c4481208273451a6f5c7bb9770ec8a}{LOGGING\_LEVEL\_ERROR}, \textcolor{stringliteral}{"
      aem\_cmd\_acquire\_entity\_write error\(\backslash\)n"});
182         assert(aem\_cmd\_acquire\_entity\_returned >= 0);
183         \textcolor{keywordflow}{return} -1;
184     \}
185 
186     \hyperlink{namespaceavdecc__lib_a0b1b5aea3c0490f77cbfd9178af5be22}{aecp\_controller\_state\_machine\_ref}->
      \hyperlink{classavdecc__lib_1_1aecp__controller__state__machine_aafc737d7ed17a62fed9df6528f18d3ec}{common\_hdr\_init}(\hyperlink{group__aecp__message__type_ga4625ce189cc209f42deb0629f48faf69}{JDKSAVDECC\_AECP\_MESSAGE\_TYPE\_AEM\_COMMAND}
      ,
187                                                        &cmd\_frame,
188                                                        \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\_end\_station\_imp\_ref}->
      \hyperlink{classavdecc__lib_1_1end__station__imp_a363b6c9664a0d701def9b17863e20ad3}{entity\_id}(),
189                                                        
      \hyperlink{group__command__acquire__entity_gacd48c850101d4deef27e5c003f1c54cb}{JDKSAVDECC\_AEM\_COMMAND\_ACQUIRE\_ENTITY\_COMMAND\_LEN} -
190                                                            
      \hyperlink{group__jdksavdecc__avtp__common__control__header_gaae84052886fb1bb42f3bc5f85b741dff}{JDKSAVDECC\_COMMON\_CONTROL\_HEADER\_LEN});
191     \hyperlink{namespaceavdecc__lib_a6dd511685627c0865a3442b539a4e8e9}{system\_queue\_tx}(notification\_id, \hyperlink{namespaceavdecc__lib_aabcadff06aa62be0ce47bc0646823604aba48b8a017e06fb240b650cdea965178}{CMD\_WITH\_NOTIFICATION}, cmd\_frame.
      payload, cmd\_frame.length);
192 
193     \textcolor{keywordflow}{return} 0;
194 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_a4ee5f42b89a728627bf1340afebc7c82_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=338pt]{classavdecc__lib_1_1descriptor__base__imp_a4ee5f42b89a728627bf1340afebc7c82_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!default\+\_\+send\+\_\+get\+\_\+name\+\_\+cmd@{default\+\_\+send\+\_\+get\+\_\+name\+\_\+cmd}}
\index{default\+\_\+send\+\_\+get\+\_\+name\+\_\+cmd@{default\+\_\+send\+\_\+get\+\_\+name\+\_\+cmd}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{default\+\_\+send\+\_\+get\+\_\+name\+\_\+cmd(descriptor\+\_\+base\+\_\+imp $\ast$desc\+\_\+base\+\_\+imp\+\_\+ref, void $\ast$notification\+\_\+id, uint16\+\_\+t name\+\_\+index, uint16\+\_\+t config\+\_\+index)}{default_send_get_name_cmd(descriptor_base_imp *desc_base_imp_ref, void *notification_id, uint16_t name_index, uint16_t config_index)}}]{\setlength{\rightskip}{0pt plus 5cm}int default\+\_\+send\+\_\+get\+\_\+name\+\_\+cmd (
\begin{DoxyParamCaption}
\item[{{\bf descriptor\+\_\+base\+\_\+imp} $\ast$}]{desc\+\_\+base\+\_\+imp\+\_\+ref, }
\item[{void $\ast$}]{notification\+\_\+id, }
\item[{uint16\+\_\+t}]{name\+\_\+index, }
\item[{uint16\+\_\+t}]{config\+\_\+index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_a92f2c88d261418872a496a8145800751}{}\label{classavdecc__lib_1_1descriptor__base__imp_a92f2c88d261418872a496a8145800751}


descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 541 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
542 \{
543     \textcolor{keyword}{struct }\hyperlink{structjdksavdecc__frame}{jdksavdecc\_frame} cmd\_frame;
544     \textcolor{keyword}{struct }\hyperlink{structjdksavdecc__aem__command__get__name}{jdksavdecc\_aem\_command\_get\_name} aem\_cmd\_get\_name;
545     ssize\_t aem\_cmd\_get\_name\_returned;
546 
547     \textcolor{comment}{/***************************************** AECP Common Data ******************************************/}
548     aem\_cmd\_get\_name.\hyperlink{structjdksavdecc__aem__command__get__name_ae1e77ccb75ff5021ad923221eab38294}{aem\_header}.\hyperlink{structjdksavdecc__aecpdu__aem_ae8460ae179666e7ce268ed1ef33d0de3}{aecpdu\_header}.
      \hyperlink{structjdksavdecc__aecpdu__common_affc928ddb4fc62d1d04a775d36e5f2c8}{controller\_entity\_id} = \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\_end\_station\_imp\_ref}->
      \hyperlink{classavdecc__lib_1_1end__station__imp_a471a74540ce6182fad0c17dfd010107e}{get\_adp}()->\hyperlink{classavdecc__lib_1_1adp_a0c0959a46658c0a22e9530334b2912da}{get\_controller\_entity\_id}();
549     \textcolor{comment}{// Fill aem\_cmd\_set\_name.sequence\_id in AEM Controller State Machine}
550     aem\_cmd\_get\_name.aem\_header.command\_type = \hyperlink{group__command_gab5a8244c35a72f9d4dcded988c51d8e3}{JDKSAVDECC\_AEM\_COMMAND\_GET\_NAME}
      ;
551 
552     \textcolor{comment}{/****************************** AECP Message Specific Data ****************************/}
553     aem\_cmd\_get\_name.descriptor\_type = desc\_base\_imp\_ref->descriptor\_type();
554     aem\_cmd\_get\_name.descriptor\_index = desc\_base\_imp\_ref->descriptor\_index();
555     aem\_cmd\_get\_name.configuration\_index = config\_index;
556     aem\_cmd\_get\_name.name\_index = \hyperlink{structjdksavdecc__aem__command__get__name_a898a74ada625e0b227dadb02901404e6}{name\_index};
557 
558     \textcolor{comment}{/**************************** Fill frame payload with AECP data and send the frame ********************
      **/}
559     \hyperlink{namespaceavdecc__lib_a0b1b5aea3c0490f77cbfd9178af5be22}{aecp\_controller\_state\_machine\_ref}->
      \hyperlink{classavdecc__lib_1_1aecp__controller__state__machine_a86ff947c5e6b799cfb877d3767bfa1f9}{ether\_frame\_init}(\hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\_end\_station\_imp\_ref}->
      \hyperlink{classavdecc__lib_1_1end__station__imp_a08e1bd1861b3b8f447ea374a65ac11f9}{mac}(), &cmd\_frame,
560                                                         \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE} + 
      \hyperlink{group__command__get__name_ga12d8b1a1daf6c9b805a6d84f5ecf92cb}{JDKSAVDECC\_AEM\_COMMAND\_GET\_NAME\_COMMAND\_LEN});
561     aem\_cmd\_get\_name\_returned = \hyperlink{group__command__get__name_ga61f178bb903a33dc13e23c5e55e2d89d}{jdksavdecc\_aem\_command\_get\_name\_write}(
      &aem\_cmd\_get\_name,
562                                                                       cmd\_frame.payload,
563                                                                       
      \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE},
564                                                                       \textcolor{keyword}{sizeof}(cmd\_frame.payload));
565 
566     \textcolor{keywordflow}{if} (aem\_cmd\_get\_name\_returned < 0)
567     \{
568         \hyperlink{namespaceavdecc__lib_acbe3e2a96ae6524943ca532c87a28529}{log\_imp\_ref}->\hyperlink{classavdecc__lib_1_1log_a68139a6297697e4ccebf36ccfd02e44a}{post\_log\_msg}(\hyperlink{namespaceavdecc__lib_a501055c431e6872ef46f252ad13f85cdaf2c4481208273451a6f5c7bb9770ec8a}{LOGGING\_LEVEL\_ERROR}, \textcolor{stringliteral}{"
      aem\_cmd\_get\_name\_write error\(\backslash\)n"});
569         assert(aem\_cmd\_get\_name\_returned >= 0);
570         \textcolor{keywordflow}{return} -1;
571     \}
572 
573     \hyperlink{namespaceavdecc__lib_a0b1b5aea3c0490f77cbfd9178af5be22}{aecp\_controller\_state\_machine\_ref}->
      \hyperlink{classavdecc__lib_1_1aecp__controller__state__machine_aafc737d7ed17a62fed9df6528f18d3ec}{common\_hdr\_init}(\hyperlink{group__aecp__message__type_ga4625ce189cc209f42deb0629f48faf69}{JDKSAVDECC\_AECP\_MESSAGE\_TYPE\_AEM\_COMMAND}
      ,
574                                                        &cmd\_frame,
575                                                        \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\_end\_station\_imp\_ref}->
      \hyperlink{classavdecc__lib_1_1end__station__imp_a363b6c9664a0d701def9b17863e20ad3}{entity\_id}(),
576                                                        
      \hyperlink{group__command__get__name_ga12d8b1a1daf6c9b805a6d84f5ecf92cb}{JDKSAVDECC\_AEM\_COMMAND\_GET\_NAME\_COMMAND\_LEN} -
577                                                            
      \hyperlink{group__jdksavdecc__avtp__common__control__header_gaae84052886fb1bb42f3bc5f85b741dff}{JDKSAVDECC\_COMMON\_CONTROL\_HEADER\_LEN});
578     \hyperlink{namespaceavdecc__lib_a6dd511685627c0865a3442b539a4e8e9}{system\_queue\_tx}(notification\_id, \hyperlink{namespaceavdecc__lib_aabcadff06aa62be0ce47bc0646823604aba48b8a017e06fb240b650cdea965178}{CMD\_WITH\_NOTIFICATION}, cmd\_frame.
      payload, cmd\_frame.length);
579     \textcolor{keywordflow}{return} 0;
580 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_a92f2c88d261418872a496a8145800751_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_a92f2c88d261418872a496a8145800751_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!default\+\_\+send\+\_\+lock\+\_\+entity\+\_\+cmd@{default\+\_\+send\+\_\+lock\+\_\+entity\+\_\+cmd}}
\index{default\+\_\+send\+\_\+lock\+\_\+entity\+\_\+cmd@{default\+\_\+send\+\_\+lock\+\_\+entity\+\_\+cmd}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{default\+\_\+send\+\_\+lock\+\_\+entity\+\_\+cmd(descriptor\+\_\+base\+\_\+imp $\ast$descriptor\+\_\+base\+\_\+imp\+\_\+ref, void $\ast$notification\+\_\+id, uint32\+\_\+t lock\+\_\+entity\+\_\+flag)}{default_send_lock_entity_cmd(descriptor_base_imp *descriptor_base_imp_ref, void *notification_id, uint32_t lock_entity_flag)}}]{\setlength{\rightskip}{0pt plus 5cm}int default\+\_\+send\+\_\+lock\+\_\+entity\+\_\+cmd (
\begin{DoxyParamCaption}
\item[{{\bf descriptor\+\_\+base\+\_\+imp} $\ast$}]{descriptor\+\_\+base\+\_\+imp\+\_\+ref, }
\item[{void $\ast$}]{notification\+\_\+id, }
\item[{{\bf uint32\+\_\+t}}]{lock\+\_\+entity\+\_\+flag}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_af40ac09b84feb7551bf0389a2a5db4ca}{}\label{classavdecc__lib_1_1descriptor__base__imp_af40ac09b84feb7551bf0389a2a5db4ca}


descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 252 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
253 \{
254     \textcolor{keyword}{struct }\hyperlink{structjdksavdecc__frame}{jdksavdecc\_frame} cmd\_frame;
255     \textcolor{keyword}{struct }\hyperlink{structjdksavdecc__aem__command__lock__entity}{jdksavdecc\_aem\_command\_lock\_entity} aem\_cmd\_lock\_entity;
256     ssize\_t aem\_cmd\_lock\_entity\_returned;
257 
258     \textcolor{comment}{/***************************************** AECP Common Data ******************************************/}
259     aem\_cmd\_lock\_entity.\hyperlink{structjdksavdecc__aem__command__lock__entity_ae1e77ccb75ff5021ad923221eab38294}{aem\_header}.\hyperlink{structjdksavdecc__aecpdu__aem_ae8460ae179666e7ce268ed1ef33d0de3}{aecpdu\_header}.
      \hyperlink{structjdksavdecc__aecpdu__common_affc928ddb4fc62d1d04a775d36e5f2c8}{controller\_entity\_id} = \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\_end\_station\_imp\_ref}->
      \hyperlink{classavdecc__lib_1_1end__station__imp_a471a74540ce6182fad0c17dfd010107e}{get\_adp}()->\hyperlink{classavdecc__lib_1_1adp_a0c0959a46658c0a22e9530334b2912da}{get\_controller\_entity\_id}();
260     \textcolor{comment}{// Fill aem\_cmd\_lock\_entity.sequence\_id in AEM Controller State Machine}
261     aem\_cmd\_lock\_entity.aem\_header.command\_type = 
      \hyperlink{group__command_ga96be22db90d10cec463db06ab42751c4}{JDKSAVDECC\_AEM\_COMMAND\_LOCK\_ENTITY};
262 
263     \textcolor{comment}{/****************************** AECP Message Specific Data ****************************/}
264     aem\_cmd\_lock\_entity.aem\_lock\_flags = lock\_entity\_flag;
265     \hyperlink{group__eui64_ga6eda4ed21b6f0d526b180ac633eeba69}{jdksavdecc\_eui64\_init}(&aem\_cmd\_lock\_entity.locked\_entity\_id);
266     aem\_cmd\_lock\_entity.descriptor\_type = descriptor\_base\_imp\_ref->descriptor\_type();
267     aem\_cmd\_lock\_entity.descriptor\_index = descriptor\_base\_imp\_ref->descriptor\_index();
268 
269     \textcolor{comment}{/**************************** Fill frame payload with AECP data and send the frame ********************
      **/}
270     \hyperlink{namespaceavdecc__lib_a0b1b5aea3c0490f77cbfd9178af5be22}{aecp\_controller\_state\_machine\_ref}->
      \hyperlink{classavdecc__lib_1_1aecp__controller__state__machine_a86ff947c5e6b799cfb877d3767bfa1f9}{ether\_frame\_init}(\hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\_end\_station\_imp\_ref}->
      \hyperlink{classavdecc__lib_1_1end__station__imp_a08e1bd1861b3b8f447ea374a65ac11f9}{mac}(), &cmd\_frame,
271                                                         \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE} + 
      \hyperlink{group__command__lock__entity_gaae9fdce1f4e3de3d6a0829b4b077b418}{JDKSAVDECC\_AEM\_COMMAND\_LOCK\_ENTITY\_COMMAND\_LEN});
272     aem\_cmd\_lock\_entity\_returned = \hyperlink{group__command__lock__entity_ga72e701eb5960e2b447364aab20d03b51}{jdksavdecc\_aem\_command\_lock\_entity\_write}
      (&aem\_cmd\_lock\_entity,
273                                                                             cmd\_frame.payload,
274                                                                             
      \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE},
275                                                                             \textcolor{keyword}{sizeof}(cmd\_frame.payload));
276 
277     \textcolor{keywordflow}{if} (aem\_cmd\_lock\_entity\_returned < 0)
278     \{
279         \hyperlink{namespaceavdecc__lib_acbe3e2a96ae6524943ca532c87a28529}{log\_imp\_ref}->\hyperlink{classavdecc__lib_1_1log_a68139a6297697e4ccebf36ccfd02e44a}{post\_log\_msg}(\hyperlink{namespaceavdecc__lib_a501055c431e6872ef46f252ad13f85cdaf2c4481208273451a6f5c7bb9770ec8a}{LOGGING\_LEVEL\_ERROR}, \textcolor{stringliteral}{"
      aem\_cmd\_lock\_entity\_write error\(\backslash\)n"});
280         assert(aem\_cmd\_lock\_entity\_returned >= 0);
281         \textcolor{keywordflow}{return} -1;
282     \}
283 
284     \hyperlink{namespaceavdecc__lib_a0b1b5aea3c0490f77cbfd9178af5be22}{aecp\_controller\_state\_machine\_ref}->
      \hyperlink{classavdecc__lib_1_1aecp__controller__state__machine_aafc737d7ed17a62fed9df6528f18d3ec}{common\_hdr\_init}(\hyperlink{group__aecp__message__type_ga4625ce189cc209f42deb0629f48faf69}{JDKSAVDECC\_AECP\_MESSAGE\_TYPE\_AEM\_COMMAND}
      ,
285                                                        &cmd\_frame,
286                                                        \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\_end\_station\_imp\_ref}->
      \hyperlink{classavdecc__lib_1_1end__station__imp_a363b6c9664a0d701def9b17863e20ad3}{entity\_id}(),
287                                                        
      \hyperlink{group__command__lock__entity_gaae9fdce1f4e3de3d6a0829b4b077b418}{JDKSAVDECC\_AEM\_COMMAND\_LOCK\_ENTITY\_COMMAND\_LEN} -
288                                                            
      \hyperlink{group__jdksavdecc__avtp__common__control__header_gaae84052886fb1bb42f3bc5f85b741dff}{JDKSAVDECC\_COMMON\_CONTROL\_HEADER\_LEN});
289     \hyperlink{namespaceavdecc__lib_a6dd511685627c0865a3442b539a4e8e9}{system\_queue\_tx}(notification\_id, \hyperlink{namespaceavdecc__lib_aabcadff06aa62be0ce47bc0646823604aba48b8a017e06fb240b650cdea965178}{CMD\_WITH\_NOTIFICATION}, cmd\_frame.
      payload, cmd\_frame.length);
290 
291     \textcolor{keywordflow}{return} 0;
292 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_af40ac09b84feb7551bf0389a2a5db4ca_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_af40ac09b84feb7551bf0389a2a5db4ca_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!default\+\_\+send\+\_\+reboot\+\_\+cmd@{default\+\_\+send\+\_\+reboot\+\_\+cmd}}
\index{default\+\_\+send\+\_\+reboot\+\_\+cmd@{default\+\_\+send\+\_\+reboot\+\_\+cmd}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{default\+\_\+send\+\_\+reboot\+\_\+cmd(descriptor\+\_\+base\+\_\+imp $\ast$descriptor\+\_\+base\+\_\+imp\+\_\+ref, void $\ast$notification\+\_\+id)}{default_send_reboot_cmd(descriptor_base_imp *descriptor_base_imp_ref, void *notification_id)}}]{\setlength{\rightskip}{0pt plus 5cm}int default\+\_\+send\+\_\+reboot\+\_\+cmd (
\begin{DoxyParamCaption}
\item[{{\bf descriptor\+\_\+base\+\_\+imp} $\ast$}]{descriptor\+\_\+base\+\_\+imp\+\_\+ref, }
\item[{void $\ast$}]{notification\+\_\+id}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_a14e3bd11c70e839a0594dc59dffcbf16}{}\label{classavdecc__lib_1_1descriptor__base__imp_a14e3bd11c70e839a0594dc59dffcbf16}


descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 349 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
350 \{
351     \textcolor{keyword}{struct }\hyperlink{structjdksavdecc__frame}{jdksavdecc\_frame} cmd\_frame;
352     \textcolor{keyword}{struct }\hyperlink{structjdksavdecc__aem__command__reboot}{jdksavdecc\_aem\_command\_reboot} aem\_cmd\_reboot;
353     memset(&aem\_cmd\_reboot, 0, \textcolor{keyword}{sizeof}(aem\_cmd\_reboot));
354 
355     \textcolor{comment}{/***************************************** AECP Common Data ******************************************/}
356     aem\_cmd\_reboot.aem\_header.aecpdu\_header.controller\_entity\_id = 
      \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\_end\_station\_imp\_ref}->\hyperlink{classavdecc__lib_1_1end__station__imp_a471a74540ce6182fad0c17dfd010107e}{get\_adp}()->
      \hyperlink{classavdecc__lib_1_1adp_a0c0959a46658c0a22e9530334b2912da}{get\_controller\_entity\_id}();
357     \textcolor{comment}{// Fill aem\_cmd\_reboot.sequence\_id in AEM Controller State Machine}
358     aem\_cmd\_reboot.aem\_header.command\_type = \hyperlink{group__command_ga859da6235182638521da6af153bc6d3c}{JDKSAVDECC\_AEM\_COMMAND\_REBOOT};
359 
360     \textcolor{comment}{/****************************** AECP Message Specific Data ****************************/}
361     aem\_cmd\_reboot.descriptor\_type = descriptor\_base\_imp\_ref->descriptor\_type();
362     aem\_cmd\_reboot.descriptor\_index = descriptor\_base\_imp\_ref->descriptor\_index();
363 
364     \textcolor{comment}{/**************************** Fill frame payload with AECP data and send the frame ********************
      **/}
365     \hyperlink{namespaceavdecc__lib_a0b1b5aea3c0490f77cbfd9178af5be22}{aecp\_controller\_state\_machine\_ref}->
      \hyperlink{classavdecc__lib_1_1aecp__controller__state__machine_a86ff947c5e6b799cfb877d3767bfa1f9}{ether\_frame\_init}(\hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\_end\_station\_imp\_ref}->
      \hyperlink{classavdecc__lib_1_1end__station__imp_a08e1bd1861b3b8f447ea374a65ac11f9}{mac}(), &cmd\_frame,
366                                                         \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE} + 
      \hyperlink{group__command__reboot_gaf5f6dbe8949b2bb7db6ad9e25e8bddf1}{JDKSAVDECC\_AEM\_COMMAND\_REBOOT\_COMMAND\_LEN});
367     ssize\_t aem\_cmd\_reboot\_entity\_returned = \hyperlink{group__command__reboot_ga47e876f80dcc650ced15fa1579fece63}{jdksavdecc\_aem\_command\_reboot\_write}
      (&aem\_cmd\_reboot,
368                                                                                  cmd\_frame.payload,
369                                                                                  
      \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE},
370                                                                                  \textcolor{keyword}{sizeof}(cmd\_frame.payload))
      ;
371 
372     \textcolor{keywordflow}{if} (aem\_cmd\_reboot\_entity\_returned < 0)
373     \{
374         \hyperlink{namespaceavdecc__lib_acbe3e2a96ae6524943ca532c87a28529}{log\_imp\_ref}->\hyperlink{classavdecc__lib_1_1log_a68139a6297697e4ccebf36ccfd02e44a}{post\_log\_msg}(\hyperlink{namespaceavdecc__lib_a501055c431e6872ef46f252ad13f85cdaf2c4481208273451a6f5c7bb9770ec8a}{LOGGING\_LEVEL\_ERROR}, \textcolor{stringliteral}{"
      aem\_cmd\_reboot\_write error\(\backslash\)n"});
375         assert(aem\_cmd\_reboot\_entity\_returned >= 0);
376         \textcolor{keywordflow}{return} -1;
377     \}
378 
379     \hyperlink{namespaceavdecc__lib_a0b1b5aea3c0490f77cbfd9178af5be22}{aecp\_controller\_state\_machine\_ref}->
      \hyperlink{classavdecc__lib_1_1aecp__controller__state__machine_aafc737d7ed17a62fed9df6528f18d3ec}{common\_hdr\_init}(\hyperlink{group__aecp__message__type_ga4625ce189cc209f42deb0629f48faf69}{JDKSAVDECC\_AECP\_MESSAGE\_TYPE\_AEM\_COMMAND}
      ,
380                                                        &cmd\_frame,
381                                                        \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\_end\_station\_imp\_ref}->
      \hyperlink{classavdecc__lib_1_1end__station__imp_a363b6c9664a0d701def9b17863e20ad3}{entity\_id}(),
382                                                        
      \hyperlink{group__command__reboot_gaf5f6dbe8949b2bb7db6ad9e25e8bddf1}{JDKSAVDECC\_AEM\_COMMAND\_REBOOT\_COMMAND\_LEN} -
383                                                            
      \hyperlink{group__jdksavdecc__avtp__common__control__header_gaae84052886fb1bb42f3bc5f85b741dff}{JDKSAVDECC\_COMMON\_CONTROL\_HEADER\_LEN});
384     \hyperlink{namespaceavdecc__lib_a6dd511685627c0865a3442b539a4e8e9}{system\_queue\_tx}(notification\_id, \hyperlink{namespaceavdecc__lib_aabcadff06aa62be0ce47bc0646823604aba48b8a017e06fb240b650cdea965178}{CMD\_WITH\_NOTIFICATION}, cmd\_frame.
      payload, cmd\_frame.length);
385 
386     \textcolor{keywordflow}{return} 0;
387 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_a14e3bd11c70e839a0594dc59dffcbf16_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_a14e3bd11c70e839a0594dc59dffcbf16_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!default\+\_\+send\+\_\+set\+\_\+name\+\_\+cmd@{default\+\_\+send\+\_\+set\+\_\+name\+\_\+cmd}}
\index{default\+\_\+send\+\_\+set\+\_\+name\+\_\+cmd@{default\+\_\+send\+\_\+set\+\_\+name\+\_\+cmd}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{default\+\_\+send\+\_\+set\+\_\+name\+\_\+cmd(descriptor\+\_\+base\+\_\+imp $\ast$desc\+\_\+base\+\_\+imp\+\_\+ref, void $\ast$notification\+\_\+id, uint16\+\_\+t name\+\_\+index, uint16\+\_\+t config\+\_\+index, const struct avdecc\+\_\+lib\+\_\+name\+\_\+string64 $\ast$name)}{default_send_set_name_cmd(descriptor_base_imp *desc_base_imp_ref, void *notification_id, uint16_t name_index, uint16_t config_index, const struct avdecc_lib_name_string64 *name)}}]{\setlength{\rightskip}{0pt plus 5cm}int default\+\_\+send\+\_\+set\+\_\+name\+\_\+cmd (
\begin{DoxyParamCaption}
\item[{{\bf descriptor\+\_\+base\+\_\+imp} $\ast$}]{desc\+\_\+base\+\_\+imp\+\_\+ref, }
\item[{void $\ast$}]{notification\+\_\+id, }
\item[{uint16\+\_\+t}]{name\+\_\+index, }
\item[{uint16\+\_\+t}]{config\+\_\+index, }
\item[{const struct {\bf avdecc\+\_\+lib\+\_\+name\+\_\+string64} $\ast$}]{name}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_aed899a0eaaaa06a02569135f844ffce8}{}\label{classavdecc__lib_1_1descriptor__base__imp_aed899a0eaaaa06a02569135f844ffce8}


descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 432 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
433 \{
434     \textcolor{keyword}{struct }\hyperlink{structjdksavdecc__frame}{jdksavdecc\_frame} cmd\_frame;
435     \textcolor{keyword}{struct }\hyperlink{structjdksavdecc__aem__command__set__name}{jdksavdecc\_aem\_command\_set\_name} aem\_cmd\_set\_name;
436     ssize\_t aem\_cmd\_set\_name\_returned;
437 
438     \textcolor{comment}{/***************************************** AECP Common Data ******************************************/}
439     aem\_cmd\_set\_name.\hyperlink{structjdksavdecc__aem__command__set__name_ae1e77ccb75ff5021ad923221eab38294}{aem\_header}.\hyperlink{structjdksavdecc__aecpdu__aem_ae8460ae179666e7ce268ed1ef33d0de3}{aecpdu\_header}.
      \hyperlink{structjdksavdecc__aecpdu__common_affc928ddb4fc62d1d04a775d36e5f2c8}{controller\_entity\_id} = \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\_end\_station\_imp\_ref}->
      \hyperlink{classavdecc__lib_1_1end__station__imp_a471a74540ce6182fad0c17dfd010107e}{get\_adp}()->\hyperlink{classavdecc__lib_1_1adp_a0c0959a46658c0a22e9530334b2912da}{get\_controller\_entity\_id}();
440     \textcolor{comment}{// Fill aem\_cmd\_set\_name.sequence\_id in AEM Controller State Machine}
441     aem\_cmd\_set\_name.aem\_header.command\_type = \hyperlink{group__command_ga67c447f46660cc499e4175923e99d32c}{JDKSAVDECC\_AEM\_COMMAND\_SET\_NAME}
      ;
442 
443     \textcolor{comment}{/****************************** AECP Message Specific Data ****************************/}
444     aem\_cmd\_set\_name.descriptor\_type = desc\_base\_imp\_ref->descriptor\_type();
445     aem\_cmd\_set\_name.descriptor\_index = desc\_base\_imp\_ref->descriptor\_index();
446     aem\_cmd\_set\_name.configuration\_index = config\_index;
447     aem\_cmd\_set\_name.name\_index = \hyperlink{structjdksavdecc__aem__command__set__name_a898a74ada625e0b227dadb02901404e6}{name\_index};
448     memcpy(aem\_cmd\_set\_name.name.value, \hyperlink{structjdksavdecc__aem__command__set__name_a7e615b51b7768e9b59bfa450051e0f8e}{name}->\hyperlink{structjdksavdecc__string_a7968db9d35aabae83b5c038723160e28}{value}, \textcolor{keyword}{sizeof}(aem\_cmd\_set\_name.name.value));
449 
450     \textcolor{comment}{/**************************** Fill frame payload with AECP data and send the frame ********************
      **/}
451     \hyperlink{namespaceavdecc__lib_a0b1b5aea3c0490f77cbfd9178af5be22}{aecp\_controller\_state\_machine\_ref}->
      \hyperlink{classavdecc__lib_1_1aecp__controller__state__machine_a86ff947c5e6b799cfb877d3767bfa1f9}{ether\_frame\_init}(\hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\_end\_station\_imp\_ref}->
      \hyperlink{classavdecc__lib_1_1end__station__imp_a08e1bd1861b3b8f447ea374a65ac11f9}{mac}(), &cmd\_frame,
452                                                         \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE} + 
      \hyperlink{group__command__set__name_ga133a28cbd2bc0e77c69d8135f36324f6}{JDKSAVDECC\_AEM\_COMMAND\_SET\_NAME\_COMMAND\_LEN});
453     aem\_cmd\_set\_name\_returned = \hyperlink{group__command__set__name_ga42e5da3685796fb973c5824f960eed2e}{jdksavdecc\_aem\_command\_set\_name\_write}(
      &aem\_cmd\_set\_name,
454                                                                       cmd\_frame.payload,
455                                                                       
      \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE},
456                                                                       \textcolor{keyword}{sizeof}(cmd\_frame.payload));
457 
458     \textcolor{keywordflow}{if} (aem\_cmd\_set\_name\_returned < 0)
459     \{
460         \hyperlink{namespaceavdecc__lib_acbe3e2a96ae6524943ca532c87a28529}{log\_imp\_ref}->\hyperlink{classavdecc__lib_1_1log_a68139a6297697e4ccebf36ccfd02e44a}{post\_log\_msg}(\hyperlink{namespaceavdecc__lib_a501055c431e6872ef46f252ad13f85cdaf2c4481208273451a6f5c7bb9770ec8a}{LOGGING\_LEVEL\_ERROR}, \textcolor{stringliteral}{"
      aem\_cmd\_set\_name\_write error\(\backslash\)n"});
461         assert(aem\_cmd\_set\_name\_returned >= 0);
462         \textcolor{keywordflow}{return} -1;
463     \}
464 
465     \hyperlink{namespaceavdecc__lib_a0b1b5aea3c0490f77cbfd9178af5be22}{aecp\_controller\_state\_machine\_ref}->
      \hyperlink{classavdecc__lib_1_1aecp__controller__state__machine_aafc737d7ed17a62fed9df6528f18d3ec}{common\_hdr\_init}(\hyperlink{group__aecp__message__type_ga4625ce189cc209f42deb0629f48faf69}{JDKSAVDECC\_AECP\_MESSAGE\_TYPE\_AEM\_COMMAND}
      ,
466                                                        &cmd\_frame,
467                                                        \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\_end\_station\_imp\_ref}->
      \hyperlink{classavdecc__lib_1_1end__station__imp_a363b6c9664a0d701def9b17863e20ad3}{entity\_id}(),
468                                                        
      \hyperlink{group__command__set__name_ga133a28cbd2bc0e77c69d8135f36324f6}{JDKSAVDECC\_AEM\_COMMAND\_SET\_NAME\_COMMAND\_LEN} -
469                                                            
      \hyperlink{group__jdksavdecc__avtp__common__control__header_gaae84052886fb1bb42f3bc5f85b741dff}{JDKSAVDECC\_COMMON\_CONTROL\_HEADER\_LEN});
470     \hyperlink{namespaceavdecc__lib_a6dd511685627c0865a3442b539a4e8e9}{system\_queue\_tx}(notification\_id, \hyperlink{namespaceavdecc__lib_aabcadff06aa62be0ce47bc0646823604aba48b8a017e06fb240b650cdea965178}{CMD\_WITH\_NOTIFICATION}, cmd\_frame.
      payload, cmd\_frame.length);
471     \textcolor{keywordflow}{return} 0;
472 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_aed899a0eaaaa06a02569135f844ffce8_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_aed899a0eaaaa06a02569135f844ffce8_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!descriptor\+\_\+index@{descriptor\+\_\+index}}
\index{descriptor\+\_\+index@{descriptor\+\_\+index}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{descriptor\+\_\+index() const =0}{descriptor_index() const =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI uint16\+\_\+t S\+T\+D\+C\+A\+LL descriptor\+\_\+index (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base_a7eed5583bffdf72d89021b188648c1b5}{}\label{classavdecc__lib_1_1descriptor__base_a7eed5583bffdf72d89021b188648c1b5}
\begin{DoxyReturn}{반환값}
The index of the descriptor. 
\end{DoxyReturn}


\hyperlink{classavdecc__lib_1_1configuration__descriptor__imp_ac23c0a35276c07cfce8c8660700c2135}{configuration\+\_\+descriptor\+\_\+imp}, \hyperlink{classavdecc__lib_1_1descriptor__base__imp_ac23c0a35276c07cfce8c8660700c2135}{descriptor\+\_\+base\+\_\+imp}에서 구현되었습니다.



이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base_a7eed5583bffdf72d89021b188648c1b5_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!descriptor\+\_\+index@{descriptor\+\_\+index}}
\index{descriptor\+\_\+index@{descriptor\+\_\+index}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{descriptor\+\_\+index() const }{descriptor_index() const }}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t S\+T\+D\+C\+A\+LL descriptor\+\_\+index (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_ac23c0a35276c07cfce8c8660700c2135}{}\label{classavdecc__lib_1_1descriptor__base__imp_ac23c0a35276c07cfce8c8660700c2135}
\begin{DoxyReturn}{반환값}
The index of the descriptor. 
\end{DoxyReturn}


\hyperlink{classavdecc__lib_1_1descriptor__base_a7eed5583bffdf72d89021b188648c1b5}{descriptor\+\_\+base}를 구현.



descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 104 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
105 \{
106     \textcolor{keywordflow}{return} \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2bbd0d8f32f687ca36aaa543c06f764c}{desc\_index};
107 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=550pt]{classavdecc__lib_1_1descriptor__base__imp_ac23c0a35276c07cfce8c8660700c2135_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!descriptor\+\_\+type@{descriptor\+\_\+type}}
\index{descriptor\+\_\+type@{descriptor\+\_\+type}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{descriptor\+\_\+type() const =0}{descriptor_type() const =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI uint16\+\_\+t S\+T\+D\+C\+A\+LL descriptor\+\_\+type (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base_a5112b70022171063ec5d3242bee9910e}{}\label{classavdecc__lib_1_1descriptor__base_a5112b70022171063ec5d3242bee9910e}
\begin{DoxyReturn}{반환값}
The type of the descriptor. 
\end{DoxyReturn}


\hyperlink{classavdecc__lib_1_1configuration__descriptor__imp_aefc543029ab093823c3f5b9d84f0ccc4}{configuration\+\_\+descriptor\+\_\+imp}, \hyperlink{classavdecc__lib_1_1descriptor__base__imp_aefc543029ab093823c3f5b9d84f0ccc4}{descriptor\+\_\+base\+\_\+imp}에서 구현되었습니다.



이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base_a5112b70022171063ec5d3242bee9910e_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!descriptor\+\_\+type@{descriptor\+\_\+type}}
\index{descriptor\+\_\+type@{descriptor\+\_\+type}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{descriptor\+\_\+type() const }{descriptor_type() const }}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t S\+T\+D\+C\+A\+LL descriptor\+\_\+type (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_aefc543029ab093823c3f5b9d84f0ccc4}{}\label{classavdecc__lib_1_1descriptor__base__imp_aefc543029ab093823c3f5b9d84f0ccc4}
\begin{DoxyReturn}{반환값}
The type of the descriptor. 
\end{DoxyReturn}


\hyperlink{classavdecc__lib_1_1descriptor__base_a5112b70022171063ec5d3242bee9910e}{descriptor\+\_\+base}를 구현.



descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 99 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
100 \{
101     \textcolor{keywordflow}{return} \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a9dada313309522d04f1e52fe887442b4}{desc\_type};
102 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=550pt]{classavdecc__lib_1_1descriptor__base__imp_aefc543029ab093823c3f5b9d84f0ccc4_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!field@{field}}
\index{field@{field}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{field(size\+\_\+t index) const =0}{field(size_t index) const =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI {\bf descriptor\+\_\+field}$\ast$ S\+T\+D\+C\+A\+LL field (
\begin{DoxyParamCaption}
\item[{size\+\_\+t}]{index}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base_aa3716832eed0b6f6dcfba358c5d2c601}{}\label{classavdecc__lib_1_1descriptor__base_aa3716832eed0b6f6dcfba358c5d2c601}
\begin{DoxyReturn}{반환값}
The indicated field in the descriptor. 
\end{DoxyReturn}


\hyperlink{classavdecc__lib_1_1descriptor__base__imp_a5f8127d32e2aa54777ca03bf09e8d7b5}{descriptor\+\_\+base\+\_\+imp}에서 구현되었습니다.



이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base_aa3716832eed0b6f6dcfba358c5d2c601_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!field@{field}}
\index{field@{field}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{field(size\+\_\+t index) const }{field(size_t index) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf descriptor\+\_\+field}$\ast$ S\+T\+D\+C\+A\+LL field (
\begin{DoxyParamCaption}
\item[{size\+\_\+t}]{index}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_a5f8127d32e2aa54777ca03bf09e8d7b5}{}\label{classavdecc__lib_1_1descriptor__base__imp_a5f8127d32e2aa54777ca03bf09e8d7b5}
\begin{DoxyReturn}{반환값}
The indicated field in the descriptor. 
\end{DoxyReturn}


\hyperlink{classavdecc__lib_1_1descriptor__base_aa3716832eed0b6f6dcfba358c5d2c601}{descriptor\+\_\+base}를 구현.



descriptor\+\_\+base\+\_\+imp.\+h 파일의 73 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
74     \{
75         \textcolor{keywordflow}{if} (index < \hyperlink{classavdecc__lib_1_1descriptor__base__imp_adce67136eb9c66da9c189b730077b9cd}{m\_fields}.size())
76             \textcolor{keywordflow}{return} \hyperlink{classavdecc__lib_1_1descriptor__base__imp_adce67136eb9c66da9c189b730077b9cd}{m\_fields}.at(index);
77         \textcolor{keywordflow}{else}
78             \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};
79     \};
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=550pt]{classavdecc__lib_1_1descriptor__base__imp_a5f8127d32e2aa54777ca03bf09e8d7b5_cgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!field\+\_\+count@{field\+\_\+count}}
\index{field\+\_\+count@{field\+\_\+count}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{field\+\_\+count() const =0}{field_count() const =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI size\+\_\+t S\+T\+D\+C\+A\+LL field\+\_\+count (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base_ab1edf4996377ed957088a7b3b16aca7d}{}\label{classavdecc__lib_1_1descriptor__base_ab1edf4996377ed957088a7b3b16aca7d}
\begin{DoxyReturn}{반환값}
The number of fields in the descriptor. 
\end{DoxyReturn}


\hyperlink{classavdecc__lib_1_1descriptor__base__imp_a9b98d4f427a6c527e9080c938cfa9334}{descriptor\+\_\+base\+\_\+imp}에서 구현되었습니다.



이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base_ab1edf4996377ed957088a7b3b16aca7d_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!field\+\_\+count@{field\+\_\+count}}
\index{field\+\_\+count@{field\+\_\+count}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{field\+\_\+count() const }{field_count() const }}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t S\+T\+D\+C\+A\+LL field\+\_\+count (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_a9b98d4f427a6c527e9080c938cfa9334}{}\label{classavdecc__lib_1_1descriptor__base__imp_a9b98d4f427a6c527e9080c938cfa9334}
\begin{DoxyReturn}{반환값}
The number of fields in the descriptor. 
\end{DoxyReturn}


\hyperlink{classavdecc__lib_1_1descriptor__base_ab1edf4996377ed957088a7b3b16aca7d}{descriptor\+\_\+base}를 구현.



descriptor\+\_\+base\+\_\+imp.\+h 파일의 68 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
69     \{
70         \textcolor{keywordflow}{return} \hyperlink{classavdecc__lib_1_1descriptor__base__imp_adce67136eb9c66da9c189b730077b9cd}{m\_fields}.size();
71     \};
\end{DoxyCode}
\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!get\+\_\+descriptor\+\_\+response@{get\+\_\+descriptor\+\_\+response}}
\index{get\+\_\+descriptor\+\_\+response@{get\+\_\+descriptor\+\_\+response}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{get\+\_\+descriptor\+\_\+response()=0}{get_descriptor_response()=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI {\bf descriptor\+\_\+response\+\_\+base}$\ast$ S\+T\+D\+C\+A\+LL get\+\_\+descriptor\+\_\+response (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base_ac64e6a5ee8781eeb9c781953e845b1be}{}\label{classavdecc__lib_1_1descriptor__base_ac64e6a5ee8781eeb9c781953e845b1be}
\begin{DoxyReturn}{반환값}
the descriptor base response class. 
\end{DoxyReturn}


\hyperlink{classavdecc__lib_1_1descriptor__base__imp_a8c64c9df60afbc144cf24eab5a42c009}{descriptor\+\_\+base\+\_\+imp}에서 구현되었습니다.



이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base_ac64e6a5ee8781eeb9c781953e845b1be_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!get\+\_\+descriptor\+\_\+response@{get\+\_\+descriptor\+\_\+response}}
\index{get\+\_\+descriptor\+\_\+response@{get\+\_\+descriptor\+\_\+response}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{get\+\_\+descriptor\+\_\+response()}{get_descriptor_response()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf descriptor\+\_\+response\+\_\+base} $\ast$S\+T\+D\+C\+A\+LL get\+\_\+descriptor\+\_\+response (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_a8c64c9df60afbc144cf24eab5a42c009}{}\label{classavdecc__lib_1_1descriptor__base__imp_a8c64c9df60afbc144cf24eab5a42c009}
\begin{DoxyReturn}{반환값}
the descriptor base response class. 
\end{DoxyReturn}


\hyperlink{classavdecc__lib_1_1descriptor__base_ac64e6a5ee8781eeb9c781953e845b1be}{descriptor\+\_\+base}를 구현.



descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 63 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
64 \{
65     std::lock\_guard<std::mutex> guard(\hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\_end\_station\_imp\_ref}->
      \hyperlink{classavdecc__lib_1_1end__station__imp_a2207f93fef130266b292686bf96ef8d3}{locker}); \textcolor{comment}{//mutex lock end station}
66     \textcolor{keywordflow}{return} \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a8b104da8319cda946944548ebb9552f4}{resp\_base} = \textcolor{keyword}{new} descriptor\_response\_base\_imp(\hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2642e3a7c10d38553e7ff4a55e875346}{resp\_ref}->
      \hyperlink{classavdecc__lib_1_1response__frame_a87db6e7ad7e047437cf9c9eaab873626}{get\_desc\_buffer}(), \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2642e3a7c10d38553e7ff4a55e875346}{resp\_ref}->\hyperlink{classavdecc__lib_1_1response__frame_a5302ae13c549f066040ce0e7c7d11ae6}{get\_desc\_size}(),
67                                                         \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2642e3a7c10d38553e7ff4a55e875346}{resp\_ref}->
      \hyperlink{classavdecc__lib_1_1response__frame_a6e6f6cc3d681d41c6de6139ca9cb79d9}{get\_desc\_pos}());
68 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_a8c64c9df60afbc144cf24eab5a42c009_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=274pt]{classavdecc__lib_1_1descriptor__base__imp_a8c64c9df60afbc144cf24eab5a42c009_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!get\+\_\+memory\+\_\+object\+\_\+response@{get\+\_\+memory\+\_\+object\+\_\+response}}
\index{get\+\_\+memory\+\_\+object\+\_\+response@{get\+\_\+memory\+\_\+object\+\_\+response}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{get\+\_\+memory\+\_\+object\+\_\+response()}{get_memory_object_response()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf memory\+\_\+object\+\_\+descriptor\+\_\+response} $\ast$S\+T\+D\+C\+A\+LL get\+\_\+memory\+\_\+object\+\_\+response (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classavdecc__lib_1_1memory__object__descriptor__imp_a08904513dd93a4e8af3c8bd3f03dae4d}{}\label{classavdecc__lib_1_1memory__object__descriptor__imp_a08904513dd93a4e8af3c8bd3f03dae4d}
\begin{DoxyReturn}{반환값}
the memory object descriptor response class. 
\end{DoxyReturn}


\hyperlink{classavdecc__lib_1_1memory__object__descriptor_ae85115ea5521b42712e2807173f9b45e}{memory\+\_\+object\+\_\+descriptor}를 구현.



memory\+\_\+object\+\_\+descriptor\+\_\+imp.\+cpp 파일의 49 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
50 \{
51     std::lock\_guard<std::mutex> guard(\hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\_end\_station\_imp\_ref}->
      \hyperlink{classavdecc__lib_1_1end__station__imp_a2207f93fef130266b292686bf96ef8d3}{locker}); \textcolor{comment}{//mutex lock end station}
52     \textcolor{keywordflow}{return} \hyperlink{classavdecc__lib_1_1memory__object__descriptor__imp_ad06f22b0ac48bb4645e644db866d01cf}{resp} = \textcolor{keyword}{new} memory\_object\_descriptor\_response\_imp(\hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2642e3a7c10d38553e7ff4a55e875346}{resp\_ref}->
      \hyperlink{classavdecc__lib_1_1response__frame_a87db6e7ad7e047437cf9c9eaab873626}{get\_desc\_buffer}(),
53                                                             \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2642e3a7c10d38553e7ff4a55e875346}{resp\_ref}->
      \hyperlink{classavdecc__lib_1_1response__frame_a5302ae13c549f066040ce0e7c7d11ae6}{get\_desc\_size}(), \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2642e3a7c10d38553e7ff4a55e875346}{resp\_ref}->\hyperlink{classavdecc__lib_1_1response__frame_a6e6f6cc3d681d41c6de6139ca9cb79d9}{get\_desc\_pos}());
54 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1memory__object__descriptor__imp_a08904513dd93a4e8af3c8bd3f03dae4d_cgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!get\+\_\+name\+\_\+response@{get\+\_\+name\+\_\+response}}
\index{get\+\_\+name\+\_\+response@{get\+\_\+name\+\_\+response}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{get\+\_\+name\+\_\+response()=0}{get_name_response()=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI {\bf descriptor\+\_\+base\+\_\+get\+\_\+name\+\_\+response}$\ast$ S\+T\+D\+C\+A\+LL get\+\_\+name\+\_\+response (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base_aba4bf8a81f90f5bf00d5c8b5a7330145}{}\label{classavdecc__lib_1_1descriptor__base_aba4bf8a81f90f5bf00d5c8b5a7330145}
\begin{DoxyReturn}{반환값}
the G\+E\+T\+\_\+\+N\+A\+ME response class. 
\end{DoxyReturn}


\hyperlink{classavdecc__lib_1_1descriptor__base__imp_abf130a286ee3ca9d1f41a7e2abbd0d33}{descriptor\+\_\+base\+\_\+imp}에서 구현되었습니다.



이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base_aba4bf8a81f90f5bf00d5c8b5a7330145_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!get\+\_\+name\+\_\+response@{get\+\_\+name\+\_\+response}}
\index{get\+\_\+name\+\_\+response@{get\+\_\+name\+\_\+response}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{get\+\_\+name\+\_\+response()}{get_name_response()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf descriptor\+\_\+base\+\_\+get\+\_\+name\+\_\+response} $\ast$S\+T\+D\+C\+A\+LL get\+\_\+name\+\_\+response (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_abf130a286ee3ca9d1f41a7e2abbd0d33}{}\label{classavdecc__lib_1_1descriptor__base__imp_abf130a286ee3ca9d1f41a7e2abbd0d33}
\begin{DoxyReturn}{반환값}
the G\+E\+T\+\_\+\+N\+A\+ME response class. 
\end{DoxyReturn}


\hyperlink{classavdecc__lib_1_1descriptor__base_aba4bf8a81f90f5bf00d5c8b5a7330145}{descriptor\+\_\+base}를 구현.



descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 70 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
71 \{
72     std::lock\_guard<std::mutex> guard(\hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\_end\_station\_imp\_ref}->
      \hyperlink{classavdecc__lib_1_1end__station__imp_a2207f93fef130266b292686bf96ef8d3}{locker}); \textcolor{comment}{//mutex lock end station}
73     \textcolor{keywordflow}{return} \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a7d3a410eb242dc2b7abe9862a1593458}{get\_name\_resp} = \textcolor{keyword}{new} descriptor\_base\_get\_name\_response\_imp(
      \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2642e3a7c10d38553e7ff4a55e875346}{resp\_ref}->\hyperlink{classavdecc__lib_1_1response__frame_ad4680d622c198b5256c03b2eb2638c22}{get\_buffer}(), \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2642e3a7c10d38553e7ff4a55e875346}{resp\_ref}->\hyperlink{classavdecc__lib_1_1response__frame_adf55ed6a1edf8e1aa4f3f5f97936ad1e}{get\_size}(),
74                                                                      \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2642e3a7c10d38553e7ff4a55e875346}{resp\_ref}->
      \hyperlink{classavdecc__lib_1_1response__frame_a4038092b7b420000faefc768241adb42}{get\_pos}());
75 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=329pt]{classavdecc__lib_1_1descriptor__base__imp_abf130a286ee3ca9d1f41a7e2abbd0d33_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=255pt]{classavdecc__lib_1_1descriptor__base__imp_abf130a286ee3ca9d1f41a7e2abbd0d33_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!localized\+\_\+description@{localized\+\_\+description}}
\index{localized\+\_\+description@{localized\+\_\+description}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{localized\+\_\+description()}{localized_description()}}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t S\+T\+D\+C\+A\+LL localized\+\_\+description (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_aa94307532fbb37e2f986fee8fec79373}{}\label{classavdecc__lib_1_1descriptor__base__imp_aa94307532fbb37e2f986fee8fec79373}
\begin{DoxyReturn}{반환값}
The localized string reference pointing to the localized descriptor name. 
\end{DoxyReturn}


\hyperlink{classavdecc__lib_1_1descriptor__base_a1fb9de45567df344090a1407aa6b775f}{descriptor\+\_\+base}를 구현.



\hyperlink{classavdecc__lib_1_1configuration__descriptor__imp_aa94307532fbb37e2f986fee8fec79373}{configuration\+\_\+descriptor\+\_\+imp}에서 재구현되었습니다.



descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 109 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
110 \{
111     \textcolor{keywordflow}{return} 0xffff;
112 \}
\end{DoxyCode}
\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!localized\+\_\+description@{localized\+\_\+description}}
\index{localized\+\_\+description@{localized\+\_\+description}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{localized\+\_\+description()=0}{localized_description()=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI uint16\+\_\+t S\+T\+D\+C\+A\+LL localized\+\_\+description (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base_a1fb9de45567df344090a1407aa6b775f}{}\label{classavdecc__lib_1_1descriptor__base_a1fb9de45567df344090a1407aa6b775f}
\begin{DoxyReturn}{반환값}
The localized string reference pointing to the localized descriptor name. 
\end{DoxyReturn}


\hyperlink{classavdecc__lib_1_1configuration__descriptor__imp_aa94307532fbb37e2f986fee8fec79373}{configuration\+\_\+descriptor\+\_\+imp}, \hyperlink{classavdecc__lib_1_1descriptor__base__imp_aa94307532fbb37e2f986fee8fec79373}{descriptor\+\_\+base\+\_\+imp}에서 구현되었습니다.



이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base_a1fb9de45567df344090a1407aa6b775f_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!lock\+\_\+entity\+\_\+flags@{lock\+\_\+entity\+\_\+flags}}
\index{lock\+\_\+entity\+\_\+flags@{lock\+\_\+entity\+\_\+flags}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{lock\+\_\+entity\+\_\+flags()=0}{lock_entity_flags()=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI {\bf uint32\+\_\+t} S\+T\+D\+C\+A\+LL lock\+\_\+entity\+\_\+flags (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base_a757e66272bba4c52cefa914df8c60bb5}{}\label{classavdecc__lib_1_1descriptor__base_a757e66272bba4c52cefa914df8c60bb5}
\begin{DoxyReturn}{반환값}
The flags after sending a L\+O\+C\+K\+\_\+\+E\+N\+T\+I\+TY command and receiving a response back for the command. 
\end{DoxyReturn}


\hyperlink{classavdecc__lib_1_1descriptor__base__imp_afe2564a2a32f83deced28efa17f332e2}{descriptor\+\_\+base\+\_\+imp}, \hyperlink{classavdecc__lib_1_1entity__descriptor__imp_afe2564a2a32f83deced28efa17f332e2}{entity\+\_\+descriptor\+\_\+imp}에서 구현되었습니다.



이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=298pt]{classavdecc__lib_1_1descriptor__base_a757e66272bba4c52cefa914df8c60bb5_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!lock\+\_\+entity\+\_\+flags@{lock\+\_\+entity\+\_\+flags}}
\index{lock\+\_\+entity\+\_\+flags@{lock\+\_\+entity\+\_\+flags}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{lock\+\_\+entity\+\_\+flags()}{lock_entity_flags()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\+\_\+t} S\+T\+D\+C\+A\+LL lock\+\_\+entity\+\_\+flags (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_afe2564a2a32f83deced28efa17f332e2}{}\label{classavdecc__lib_1_1descriptor__base__imp_afe2564a2a32f83deced28efa17f332e2}
Get the flags after sending a L\+O\+C\+K\+\_\+\+E\+N\+T\+I\+TY command and receiving a response back for the command. 

\hyperlink{classavdecc__lib_1_1descriptor__base_a757e66272bba4c52cefa914df8c60bb5}{descriptor\+\_\+base}를 구현.



\hyperlink{classavdecc__lib_1_1entity__descriptor__imp_afe2564a2a32f83deced28efa17f332e2}{entity\+\_\+descriptor\+\_\+imp}에서 재구현되었습니다.



descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 124 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
125 \{
126     \textcolor{keywordflow}{return} 0;
127 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=241pt]{classavdecc__lib_1_1descriptor__base__imp_afe2564a2a32f83deced28efa17f332e2_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!lock\+\_\+entity\+\_\+locked\+\_\+entity\+\_\+id@{lock\+\_\+entity\+\_\+locked\+\_\+entity\+\_\+id}}
\index{lock\+\_\+entity\+\_\+locked\+\_\+entity\+\_\+id@{lock\+\_\+entity\+\_\+locked\+\_\+entity\+\_\+id}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{lock\+\_\+entity\+\_\+locked\+\_\+entity\+\_\+id()=0}{lock_entity_locked_entity_id()=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI {\bf uint64\+\_\+t} S\+T\+D\+C\+A\+LL lock\+\_\+entity\+\_\+locked\+\_\+entity\+\_\+id (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base_a052b47529d0e60ca87894159fcb65e14}{}\label{classavdecc__lib_1_1descriptor__base_a052b47529d0e60ca87894159fcb65e14}
\begin{DoxyReturn}{반환값}
The locked entity id after sending a L\+O\+C\+K\+\_\+\+E\+N\+T\+I\+TY command and receiving a response back for the command. 
\end{DoxyReturn}


\hyperlink{classavdecc__lib_1_1descriptor__base__imp_aeb8f096d55f82522516cbf00a616246a}{descriptor\+\_\+base\+\_\+imp}, \hyperlink{classavdecc__lib_1_1entity__descriptor__imp_aeb8f096d55f82522516cbf00a616246a}{entity\+\_\+descriptor\+\_\+imp}에서 구현되었습니다.



이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=306pt]{classavdecc__lib_1_1descriptor__base_a052b47529d0e60ca87894159fcb65e14_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!lock\+\_\+entity\+\_\+locked\+\_\+entity\+\_\+id@{lock\+\_\+entity\+\_\+locked\+\_\+entity\+\_\+id}}
\index{lock\+\_\+entity\+\_\+locked\+\_\+entity\+\_\+id@{lock\+\_\+entity\+\_\+locked\+\_\+entity\+\_\+id}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{lock\+\_\+entity\+\_\+locked\+\_\+entity\+\_\+id()}{lock_entity_locked_entity_id()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint64\+\_\+t} S\+T\+D\+C\+A\+LL lock\+\_\+entity\+\_\+locked\+\_\+entity\+\_\+id (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_aeb8f096d55f82522516cbf00a616246a}{}\label{classavdecc__lib_1_1descriptor__base__imp_aeb8f096d55f82522516cbf00a616246a}
Get the locked entity id after sending a L\+O\+C\+K\+\_\+\+E\+N\+T\+I\+TY command and receiving a response back for the command. 

\hyperlink{classavdecc__lib_1_1descriptor__base_a052b47529d0e60ca87894159fcb65e14}{descriptor\+\_\+base}를 구현.



\hyperlink{classavdecc__lib_1_1entity__descriptor__imp_aeb8f096d55f82522516cbf00a616246a}{entity\+\_\+descriptor\+\_\+imp}에서 재구현되었습니다.



descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 129 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
130 \{
131     \textcolor{keywordflow}{return} 0;
132 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=249pt]{classavdecc__lib_1_1descriptor__base__imp_aeb8f096d55f82522516cbf00a616246a_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!proc\+\_\+acquire\+\_\+entity\+\_\+resp@{proc\+\_\+acquire\+\_\+entity\+\_\+resp}}
\index{proc\+\_\+acquire\+\_\+entity\+\_\+resp@{proc\+\_\+acquire\+\_\+entity\+\_\+resp}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{proc\+\_\+acquire\+\_\+entity\+\_\+resp(void $\ast$\&notification\+\_\+id, const uint8\+\_\+t $\ast$frame, size\+\_\+t frame\+\_\+len, int \&status)}{proc_acquire_entity_resp(void *&notification_id, const uint8_t *frame, size_t frame_len, int &status)}}]{\setlength{\rightskip}{0pt plus 5cm}int proc\+\_\+acquire\+\_\+entity\+\_\+resp (
\begin{DoxyParamCaption}
\item[{void $\ast$\&}]{notification\+\_\+id, }
\item[{const {\bf uint8\+\_\+t} $\ast$}]{frame, }
\item[{size\+\_\+t}]{frame\+\_\+len, }
\item[{int \&}]{status}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_a934de13d0b017574d514ce276180a004}{}\label{classavdecc__lib_1_1descriptor__base__imp_a934de13d0b017574d514ce276180a004}


\hyperlink{classavdecc__lib_1_1entity__descriptor__imp_a934de13d0b017574d514ce276180a004}{entity\+\_\+descriptor\+\_\+imp}에서 재구현되었습니다.



descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 143 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
144 \{
145     (void)notification\_id; \textcolor{comment}{//unused}
146     (void)\hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame};
147     (void)frame\_len;
148     (void)status;
149 
150     \hyperlink{namespaceavdecc__lib_acbe3e2a96ae6524943ca532c87a28529}{log\_imp\_ref}->\hyperlink{classavdecc__lib_1_1log_a68139a6297697e4ccebf36ccfd02e44a}{post\_log\_msg}(\hyperlink{namespaceavdecc__lib_a501055c431e6872ef46f252ad13f85cdaf2c4481208273451a6f5c7bb9770ec8a}{LOGGING\_LEVEL\_ERROR}, \textcolor{stringliteral}{"Need to
       override proc\_acquire\_entity\_resp.\(\backslash\)n"});
151     \textcolor{keywordflow}{return} 0;
152 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_a934de13d0b017574d514ce276180a004_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_a934de13d0b017574d514ce276180a004_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!proc\+\_\+get\+\_\+name\+\_\+resp@{proc\+\_\+get\+\_\+name\+\_\+resp}}
\index{proc\+\_\+get\+\_\+name\+\_\+resp@{proc\+\_\+get\+\_\+name\+\_\+resp}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{proc\+\_\+get\+\_\+name\+\_\+resp(void $\ast$\&notification\+\_\+id, const uint8\+\_\+t $\ast$frame, size\+\_\+t frame\+\_\+len, int \&status)}{proc_get_name_resp(void *&notification_id, const uint8_t *frame, size_t frame_len, int &status)}}]{\setlength{\rightskip}{0pt plus 5cm}int proc\+\_\+get\+\_\+name\+\_\+resp (
\begin{DoxyParamCaption}
\item[{void $\ast$\&}]{notification\+\_\+id, }
\item[{const {\bf uint8\+\_\+t} $\ast$}]{frame, }
\item[{size\+\_\+t}]{frame\+\_\+len, }
\item[{int \&}]{status}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_ac4e290a88039a8e4915f7b9f8738881f}{}\label{classavdecc__lib_1_1descriptor__base__imp_ac4e290a88039a8e4915f7b9f8738881f}


descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 623 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
624 \{
625     \textcolor{keyword}{struct }\hyperlink{structjdksavdecc__aem__command__get__name__response}{jdksavdecc\_aem\_command\_get\_name\_response} 
      aem\_cmd\_get\_name\_resp;
626     memset(&aem\_cmd\_get\_name\_resp, 0, \textcolor{keyword}{sizeof}(
      \hyperlink{structjdksavdecc__aem__command__get__name__response}{jdksavdecc\_aem\_command\_get\_name\_response}));
627     \textcolor{keywordflow}{return} \hyperlink{classavdecc__lib_1_1descriptor__base__imp_acc8b1c1591bd54bc9a2d21d4f0db2e86}{default\_proc\_get\_name\_resp}(aem\_cmd\_get\_name\_resp, notification\_id, 
      \hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, frame\_len, status);
628 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_ac4e290a88039a8e4915f7b9f8738881f_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_ac4e290a88039a8e4915f7b9f8738881f_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!proc\+\_\+lock\+\_\+entity\+\_\+resp@{proc\+\_\+lock\+\_\+entity\+\_\+resp}}
\index{proc\+\_\+lock\+\_\+entity\+\_\+resp@{proc\+\_\+lock\+\_\+entity\+\_\+resp}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{proc\+\_\+lock\+\_\+entity\+\_\+resp(void $\ast$\&notification\+\_\+id, const uint8\+\_\+t $\ast$frame, size\+\_\+t frame\+\_\+len, int \&status)}{proc_lock_entity_resp(void *&notification_id, const uint8_t *frame, size_t frame_len, int &status)}}]{\setlength{\rightskip}{0pt plus 5cm}int proc\+\_\+lock\+\_\+entity\+\_\+resp (
\begin{DoxyParamCaption}
\item[{void $\ast$\&}]{notification\+\_\+id, }
\item[{const {\bf uint8\+\_\+t} $\ast$}]{frame, }
\item[{size\+\_\+t}]{frame\+\_\+len, }
\item[{int \&}]{status}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_a6cd2b73ea95b18f07dbdc251140679b0}{}\label{classavdecc__lib_1_1descriptor__base__imp_a6cd2b73ea95b18f07dbdc251140679b0}


\hyperlink{classavdecc__lib_1_1entity__descriptor__imp_a6cd2b73ea95b18f07dbdc251140679b0}{entity\+\_\+descriptor\+\_\+imp}에서 재구현되었습니다.



descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 240 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
241 \{
242     (void)notification\_id; \textcolor{comment}{//unused}
243     (void)\hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame};
244     (void)frame\_len;
245     (void)status;
246 
247     \hyperlink{namespaceavdecc__lib_acbe3e2a96ae6524943ca532c87a28529}{log\_imp\_ref}->\hyperlink{classavdecc__lib_1_1log_a68139a6297697e4ccebf36ccfd02e44a}{post\_log\_msg}(\hyperlink{namespaceavdecc__lib_a501055c431e6872ef46f252ad13f85cdaf2c4481208273451a6f5c7bb9770ec8a}{LOGGING\_LEVEL\_ERROR}, \textcolor{stringliteral}{"Need to
       override proc\_lock\_entity\_resp.\(\backslash\)n"});
248 
249     \textcolor{keywordflow}{return} 0;
250 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_a6cd2b73ea95b18f07dbdc251140679b0_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_a6cd2b73ea95b18f07dbdc251140679b0_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!proc\+\_\+operation\+\_\+status\+\_\+resp@{proc\+\_\+operation\+\_\+status\+\_\+resp}}
\index{proc\+\_\+operation\+\_\+status\+\_\+resp@{proc\+\_\+operation\+\_\+status\+\_\+resp}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{proc\+\_\+operation\+\_\+status\+\_\+resp(void $\ast$\&notification\+\_\+id, const uint8\+\_\+t $\ast$frame, size\+\_\+t frame\+\_\+len, int \&status, uint16\+\_\+t \&operation\+\_\+id, bool \&is\+\_\+operation\+\_\+id\+\_\+valid)}{proc_operation_status_resp(void *&notification_id, const uint8_t *frame, size_t frame_len, int &status, uint16_t &operation_id, bool &is_operation_id_valid)}}]{\setlength{\rightskip}{0pt plus 5cm}int proc\+\_\+operation\+\_\+status\+\_\+resp (
\begin{DoxyParamCaption}
\item[{void $\ast$\&}]{notification\+\_\+id, }
\item[{const {\bf uint8\+\_\+t} $\ast$}]{frame, }
\item[{size\+\_\+t}]{frame\+\_\+len, }
\item[{int \&}]{status, }
\item[{uint16\+\_\+t \&}]{operation\+\_\+id, }
\item[{{\bf bool} \&}]{is\+\_\+operation\+\_\+id\+\_\+valid}
\end{DoxyParamCaption}
)}\hypertarget{classavdecc__lib_1_1memory__object__descriptor__imp_a7c108e43d954d43c7f53400a86c53354}{}\label{classavdecc__lib_1_1memory__object__descriptor__imp_a7c108e43d954d43c7f53400a86c53354}


memory\+\_\+object\+\_\+descriptor\+\_\+imp.\+cpp 파일의 134 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
140 \{
141     \textcolor{keyword}{struct }\hyperlink{structjdksavdecc__frame}{jdksavdecc\_frame} cmd\_frame;
142     \textcolor{keyword}{struct }\hyperlink{structjdksavdecc__aem__command__operation__status__response}{jdksavdecc\_aem\_command\_operation\_status\_response}
       aem\_operation\_status\_resp;
143     memset(&aem\_operation\_status\_resp, 0, \textcolor{keyword}{sizeof}(aem\_operation\_status\_resp));
144     memcpy(cmd\_frame.payload, \hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, frame\_len);
145 
146     ssize\_t aem\_operation\_status\_resp\_returned = 
      \hyperlink{group__command__operation__status__response_ga5ceaedceaf06924eec56ff6ea246dd7e}{jdksavdecc\_aem\_command\_operation\_status\_response\_read}(
      &aem\_operation\_status\_resp,
147                                                                                                        
      \hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame},
148                                                                                                        
      \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE},
149                                                                                                        
      frame\_len);
150 
151     \textcolor{keywordflow}{if} (aem\_operation\_status\_resp\_returned < 0)
152     \{
153         \hyperlink{namespaceavdecc__lib_acbe3e2a96ae6524943ca532c87a28529}{log\_imp\_ref}->\hyperlink{classavdecc__lib_1_1log_a68139a6297697e4ccebf36ccfd02e44a}{post\_log\_msg}(\hyperlink{namespaceavdecc__lib_a501055c431e6872ef46f252ad13f85cdaf2c4481208273451a6f5c7bb9770ec8a}{LOGGING\_LEVEL\_ERROR}, \textcolor{stringliteral}{"
      aem\_command\_operation\_status\_response\_read error"});
154         \textcolor{keywordflow}{return} -1;
155     \}
156 
157     \hyperlink{parse_8c_a6eb1e68cc391dd753bc8ce896dbb8315}{uint32\_t} msg\_type = aem\_operation\_status\_resp.aem\_header.aecpdu\_header.header.message\_type;
158     status = aem\_operation\_status\_resp.aem\_header.aecpdu\_header.header.status;
159     \textcolor{keywordtype}{bool} u\_field = aem\_operation\_status\_resp.aem\_header.command\_type >> 15 & 0x01;
160     \hyperlink{structjdksavdecc__aem__command__operation__status__response_a5b1b19c38a3b340cfc6ebcb9eeb153e2}{operation\_id} = aem\_operation\_status\_resp.operation\_id;
161     uint16\_t \hyperlink{structjdksavdecc__aem__command__operation__status__response_aecd19b49efe60de843635a9ab3ac6dd7}{percent\_complete} = aem\_operation\_status\_resp.percent\_complete;
162 
163     \textcolor{keywordflow}{if} (\hyperlink{structjdksavdecc__aem__command__operation__status__response_a5b1b19c38a3b340cfc6ebcb9eeb153e2}{operation\_id})
164         is\_operation\_id\_valid = \textcolor{keyword}{true};
165 
166     \hyperlink{namespaceavdecc__lib_a0b1b5aea3c0490f77cbfd9178af5be22}{aecp\_controller\_state\_machine\_ref}->
      \hyperlink{classavdecc__lib_1_1aecp__controller__state__machine_a997abd9786c330a5505e903e6443208e}{update\_inflight\_for\_rcvd\_resp}(notification\_id, msg\_type, u\_field, &cmd\_frame);
167     \hyperlink{namespaceavdecc__lib_a0b1b5aea3c0490f77cbfd9178af5be22}{aecp\_controller\_state\_machine\_ref}->
      \hyperlink{classavdecc__lib_1_1aecp__controller__state__machine_a862f2ed40a94cb35626166286b0fa151}{update\_operation\_for\_rcvd\_resp}(notification\_id, 
      \hyperlink{structjdksavdecc__aem__command__operation__status__response_a5b1b19c38a3b340cfc6ebcb9eeb153e2}{operation\_id}, percent\_complete, &cmd\_frame);
168 
169     \textcolor{keywordflow}{return} 0;
170 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1memory__object__descriptor__imp_a7c108e43d954d43c7f53400a86c53354_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1memory__object__descriptor__imp_a7c108e43d954d43c7f53400a86c53354_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!proc\+\_\+reboot\+\_\+resp@{proc\+\_\+reboot\+\_\+resp}}
\index{proc\+\_\+reboot\+\_\+resp@{proc\+\_\+reboot\+\_\+resp}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{proc\+\_\+reboot\+\_\+resp(void $\ast$\&notification\+\_\+id, const uint8\+\_\+t $\ast$frame, size\+\_\+t frame\+\_\+len, int \&status)}{proc_reboot_resp(void *&notification_id, const uint8_t *frame, size_t frame_len, int &status)}}]{\setlength{\rightskip}{0pt plus 5cm}int proc\+\_\+reboot\+\_\+resp (
\begin{DoxyParamCaption}
\item[{void $\ast$\&}]{notification\+\_\+id, }
\item[{const {\bf uint8\+\_\+t} $\ast$}]{frame, }
\item[{size\+\_\+t}]{frame\+\_\+len, }
\item[{int \&}]{status}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_a8b3de398748e8299daf7296964f73c22}{}\label{classavdecc__lib_1_1descriptor__base__imp_a8b3de398748e8299daf7296964f73c22}


\hyperlink{classavdecc__lib_1_1entity__descriptor__imp_a8b3de398748e8299daf7296964f73c22}{entity\+\_\+descriptor\+\_\+imp}에서 재구현되었습니다.



descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 337 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
338 \{
339     (void)notification\_id; \textcolor{comment}{//unused}
340     (void)\hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame};
341     (void)frame\_len;
342     (void)status;
343 
344     \hyperlink{namespaceavdecc__lib_acbe3e2a96ae6524943ca532c87a28529}{log\_imp\_ref}->\hyperlink{classavdecc__lib_1_1log_a68139a6297697e4ccebf36ccfd02e44a}{post\_log\_msg}(\hyperlink{namespaceavdecc__lib_a501055c431e6872ef46f252ad13f85cdaf2c4481208273451a6f5c7bb9770ec8a}{LOGGING\_LEVEL\_ERROR}, \textcolor{stringliteral}{"Need to
       override proc\_reboot\_resp.\(\backslash\)n"});
345 
346     \textcolor{keywordflow}{return} 0;
347 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_a8b3de398748e8299daf7296964f73c22_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=243pt]{classavdecc__lib_1_1descriptor__base__imp_a8b3de398748e8299daf7296964f73c22_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!proc\+\_\+set\+\_\+name\+\_\+resp@{proc\+\_\+set\+\_\+name\+\_\+resp}}
\index{proc\+\_\+set\+\_\+name\+\_\+resp@{proc\+\_\+set\+\_\+name\+\_\+resp}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{proc\+\_\+set\+\_\+name\+\_\+resp(void $\ast$\&notification\+\_\+id, const uint8\+\_\+t $\ast$frame, size\+\_\+t frame\+\_\+len, int \&status)}{proc_set_name_resp(void *&notification_id, const uint8_t *frame, size_t frame_len, int &status)}}]{\setlength{\rightskip}{0pt plus 5cm}int proc\+\_\+set\+\_\+name\+\_\+resp (
\begin{DoxyParamCaption}
\item[{void $\ast$\&}]{notification\+\_\+id, }
\item[{const {\bf uint8\+\_\+t} $\ast$}]{frame, }
\item[{size\+\_\+t}]{frame\+\_\+len, }
\item[{int \&}]{status}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_a182c43d9f31980bb74f05956b1323624}{}\label{classavdecc__lib_1_1descriptor__base__imp_a182c43d9f31980bb74f05956b1323624}


descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 426 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
427 \{
428     \textcolor{keyword}{struct }\hyperlink{structjdksavdecc__aem__command__set__name__response}{jdksavdecc\_aem\_command\_set\_name\_response} 
      aem\_cmd\_set\_name\_resp;
429     \textcolor{keywordflow}{return} \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2f52c3b9a7ad6f490bed0c96a9136bc3}{default\_proc\_set\_name\_resp}(aem\_cmd\_set\_name\_resp, notification\_id, 
      \hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, frame\_len, status);
430 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_a182c43d9f31980bb74f05956b1323624_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_a182c43d9f31980bb74f05956b1323624_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!proc\+\_\+start\+\_\+operation\+\_\+resp@{proc\+\_\+start\+\_\+operation\+\_\+resp}}
\index{proc\+\_\+start\+\_\+operation\+\_\+resp@{proc\+\_\+start\+\_\+operation\+\_\+resp}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{proc\+\_\+start\+\_\+operation\+\_\+resp(void $\ast$\&notification\+\_\+id, const uint8\+\_\+t $\ast$frame, size\+\_\+t frame\+\_\+len, int \&status, uint16\+\_\+t \&operation\+\_\+id, uint16\+\_\+t \&operation\+\_\+type)}{proc_start_operation_resp(void *&notification_id, const uint8_t *frame, size_t frame_len, int &status, uint16_t &operation_id, uint16_t &operation_type)}}]{\setlength{\rightskip}{0pt plus 5cm}int proc\+\_\+start\+\_\+operation\+\_\+resp (
\begin{DoxyParamCaption}
\item[{void $\ast$\&}]{notification\+\_\+id, }
\item[{const {\bf uint8\+\_\+t} $\ast$}]{frame, }
\item[{size\+\_\+t}]{frame\+\_\+len, }
\item[{int \&}]{status, }
\item[{uint16\+\_\+t \&}]{operation\+\_\+id, }
\item[{uint16\+\_\+t \&}]{operation\+\_\+type}
\end{DoxyParamCaption}
)}\hypertarget{classavdecc__lib_1_1memory__object__descriptor__imp_afac474ba080005fc6eeb6fb8ebae4d96}{}\label{classavdecc__lib_1_1memory__object__descriptor__imp_afac474ba080005fc6eeb6fb8ebae4d96}


memory\+\_\+object\+\_\+descriptor\+\_\+imp.\+cpp 파일의 99 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
105 \{
106     \textcolor{keyword}{struct }\hyperlink{structjdksavdecc__frame}{jdksavdecc\_frame} cmd\_frame;
107     \textcolor{keyword}{struct }\hyperlink{structjdksavdecc__aem__command__start__operation__response}{jdksavdecc\_aem\_command\_start\_operation\_response} 
      aem\_cmd\_start\_operation\_resp;
108 
109     memcpy(cmd\_frame.payload, \hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, frame\_len);
110     memset(&aem\_cmd\_start\_operation\_resp, 0, \textcolor{keyword}{sizeof}(aem\_cmd\_start\_operation\_resp));
111 
112     ssize\_t aem\_cmd\_start\_operation\_resp\_returned = 
      \hyperlink{group__command__start__operation__response_gad6d5107768b710fefada454e6ee9d98c}{jdksavdecc\_aem\_command\_start\_operation\_response\_read}(&
      aem\_cmd\_start\_operation\_resp,
113                                                                                                          
      \hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame},
114                                                                                                          
      \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE},
115                                                                                                          
      frame\_len);
116 
117     \textcolor{keywordflow}{if} (aem\_cmd\_start\_operation\_resp\_returned < 0)
118     \{
119         \hyperlink{namespaceavdecc__lib_acbe3e2a96ae6524943ca532c87a28529}{log\_imp\_ref}->\hyperlink{classavdecc__lib_1_1log_a68139a6297697e4ccebf36ccfd02e44a}{post\_log\_msg}(\hyperlink{namespaceavdecc__lib_a501055c431e6872ef46f252ad13f85cdaf2c4481208273451a6f5c7bb9770ec8a}{LOGGING\_LEVEL\_ERROR}, \textcolor{stringliteral}{"
      aem\_command\_start\_operation\_response\_read error"});
120         \textcolor{keywordflow}{return} -1;
121     \}
122 
123     \hyperlink{parse_8c_a6eb1e68cc391dd753bc8ce896dbb8315}{uint32\_t} msg\_type = aem\_cmd\_start\_operation\_resp.aem\_header.aecpdu\_header.header.message\_type;
124     status = aem\_cmd\_start\_operation\_resp.aem\_header.aecpdu\_header.header.status;
125     \textcolor{keywordtype}{bool} u\_field = aem\_cmd\_start\_operation\_resp.aem\_header.command\_type >> 15 & 0x01;
126     \hyperlink{structjdksavdecc__aem__command__start__operation__response_a5b1b19c38a3b340cfc6ebcb9eeb153e2}{operation\_id} = aem\_cmd\_start\_operation\_resp.operation\_id;
127     \hyperlink{structjdksavdecc__aem__command__start__operation__response_ab2dfcd06646c4907feb4ec8153ba7b79}{operation\_type} = aem\_cmd\_start\_operation\_resp.operation\_type;
128 
129     \hyperlink{namespaceavdecc__lib_a0b1b5aea3c0490f77cbfd9178af5be22}{aecp\_controller\_state\_machine\_ref}->
      \hyperlink{classavdecc__lib_1_1aecp__controller__state__machine_a997abd9786c330a5505e903e6443208e}{update\_inflight\_for\_rcvd\_resp}(notification\_id, msg\_type, u\_field, &cmd\_frame);
130 
131     \textcolor{keywordflow}{return} 0;
132 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1memory__object__descriptor__imp_afac474ba080005fc6eeb6fb8ebae4d96_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1memory__object__descriptor__imp_afac474ba080005fc6eeb6fb8ebae4d96_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!replace\+\_\+desc\+\_\+frame@{replace\+\_\+desc\+\_\+frame}}
\index{replace\+\_\+desc\+\_\+frame@{replace\+\_\+desc\+\_\+frame}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{replace\+\_\+desc\+\_\+frame(const uint8\+\_\+t $\ast$frame, ssize\+\_\+t pos, size\+\_\+t size)}{replace_desc_frame(const uint8_t *frame, ssize_t pos, size_t size)}}]{\setlength{\rightskip}{0pt plus 5cm}void S\+T\+D\+C\+A\+LL replace\+\_\+desc\+\_\+frame (
\begin{DoxyParamCaption}
\item[{const {\bf uint8\+\_\+t} $\ast$}]{frame, }
\item[{ssize\+\_\+t}]{pos, }
\item[{size\+\_\+t}]{size}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_a8dbf7d4faedf36ec789d33f228e22039}{}\label{classavdecc__lib_1_1descriptor__base__imp_a8dbf7d4faedf36ec789d33f228e22039}
Replace the frame for descriptors. 

descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 93 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
94 \{
95     std::lock\_guard<std::mutex> guard(\hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\_end\_station\_imp\_ref}->
      \hyperlink{classavdecc__lib_1_1end__station__imp_a2207f93fef130266b292686bf96ef8d3}{locker}); \textcolor{comment}{//mutex lock the end station}
96     \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2642e3a7c10d38553e7ff4a55e875346}{resp\_ref}->\hyperlink{classavdecc__lib_1_1response__frame_a438c7ec184b6d10ffcd8bc97a4cfa773}{replace\_desc\_frame}(\hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, pos, \hyperlink{gst__avb__playbin_8c_a439227feff9d7f55384e8780cfc2eb82}{size});
97 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_a8dbf7d4faedf36ec789d33f228e22039_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=550pt]{classavdecc__lib_1_1descriptor__base__imp_a8dbf7d4faedf36ec789d33f228e22039_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!replace\+\_\+frame@{replace\+\_\+frame}}
\index{replace\+\_\+frame@{replace\+\_\+frame}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{replace\+\_\+frame(const uint8\+\_\+t $\ast$frame, ssize\+\_\+t pos, size\+\_\+t size)}{replace_frame(const uint8_t *frame, ssize_t pos, size_t size)}}]{\setlength{\rightskip}{0pt plus 5cm}void S\+T\+D\+C\+A\+LL replace\+\_\+frame (
\begin{DoxyParamCaption}
\item[{const {\bf uint8\+\_\+t} $\ast$}]{frame, }
\item[{ssize\+\_\+t}]{pos, }
\item[{size\+\_\+t}]{size}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_a482fe95208e9e14885e28e73e7be2c49}{}\label{classavdecc__lib_1_1descriptor__base__imp_a482fe95208e9e14885e28e73e7be2c49}
Replace the frame for counters/commands. 

descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 87 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
88 \{
89     std::lock\_guard<std::mutex> guard(\hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\_end\_station\_imp\_ref}->
      \hyperlink{classavdecc__lib_1_1end__station__imp_a2207f93fef130266b292686bf96ef8d3}{locker}); \textcolor{comment}{//mutex lock the end station}
90     \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2642e3a7c10d38553e7ff4a55e875346}{resp\_ref}->\hyperlink{classavdecc__lib_1_1response__frame_adaac07821dba7c4ae2c35642d67a9a37}{replace\_frame}(\hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, pos, \hyperlink{gst__avb__playbin_8c_a439227feff9d7f55384e8780cfc2eb82}{size});
91 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_a482fe95208e9e14885e28e73e7be2c49_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_a482fe95208e9e14885e28e73e7be2c49_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!send\+\_\+acquire\+\_\+entity\+\_\+cmd@{send\+\_\+acquire\+\_\+entity\+\_\+cmd}}
\index{send\+\_\+acquire\+\_\+entity\+\_\+cmd@{send\+\_\+acquire\+\_\+entity\+\_\+cmd}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{send\+\_\+acquire\+\_\+entity\+\_\+cmd(void $\ast$notification\+\_\+id, uint32\+\_\+t acquire\+\_\+entity\+\_\+flag)=0}{send_acquire_entity_cmd(void *notification_id, uint32_t acquire_entity_flag)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI int S\+T\+D\+C\+A\+LL send\+\_\+acquire\+\_\+entity\+\_\+cmd (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{notification\+\_\+id, }
\item[{{\bf uint32\+\_\+t}}]{acquire\+\_\+entity\+\_\+flag}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base_adfd0cf2a51bff7d762b0efc743480c48}{}\label{classavdecc__lib_1_1descriptor__base_adfd0cf2a51bff7d762b0efc743480c48}
Send a A\+C\+Q\+U\+R\+E\+\_\+\+E\+N\+T\+I\+TY command to obtain exclusive access to an entire Entity or a sub-\/tree of objects.


\begin{DoxyParams}{매개변수}
{\em notification\+\_\+id} & A void pointer to the unique identifier associated with the command. \\
\hline
{\em acquire\+\_\+entity\+\_\+flag} & The flag to be set for the command. Valid flags are 0, 1 (P\+E\+R\+S\+I\+S\+T\+E\+NT), and 0x80000000 (R\+E\+L\+E\+A\+SE).\\
\hline
\end{DoxyParams}
The flags and owner id can be retrieved by calling the following function after successfully receiving a response back for the A\+C\+Q\+U\+R\+E\+\_\+\+E\+N\+T\+I\+TY command sent.

\begin{DoxySeeAlso}{참고}
\hyperlink{classavdecc__lib_1_1descriptor__base_a42f2a796375edd05c8d29856c018042d}{acquire\+\_\+entity\+\_\+flags()}, \hyperlink{classavdecc__lib_1_1descriptor__base_a6480d803970d505ce7a9b429a6eb71bd}{acquire\+\_\+entity\+\_\+owner\+\_\+entity\+\_\+id()} 
\end{DoxySeeAlso}


\hyperlink{classavdecc__lib_1_1descriptor__base__imp_aea9e3053b75477816c15487d3e9a6f70}{descriptor\+\_\+base\+\_\+imp}, \hyperlink{classavdecc__lib_1_1entity__descriptor__imp_aea9e3053b75477816c15487d3e9a6f70}{entity\+\_\+descriptor\+\_\+imp}에서 구현되었습니다.



이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base_adfd0cf2a51bff7d762b0efc743480c48_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!send\+\_\+acquire\+\_\+entity\+\_\+cmd@{send\+\_\+acquire\+\_\+entity\+\_\+cmd}}
\index{send\+\_\+acquire\+\_\+entity\+\_\+cmd@{send\+\_\+acquire\+\_\+entity\+\_\+cmd}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{send\+\_\+acquire\+\_\+entity\+\_\+cmd(void $\ast$notification\+\_\+id, uint32\+\_\+t acquire\+\_\+entity\+\_\+flag)}{send_acquire_entity_cmd(void *notification_id, uint32_t acquire_entity_flag)}}]{\setlength{\rightskip}{0pt plus 5cm}int S\+T\+D\+C\+A\+LL send\+\_\+acquire\+\_\+entity\+\_\+cmd (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{notification\+\_\+id, }
\item[{{\bf uint32\+\_\+t}}]{acquire\+\_\+entity\+\_\+flag}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_aea9e3053b75477816c15487d3e9a6f70}{}\label{classavdecc__lib_1_1descriptor__base__imp_aea9e3053b75477816c15487d3e9a6f70}
Send a A\+C\+Q\+U\+R\+E\+\_\+\+E\+N\+T\+I\+TY command to obtain exclusive access to an entire Entity or a sub-\/tree of objects.


\begin{DoxyParams}{매개변수}
{\em notification\+\_\+id} & A void pointer to the unique identifier associated with the command. \\
\hline
{\em acquire\+\_\+entity\+\_\+flag} & The flag to be set for the command. Valid flags are 0, 1 (P\+E\+R\+S\+I\+S\+T\+E\+NT), and 0x80000000 (R\+E\+L\+E\+A\+SE).\\
\hline
\end{DoxyParams}
The flags and owner id can be retrieved by calling the following function after successfully receiving a response back for the A\+C\+Q\+U\+R\+E\+\_\+\+E\+N\+T\+I\+TY command sent.

\begin{DoxySeeAlso}{참고}
\hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2d270d205bcea948cf61311a1f8336c6}{acquire\+\_\+entity\+\_\+flags()}, \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a507b250a984bb5611d2699cd26d60a51}{acquire\+\_\+entity\+\_\+owner\+\_\+entity\+\_\+id()} 
\end{DoxySeeAlso}


\hyperlink{classavdecc__lib_1_1descriptor__base_adfd0cf2a51bff7d762b0efc743480c48}{descriptor\+\_\+base}를 구현.



\hyperlink{classavdecc__lib_1_1entity__descriptor__imp_aea9e3053b75477816c15487d3e9a6f70}{entity\+\_\+descriptor\+\_\+imp}에서 재구현되었습니다.



descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 134 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
135 \{
136     (void)notification\_id; \textcolor{comment}{//unused}
137     (void)acquire\_entity\_flag;
138 
139     \hyperlink{namespaceavdecc__lib_acbe3e2a96ae6524943ca532c87a28529}{log\_imp\_ref}->\hyperlink{classavdecc__lib_1_1log_a68139a6297697e4ccebf36ccfd02e44a}{post\_log\_msg}(\hyperlink{namespaceavdecc__lib_a501055c431e6872ef46f252ad13f85cdaf2c4481208273451a6f5c7bb9770ec8a}{LOGGING\_LEVEL\_ERROR}, \textcolor{stringliteral}{"Need to
       override send\_acquire\_entity\_cmd.\(\backslash\)n"});
140     \textcolor{keywordflow}{return} 0;
141 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_aea9e3053b75477816c15487d3e9a6f70_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=279pt]{classavdecc__lib_1_1descriptor__base__imp_aea9e3053b75477816c15487d3e9a6f70_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!send\+\_\+get\+\_\+name\+\_\+cmd@{send\+\_\+get\+\_\+name\+\_\+cmd}}
\index{send\+\_\+get\+\_\+name\+\_\+cmd@{send\+\_\+get\+\_\+name\+\_\+cmd}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{send\+\_\+get\+\_\+name\+\_\+cmd(void $\ast$notification\+\_\+id, uint16\+\_\+t name\+\_\+index, uint16\+\_\+t config\+\_\+index)=0}{send_get_name_cmd(void *notification_id, uint16_t name_index, uint16_t config_index)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI int S\+T\+D\+C\+A\+LL send\+\_\+get\+\_\+name\+\_\+cmd (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{notification\+\_\+id, }
\item[{uint16\+\_\+t}]{name\+\_\+index, }
\item[{uint16\+\_\+t}]{config\+\_\+index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base_a27ba9959456de53a8de18eead74806f7}{}\label{classavdecc__lib_1_1descriptor__base_a27ba9959456de53a8de18eead74806f7}
Send a G\+E\+T\+\_\+\+N\+A\+ME command to get the value of a name field within a descriptor. For descriptors with multiple names, this sets only one specified name.


\begin{DoxyParams}{매개변수}
{\em notification\+\_\+id} & A void pointer to the unique identifier associated with the command. \\
\hline
{\em name\+\_\+index} & The index of the name within the descriptor, with the first name being index 0 and so on. \\
\hline
{\em config\+\_\+index} & The descriptor index of the configuration, which contains the descriptor whose name is being set. If the descriptor type field is either E\+N\+T\+I\+TY or C\+O\+N\+F\+I\+G\+U\+R\+A\+T\+I\+ON, then this field is set to 0. \\
\hline
\end{DoxyParams}


\hyperlink{classavdecc__lib_1_1descriptor__base__imp_a4e8ce103baabbd5fc07deabfb95f791a}{descriptor\+\_\+base\+\_\+imp}에서 구현되었습니다.



이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base_a27ba9959456de53a8de18eead74806f7_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!send\+\_\+get\+\_\+name\+\_\+cmd@{send\+\_\+get\+\_\+name\+\_\+cmd}}
\index{send\+\_\+get\+\_\+name\+\_\+cmd@{send\+\_\+get\+\_\+name\+\_\+cmd}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{send\+\_\+get\+\_\+name\+\_\+cmd(void $\ast$notification\+\_\+id, uint16\+\_\+t name\+\_\+index, uint16\+\_\+t config\+\_\+index)}{send_get_name_cmd(void *notification_id, uint16_t name_index, uint16_t config_index)}}]{\setlength{\rightskip}{0pt plus 5cm}int S\+T\+D\+C\+A\+LL send\+\_\+get\+\_\+name\+\_\+cmd (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{notification\+\_\+id, }
\item[{uint16\+\_\+t}]{name\+\_\+index, }
\item[{uint16\+\_\+t}]{config\+\_\+index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_a4e8ce103baabbd5fc07deabfb95f791a}{}\label{classavdecc__lib_1_1descriptor__base__imp_a4e8ce103baabbd5fc07deabfb95f791a}
Send a G\+E\+T\+\_\+\+N\+A\+ME command to get the value of a name field within a descriptor. For descriptors with multiple names, this sets only one specified name.


\begin{DoxyParams}{매개변수}
{\em notification\+\_\+id} & A void pointer to the unique identifier associated with the command. \\
\hline
{\em name\+\_\+index} & The index of the name within the descriptor, with the first name being index 0 and so on. \\
\hline
{\em config\+\_\+index} & The descriptor index of the configuration, which contains the descriptor whose name is being set. If the descriptor type field is either E\+N\+T\+I\+TY or C\+O\+N\+F\+I\+G\+U\+R\+A\+T\+I\+ON, then this field is set to 0. \\
\hline
\end{DoxyParams}


\hyperlink{classavdecc__lib_1_1descriptor__base_a27ba9959456de53a8de18eead74806f7}{descriptor\+\_\+base}를 구현.



descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 618 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
619 \{
620     \textcolor{keywordflow}{return} \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a92f2c88d261418872a496a8145800751}{default\_send\_get\_name\_cmd}(\textcolor{keyword}{this}, notification\_id, name\_index, 
      config\_index);
621 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_a4e8ce103baabbd5fc07deabfb95f791a_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=261pt]{classavdecc__lib_1_1descriptor__base__imp_a4e8ce103baabbd5fc07deabfb95f791a_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!send\+\_\+lock\+\_\+entity\+\_\+cmd@{send\+\_\+lock\+\_\+entity\+\_\+cmd}}
\index{send\+\_\+lock\+\_\+entity\+\_\+cmd@{send\+\_\+lock\+\_\+entity\+\_\+cmd}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{send\+\_\+lock\+\_\+entity\+\_\+cmd(void $\ast$notification\+\_\+id, uint32\+\_\+t lock\+\_\+entity\+\_\+flag)=0}{send_lock_entity_cmd(void *notification_id, uint32_t lock_entity_flag)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI int S\+T\+D\+C\+A\+LL send\+\_\+lock\+\_\+entity\+\_\+cmd (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{notification\+\_\+id, }
\item[{{\bf uint32\+\_\+t}}]{lock\+\_\+entity\+\_\+flag}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base_a1ac1f5c700f4eebd37b7c45498b36bbc}{}\label{classavdecc__lib_1_1descriptor__base_a1ac1f5c700f4eebd37b7c45498b36bbc}
Send a L\+O\+C\+K\+\_\+\+E\+N\+T\+I\+TY command to provide short term exclusive access to the A\+V\+D\+E\+CC Entity to perform atomic operations.


\begin{DoxyParams}{매개변수}
{\em notification\+\_\+id} & A void pointer to the unique identifier associated with the command. \\
\hline
{\em lock\+\_\+entity\+\_\+flag} & The flag to be set for the command. Valid flags are 0 and 1 (U\+N\+L\+O\+CK).\\
\hline
\end{DoxyParams}
The flags and locked entity id can be retrieved by calling the following function after successfully receiving a response back for the L\+O\+C\+K\+\_\+\+E\+N\+T\+I\+TY command sent.

\begin{DoxySeeAlso}{참고}
\hyperlink{classavdecc__lib_1_1descriptor__base_a757e66272bba4c52cefa914df8c60bb5}{lock\+\_\+entity\+\_\+flags()}, \hyperlink{classavdecc__lib_1_1descriptor__base_a052b47529d0e60ca87894159fcb65e14}{lock\+\_\+entity\+\_\+locked\+\_\+entity\+\_\+id()} 
\end{DoxySeeAlso}


\hyperlink{classavdecc__lib_1_1descriptor__base__imp_a26fd66d8c409502eaa4dba47742ca7fa}{descriptor\+\_\+base\+\_\+imp}, \hyperlink{classavdecc__lib_1_1entity__descriptor__imp_a26fd66d8c409502eaa4dba47742ca7fa}{entity\+\_\+descriptor\+\_\+imp}에서 구현되었습니다.



이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base_a1ac1f5c700f4eebd37b7c45498b36bbc_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!send\+\_\+lock\+\_\+entity\+\_\+cmd@{send\+\_\+lock\+\_\+entity\+\_\+cmd}}
\index{send\+\_\+lock\+\_\+entity\+\_\+cmd@{send\+\_\+lock\+\_\+entity\+\_\+cmd}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{send\+\_\+lock\+\_\+entity\+\_\+cmd(void $\ast$notification\+\_\+id, uint32\+\_\+t lock\+\_\+entity\+\_\+flag)}{send_lock_entity_cmd(void *notification_id, uint32_t lock_entity_flag)}}]{\setlength{\rightskip}{0pt plus 5cm}int S\+T\+D\+C\+A\+LL send\+\_\+lock\+\_\+entity\+\_\+cmd (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{notification\+\_\+id, }
\item[{{\bf uint32\+\_\+t}}]{lock\+\_\+entity\+\_\+flag}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_a26fd66d8c409502eaa4dba47742ca7fa}{}\label{classavdecc__lib_1_1descriptor__base__imp_a26fd66d8c409502eaa4dba47742ca7fa}
Send a L\+O\+C\+K\+\_\+\+E\+N\+T\+I\+TY command to provide short term exclusive access to the A\+V\+D\+E\+CC Entity to perform atomic operations.


\begin{DoxyParams}{매개변수}
{\em notification\+\_\+id} & A void pointer to the unique identifier associated with the command. \\
\hline
{\em lock\+\_\+entity\+\_\+flag} & The flag to be set for the command. Valid flags are 0 and 1 (U\+N\+L\+O\+CK).\\
\hline
\end{DoxyParams}
The flags and locked entity id can be retrieved by calling the following function after successfully receiving a response back for the L\+O\+C\+K\+\_\+\+E\+N\+T\+I\+TY command sent.

\begin{DoxySeeAlso}{참고}
\hyperlink{classavdecc__lib_1_1descriptor__base__imp_afe2564a2a32f83deced28efa17f332e2}{lock\+\_\+entity\+\_\+flags()}, \hyperlink{classavdecc__lib_1_1descriptor__base__imp_aeb8f096d55f82522516cbf00a616246a}{lock\+\_\+entity\+\_\+locked\+\_\+entity\+\_\+id()} 
\end{DoxySeeAlso}


\hyperlink{classavdecc__lib_1_1descriptor__base_a1ac1f5c700f4eebd37b7c45498b36bbc}{descriptor\+\_\+base}를 구현.



\hyperlink{classavdecc__lib_1_1entity__descriptor__imp_a26fd66d8c409502eaa4dba47742ca7fa}{entity\+\_\+descriptor\+\_\+imp}에서 재구현되었습니다.



descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 230 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
231 \{
232     (void)notification\_id; \textcolor{comment}{//unused}
233     (void)lock\_entity\_flag;
234 
235     \hyperlink{namespaceavdecc__lib_acbe3e2a96ae6524943ca532c87a28529}{log\_imp\_ref}->\hyperlink{classavdecc__lib_1_1log_a68139a6297697e4ccebf36ccfd02e44a}{post\_log\_msg}(\hyperlink{namespaceavdecc__lib_a501055c431e6872ef46f252ad13f85cdaf2c4481208273451a6f5c7bb9770ec8a}{LOGGING\_LEVEL\_ERROR}, \textcolor{stringliteral}{"Need to
       override send\_lock\_entity\_cmd.\(\backslash\)n"});
236 
237     \textcolor{keywordflow}{return} 0;
238 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_a26fd66d8c409502eaa4dba47742ca7fa_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=265pt]{classavdecc__lib_1_1descriptor__base__imp_a26fd66d8c409502eaa4dba47742ca7fa_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!send\+\_\+reboot\+\_\+cmd@{send\+\_\+reboot\+\_\+cmd}}
\index{send\+\_\+reboot\+\_\+cmd@{send\+\_\+reboot\+\_\+cmd}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{send\+\_\+reboot\+\_\+cmd(void $\ast$notification\+\_\+id)=0}{send_reboot_cmd(void *notification_id)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI int S\+T\+D\+C\+A\+LL send\+\_\+reboot\+\_\+cmd (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{notification\+\_\+id}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base_a1618412a9b3d57a12044030b31cfd5a3}{}\label{classavdecc__lib_1_1descriptor__base_a1618412a9b3d57a12044030b31cfd5a3}
Send a R\+E\+B\+O\+OT command to the A\+V\+D\+E\+CC Entity


\begin{DoxyParams}{매개변수}
{\em notification\+\_\+id} & A void pointer to the unique identifier associated with the command. \\
\hline
{\em lock\+\_\+entity\+\_\+flag} & The flag to be set for the command. Valid flags are 0 and 1 (U\+N\+L\+O\+CK). \\
\hline
\end{DoxyParams}


\hyperlink{classavdecc__lib_1_1descriptor__base__imp_a7579db44e8e86da0f8f94aa4680df795}{descriptor\+\_\+base\+\_\+imp}, \hyperlink{classavdecc__lib_1_1entity__descriptor__imp_a7579db44e8e86da0f8f94aa4680df795}{entity\+\_\+descriptor\+\_\+imp}에서 구현되었습니다.



이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base_a1618412a9b3d57a12044030b31cfd5a3_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!send\+\_\+reboot\+\_\+cmd@{send\+\_\+reboot\+\_\+cmd}}
\index{send\+\_\+reboot\+\_\+cmd@{send\+\_\+reboot\+\_\+cmd}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{send\+\_\+reboot\+\_\+cmd(void $\ast$notification\+\_\+id)}{send_reboot_cmd(void *notification_id)}}]{\setlength{\rightskip}{0pt plus 5cm}int S\+T\+D\+C\+A\+LL send\+\_\+reboot\+\_\+cmd (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{notification\+\_\+id}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_a7579db44e8e86da0f8f94aa4680df795}{}\label{classavdecc__lib_1_1descriptor__base__imp_a7579db44e8e86da0f8f94aa4680df795}
Send a R\+E\+B\+O\+OT command to the A\+V\+D\+E\+CC Entity


\begin{DoxyParams}{매개변수}
{\em notification\+\_\+id} & A void pointer to the unique identifier associated with the command. \\
\hline
{\em lock\+\_\+entity\+\_\+flag} & The flag to be set for the command. Valid flags are 0 and 1 (U\+N\+L\+O\+CK). \\
\hline
\end{DoxyParams}


\hyperlink{classavdecc__lib_1_1descriptor__base_a1618412a9b3d57a12044030b31cfd5a3}{descriptor\+\_\+base}를 구현.



\hyperlink{classavdecc__lib_1_1entity__descriptor__imp_a7579db44e8e86da0f8f94aa4680df795}{entity\+\_\+descriptor\+\_\+imp}에서 재구현되었습니다.



descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 328 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
329 \{
330     (void)notification\_id; \textcolor{comment}{//unused}
331 
332     \hyperlink{namespaceavdecc__lib_acbe3e2a96ae6524943ca532c87a28529}{log\_imp\_ref}->\hyperlink{classavdecc__lib_1_1log_a68139a6297697e4ccebf36ccfd02e44a}{post\_log\_msg}(\hyperlink{namespaceavdecc__lib_a501055c431e6872ef46f252ad13f85cdaf2c4481208273451a6f5c7bb9770ec8a}{LOGGING\_LEVEL\_ERROR}, \textcolor{stringliteral}{"Need to
       override send\_reboot\_cmd.\(\backslash\)n"});
333 
334     \textcolor{keywordflow}{return} 0;
335 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_a7579db44e8e86da0f8f94aa4680df795_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=245pt]{classavdecc__lib_1_1descriptor__base__imp_a7579db44e8e86da0f8f94aa4680df795_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!send\+\_\+set\+\_\+name\+\_\+cmd@{send\+\_\+set\+\_\+name\+\_\+cmd}}
\index{send\+\_\+set\+\_\+name\+\_\+cmd@{send\+\_\+set\+\_\+name\+\_\+cmd}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{send\+\_\+set\+\_\+name\+\_\+cmd(void $\ast$notification\+\_\+id, uint16\+\_\+t name\+\_\+index, uint16\+\_\+t config\+\_\+index, const struct avdecc\+\_\+lib\+\_\+name\+\_\+string64 $\ast$new\+\_\+name)=0}{send_set_name_cmd(void *notification_id, uint16_t name_index, uint16_t config_index, const struct avdecc_lib_name_string64 *new_name)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI int S\+T\+D\+C\+A\+LL send\+\_\+set\+\_\+name\+\_\+cmd (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{notification\+\_\+id, }
\item[{uint16\+\_\+t}]{name\+\_\+index, }
\item[{uint16\+\_\+t}]{config\+\_\+index, }
\item[{const struct {\bf avdecc\+\_\+lib\+\_\+name\+\_\+string64} $\ast$}]{new\+\_\+name}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base_a6a8c227d7a202f251c689107df7ede0b}{}\label{classavdecc__lib_1_1descriptor__base_a6a8c227d7a202f251c689107df7ede0b}
Send a S\+E\+T\+\_\+\+N\+A\+ME command to change the value of a name field within a descriptor. For descriptors with multiple names, this sets only one specified name per command.


\begin{DoxyParams}{매개변수}
{\em notification\+\_\+id} & A void pointer to the unique identifier associated with the command. \\
\hline
{\em name\+\_\+index} & The index of the name within the descriptor, with the first name being index 0 and so on. \\
\hline
{\em config\+\_\+index} & The descriptor index of the configuration, which contains the descriptor whose name is being set. If the descriptor type field is either E\+N\+T\+I\+TY or C\+O\+N\+F\+I\+G\+U\+R\+A\+T\+I\+ON, then this field is set to 0. \\
\hline
{\em new\+\_\+name} & The new name to be set. The name does not contain a trailing N\+U\+LL, but if the name is less than 64 bytes in length, then it is zero padded. \\
\hline
\end{DoxyParams}


\hyperlink{classavdecc__lib_1_1descriptor__base__imp_af0bb05af3bf67f2ab0eb522096011592}{descriptor\+\_\+base\+\_\+imp}에서 구현되었습니다.



이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base_a6a8c227d7a202f251c689107df7ede0b_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!send\+\_\+set\+\_\+name\+\_\+cmd@{send\+\_\+set\+\_\+name\+\_\+cmd}}
\index{send\+\_\+set\+\_\+name\+\_\+cmd@{send\+\_\+set\+\_\+name\+\_\+cmd}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{send\+\_\+set\+\_\+name\+\_\+cmd(void $\ast$notification\+\_\+id, uint16\+\_\+t name\+\_\+index, uint16\+\_\+t config\+\_\+index, const struct avdecc\+\_\+lib\+\_\+name\+\_\+string64 $\ast$new\+\_\+name)}{send_set_name_cmd(void *notification_id, uint16_t name_index, uint16_t config_index, const struct avdecc_lib_name_string64 *new_name)}}]{\setlength{\rightskip}{0pt plus 5cm}int S\+T\+D\+C\+A\+LL send\+\_\+set\+\_\+name\+\_\+cmd (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{notification\+\_\+id, }
\item[{uint16\+\_\+t}]{name\+\_\+index, }
\item[{uint16\+\_\+t}]{config\+\_\+index, }
\item[{const struct {\bf avdecc\+\_\+lib\+\_\+name\+\_\+string64} $\ast$}]{new\+\_\+name}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_af0bb05af3bf67f2ab0eb522096011592}{}\label{classavdecc__lib_1_1descriptor__base__imp_af0bb05af3bf67f2ab0eb522096011592}
Send a S\+E\+T\+\_\+\+N\+A\+ME command to change the value of a name field within a descriptor. For descriptors with multiple names, this sets only one specified name per command.


\begin{DoxyParams}{매개변수}
{\em notification\+\_\+id} & A void pointer to the unique identifier associated with the command. \\
\hline
{\em name\+\_\+index} & The index of the name within the descriptor, with the first name being index 0 and so on. \\
\hline
{\em config\+\_\+index} & The descriptor index of the configuration, which contains the descriptor whose name is being set. If the descriptor type field is either E\+N\+T\+I\+TY or C\+O\+N\+F\+I\+G\+U\+R\+A\+T\+I\+ON, then this field is set to 0. \\
\hline
{\em new\+\_\+name} & The new name to be set. The name does not contain a trailing N\+U\+LL, but if the name is less than 64 bytes in length, then it is zero padded. \\
\hline
\end{DoxyParams}


\hyperlink{classavdecc__lib_1_1descriptor__base_a6a8c227d7a202f251c689107df7ede0b}{descriptor\+\_\+base}를 구현.



descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 421 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
422 \{
423     \textcolor{keywordflow}{return} \hyperlink{classavdecc__lib_1_1descriptor__base__imp_aed899a0eaaaa06a02569135f844ffce8}{default\_send\_set\_name\_cmd}(\textcolor{keyword}{this}, notification\_id, name\_index, 
      config\_index, name);
424 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_af0bb05af3bf67f2ab0eb522096011592_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=261pt]{classavdecc__lib_1_1descriptor__base__imp_af0bb05af3bf67f2ab0eb522096011592_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!start\+\_\+operation\+\_\+cmd@{start\+\_\+operation\+\_\+cmd}}
\index{start\+\_\+operation\+\_\+cmd@{start\+\_\+operation\+\_\+cmd}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{start\+\_\+operation\+\_\+cmd(void $\ast$notification\+\_\+id, uint16\+\_\+t operation\+\_\+type)}{start_operation_cmd(void *notification_id, uint16_t operation_type)}}]{\setlength{\rightskip}{0pt plus 5cm}int S\+T\+D\+C\+A\+LL start\+\_\+operation\+\_\+cmd (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{notification\+\_\+id, }
\item[{uint16\+\_\+t}]{operation\+\_\+type}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classavdecc__lib_1_1memory__object__descriptor__imp_aa2bf4467e8b82b1d4576d50fd4ad1923}{}\label{classavdecc__lib_1_1memory__object__descriptor__imp_aa2bf4467e8b82b1d4576d50fd4ad1923}
Send a S\+T\+A\+R\+T\+\_\+\+O\+P\+E\+R\+A\+T\+I\+ON command with a notification id to begin an operation on the memory object


\begin{DoxyParams}{매개변수}
{\em notification\+\_\+id} & A void pointer to the unique identifier associated with the command. \\
\hline
{\em operation\+\_\+tyoe} & An integer representation the operation type to perform on the object \\
\hline
\end{DoxyParams}


\hyperlink{classavdecc__lib_1_1memory__object__descriptor_a0abecb47f59507cddf854b3b62602f22}{memory\+\_\+object\+\_\+descriptor}를 구현.



memory\+\_\+object\+\_\+descriptor\+\_\+imp.\+cpp 파일의 56 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
57 \{
58     \textcolor{keyword}{struct }\hyperlink{structjdksavdecc__frame}{jdksavdecc\_frame} cmd\_frame;
59     \textcolor{keyword}{struct }\hyperlink{structjdksavdecc__aem__command__start__operation}{jdksavdecc\_aem\_command\_start\_operation} 
      aem\_cmd\_start\_operation;
60     memset(&aem\_cmd\_start\_operation, 0, \textcolor{keyword}{sizeof}(aem\_cmd\_start\_operation));
61 
62     \textcolor{keywordflow}{if} (\hyperlink{structjdksavdecc__aem__command__start__operation_ab2dfcd06646c4907feb4ec8153ba7b79}{operation\_type} > \hyperlink{group__memory__object__operation_ga12771131c3cd62bc914e847886a74f00}{JDKSAVDECC\_MEMORY\_OBJECT\_OPERATION\_UPLOAD}
      )
63     \{
64         \hyperlink{namespaceavdecc__lib_acbe3e2a96ae6524943ca532c87a28529}{log\_imp\_ref}->\hyperlink{classavdecc__lib_1_1log_a68139a6297697e4ccebf36ccfd02e44a}{post\_log\_msg}(\hyperlink{namespaceavdecc__lib_a501055c431e6872ef46f252ad13f85cdaf2c4481208273451a6f5c7bb9770ec8a}{LOGGING\_LEVEL\_ERROR}, \textcolor{stringliteral}{" Invalid
       operation type %x on memory object\(\backslash\)n"}, \hyperlink{structjdksavdecc__aem__command__start__operation_ab2dfcd06646c4907feb4ec8153ba7b79}{operation\_type});
65         \textcolor{keywordflow}{return} -1;
66     \}
67 
68     aem\_cmd\_start\_operation.aem\_header.aecpdu\_header.controller\_entity\_id = 
      \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\_end\_station\_imp\_ref}->\hyperlink{classavdecc__lib_1_1end__station__imp_a471a74540ce6182fad0c17dfd010107e}{get\_adp}()->
      \hyperlink{classavdecc__lib_1_1adp_a0c0959a46658c0a22e9530334b2912da}{get\_controller\_entity\_id}();
69     aem\_cmd\_start\_operation.aem\_header.command\_type = 
      \hyperlink{group__command_ga6d1838e518b989e48a5cc727401fb4db}{JDKSAVDECC\_AEM\_COMMAND\_START\_OPERATION};
70 
71     aem\_cmd\_start\_operation.descriptor\_type = \hyperlink{classavdecc__lib_1_1descriptor__base__imp_aefc543029ab093823c3f5b9d84f0ccc4}{descriptor\_type}();
72     aem\_cmd\_start\_operation.descriptor\_index = \hyperlink{classavdecc__lib_1_1descriptor__base__imp_ac23c0a35276c07cfce8c8660700c2135}{descriptor\_index}();
73     aem\_cmd\_start\_operation.operation\_id = 0;
74     aem\_cmd\_start\_operation.operation\_type = \hyperlink{structjdksavdecc__aem__command__start__operation_ab2dfcd06646c4907feb4ec8153ba7b79}{operation\_type};
75 
76     \hyperlink{namespaceavdecc__lib_a0b1b5aea3c0490f77cbfd9178af5be22}{aecp\_controller\_state\_machine\_ref}->
      \hyperlink{classavdecc__lib_1_1aecp__controller__state__machine_a86ff947c5e6b799cfb877d3767bfa1f9}{ether\_frame\_init}(\hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\_end\_station\_imp\_ref}->
      \hyperlink{classavdecc__lib_1_1end__station__imp_a08e1bd1861b3b8f447ea374a65ac11f9}{mac}(), &cmd\_frame,
77                                                         \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE} + 
      \hyperlink{group__command__start__operation_gadc16cfcdc418cdc8d97b9593e4d3cea1}{JDKSAVDECC\_AEM\_COMMAND\_START\_OPERATION\_COMMAND\_LEN});
78     ssize\_t aem\_cmd\_start\_operation\_returned = 
      \hyperlink{group__command__start__operation_gaf0cf1d038dab08ae22452d1516ad876e}{jdksavdecc\_aem\_command\_start\_operation\_write}(&
      aem\_cmd\_start\_operation,
79                                                                                             cmd\_frame.
      payload,
80                                                                                             
      \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE},
81                                                                                             \textcolor{keyword}{sizeof}(
      cmd\_frame.payload));
82 
83     \textcolor{keywordflow}{if} (aem\_cmd\_start\_operation\_returned < 0)
84     \{
85         \hyperlink{namespaceavdecc__lib_acbe3e2a96ae6524943ca532c87a28529}{log\_imp\_ref}->\hyperlink{classavdecc__lib_1_1log_a68139a6297697e4ccebf36ccfd02e44a}{post\_log\_msg}(\hyperlink{namespaceavdecc__lib_a501055c431e6872ef46f252ad13f85cdaf2c4481208273451a6f5c7bb9770ec8a}{LOGGING\_LEVEL\_ERROR}, \textcolor{stringliteral}{"
      aem\_command\_start\_operation\_write error\(\backslash\)n"});
86         \textcolor{keywordflow}{return} -1;
87     \}
88 
89     \hyperlink{namespaceavdecc__lib_a0b1b5aea3c0490f77cbfd9178af5be22}{aecp\_controller\_state\_machine\_ref}->
      \hyperlink{classavdecc__lib_1_1aecp__controller__state__machine_aafc737d7ed17a62fed9df6528f18d3ec}{common\_hdr\_init}(\hyperlink{group__aecp__message__type_ga4625ce189cc209f42deb0629f48faf69}{JDKSAVDECC\_AECP\_MESSAGE\_TYPE\_AEM\_COMMAND}
      ,
90                                                        &cmd\_frame,
91                                                        \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\_end\_station\_imp\_ref}->
      \hyperlink{classavdecc__lib_1_1end__station__imp_a363b6c9664a0d701def9b17863e20ad3}{entity\_id}(),
92                                                        
      \hyperlink{group__command__start__operation_gadc16cfcdc418cdc8d97b9593e4d3cea1}{JDKSAVDECC\_AEM\_COMMAND\_START\_OPERATION\_COMMAND\_LEN} -
93                                                            
      \hyperlink{group__jdksavdecc__avtp__common__control__header_gaae84052886fb1bb42f3bc5f85b741dff}{JDKSAVDECC\_COMMON\_CONTROL\_HEADER\_LEN});
94     \hyperlink{namespaceavdecc__lib_a6dd511685627c0865a3442b539a4e8e9}{system\_queue\_tx}(notification\_id, \hyperlink{namespaceavdecc__lib_aabcadff06aa62be0ce47bc0646823604aba48b8a017e06fb240b650cdea965178}{CMD\_WITH\_NOTIFICATION}, cmd\_frame.
      payload, cmd\_frame.length);
95 
96     \textcolor{keywordflow}{return} 0;
97 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1memory__object__descriptor__imp_aa2bf4467e8b82b1d4576d50fd4ad1923_cgraph}
\end{center}
\end{figure}




\subsection{필드 문서화}
\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!base\+\_\+end\+\_\+station\+\_\+imp\+\_\+ref@{base\+\_\+end\+\_\+station\+\_\+imp\+\_\+ref}}
\index{base\+\_\+end\+\_\+station\+\_\+imp\+\_\+ref@{base\+\_\+end\+\_\+station\+\_\+imp\+\_\+ref}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{base\+\_\+end\+\_\+station\+\_\+imp\+\_\+ref}{base_end_station_imp_ref}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf end\+\_\+station\+\_\+imp}$\ast$ base\+\_\+end\+\_\+station\+\_\+imp\+\_\+ref\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{}\label{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}


descriptor\+\_\+base\+\_\+imp.\+h 파일의 54 번째 라인에서 정의되었습니다.

\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!desc\+\_\+index@{desc\+\_\+index}}
\index{desc\+\_\+index@{desc\+\_\+index}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{desc\+\_\+index}{desc_index}}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t desc\+\_\+index\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_a2bbd0d8f32f687ca36aaa543c06f764c}{}\label{classavdecc__lib_1_1descriptor__base__imp_a2bbd0d8f32f687ca36aaa543c06f764c}


descriptor\+\_\+base\+\_\+imp.\+h 파일의 58 번째 라인에서 정의되었습니다.

\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!desc\+\_\+type@{desc\+\_\+type}}
\index{desc\+\_\+type@{desc\+\_\+type}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{desc\+\_\+type}{desc_type}}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t desc\+\_\+type\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_a9dada313309522d04f1e52fe887442b4}{}\label{classavdecc__lib_1_1descriptor__base__imp_a9dada313309522d04f1e52fe887442b4}


descriptor\+\_\+base\+\_\+imp.\+h 파일의 57 번째 라인에서 정의되었습니다.

\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!get\+\_\+name\+\_\+resp@{get\+\_\+name\+\_\+resp}}
\index{get\+\_\+name\+\_\+resp@{get\+\_\+name\+\_\+resp}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{get\+\_\+name\+\_\+resp}{get_name_resp}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf descriptor\+\_\+base\+\_\+get\+\_\+name\+\_\+response\+\_\+imp}$\ast$ get\+\_\+name\+\_\+resp\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_a7d3a410eb242dc2b7abe9862a1593458}{}\label{classavdecc__lib_1_1descriptor__base__imp_a7d3a410eb242dc2b7abe9862a1593458}


descriptor\+\_\+base\+\_\+imp.\+h 파일의 53 번째 라인에서 정의되었습니다.

\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!m\+\_\+fields@{m\+\_\+fields}}
\index{m\+\_\+fields@{m\+\_\+fields}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{m\+\_\+fields}{m_fields}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::vector$<${\bf descriptor\+\_\+field\+\_\+imp} $\ast$$>$ m\+\_\+fields\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_adce67136eb9c66da9c189b730077b9cd}{}\label{classavdecc__lib_1_1descriptor__base__imp_adce67136eb9c66da9c189b730077b9cd}


descriptor\+\_\+base\+\_\+imp.\+h 파일의 55 번째 라인에서 정의되었습니다.

\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!resp@{resp}}
\index{resp@{resp}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{resp}{resp}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf memory\+\_\+object\+\_\+descriptor\+\_\+response\+\_\+imp}$\ast$ resp}\hypertarget{classavdecc__lib_1_1memory__object__descriptor__imp_ad06f22b0ac48bb4645e644db866d01cf}{}\label{classavdecc__lib_1_1memory__object__descriptor__imp_ad06f22b0ac48bb4645e644db866d01cf}


memory\+\_\+object\+\_\+descriptor\+\_\+imp.\+h 파일의 44 번째 라인에서 정의되었습니다.

\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!resp\+\_\+base@{resp\+\_\+base}}
\index{resp\+\_\+base@{resp\+\_\+base}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{resp\+\_\+base}{resp_base}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf descriptor\+\_\+response\+\_\+base\+\_\+imp}$\ast$ resp\+\_\+base\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_a8b104da8319cda946944548ebb9552f4}{}\label{classavdecc__lib_1_1descriptor__base__imp_a8b104da8319cda946944548ebb9552f4}


descriptor\+\_\+base\+\_\+imp.\+h 파일의 52 번째 라인에서 정의되었습니다.

\index{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}!resp\+\_\+ref@{resp\+\_\+ref}}
\index{resp\+\_\+ref@{resp\+\_\+ref}!avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::memory\+\_\+object\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{resp\+\_\+ref}{resp_ref}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf response\+\_\+frame}$\ast$ resp\+\_\+ref\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_a2642e3a7c10d38553e7ff4a55e875346}{}\label{classavdecc__lib_1_1descriptor__base__imp_a2642e3a7c10d38553e7ff4a55e875346}


descriptor\+\_\+base\+\_\+imp.\+h 파일의 56 번째 라인에서 정의되었습니다.



이 클래스에 대한 문서화 페이지는 다음의 파일들로부터 생성되었습니다.\+:\begin{DoxyCompactItemize}
\item 
avdecc-\/lib/controller/lib/src/\hyperlink{memory__object__descriptor__imp_8h}{memory\+\_\+object\+\_\+descriptor\+\_\+imp.\+h}\item 
avdecc-\/lib/controller/lib/src/\hyperlink{memory__object__descriptor__imp_8cpp}{memory\+\_\+object\+\_\+descriptor\+\_\+imp.\+cpp}\end{DoxyCompactItemize}
