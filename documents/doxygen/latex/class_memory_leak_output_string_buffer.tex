\hypertarget{class_memory_leak_output_string_buffer}{}\section{Memory\+Leak\+Output\+String\+Buffer 클래스 참조}
\label{class_memory_leak_output_string_buffer}\index{Memory\+Leak\+Output\+String\+Buffer@{Memory\+Leak\+Output\+String\+Buffer}}


{\ttfamily \#include $<$Memory\+Leak\+Detector.\+h$>$}



Memory\+Leak\+Output\+String\+Buffer에 대한 협력 다이어그램\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=550pt]{class_memory_leak_output_string_buffer__coll__graph}
\end{center}
\end{figure}
\subsection*{Public 멤버 함수}
\begin{DoxyCompactItemize}
\item 
\hyperlink{class_memory_leak_output_string_buffer_a0179a0f1ab6daada47cc5396b807e94a}{Memory\+Leak\+Output\+String\+Buffer} ()
\item 
void \hyperlink{class_memory_leak_output_string_buffer_ac8bb3912a3ce86b15842e79d0b421204}{clear} ()
\item 
void \hyperlink{class_memory_leak_output_string_buffer_a99cb7722b04d6e0539701d105c08af23}{start\+Memory\+Leak\+Reporting} ()
\item 
void \hyperlink{class_memory_leak_output_string_buffer_a25142db8cabaf786bf4e41baa0bcc417}{stop\+Memory\+Leak\+Reporting} ()
\item 
void \hyperlink{class_memory_leak_output_string_buffer_a93f881f339b50ea69b8cd7b543e15377}{report\+Memory\+Leak} (\hyperlink{struct_memory_leak_detector_node}{Memory\+Leak\+Detector\+Node} $\ast$leak)
\item 
void \hyperlink{class_memory_leak_output_string_buffer_a0061b779a33beb2d8c87eb915b20309a}{report\+Deallocate\+Non\+Allocated\+Memory\+Failure} (const char $\ast$free\+File, int free\+Line, \hyperlink{class_test_memory_allocator}{Test\+Memory\+Allocator} $\ast$free\+Allocator, \hyperlink{class_memory_leak_failure}{Memory\+Leak\+Failure} $\ast$reporter)
\item 
void \hyperlink{class_memory_leak_output_string_buffer_a14efcbb890531b638e1ff5e6a21e485a}{report\+Memory\+Corruption\+Failure} (\hyperlink{struct_memory_leak_detector_node}{Memory\+Leak\+Detector\+Node} $\ast$node, const char $\ast$free\+File, int free\+Line\+Number, \hyperlink{class_test_memory_allocator}{Test\+Memory\+Allocator} $\ast$free\+Allocator, \hyperlink{class_memory_leak_failure}{Memory\+Leak\+Failure} $\ast$reporter)
\item 
void \hyperlink{class_memory_leak_output_string_buffer_a94baa48406f230991c764abd1cf3a904}{report\+Allocation\+Deallocation\+Mismatch\+Failure} (\hyperlink{struct_memory_leak_detector_node}{Memory\+Leak\+Detector\+Node} $\ast$node, const char $\ast$free\+File, int free\+Line\+Number, \hyperlink{class_test_memory_allocator}{Test\+Memory\+Allocator} $\ast$free\+Allocator, \hyperlink{class_memory_leak_failure}{Memory\+Leak\+Failure} $\ast$reporter)
\item 
char $\ast$ \hyperlink{class_memory_leak_output_string_buffer_ac4969471df03a7a438bd99bfe61a0d5e}{to\+String} ()
\end{DoxyCompactItemize}
\subsection*{Private 멤버 함수}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{class_memory_leak_output_string_buffer_a5f6e2b7ab5d4600d3a3c829c1ec6faa7}{add\+Allocation\+Location} (const char $\ast$allocation\+File, int allocation\+Line\+Number, size\+\_\+t allocation\+Size, \hyperlink{class_test_memory_allocator}{Test\+Memory\+Allocator} $\ast$\hyperlink{_memory_leak_warning_test_8cpp_a83fc2e9b9142613f7df2bcc3ff8292bc}{allocator})
\item 
void \hyperlink{class_memory_leak_output_string_buffer_acae4e17ec89e44eb6767751248d5cdb3}{add\+Deallocation\+Location} (const char $\ast$free\+File, int free\+Line\+Number, \hyperlink{class_test_memory_allocator}{Test\+Memory\+Allocator} $\ast$\hyperlink{_memory_leak_warning_test_8cpp_a83fc2e9b9142613f7df2bcc3ff8292bc}{allocator})
\item 
void \hyperlink{class_memory_leak_output_string_buffer_af2e1dc56c3bf80241f576a81ff02dd60}{add\+Memory\+Leak\+Header} ()
\item 
void \hyperlink{class_memory_leak_output_string_buffer_a8ae585bb2ebf4a57a7414d855eb877fe}{add\+Memory\+Leak\+Footer} (int total\+Amount\+Of\+Leaks)
\item 
void \hyperlink{class_memory_leak_output_string_buffer_a57d7e9800c9f156619ea03a7cca303d8}{add\+Warning\+For\+Using\+Malloc} ()
\item 
void \hyperlink{class_memory_leak_output_string_buffer_a4fb8c9f82dfd44fc7ec4c313b847b902}{add\+No\+Memory\+Leaks\+Message} ()
\item 
void \hyperlink{class_memory_leak_output_string_buffer_a0259a6c52dc5b5530e4cab9383bea68c}{add\+Error\+Message\+For\+Too\+Much\+Leaks} ()
\item 
void \hyperlink{class_memory_leak_output_string_buffer_ae3d2ba0fc07468c3ac05c87be80caf55}{report\+Failure} (const char $\ast$message, const char $\ast$alloc\+File, int alloc\+Line, size\+\_\+t alloc\+Size, \hyperlink{class_test_memory_allocator}{Test\+Memory\+Allocator} $\ast$alloc\+Allocator, const char $\ast$free\+File, int free\+Line, \hyperlink{class_test_memory_allocator}{Test\+Memory\+Allocator} $\ast$free\+Allocator, \hyperlink{class_memory_leak_failure}{Memory\+Leak\+Failure} $\ast$reporter)
\end{DoxyCompactItemize}
\subsection*{Private 속성}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{class_memory_leak_output_string_buffer_aba01adde02a49ff2d2334a1bc63d3efd}{total\+\_\+leaks\+\_\+}
\item 
\hyperlink{avb__gptp_8h_af6a258d8f3ee5206d682d799316314b1}{bool} \hyperlink{class_memory_leak_output_string_buffer_a04fdc0c69ccd96059de5757ca5e45388}{give\+Warning\+On\+Using\+Malloc\+\_\+}
\item 
\hyperlink{struct_simple_string_buffer}{Simple\+String\+Buffer} \hyperlink{class_memory_leak_output_string_buffer_aba62884e35f3c42b627faf57b0e80a8c}{output\+Buffer\+\_\+}
\end{DoxyCompactItemize}


\subsection{상세한 설명}


Memory\+Leak\+Detector.\+h 파일의 77 번째 라인에서 정의되었습니다.



\subsection{생성자 \& 소멸자 문서화}
\index{Memory\+Leak\+Output\+String\+Buffer@{Memory\+Leak\+Output\+String\+Buffer}!Memory\+Leak\+Output\+String\+Buffer@{Memory\+Leak\+Output\+String\+Buffer}}
\index{Memory\+Leak\+Output\+String\+Buffer@{Memory\+Leak\+Output\+String\+Buffer}!Memory\+Leak\+Output\+String\+Buffer@{Memory\+Leak\+Output\+String\+Buffer}}
\subsubsection[{\texorpdfstring{Memory\+Leak\+Output\+String\+Buffer()}{MemoryLeakOutputStringBuffer()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Memory\+Leak\+Output\+String\+Buffer} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{class_memory_leak_output_string_buffer_a0179a0f1ab6daada47cc5396b807e94a}{}\label{class_memory_leak_output_string_buffer_a0179a0f1ab6daada47cc5396b807e94a}


Memory\+Leak\+Detector.\+cpp 파일의 132 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
133     : \hyperlink{class_memory_leak_output_string_buffer_aba01adde02a49ff2d2334a1bc63d3efd}{total\_leaks\_}(0), \hyperlink{class_memory_leak_output_string_buffer_a04fdc0c69ccd96059de5757ca5e45388}{giveWarningOnUsingMalloc\_}(\textcolor{keyword}{false})
134 \{
135 \}
\end{DoxyCode}


\subsection{멤버 함수 문서화}
\index{Memory\+Leak\+Output\+String\+Buffer@{Memory\+Leak\+Output\+String\+Buffer}!add\+Allocation\+Location@{add\+Allocation\+Location}}
\index{add\+Allocation\+Location@{add\+Allocation\+Location}!Memory\+Leak\+Output\+String\+Buffer@{Memory\+Leak\+Output\+String\+Buffer}}
\subsubsection[{\texorpdfstring{add\+Allocation\+Location(const char $\ast$allocation\+File, int allocation\+Line\+Number, size\+\_\+t allocation\+Size, Test\+Memory\+Allocator $\ast$allocator)}{addAllocationLocation(const char *allocationFile, int allocationLineNumber, size_t allocationSize, TestMemoryAllocator *allocator)}}]{\setlength{\rightskip}{0pt plus 5cm}void add\+Allocation\+Location (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{allocation\+File, }
\item[{int}]{allocation\+Line\+Number, }
\item[{size\+\_\+t}]{allocation\+Size, }
\item[{{\bf Test\+Memory\+Allocator} $\ast$}]{allocator}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_memory_leak_output_string_buffer_a5f6e2b7ab5d4600d3a3c829c1ec6faa7}{}\label{class_memory_leak_output_string_buffer_a5f6e2b7ab5d4600d3a3c829c1ec6faa7}


Memory\+Leak\+Detector.\+cpp 파일의 137 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
138 \{
139     \hyperlink{class_memory_leak_output_string_buffer_aba62884e35f3c42b627faf57b0e80a8c}{outputBuffer\_}.\hyperlink{struct_simple_string_buffer_ae2aa8147b398c989b73608c779bc7611}{add}(\textcolor{stringliteral}{"   allocated at file: %s line: %d size: %lu type: %s\(\backslash\)n"}, 
      allocationFile, allocationLineNumber, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long}) allocationSize, allocator->\hyperlink{class_test_memory_allocator_afab6c44b5468c71a699c1efbd787e6e7}{alloc\_name}());
140 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=348pt]{class_memory_leak_output_string_buffer_a5f6e2b7ab5d4600d3a3c829c1ec6faa7_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_memory_leak_output_string_buffer_a5f6e2b7ab5d4600d3a3c829c1ec6faa7_icgraph}
\end{center}
\end{figure}


\index{Memory\+Leak\+Output\+String\+Buffer@{Memory\+Leak\+Output\+String\+Buffer}!add\+Deallocation\+Location@{add\+Deallocation\+Location}}
\index{add\+Deallocation\+Location@{add\+Deallocation\+Location}!Memory\+Leak\+Output\+String\+Buffer@{Memory\+Leak\+Output\+String\+Buffer}}
\subsubsection[{\texorpdfstring{add\+Deallocation\+Location(const char $\ast$free\+File, int free\+Line\+Number, Test\+Memory\+Allocator $\ast$allocator)}{addDeallocationLocation(const char *freeFile, int freeLineNumber, TestMemoryAllocator *allocator)}}]{\setlength{\rightskip}{0pt plus 5cm}void add\+Deallocation\+Location (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{free\+File, }
\item[{int}]{free\+Line\+Number, }
\item[{{\bf Test\+Memory\+Allocator} $\ast$}]{allocator}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_memory_leak_output_string_buffer_acae4e17ec89e44eb6767751248d5cdb3}{}\label{class_memory_leak_output_string_buffer_acae4e17ec89e44eb6767751248d5cdb3}


Memory\+Leak\+Detector.\+cpp 파일의 142 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
143 \{
144     \hyperlink{class_memory_leak_output_string_buffer_aba62884e35f3c42b627faf57b0e80a8c}{outputBuffer\_}.\hyperlink{struct_simple_string_buffer_ae2aa8147b398c989b73608c779bc7611}{add}(\textcolor{stringliteral}{"   deallocated at file: %s line: %d type: %s\(\backslash\)n"}, freeFile, 
      freeLineNumber, allocator->\hyperlink{class_test_memory_allocator_aac134aac79b30bc5903d0b2b7cc55b74}{free\_name}());
145 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_memory_leak_output_string_buffer_acae4e17ec89e44eb6767751248d5cdb3_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_memory_leak_output_string_buffer_acae4e17ec89e44eb6767751248d5cdb3_icgraph}
\end{center}
\end{figure}


\index{Memory\+Leak\+Output\+String\+Buffer@{Memory\+Leak\+Output\+String\+Buffer}!add\+Error\+Message\+For\+Too\+Much\+Leaks@{add\+Error\+Message\+For\+Too\+Much\+Leaks}}
\index{add\+Error\+Message\+For\+Too\+Much\+Leaks@{add\+Error\+Message\+For\+Too\+Much\+Leaks}!Memory\+Leak\+Output\+String\+Buffer@{Memory\+Leak\+Output\+String\+Buffer}}
\subsubsection[{\texorpdfstring{add\+Error\+Message\+For\+Too\+Much\+Leaks()}{addErrorMessageForTooMuchLeaks()}}]{\setlength{\rightskip}{0pt plus 5cm}void add\+Error\+Message\+For\+Too\+Much\+Leaks (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_memory_leak_output_string_buffer_a0259a6c52dc5b5530e4cab9383bea68c}{}\label{class_memory_leak_output_string_buffer_a0259a6c52dc5b5530e4cab9383bea68c}


Memory\+Leak\+Detector.\+cpp 파일의 203 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
204 \{
205     \hyperlink{class_memory_leak_output_string_buffer_aba62884e35f3c42b627faf57b0e80a8c}{outputBuffer\_}.\hyperlink{struct_simple_string_buffer_ae2aa8147b398c989b73608c779bc7611}{add}(\hyperlink{_memory_leak_detector_8cpp_a740c12f400ecb89a5ccc5cfa2bd6eb26}{MEM\_LEAK\_TOO\_MUCH});
206 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_memory_leak_output_string_buffer_a0259a6c52dc5b5530e4cab9383bea68c_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_memory_leak_output_string_buffer_a0259a6c52dc5b5530e4cab9383bea68c_icgraph}
\end{center}
\end{figure}


\index{Memory\+Leak\+Output\+String\+Buffer@{Memory\+Leak\+Output\+String\+Buffer}!add\+Memory\+Leak\+Footer@{add\+Memory\+Leak\+Footer}}
\index{add\+Memory\+Leak\+Footer@{add\+Memory\+Leak\+Footer}!Memory\+Leak\+Output\+String\+Buffer@{Memory\+Leak\+Output\+String\+Buffer}}
\subsubsection[{\texorpdfstring{add\+Memory\+Leak\+Footer(int total\+Amount\+Of\+Leaks)}{addMemoryLeakFooter(int totalAmountOfLeaks)}}]{\setlength{\rightskip}{0pt plus 5cm}void add\+Memory\+Leak\+Footer (
\begin{DoxyParamCaption}
\item[{int}]{total\+Amount\+Of\+Leaks}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_memory_leak_output_string_buffer_a8ae585bb2ebf4a57a7414d855eb877fe}{}\label{class_memory_leak_output_string_buffer_a8ae585bb2ebf4a57a7414d855eb877fe}


Memory\+Leak\+Detector.\+cpp 파일의 208 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
209 \{
210     \hyperlink{class_memory_leak_output_string_buffer_aba62884e35f3c42b627faf57b0e80a8c}{outputBuffer\_}.\hyperlink{struct_simple_string_buffer_ae2aa8147b398c989b73608c779bc7611}{add}(\textcolor{stringliteral}{"%s %d\(\backslash\)n"}, \hyperlink{_memory_leak_detector_8cpp_ace72fade8aa1897ef04cb12166496a02}{MEM\_LEAK\_FOOTER}, amountOfLeaks);
211 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_memory_leak_output_string_buffer_a8ae585bb2ebf4a57a7414d855eb877fe_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_memory_leak_output_string_buffer_a8ae585bb2ebf4a57a7414d855eb877fe_icgraph}
\end{center}
\end{figure}


\index{Memory\+Leak\+Output\+String\+Buffer@{Memory\+Leak\+Output\+String\+Buffer}!add\+Memory\+Leak\+Header@{add\+Memory\+Leak\+Header}}
\index{add\+Memory\+Leak\+Header@{add\+Memory\+Leak\+Header}!Memory\+Leak\+Output\+String\+Buffer@{Memory\+Leak\+Output\+String\+Buffer}}
\subsubsection[{\texorpdfstring{add\+Memory\+Leak\+Header()}{addMemoryLeakHeader()}}]{\setlength{\rightskip}{0pt plus 5cm}void add\+Memory\+Leak\+Header (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_memory_leak_output_string_buffer_af2e1dc56c3bf80241f576a81ff02dd60}{}\label{class_memory_leak_output_string_buffer_af2e1dc56c3bf80241f576a81ff02dd60}


Memory\+Leak\+Detector.\+cpp 파일의 198 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
199 \{
200     \hyperlink{class_memory_leak_output_string_buffer_aba62884e35f3c42b627faf57b0e80a8c}{outputBuffer\_}.\hyperlink{struct_simple_string_buffer_ae2aa8147b398c989b73608c779bc7611}{add}(\textcolor{stringliteral}{"Memory leak(s) found.\(\backslash\)n"});
201 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_memory_leak_output_string_buffer_af2e1dc56c3bf80241f576a81ff02dd60_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=334pt]{class_memory_leak_output_string_buffer_af2e1dc56c3bf80241f576a81ff02dd60_icgraph}
\end{center}
\end{figure}


\index{Memory\+Leak\+Output\+String\+Buffer@{Memory\+Leak\+Output\+String\+Buffer}!add\+No\+Memory\+Leaks\+Message@{add\+No\+Memory\+Leaks\+Message}}
\index{add\+No\+Memory\+Leaks\+Message@{add\+No\+Memory\+Leaks\+Message}!Memory\+Leak\+Output\+String\+Buffer@{Memory\+Leak\+Output\+String\+Buffer}}
\subsubsection[{\texorpdfstring{add\+No\+Memory\+Leaks\+Message()}{addNoMemoryLeaksMessage()}}]{\setlength{\rightskip}{0pt plus 5cm}void add\+No\+Memory\+Leaks\+Message (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_memory_leak_output_string_buffer_a4fb8c9f82dfd44fc7ec4c313b847b902}{}\label{class_memory_leak_output_string_buffer_a4fb8c9f82dfd44fc7ec4c313b847b902}


Memory\+Leak\+Detector.\+cpp 파일의 147 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
148 \{
149     \hyperlink{class_memory_leak_output_string_buffer_aba62884e35f3c42b627faf57b0e80a8c}{outputBuffer\_}.\hyperlink{struct_simple_string_buffer_ae2aa8147b398c989b73608c779bc7611}{add}(\textcolor{stringliteral}{"No memory leaks were detected."});
150 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_memory_leak_output_string_buffer_a4fb8c9f82dfd44fc7ec4c313b847b902_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_memory_leak_output_string_buffer_a4fb8c9f82dfd44fc7ec4c313b847b902_icgraph}
\end{center}
\end{figure}


\index{Memory\+Leak\+Output\+String\+Buffer@{Memory\+Leak\+Output\+String\+Buffer}!add\+Warning\+For\+Using\+Malloc@{add\+Warning\+For\+Using\+Malloc}}
\index{add\+Warning\+For\+Using\+Malloc@{add\+Warning\+For\+Using\+Malloc}!Memory\+Leak\+Output\+String\+Buffer@{Memory\+Leak\+Output\+String\+Buffer}}
\subsubsection[{\texorpdfstring{add\+Warning\+For\+Using\+Malloc()}{addWarningForUsingMalloc()}}]{\setlength{\rightskip}{0pt plus 5cm}void add\+Warning\+For\+Using\+Malloc (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_memory_leak_output_string_buffer_a57d7e9800c9f156619ea03a7cca303d8}{}\label{class_memory_leak_output_string_buffer_a57d7e9800c9f156619ea03a7cca303d8}


Memory\+Leak\+Detector.\+cpp 파일의 213 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
214 \{
215     \hyperlink{class_memory_leak_output_string_buffer_aba62884e35f3c42b627faf57b0e80a8c}{outputBuffer\_}.\hyperlink{struct_simple_string_buffer_ae2aa8147b398c989b73608c779bc7611}{add}(\hyperlink{_memory_leak_detector_8cpp_af3a45c613922f0cc88e7441ee552a926}{MEM\_LEAK\_ADDITION\_MALLOC\_WARNING});
216 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_memory_leak_output_string_buffer_a57d7e9800c9f156619ea03a7cca303d8_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_memory_leak_output_string_buffer_a57d7e9800c9f156619ea03a7cca303d8_icgraph}
\end{center}
\end{figure}


\index{Memory\+Leak\+Output\+String\+Buffer@{Memory\+Leak\+Output\+String\+Buffer}!clear@{clear}}
\index{clear@{clear}!Memory\+Leak\+Output\+String\+Buffer@{Memory\+Leak\+Output\+String\+Buffer}}
\subsubsection[{\texorpdfstring{clear()}{clear()}}]{\setlength{\rightskip}{0pt plus 5cm}void clear (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{class_memory_leak_output_string_buffer_ac8bb3912a3ce86b15842e79d0b421204}{}\label{class_memory_leak_output_string_buffer_ac8bb3912a3ce86b15842e79d0b421204}


Memory\+Leak\+Detector.\+cpp 파일의 248 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
249 \{
250     \hyperlink{class_memory_leak_output_string_buffer_aba62884e35f3c42b627faf57b0e80a8c}{outputBuffer\_}.\hyperlink{struct_simple_string_buffer_ac8bb3912a3ce86b15842e79d0b421204}{clear}();
251 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=252pt]{class_memory_leak_output_string_buffer_ac8bb3912a3ce86b15842e79d0b421204_cgraph}
\end{center}
\end{figure}


\index{Memory\+Leak\+Output\+String\+Buffer@{Memory\+Leak\+Output\+String\+Buffer}!report\+Allocation\+Deallocation\+Mismatch\+Failure@{report\+Allocation\+Deallocation\+Mismatch\+Failure}}
\index{report\+Allocation\+Deallocation\+Mismatch\+Failure@{report\+Allocation\+Deallocation\+Mismatch\+Failure}!Memory\+Leak\+Output\+String\+Buffer@{Memory\+Leak\+Output\+String\+Buffer}}
\subsubsection[{\texorpdfstring{report\+Allocation\+Deallocation\+Mismatch\+Failure(\+Memory\+Leak\+Detector\+Node $\ast$node, const char $\ast$free\+File, int free\+Line\+Number, Test\+Memory\+Allocator $\ast$free\+Allocator, Memory\+Leak\+Failure $\ast$reporter)}{reportAllocationDeallocationMismatchFailure(MemoryLeakDetectorNode *node, const char *freeFile, int freeLineNumber, TestMemoryAllocator *freeAllocator, MemoryLeakFailure *reporter)}}]{\setlength{\rightskip}{0pt plus 5cm}void report\+Allocation\+Deallocation\+Mismatch\+Failure (
\begin{DoxyParamCaption}
\item[{{\bf Memory\+Leak\+Detector\+Node} $\ast$}]{node, }
\item[{const char $\ast$}]{free\+File, }
\item[{int}]{free\+Line\+Number, }
\item[{{\bf Test\+Memory\+Allocator} $\ast$}]{free\+Allocator, }
\item[{{\bf Memory\+Leak\+Failure} $\ast$}]{reporter}
\end{DoxyParamCaption}
)}\hypertarget{class_memory_leak_output_string_buffer_a94baa48406f230991c764abd1cf3a904}{}\label{class_memory_leak_output_string_buffer_a94baa48406f230991c764abd1cf3a904}


Memory\+Leak\+Detector.\+cpp 파일의 223 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
224 \{
225     \hyperlink{class_memory_leak_output_string_buffer_ae3d2ba0fc07468c3ac05c87be80caf55}{reportFailure}(\textcolor{stringliteral}{"Allocation/deallocation type mismatch\(\backslash\)n"}, node->
      \hyperlink{struct_memory_leak_detector_node_a1f340748cdde8f8781fa62b4a3562190}{file\_}, node->\hyperlink{struct_memory_leak_detector_node_ac515e5f5602db49593f96316f1b5c054}{line\_}, node->\hyperlink{struct_memory_leak_detector_node_a5f31775800bbb46b35b5791def1f3acc}{size\_}, node->\hyperlink{struct_memory_leak_detector_node_a12122107c5adfce5f08568d080ad411a}{allocator\_}, freeFile, freeLineNumber, 
      freeAllocator, reporter);
226 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_memory_leak_output_string_buffer_a94baa48406f230991c764abd1cf3a904_cgraph}
\end{center}
\end{figure}


\index{Memory\+Leak\+Output\+String\+Buffer@{Memory\+Leak\+Output\+String\+Buffer}!report\+Deallocate\+Non\+Allocated\+Memory\+Failure@{report\+Deallocate\+Non\+Allocated\+Memory\+Failure}}
\index{report\+Deallocate\+Non\+Allocated\+Memory\+Failure@{report\+Deallocate\+Non\+Allocated\+Memory\+Failure}!Memory\+Leak\+Output\+String\+Buffer@{Memory\+Leak\+Output\+String\+Buffer}}
\subsubsection[{\texorpdfstring{report\+Deallocate\+Non\+Allocated\+Memory\+Failure(const char $\ast$free\+File, int free\+Line, Test\+Memory\+Allocator $\ast$free\+Allocator, Memory\+Leak\+Failure $\ast$reporter)}{reportDeallocateNonAllocatedMemoryFailure(const char *freeFile, int freeLine, TestMemoryAllocator *freeAllocator, MemoryLeakFailure *reporter)}}]{\setlength{\rightskip}{0pt plus 5cm}void report\+Deallocate\+Non\+Allocated\+Memory\+Failure (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{free\+File, }
\item[{int}]{free\+Line, }
\item[{{\bf Test\+Memory\+Allocator} $\ast$}]{free\+Allocator, }
\item[{{\bf Memory\+Leak\+Failure} $\ast$}]{reporter}
\end{DoxyParamCaption}
)}\hypertarget{class_memory_leak_output_string_buffer_a0061b779a33beb2d8c87eb915b20309a}{}\label{class_memory_leak_output_string_buffer_a0061b779a33beb2d8c87eb915b20309a}


Memory\+Leak\+Detector.\+cpp 파일의 218 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
219 \{
220     \hyperlink{class_memory_leak_output_string_buffer_ae3d2ba0fc07468c3ac05c87be80caf55}{reportFailure}(\textcolor{stringliteral}{"Deallocating non-allocated memory\(\backslash\)n"}, \textcolor{stringliteral}{"<unknown>"}, 0, 0, 
      \hyperlink{class_null_unknown_allocator_ac84da234039b5be7236af9fe3e0bac61}{NullUnknownAllocator::defaultAllocator}(), freeFile, freeLine, 
      freeAllocator, reporter);
221 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_memory_leak_output_string_buffer_a0061b779a33beb2d8c87eb915b20309a_cgraph}
\end{center}
\end{figure}


\index{Memory\+Leak\+Output\+String\+Buffer@{Memory\+Leak\+Output\+String\+Buffer}!report\+Failure@{report\+Failure}}
\index{report\+Failure@{report\+Failure}!Memory\+Leak\+Output\+String\+Buffer@{Memory\+Leak\+Output\+String\+Buffer}}
\subsubsection[{\texorpdfstring{report\+Failure(const char $\ast$message, const char $\ast$alloc\+File, int alloc\+Line, size\+\_\+t alloc\+Size, Test\+Memory\+Allocator $\ast$alloc\+Allocator, const char $\ast$free\+File, int free\+Line, Test\+Memory\+Allocator $\ast$free\+Allocator, Memory\+Leak\+Failure $\ast$reporter)}{reportFailure(const char *message, const char *allocFile, int allocLine, size_t allocSize, TestMemoryAllocator *allocAllocator, const char *freeFile, int freeLine, TestMemoryAllocator *freeAllocator, MemoryLeakFailure *reporter)}}]{\setlength{\rightskip}{0pt plus 5cm}void report\+Failure (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{message, }
\item[{const char $\ast$}]{alloc\+File, }
\item[{int}]{alloc\+Line, }
\item[{size\+\_\+t}]{alloc\+Size, }
\item[{{\bf Test\+Memory\+Allocator} $\ast$}]{alloc\+Allocator, }
\item[{const char $\ast$}]{free\+File, }
\item[{int}]{free\+Line, }
\item[{{\bf Test\+Memory\+Allocator} $\ast$}]{free\+Allocator, }
\item[{{\bf Memory\+Leak\+Failure} $\ast$}]{reporter}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_memory_leak_output_string_buffer_ae3d2ba0fc07468c3ac05c87be80caf55}{}\label{class_memory_leak_output_string_buffer_ae3d2ba0fc07468c3ac05c87be80caf55}


Memory\+Leak\+Detector.\+cpp 파일의 233 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
235 \{
236     \hyperlink{class_memory_leak_output_string_buffer_aba62884e35f3c42b627faf57b0e80a8c}{outputBuffer\_}.\hyperlink{struct_simple_string_buffer_ae2aa8147b398c989b73608c779bc7611}{add}(\textcolor{stringliteral}{"%s"}, message);
237     \hyperlink{class_memory_leak_output_string_buffer_a5f6e2b7ab5d4600d3a3c829c1ec6faa7}{addAllocationLocation}(allocFile, allocLine, allocSize, allocAllocator);
238     \hyperlink{class_memory_leak_output_string_buffer_acae4e17ec89e44eb6767751248d5cdb3}{addDeallocationLocation}(freeFile, freeLine, freeAllocator);
239     reporter->\hyperlink{class_memory_leak_failure_a02162a2e65c782866a5acf6b84abc7aa}{fail}(\hyperlink{class_memory_leak_output_string_buffer_ac4969471df03a7a438bd99bfe61a0d5e}{toString}());
240 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_memory_leak_output_string_buffer_ae3d2ba0fc07468c3ac05c87be80caf55_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=338pt]{class_memory_leak_output_string_buffer_ae3d2ba0fc07468c3ac05c87be80caf55_icgraph}
\end{center}
\end{figure}


\index{Memory\+Leak\+Output\+String\+Buffer@{Memory\+Leak\+Output\+String\+Buffer}!report\+Memory\+Corruption\+Failure@{report\+Memory\+Corruption\+Failure}}
\index{report\+Memory\+Corruption\+Failure@{report\+Memory\+Corruption\+Failure}!Memory\+Leak\+Output\+String\+Buffer@{Memory\+Leak\+Output\+String\+Buffer}}
\subsubsection[{\texorpdfstring{report\+Memory\+Corruption\+Failure(\+Memory\+Leak\+Detector\+Node $\ast$node, const char $\ast$free\+File, int free\+Line\+Number, Test\+Memory\+Allocator $\ast$free\+Allocator, Memory\+Leak\+Failure $\ast$reporter)}{reportMemoryCorruptionFailure(MemoryLeakDetectorNode *node, const char *freeFile, int freeLineNumber, TestMemoryAllocator *freeAllocator, MemoryLeakFailure *reporter)}}]{\setlength{\rightskip}{0pt plus 5cm}void report\+Memory\+Corruption\+Failure (
\begin{DoxyParamCaption}
\item[{{\bf Memory\+Leak\+Detector\+Node} $\ast$}]{node, }
\item[{const char $\ast$}]{free\+File, }
\item[{int}]{free\+Line\+Number, }
\item[{{\bf Test\+Memory\+Allocator} $\ast$}]{free\+Allocator, }
\item[{{\bf Memory\+Leak\+Failure} $\ast$}]{reporter}
\end{DoxyParamCaption}
)}\hypertarget{class_memory_leak_output_string_buffer_a14efcbb890531b638e1ff5e6a21e485a}{}\label{class_memory_leak_output_string_buffer_a14efcbb890531b638e1ff5e6a21e485a}


Memory\+Leak\+Detector.\+cpp 파일의 228 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
229 \{
230         \hyperlink{class_memory_leak_output_string_buffer_ae3d2ba0fc07468c3ac05c87be80caf55}{reportFailure}(\textcolor{stringliteral}{"Memory corruption (written out of bounds?)\(\backslash\)n"}, node->
      \hyperlink{struct_memory_leak_detector_node_a1f340748cdde8f8781fa62b4a3562190}{file\_}, node->\hyperlink{struct_memory_leak_detector_node_ac515e5f5602db49593f96316f1b5c054}{line\_}, node->\hyperlink{struct_memory_leak_detector_node_a5f31775800bbb46b35b5791def1f3acc}{size\_}, node->\hyperlink{struct_memory_leak_detector_node_a12122107c5adfce5f08568d080ad411a}{allocator\_}, freeFile, freeLineNumber, 
      freeAllocator, reporter);
231 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_memory_leak_output_string_buffer_a14efcbb890531b638e1ff5e6a21e485a_cgraph}
\end{center}
\end{figure}


\index{Memory\+Leak\+Output\+String\+Buffer@{Memory\+Leak\+Output\+String\+Buffer}!report\+Memory\+Leak@{report\+Memory\+Leak}}
\index{report\+Memory\+Leak@{report\+Memory\+Leak}!Memory\+Leak\+Output\+String\+Buffer@{Memory\+Leak\+Output\+String\+Buffer}}
\subsubsection[{\texorpdfstring{report\+Memory\+Leak(\+Memory\+Leak\+Detector\+Node $\ast$leak)}{reportMemoryLeak(MemoryLeakDetectorNode *leak)}}]{\setlength{\rightskip}{0pt plus 5cm}void report\+Memory\+Leak (
\begin{DoxyParamCaption}
\item[{{\bf Memory\+Leak\+Detector\+Node} $\ast$}]{leak}
\end{DoxyParamCaption}
)}\hypertarget{class_memory_leak_output_string_buffer_a93f881f339b50ea69b8cd7b543e15377}{}\label{class_memory_leak_output_string_buffer_a93f881f339b50ea69b8cd7b543e15377}


Memory\+Leak\+Detector.\+cpp 파일의 163 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
164 \{
165     \textcolor{keywordflow}{if} (\hyperlink{class_memory_leak_output_string_buffer_aba01adde02a49ff2d2334a1bc63d3efd}{total\_leaks\_} == 0) \{
166         \hyperlink{class_memory_leak_output_string_buffer_af2e1dc56c3bf80241f576a81ff02dd60}{addMemoryLeakHeader}();
167     \}
168 
169     \hyperlink{class_memory_leak_output_string_buffer_aba01adde02a49ff2d2334a1bc63d3efd}{total\_leaks\_}++;
170     \hyperlink{class_memory_leak_output_string_buffer_aba62884e35f3c42b627faf57b0e80a8c}{outputBuffer\_}.\hyperlink{struct_simple_string_buffer_ae2aa8147b398c989b73608c779bc7611}{add}(\textcolor{stringliteral}{"Alloc num (%u) Leak size: %lu Allocated at: %s and line: %d. Type: 
      \(\backslash\)"%s\(\backslash\)"\(\backslash\)n\(\backslash\)tMemory: <%p> Content:\(\backslash\)n"},
171             leak->\hyperlink{struct_memory_leak_detector_node_aa14f02a32a8cc537af13ce5397fcd2b1}{number\_}, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long}) leak->\hyperlink{struct_memory_leak_detector_node_a5f31775800bbb46b35b5791def1f3acc}{size\_}, leak->\hyperlink{struct_memory_leak_detector_node_a1f340748cdde8f8781fa62b4a3562190}{file\_}, leak->
      \hyperlink{struct_memory_leak_detector_node_ac515e5f5602db49593f96316f1b5c054}{line\_}, leak->\hyperlink{struct_memory_leak_detector_node_a12122107c5adfce5f08568d080ad411a}{allocator\_}->\hyperlink{class_test_memory_allocator_afab6c44b5468c71a699c1efbd787e6e7}{alloc\_name}(), (\textcolor{keywordtype}{void}*) leak->
      \hyperlink{struct_memory_leak_detector_node_a6cdb5ad30702010eaf86e4e5f26defce}{memory\_});
172     \hyperlink{class_memory_leak_output_string_buffer_aba62884e35f3c42b627faf57b0e80a8c}{outputBuffer\_}.\hyperlink{struct_simple_string_buffer_a2e93e33f23d85779303a1c58a7eca212}{addMemoryDump}(leak->\hyperlink{struct_memory_leak_detector_node_a6cdb5ad30702010eaf86e4e5f26defce}{memory\_}, leak->
      \hyperlink{struct_memory_leak_detector_node_a5f31775800bbb46b35b5791def1f3acc}{size\_});
173 
174     \textcolor{keywordflow}{if} (\hyperlink{class_simple_string_a0b7a8ae895cbde84a491b42c43de23a6}{SimpleString::StrCmp}(leak->\hyperlink{struct_memory_leak_detector_node_a12122107c5adfce5f08568d080ad411a}{allocator\_}->
      \hyperlink{class_test_memory_allocator_afab6c44b5468c71a699c1efbd787e6e7}{alloc\_name}(), (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*) \textcolor{stringliteral}{"malloc"}) == 0)
175         \hyperlink{class_memory_leak_output_string_buffer_a04fdc0c69ccd96059de5757ca5e45388}{giveWarningOnUsingMalloc\_} = \textcolor{keyword}{true};
176 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_memory_leak_output_string_buffer_a93f881f339b50ea69b8cd7b543e15377_cgraph}
\end{center}
\end{figure}


\index{Memory\+Leak\+Output\+String\+Buffer@{Memory\+Leak\+Output\+String\+Buffer}!start\+Memory\+Leak\+Reporting@{start\+Memory\+Leak\+Reporting}}
\index{start\+Memory\+Leak\+Reporting@{start\+Memory\+Leak\+Reporting}!Memory\+Leak\+Output\+String\+Buffer@{Memory\+Leak\+Output\+String\+Buffer}}
\subsubsection[{\texorpdfstring{start\+Memory\+Leak\+Reporting()}{startMemoryLeakReporting()}}]{\setlength{\rightskip}{0pt plus 5cm}void start\+Memory\+Leak\+Reporting (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{class_memory_leak_output_string_buffer_a99cb7722b04d6e0539701d105c08af23}{}\label{class_memory_leak_output_string_buffer_a99cb7722b04d6e0539701d105c08af23}


Memory\+Leak\+Detector.\+cpp 파일의 152 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
153 \{
154     \hyperlink{class_memory_leak_output_string_buffer_a04fdc0c69ccd96059de5757ca5e45388}{giveWarningOnUsingMalloc\_} = \textcolor{keyword}{false};
155     \hyperlink{class_memory_leak_output_string_buffer_aba01adde02a49ff2d2334a1bc63d3efd}{total\_leaks\_} = 0;
156 
157     \textcolor{keywordtype}{size\_t} memory\_leak\_normal\_footer\_size = \textcolor{keyword}{sizeof}(\hyperlink{_memory_leak_detector_8cpp_ace72fade8aa1897ef04cb12166496a02}{MEM\_LEAK\_FOOTER}) + 10 + \textcolor{keyword}{sizeof}(
      \hyperlink{_memory_leak_detector_8cpp_a740c12f400ecb89a5ccc5cfa2bd6eb26}{MEM\_LEAK\_TOO\_MUCH}); \textcolor{comment}{/* the number of leaks */}
158     \textcolor{keywordtype}{size\_t} memory\_leak\_foot\_size\_with\_malloc\_warning = memory\_leak\_normal\_footer\_size + \textcolor{keyword}{sizeof}(
      \hyperlink{_memory_leak_detector_8cpp_af3a45c613922f0cc88e7441ee552a926}{MEM\_LEAK\_ADDITION\_MALLOC\_WARNING});
159 
160     \hyperlink{class_memory_leak_output_string_buffer_aba62884e35f3c42b627faf57b0e80a8c}{outputBuffer\_}.\hyperlink{struct_simple_string_buffer_abd59b77081323992830e4a3b9db501e6}{setWriteLimit}(
      \hyperlink{struct_simple_string_buffer_a4efaf4e07364d6302f598569aa7e55dca495824058d0344ce7789bfdfe6658843}{SimpleStringBuffer::SIMPLE\_STRING\_BUFFER\_LEN} - 
      memory\_leak\_foot\_size\_with\_malloc\_warning);
161 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=348pt]{class_memory_leak_output_string_buffer_a99cb7722b04d6e0539701d105c08af23_cgraph}
\end{center}
\end{figure}


\index{Memory\+Leak\+Output\+String\+Buffer@{Memory\+Leak\+Output\+String\+Buffer}!stop\+Memory\+Leak\+Reporting@{stop\+Memory\+Leak\+Reporting}}
\index{stop\+Memory\+Leak\+Reporting@{stop\+Memory\+Leak\+Reporting}!Memory\+Leak\+Output\+String\+Buffer@{Memory\+Leak\+Output\+String\+Buffer}}
\subsubsection[{\texorpdfstring{stop\+Memory\+Leak\+Reporting()}{stopMemoryLeakReporting()}}]{\setlength{\rightskip}{0pt plus 5cm}void stop\+Memory\+Leak\+Reporting (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{class_memory_leak_output_string_buffer_a25142db8cabaf786bf4e41baa0bcc417}{}\label{class_memory_leak_output_string_buffer_a25142db8cabaf786bf4e41baa0bcc417}


Memory\+Leak\+Detector.\+cpp 파일의 178 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
179 \{
180     \textcolor{keywordflow}{if} (\hyperlink{class_memory_leak_output_string_buffer_aba01adde02a49ff2d2334a1bc63d3efd}{total\_leaks\_} == 0) \{
181         \hyperlink{class_memory_leak_output_string_buffer_a4fb8c9f82dfd44fc7ec4c313b847b902}{addNoMemoryLeaksMessage}();
182         \textcolor{keywordflow}{return};
183     \}
184 
185     \textcolor{keywordtype}{bool} buffer\_reached\_its\_capacity = \hyperlink{class_memory_leak_output_string_buffer_aba62884e35f3c42b627faf57b0e80a8c}{outputBuffer\_}.
      \hyperlink{struct_simple_string_buffer_a31b75ce17bbbd17e22886da56b3b7cf8}{reachedItsCapacity}();
186     \hyperlink{class_memory_leak_output_string_buffer_aba62884e35f3c42b627faf57b0e80a8c}{outputBuffer\_}.\hyperlink{struct_simple_string_buffer_a87467672236b76114024397b6d45a65c}{resetWriteLimit}();
187 
188     \textcolor{keywordflow}{if} (buffer\_reached\_its\_capacity)
189         \hyperlink{class_memory_leak_output_string_buffer_a0259a6c52dc5b5530e4cab9383bea68c}{addErrorMessageForTooMuchLeaks}();
190 
191     \hyperlink{class_memory_leak_output_string_buffer_a8ae585bb2ebf4a57a7414d855eb877fe}{addMemoryLeakFooter}(\hyperlink{class_memory_leak_output_string_buffer_aba01adde02a49ff2d2334a1bc63d3efd}{total\_leaks\_});
192 
193     \textcolor{keywordflow}{if} (\hyperlink{class_memory_leak_output_string_buffer_a04fdc0c69ccd96059de5757ca5e45388}{giveWarningOnUsingMalloc\_})
194         \hyperlink{class_memory_leak_output_string_buffer_a57d7e9800c9f156619ea03a7cca303d8}{addWarningForUsingMalloc}();
195 
196 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_memory_leak_output_string_buffer_a25142db8cabaf786bf4e41baa0bcc417_cgraph}
\end{center}
\end{figure}


\index{Memory\+Leak\+Output\+String\+Buffer@{Memory\+Leak\+Output\+String\+Buffer}!to\+String@{to\+String}}
\index{to\+String@{to\+String}!Memory\+Leak\+Output\+String\+Buffer@{Memory\+Leak\+Output\+String\+Buffer}}
\subsubsection[{\texorpdfstring{to\+String()}{toString()}}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$ to\+String (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{class_memory_leak_output_string_buffer_ac4969471df03a7a438bd99bfe61a0d5e}{}\label{class_memory_leak_output_string_buffer_ac4969471df03a7a438bd99bfe61a0d5e}


Memory\+Leak\+Detector.\+cpp 파일의 243 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
244 \{
245     \textcolor{keywordflow}{return} \hyperlink{class_memory_leak_output_string_buffer_aba62884e35f3c42b627faf57b0e80a8c}{outputBuffer\_}.\hyperlink{struct_simple_string_buffer_ac4969471df03a7a438bd99bfe61a0d5e}{toString}();
246 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=264pt]{class_memory_leak_output_string_buffer_ac4969471df03a7a438bd99bfe61a0d5e_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_memory_leak_output_string_buffer_ac4969471df03a7a438bd99bfe61a0d5e_icgraph}
\end{center}
\end{figure}




\subsection{필드 문서화}
\index{Memory\+Leak\+Output\+String\+Buffer@{Memory\+Leak\+Output\+String\+Buffer}!give\+Warning\+On\+Using\+Malloc\+\_\+@{give\+Warning\+On\+Using\+Malloc\+\_\+}}
\index{give\+Warning\+On\+Using\+Malloc\+\_\+@{give\+Warning\+On\+Using\+Malloc\+\_\+}!Memory\+Leak\+Output\+String\+Buffer@{Memory\+Leak\+Output\+String\+Buffer}}
\subsubsection[{\texorpdfstring{give\+Warning\+On\+Using\+Malloc\+\_\+}{giveWarningOnUsingMalloc_}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf bool} give\+Warning\+On\+Using\+Malloc\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_memory_leak_output_string_buffer_a04fdc0c69ccd96059de5757ca5e45388}{}\label{class_memory_leak_output_string_buffer_a04fdc0c69ccd96059de5757ca5e45388}


Memory\+Leak\+Detector.\+h 파일의 107 번째 라인에서 정의되었습니다.

\index{Memory\+Leak\+Output\+String\+Buffer@{Memory\+Leak\+Output\+String\+Buffer}!output\+Buffer\+\_\+@{output\+Buffer\+\_\+}}
\index{output\+Buffer\+\_\+@{output\+Buffer\+\_\+}!Memory\+Leak\+Output\+String\+Buffer@{Memory\+Leak\+Output\+String\+Buffer}}
\subsubsection[{\texorpdfstring{output\+Buffer\+\_\+}{outputBuffer_}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Simple\+String\+Buffer} output\+Buffer\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_memory_leak_output_string_buffer_aba62884e35f3c42b627faf57b0e80a8c}{}\label{class_memory_leak_output_string_buffer_aba62884e35f3c42b627faf57b0e80a8c}


Memory\+Leak\+Detector.\+h 파일의 114 번째 라인에서 정의되었습니다.

\index{Memory\+Leak\+Output\+String\+Buffer@{Memory\+Leak\+Output\+String\+Buffer}!total\+\_\+leaks\+\_\+@{total\+\_\+leaks\+\_\+}}
\index{total\+\_\+leaks\+\_\+@{total\+\_\+leaks\+\_\+}!Memory\+Leak\+Output\+String\+Buffer@{Memory\+Leak\+Output\+String\+Buffer}}
\subsubsection[{\texorpdfstring{total\+\_\+leaks\+\_\+}{total_leaks_}}]{\setlength{\rightskip}{0pt plus 5cm}int total\+\_\+leaks\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_memory_leak_output_string_buffer_aba01adde02a49ff2d2334a1bc63d3efd}{}\label{class_memory_leak_output_string_buffer_aba01adde02a49ff2d2334a1bc63d3efd}


Memory\+Leak\+Detector.\+h 파일의 106 번째 라인에서 정의되었습니다.



이 클래스에 대한 문서화 페이지는 다음의 파일들로부터 생성되었습니다.\+:\begin{DoxyCompactItemize}
\item 
thirdparty/cpputest/include/\+Cpp\+U\+Test/\hyperlink{_memory_leak_detector_8h}{Memory\+Leak\+Detector.\+h}\item 
thirdparty/cpputest/src/\+Cpp\+U\+Test/\hyperlink{_memory_leak_detector_8cpp}{Memory\+Leak\+Detector.\+cpp}\end{DoxyCompactItemize}
