\hypertarget{cmd__line__main_8cpp}{}\section{avdecc-\/lib/controller/app/cmdline/src/cmd\+\_\+line\+\_\+main.cpp 파일 참조}
\label{cmd__line__main_8cpp}\index{avdecc-\/lib/controller/app/cmdline/src/cmd\+\_\+line\+\_\+main.\+cpp@{avdecc-\/lib/controller/app/cmdline/src/cmd\+\_\+line\+\_\+main.\+cpp}}
{\ttfamily \#include $<$iostream$>$}\\*
{\ttfamily \#include $<$fstream$>$}\\*
{\ttfamily \#include $<$iomanip$>$}\\*
{\ttfamily \#include $<$string$>$}\\*
{\ttfamily \#include $<$vector$>$}\\*
{\ttfamily \#include $<$cstdint$>$}\\*
{\ttfamily \#include $<$cinttypes$>$}\\*
{\ttfamily \#include $<$stdexcept$>$}\\*
{\ttfamily \#include \char`\"{}cmd\+\_\+line.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}msvc\textbackslash{}getopt.\+h\char`\"{}}\\*
cmd\+\_\+line\+\_\+main.\+cpp에 대한 include 의존 그래프
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{cmd__line__main_8cpp__incl}
\end{center}
\end{figure}
\subsection*{함수}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{cmd__line__main_8cpp_a5e19a4f077d77019fc6474b479a6ea35}{notification\+\_\+callback} (void $\ast$user\+\_\+obj, \hyperlink{parse_8c_a37994e3b11c72957c6f454c6ec96d43d}{int32\+\_\+t} notification\+\_\+type, \hyperlink{parse_8c_aec6fcb673ff035718c238c8c9d544c47}{uint64\+\_\+t} entity\+\_\+id, uint16\+\_\+t cmd\+\_\+type, uint16\+\_\+t desc\+\_\+type, uint16\+\_\+t desc\+\_\+index, \hyperlink{parse_8c_a6eb1e68cc391dd753bc8ce896dbb8315}{uint32\+\_\+t} cmd\+\_\+status, void $\ast$notification\+\_\+id)
\item 
void \hyperlink{cmd__line__main_8cpp_ad5ddf1bf7126d36551ebbbeebeb304a2}{log\+\_\+callback} (void $\ast$user\+\_\+obj, \hyperlink{parse_8c_a37994e3b11c72957c6f454c6ec96d43d}{int32\+\_\+t} log\+\_\+level, const char $\ast$log\+\_\+msg, \hyperlink{parse_8c_a37994e3b11c72957c6f454c6ec96d43d}{int32\+\_\+t} time\+\_\+stamp\+\_\+ms)
\item 
static void \hyperlink{cmd__line__main_8cpp_aff0686fc947e4358db9c75b5c2635ed6}{usage} (char $\ast$argv\mbox{[}$\,$\mbox{]})
\item 
int \hyperlink{cmd__line__main_8cpp_a0ddf1224851353fc92bfbff6f499fa97}{main} (int argc, char $\ast$argv\mbox{[}$\,$\mbox{]})
\end{DoxyCompactItemize}


\subsection{함수 문서화}
\index{cmd\+\_\+line\+\_\+main.\+cpp@{cmd\+\_\+line\+\_\+main.\+cpp}!log\+\_\+callback@{log\+\_\+callback}}
\index{log\+\_\+callback@{log\+\_\+callback}!cmd\+\_\+line\+\_\+main.\+cpp@{cmd\+\_\+line\+\_\+main.\+cpp}}
\subsubsection[{\texorpdfstring{log\+\_\+callback(void $\ast$user\+\_\+obj, int32\+\_\+t log\+\_\+level, const char $\ast$log\+\_\+msg, int32\+\_\+t time\+\_\+stamp\+\_\+ms)}{log_callback(void *user_obj, int32_t log_level, const char *log_msg, int32_t time_stamp_ms)}}]{\setlength{\rightskip}{0pt plus 5cm}void log\+\_\+callback (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{user\+\_\+obj, }
\item[{{\bf int32\+\_\+t}}]{log\+\_\+level, }
\item[{const char $\ast$}]{log\+\_\+msg, }
\item[{{\bf int32\+\_\+t}}]{time\+\_\+stamp\+\_\+ms}
\end{DoxyParamCaption}
)}\hypertarget{cmd__line__main_8cpp_ad5ddf1bf7126d36551ebbbeebeb304a2}{}\label{cmd__line__main_8cpp_ad5ddf1bf7126d36551ebbbeebeb304a2}


cmd\+\_\+line\+\_\+main.\+cpp 파일의 107 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
108 \{
109     printf(\textcolor{stringliteral}{"\(\backslash\)n[LOG] %s (%s)\(\backslash\)n"}, \hyperlink{namespaceavdecc__lib_1_1utility_a8de9c558c33109aae8eb0fae10468431}{avdecc\_lib::utility::logging\_level\_value\_to\_name}
      (log\_level), log\_msg);
110 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=305pt]{cmd__line__main_8cpp_ad5ddf1bf7126d36551ebbbeebeb304a2_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=296pt]{cmd__line__main_8cpp_ad5ddf1bf7126d36551ebbbeebeb304a2_icgraph}
\end{center}
\end{figure}


\index{cmd\+\_\+line\+\_\+main.\+cpp@{cmd\+\_\+line\+\_\+main.\+cpp}!main@{main}}
\index{main@{main}!cmd\+\_\+line\+\_\+main.\+cpp@{cmd\+\_\+line\+\_\+main.\+cpp}}
\subsubsection[{\texorpdfstring{main(int argc, char $\ast$argv[])}{main(int argc, char *argv[])}}]{\setlength{\rightskip}{0pt plus 5cm}int main (
\begin{DoxyParamCaption}
\item[{int}]{argc, }
\item[{char $\ast$}]{argv\mbox{[}$\,$\mbox{]}}
\end{DoxyParamCaption}
)}\hypertarget{cmd__line__main_8cpp_a0ddf1224851353fc92bfbff6f499fa97}{}\label{cmd__line__main_8cpp_a0ddf1224851353fc92bfbff6f499fa97}


cmd\+\_\+line\+\_\+main.\+cpp 파일의 220 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
221 \{
222     \textcolor{keywordtype}{bool} test\_mode = \textcolor{keyword}{false};
223     \textcolor{keywordtype}{int} error = 0;
224     \textcolor{keywordtype}{char} * \textcolor{keyword}{interface }= \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
225     \textcolor{keywordtype}{int} \hyperlink{shaper__daemon_8c_a4e1e0e72dd773439e333c84dd762a9c3}{c} = 0;
226     \hyperlink{parse_8c_a37994e3b11c72957c6f454c6ec96d43d}{int32\_t} log\_level = \hyperlink{namespaceavdecc__lib_a501055c431e6872ef46f252ad13f85cdaf2c4481208273451a6f5c7bb9770ec8a}{avdecc\_lib::LOGGING\_LEVEL\_ERROR};
227 
228     \textcolor{keywordflow}{while} ((c = \hyperlink{getopt_8c_a5b4d105808f29eef11f1a690ccc4e04a}{getopt}(argc, argv, \textcolor{stringliteral}{"ti:l:"})) != -1)
229     \{
230         \textcolor{keywordflow}{switch} (c)
231         \{
232         \textcolor{keywordflow}{case} \textcolor{charliteral}{'t'}:
233             test\_mode = \textcolor{keyword}{true};
234             \textcolor{keywordflow}{break};
235         \textcolor{keywordflow}{case} \textcolor{charliteral}{'i'}:
236             \textcolor{keyword}{interface }= \hyperlink{getopt_8c_adb50a0eab9fed92fc3bfc7dfa4f2c410}{optarg};
237             \textcolor{keywordflow}{break};
238         \textcolor{keywordflow}{case} \textcolor{charliteral}{'l'}:
239             log\_level = atoi(\hyperlink{getopt_8c_adb50a0eab9fed92fc3bfc7dfa4f2c410}{optarg});
240             \textcolor{keywordflow}{break};
241         \textcolor{keywordflow}{case} \textcolor{charliteral}{':'}:
242             fprintf(stderr, \textcolor{stringliteral}{"Option -%c requires an operand\(\backslash\)n"}, \hyperlink{getopt_8c_a475b8db98445da73e5f62a1ef6324b95}{optopt});
243             error++;
244             \textcolor{keywordflow}{break};
245         \textcolor{keywordflow}{case} \textcolor{charliteral}{'?'}:
246             fprintf(stderr, \textcolor{stringliteral}{"Unrecognized option: '-%c'\(\backslash\)n"}, \hyperlink{getopt_8c_a475b8db98445da73e5f62a1ef6324b95}{optopt});
247             error++;
248             \textcolor{keywordflow}{break};
249         \}
250     \}
251 
252     \textcolor{keywordflow}{for} (; \hyperlink{getopt_8c_ad5e1c16213bbee2d5e8cc363309f418c}{optind} < argc; \hyperlink{getopt_8c_ad5e1c16213bbee2d5e8cc363309f418c}{optind}++)
253     \{
254         error++; \textcolor{comment}{// Unused arguments}
255     \}
256 
257     \textcolor{keywordflow}{if} (error)
258     \{
259         \hyperlink{cmd__line__main_8cpp_aff0686fc947e4358db9c75b5c2635ed6}{usage}(argv);
260     \}
261 
262     \textcolor{keywordflow}{if} (test\_mode)
263     \{
264         \textcolor{comment}{// Ensure that stdout is not buffered}
265         setvbuf(stdout, \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}, \_IOLBF, 0);
266     \}
267 
268     \hyperlink{classcmd__line}{cmd\_line} avdecc\_cmd\_line\_ref(\hyperlink{cmd__line__main_8cpp_a5e19a4f077d77019fc6474b479a6ea35}{notification\_callback}, 
      \hyperlink{cmd__line__main_8cpp_ad5ddf1bf7126d36551ebbbeebeb304a2}{log\_callback},
269                                  test\_mode, \hyperlink{mrpd_8c_af663a7576d2f8f288bb3996381484cd3}{interface}, log\_level);
270 
271     std::vector<std::string> input\_argv;
272     \textcolor{keywordtype}{size\_t} pos = 0;
273     \textcolor{keywordtype}{bool} \hyperlink{mrp_validate_8c_a5992b274cfdcacdbc1fa8347fd01ebde}{done} = \textcolor{keyword}{false};
274     \textcolor{comment}{//bool is\_input\_valid = false;}
275     std::string cmd\_input\_orig;
276 \textcolor{preprocessor}{#if defined(\_\_MACH\_\_) || defined(\_\_linux\_\_)}
277     \textcolor{keywordtype}{char} * input;
278 
279     \textcolor{comment}{// Set up the state for command-line completion}
280     top\_level\_command = avdecc\_cmd\_line\_ref.get\_commands();
281     rl\_attempted\_completion\_function = command\_completer;
282 
283 \textcolor{preprocessor}{#endif}
284 \textcolor{comment}{// Override to prevent filename completion}
285 \textcolor{preprocessor}{#if defined(\_\_MACH\_\_)}
286     rl\_completion\_entry\_function = (Function *)null\_completer;
287 \textcolor{preprocessor}{#elif defined(\_\_linux\_\_)}
288     rl\_completion\_entry\_function = null\_completer;
289 \textcolor{preprocessor}{#endif}
290 
291     std::cout << \textcolor{stringliteral}{"\(\backslash\)nEnter \(\backslash\)"help\(\backslash\)" for a list of valid commands."} << std::endl;
292 
293     \textcolor{keywordflow}{while} (!done)
294     \{
295 \textcolor{preprocessor}{#if defined(\_\_MACH\_\_) || defined(\_\_linux\_\_)}
296         input = readline(\textcolor{stringliteral}{"$ "});
297 
298         \textcolor{keywordflow}{if} (!input)
299             \textcolor{keywordflow}{break};
300         \textcolor{keywordflow}{if} (strlen(input) == 0)
301             \textcolor{keywordflow}{continue};
302         std::string cmd\_input(input);
303         cmd\_input\_orig = cmd\_input;
304         add\_history(input);
305 \textcolor{preprocessor}{#else}
306         std::string cmd\_input;
307         printf(\textcolor{stringliteral}{"\(\backslash\)n>"});
308         std::getline(std::cin, cmd\_input);
309         cmd\_input\_orig = cmd\_input;
310 \textcolor{preprocessor}{#endif}
311 
312         \textcolor{keywordflow}{while} ((pos = cmd\_input.find(\textcolor{stringliteral}{" "})) != std::string::npos)
313         \{
314             \textcolor{keywordflow}{if} (pos)
315                 input\_argv.push\_back(cmd\_input.substr(0, pos));
316 
317             cmd\_input.erase(0, pos + 1);
318         \}
319 
320         \textcolor{keywordflow}{if} (cmd\_input.length() && cmd\_input != \textcolor{stringliteral}{" "})
321         \{
322             input\_argv.push\_back(cmd\_input);
323         \}
324 
325         \textcolor{keywordflow}{if} (avdecc\_cmd\_line\_ref.is\_output\_redirected())
326         \{
327             std::cout << \textcolor{stringliteral}{"\(\backslash\)n> "} << cmd\_input\_orig << std::endl;
328         \}
329 
330         done = avdecc\_cmd\_line\_ref.handle(input\_argv);
331 
332         \textcolor{comment}{//is\_input\_valid = false;}
333         input\_argv.clear();
334 \textcolor{preprocessor}{#if defined(\_\_MACH\_\_) || defined(\_\_linux\_\_)}
335         \hyperlink{_memory_leak_detector_malloc_macros_8h_aa7157aa9480bb73f090dca36776419bf}{free}(input);
336 \textcolor{preprocessor}{#endif}
337     \}
338 
339     \textcolor{keywordflow}{return} 0;
340 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{cmd__line__main_8cpp_a0ddf1224851353fc92bfbff6f499fa97_cgraph}
\end{center}
\end{figure}


\index{cmd\+\_\+line\+\_\+main.\+cpp@{cmd\+\_\+line\+\_\+main.\+cpp}!notification\+\_\+callback@{notification\+\_\+callback}}
\index{notification\+\_\+callback@{notification\+\_\+callback}!cmd\+\_\+line\+\_\+main.\+cpp@{cmd\+\_\+line\+\_\+main.\+cpp}}
\subsubsection[{\texorpdfstring{notification\+\_\+callback(void $\ast$user\+\_\+obj, int32\+\_\+t notification\+\_\+type, uint64\+\_\+t entity\+\_\+id, uint16\+\_\+t cmd\+\_\+type, uint16\+\_\+t desc\+\_\+type, uint16\+\_\+t desc\+\_\+index, uint32\+\_\+t cmd\+\_\+status, void $\ast$notification\+\_\+id)}{notification_callback(void *user_obj, int32_t notification_type, uint64_t entity_id, uint16_t cmd_type, uint16_t desc_type, uint16_t desc_index, uint32_t cmd_status, void *notification_id)}}]{\setlength{\rightskip}{0pt plus 5cm}void notification\+\_\+callback (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{user\+\_\+obj, }
\item[{{\bf int32\+\_\+t}}]{notification\+\_\+type, }
\item[{{\bf uint64\+\_\+t}}]{entity\+\_\+id, }
\item[{uint16\+\_\+t}]{cmd\+\_\+type, }
\item[{uint16\+\_\+t}]{desc\+\_\+type, }
\item[{uint16\+\_\+t}]{desc\+\_\+index, }
\item[{{\bf uint32\+\_\+t}}]{cmd\+\_\+status, }
\item[{void $\ast$}]{notification\+\_\+id}
\end{DoxyParamCaption}
)}\hypertarget{cmd__line__main_8cpp_a5e19a4f077d77019fc6474b479a6ea35}{}\label{cmd__line__main_8cpp_a5e19a4f077d77019fc6474b479a6ea35}


cmd\+\_\+line\+\_\+main.\+cpp 파일의 62 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
65 \{
66     \textcolor{keywordflow}{if} (notification\_type == \hyperlink{namespaceavdecc__lib_ad2a3e740ca3019cf9fd0f9514afb6419a3aade74a66ec6e710103bd63b10d661f}{avdecc\_lib::COMMAND\_TIMEOUT} || notification\_type ==
       \hyperlink{namespaceavdecc__lib_ad2a3e740ca3019cf9fd0f9514afb6419a76526acf7fff481667c4ec404347c3ce}{avdecc\_lib::RESPONSE\_RECEIVED})
67     \{
68         \textcolor{keyword}{const} \textcolor{keywordtype}{char} * cmd\_name;
69         \textcolor{keyword}{const} \textcolor{keywordtype}{char} * desc\_name;
70         \textcolor{keyword}{const} \textcolor{keywordtype}{char} * cmd\_status\_name;
71 
72         \textcolor{keywordflow}{if} (cmd\_type < \hyperlink{namespaceavdecc__lib_ab6b306ef981f5e21bb41ea2c2dbe8cd9a3d122abbe03d5d839b4708ad02b7586d}{avdecc\_lib::CMD\_LOOKUP})
73         \{
74             cmd\_name = \hyperlink{namespaceavdecc__lib_1_1utility_a4c304db966bad783728a6a9e0aefed18}{avdecc\_lib::utility::aem\_cmd\_value\_to\_name}
      (cmd\_type);
75             desc\_name = \hyperlink{namespaceavdecc__lib_1_1utility_a6bdd02679e5a911a071d4aa03be341f0}{avdecc\_lib::utility::aem\_desc\_value\_to\_name}
      (desc\_type);
76             cmd\_status\_name = \hyperlink{namespaceavdecc__lib_1_1utility_aca66a547b66fdb27f3221ad0844d60c6}{avdecc\_lib::utility::aem\_cmd\_status\_value\_to\_name}
      (cmd\_status);
77         \}
78         \textcolor{keywordflow}{else}
79         \{
80             cmd\_name = \hyperlink{namespaceavdecc__lib_1_1utility_a89e861257b12dded819c0e1966cbb798}{avdecc\_lib::utility::acmp\_cmd\_value\_to\_name}
      (cmd\_type - \hyperlink{namespaceavdecc__lib_ab6b306ef981f5e21bb41ea2c2dbe8cd9a3d122abbe03d5d839b4708ad02b7586d}{avdecc\_lib::CMD\_LOOKUP});
81             desc\_name = \textcolor{stringliteral}{"NULL"};
82             cmd\_status\_name = \hyperlink{namespaceavdecc__lib_1_1utility_a997ca93009ef89352844dec17b15719f}{avdecc\_lib::utility::acmp\_cmd\_status\_value\_to\_name}
      (cmd\_status);
83         \}
84 
85         printf(\textcolor{stringliteral}{"\(\backslash\)n[NOTIFICATION] (%s, 0x%"} \hyperlink{mmrp__tests_8cpp_aba38357387a474f439428dee1984fc5a}{PRIx64} \textcolor{stringliteral}{", %s, %s, %d, %s, %p)\(\backslash\)n"},
86                \hyperlink{namespaceavdecc__lib_1_1utility_a8b711a8b94eb1be638675a9e0c97d404}{avdecc\_lib::utility::notification\_value\_to\_name}
      (notification\_type),
87                entity\_id,
88                cmd\_name,
89                desc\_name,
90                desc\_index,
91                cmd\_status\_name,
92                notification\_id);
93     \}
94     \textcolor{keywordflow}{else}
95     \{
96         printf(\textcolor{stringliteral}{"\(\backslash\)n[NOTIFICATION] (%s, 0x%"} \hyperlink{mmrp__tests_8cpp_aba38357387a474f439428dee1984fc5a}{PRIx64} \textcolor{stringliteral}{", %d, %d, %d, %d, %p)\(\backslash\)n"},
97                \hyperlink{namespaceavdecc__lib_1_1utility_a8b711a8b94eb1be638675a9e0c97d404}{avdecc\_lib::utility::notification\_value\_to\_name}
      (notification\_type),
98                entity\_id,
99                cmd\_type,
100                desc\_type,
101                desc\_index,
102                cmd\_status,
103                notification\_id);
104     \}
105 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{cmd__line__main_8cpp_a5e19a4f077d77019fc6474b479a6ea35_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=330pt]{cmd__line__main_8cpp_a5e19a4f077d77019fc6474b479a6ea35_icgraph}
\end{center}
\end{figure}


\index{cmd\+\_\+line\+\_\+main.\+cpp@{cmd\+\_\+line\+\_\+main.\+cpp}!usage@{usage}}
\index{usage@{usage}!cmd\+\_\+line\+\_\+main.\+cpp@{cmd\+\_\+line\+\_\+main.\+cpp}}
\subsubsection[{\texorpdfstring{usage(char $\ast$argv[])}{usage(char *argv[])}}]{\setlength{\rightskip}{0pt plus 5cm}static void usage (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{argv\mbox{[}$\,$\mbox{]}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{cmd__line__main_8cpp_aff0686fc947e4358db9c75b5c2635ed6}{}\label{cmd__line__main_8cpp_aff0686fc947e4358db9c75b5c2635ed6}


cmd\+\_\+line\+\_\+main.\+cpp 파일의 210 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
211 \{
212     std::cerr << \textcolor{stringliteral}{"Usage: "} << argv[0] << \textcolor{stringliteral}{" [-d] [-i interface]"} << std::endl;
213     std::cerr << \textcolor{stringliteral}{"  -t           :  Sets test mode which disables checks"} << std::endl;
214     std::cerr << \textcolor{stringliteral}{"  -i interface :  Sets the name of the interface to use"} << std::endl;
215     std::cerr << \textcolor{stringliteral}{"  -l log\_level :  Sets the log level to use."} << std::endl;
216     std::cerr << \hyperlink{cmd__line_8cpp_ae9748449330c2410b12c7cef3c512f5b}{log\_level\_help} << std::endl;
217     exit(1);
218 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=197pt]{cmd__line__main_8cpp_aff0686fc947e4358db9c75b5c2635ed6_icgraph}
\end{center}
\end{figure}


