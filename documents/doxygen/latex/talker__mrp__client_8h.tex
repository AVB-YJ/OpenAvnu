\hypertarget{talker__mrp__client_8h}{}\section{examples/common/talker\+\_\+mrp\+\_\+client.h 파일 참조}
\label{talker__mrp__client_8h}\index{examples/common/talker\+\_\+mrp\+\_\+client.\+h@{examples/common/talker\+\_\+mrp\+\_\+client.\+h}}
{\ttfamily \#include $<$stdlib.\+h$>$}\\*
{\ttfamily \#include $<$stdio.\+h$>$}\\*
{\ttfamily \#include $<$string.\+h$>$}\\*
{\ttfamily \#include $<$netinet/in.\+h$>$}\\*
{\ttfamily \#include $<$pthread.\+h$>$}\\*
{\ttfamily \#include $<$poll.\+h$>$}\\*
{\ttfamily \#include \char`\"{}mrpd.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}mrp.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}msrp.\+h\char`\"{}}\\*
talker\+\_\+mrp\+\_\+client.\+h에 대한 include 의존 그래프
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{talker__mrp__client_8h__incl}
\end{center}
\end{figure}
이 그래프는 이 파일을 직/간접적으로 include 하는 파일들을 보여줍니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{talker__mrp__client_8h__dep__incl}
\end{center}
\end{figure}
\subsection*{데이타 구조}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structmrp__talker__ctx}{mrp\+\_\+talker\+\_\+ctx}
\item 
struct \hyperlink{structmrp__domain__attr}{mrp\+\_\+domain\+\_\+attr}
\end{DoxyCompactItemize}
\subsection*{함수}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{talker__mrp__client_8h_aa94a906b50f9aca85cb00a18235c627f}{mrp\+\_\+connect} (struct \hyperlink{structmrp__talker__ctx}{mrp\+\_\+talker\+\_\+ctx} $\ast$\hyperlink{jack_8h_a1cde2a2cf8a56164b5e83159035be03b}{ctx})
\item 
int \hyperlink{talker__mrp__client_8h_a9c244bc9e37fdc937cd38b09307003d7}{mrp\+\_\+disconnect} (struct \hyperlink{structmrp__talker__ctx}{mrp\+\_\+talker\+\_\+ctx} $\ast$\hyperlink{jack_8h_a1cde2a2cf8a56164b5e83159035be03b}{ctx})
\item 
int \hyperlink{talker__mrp__client_8h_ad06b236726820804f4273102e9177efd}{mrp\+\_\+register\+\_\+domain} (struct \hyperlink{structmrp__domain__attr}{mrp\+\_\+domain\+\_\+attr} $\ast$reg\+\_\+class, struct \hyperlink{structmrp__talker__ctx}{mrp\+\_\+talker\+\_\+ctx} $\ast$\hyperlink{jack_8h_a1cde2a2cf8a56164b5e83159035be03b}{ctx})
\item 
int \hyperlink{talker__mrp__client_8h_a5a1dbea67f6c32ce5de65b8f5d51c2de}{mrp\+\_\+join\+\_\+vlan} (struct \hyperlink{structmrp__domain__attr}{mrp\+\_\+domain\+\_\+attr} $\ast$reg\+\_\+class, struct \hyperlink{structmrp__talker__ctx}{mrp\+\_\+talker\+\_\+ctx} $\ast$\hyperlink{jack_8h_a1cde2a2cf8a56164b5e83159035be03b}{ctx})
\item 
int \hyperlink{talker__mrp__client_8h_a3677b13e5eb218df9fd6b310313439da}{mrp\+\_\+advertise\+\_\+stream} (\hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} $\ast$streamid, \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} $\ast$destaddr, int pktsz, int interval, int latency, struct \hyperlink{structmrp__talker__ctx}{mrp\+\_\+talker\+\_\+ctx} $\ast$\hyperlink{jack_8h_a1cde2a2cf8a56164b5e83159035be03b}{ctx})
\item 
int \hyperlink{talker__mrp__client_8h_ad07070e607ae7c6127ffb3cc3e6e1d7b}{mrp\+\_\+unadvertise\+\_\+stream} (\hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} $\ast$streamid, \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} $\ast$destaddr, int pktsz, int interval, int latency, struct \hyperlink{structmrp__talker__ctx}{mrp\+\_\+talker\+\_\+ctx} $\ast$\hyperlink{jack_8h_a1cde2a2cf8a56164b5e83159035be03b}{ctx})
\item 
int \hyperlink{talker__mrp__client_8h_af1c01cfeeb99c9ebffcbc301aa5784e2}{mrp\+\_\+await\+\_\+listener} (unsigned char $\ast$streamid, struct \hyperlink{structmrp__talker__ctx}{mrp\+\_\+talker\+\_\+ctx} $\ast$\hyperlink{jack_8h_a1cde2a2cf8a56164b5e83159035be03b}{ctx})
\item 
int \hyperlink{talker__mrp__client_8h_aeb2be83ee100a0241552a07a7d91f4e0}{mrp\+\_\+get\+\_\+domain} (struct \hyperlink{structmrp__talker__ctx}{mrp\+\_\+talker\+\_\+ctx} $\ast$\hyperlink{jack_8h_a1cde2a2cf8a56164b5e83159035be03b}{ctx}, struct \hyperlink{structmrp__domain__attr}{mrp\+\_\+domain\+\_\+attr} $\ast$class\+\_\+a, struct \hyperlink{structmrp__domain__attr}{mrp\+\_\+domain\+\_\+attr} $\ast$class\+\_\+b)
\item 
int \hyperlink{talker__mrp__client_8h_a74c2fc24c07fa72e2fd10a3a98f9dc9d}{mrp\+\_\+talker\+\_\+client\+\_\+init} (struct \hyperlink{structmrp__talker__ctx}{mrp\+\_\+talker\+\_\+ctx} $\ast$\hyperlink{jack_8h_a1cde2a2cf8a56164b5e83159035be03b}{ctx})
\end{DoxyCompactItemize}
\subsection*{변수}
\begin{DoxyCompactItemize}
\item 
volatile int \hyperlink{talker__mrp__client_8h_a7e0861f30a3dba1eb162e77371fe9c21}{mrp\+\_\+error}
\end{DoxyCompactItemize}


\subsection{함수 문서화}
\index{talker\+\_\+mrp\+\_\+client.\+h@{talker\+\_\+mrp\+\_\+client.\+h}!mrp\+\_\+advertise\+\_\+stream@{mrp\+\_\+advertise\+\_\+stream}}
\index{mrp\+\_\+advertise\+\_\+stream@{mrp\+\_\+advertise\+\_\+stream}!talker\+\_\+mrp\+\_\+client.\+h@{talker\+\_\+mrp\+\_\+client.\+h}}
\subsubsection[{\texorpdfstring{mrp\+\_\+advertise\+\_\+stream(uint8\+\_\+t $\ast$streamid, uint8\+\_\+t $\ast$destaddr, int pktsz, int interval, int latency, struct mrp\+\_\+talker\+\_\+ctx $\ast$ctx)}{mrp_advertise_stream(uint8_t *streamid, uint8_t *destaddr, int pktsz, int interval, int latency, struct mrp_talker_ctx *ctx)}}]{\setlength{\rightskip}{0pt plus 5cm}int mrp\+\_\+advertise\+\_\+stream (
\begin{DoxyParamCaption}
\item[{{\bf uint8\+\_\+t} $\ast$}]{streamid, }
\item[{{\bf uint8\+\_\+t} $\ast$}]{destaddr, }
\item[{int}]{pktsz, }
\item[{int}]{interval, }
\item[{int}]{latency, }
\item[{struct {\bf mrp\+\_\+talker\+\_\+ctx} $\ast$}]{ctx}
\end{DoxyParamCaption}
)}\hypertarget{talker__mrp__client_8h_a3677b13e5eb218df9fd6b310313439da}{}\label{talker__mrp__client_8h_a3677b13e5eb218df9fd6b310313439da}


talker\+\_\+mrp\+\_\+client.\+c 파일의 425 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
428 \{
429     \textcolor{keywordtype}{char} *\hyperlink{mrp_validate_8c_a3820841c4bbf28f04505bea65d6b84f7}{msgbuf};
430     \textcolor{keywordtype}{int} rc;
431 
432     msgbuf = \hyperlink{_memory_leak_detector_malloc_macros_8h_ab8b25cd8f16d4a6552afe4e65c4f082d}{malloc}(1500);
433     \textcolor{keywordflow}{if} (\hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} == msgbuf)
434         \textcolor{keywordflow}{return} -1;
435     memset(msgbuf, 0, 1500);
436 
437     sprintf(msgbuf, \textcolor{stringliteral}{"S++:S=%02X%02X%02X%02X%02X%02X%02X%02X"}
438         \textcolor{stringliteral}{",A=%02X%02X%02X%02X%02X%02X"}
439         \textcolor{stringliteral}{",V=%04X"}
440         \textcolor{stringliteral}{",Z=%d"}
441         \textcolor{stringliteral}{",I=%d"}
442         \textcolor{stringliteral}{",P=%d"}
443         \textcolor{stringliteral}{",L=%d"}, streamid[0], streamid[1], streamid[2],
444         streamid[3], streamid[4], streamid[5], streamid[6],
445         streamid[7], destaddr[0], destaddr[1], destaddr[2],
446         destaddr[3], destaddr[4], destaddr[5], ctx->\hyperlink{structmrp__talker__ctx_ac575246135a50baaf0c802ef29aa2779}{domain\_class\_a\_vid}, pktsz,
447         interval, ctx->\hyperlink{structmrp__talker__ctx_ac98b99ec0ffd190c1da93e6caffe36d4}{domain\_class\_a\_priority} << 5, latency);
448     \hyperlink{talker__mrp__client_8c_a5238adacbd2c4d99b6238f3e4ad554ca}{mrp\_okay} = 0;
449     rc = \hyperlink{talker__mrp__client_8c_adb1f8eb8ae4f2e22f8c4219da68f2eb0}{send\_mrp\_msg}(msgbuf, 1500, ctx);
450     \hyperlink{_memory_leak_detector_malloc_macros_8h_aa7157aa9480bb73f090dca36776419bf}{free}(msgbuf);
451 
452     \textcolor{keywordflow}{if} (rc != 1500)
453         \textcolor{keywordflow}{return} -1;
454     \textcolor{keywordflow}{else}
455         \textcolor{keywordflow}{return} 0;
456 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=312pt]{talker__mrp__client_8h_a3677b13e5eb218df9fd6b310313439da_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{talker__mrp__client_8h_a3677b13e5eb218df9fd6b310313439da_icgraph}
\end{center}
\end{figure}


\index{talker\+\_\+mrp\+\_\+client.\+h@{talker\+\_\+mrp\+\_\+client.\+h}!mrp\+\_\+await\+\_\+listener@{mrp\+\_\+await\+\_\+listener}}
\index{mrp\+\_\+await\+\_\+listener@{mrp\+\_\+await\+\_\+listener}!talker\+\_\+mrp\+\_\+client.\+h@{talker\+\_\+mrp\+\_\+client.\+h}}
\subsubsection[{\texorpdfstring{mrp\+\_\+await\+\_\+listener(unsigned char $\ast$streamid, struct mrp\+\_\+talker\+\_\+ctx $\ast$ctx)}{mrp_await_listener(unsigned char *streamid, struct mrp_talker_ctx *ctx)}}]{\setlength{\rightskip}{0pt plus 5cm}int mrp\+\_\+await\+\_\+listener (
\begin{DoxyParamCaption}
\item[{unsigned char $\ast$}]{streamid, }
\item[{struct {\bf mrp\+\_\+talker\+\_\+ctx} $\ast$}]{ctx}
\end{DoxyParamCaption}
)}\hypertarget{talker__mrp__client_8h_af1c01cfeeb99c9ebffcbc301aa5784e2}{}\label{talker__mrp__client_8h_af1c01cfeeb99c9ebffcbc301aa5784e2}


talker\+\_\+mrp\+\_\+client.\+c 파일의 491 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
492 \{
493     \textcolor{keywordtype}{char} *\hyperlink{mrp_validate_8c_a3820841c4bbf28f04505bea65d6b84f7}{msgbuf};
494     \textcolor{keywordtype}{int} rc;
495 
496     memcpy(ctx->\hyperlink{structmrp__talker__ctx_a0be105011a16541a479847730d7321c9}{monitor\_stream\_id}, streamid, \textcolor{keyword}{sizeof}(ctx->
      \hyperlink{structmrp__talker__ctx_a0be105011a16541a479847730d7321c9}{monitor\_stream\_id}));
497     msgbuf = \hyperlink{_memory_leak_detector_malloc_macros_8h_ab8b25cd8f16d4a6552afe4e65c4f082d}{malloc}(1500);
498     \textcolor{keywordflow}{if} (\hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} == msgbuf)
499         \textcolor{keywordflow}{return} -1;
500     memset(msgbuf, 0, 1500);
501     sprintf(msgbuf, \textcolor{stringliteral}{"S??"});
502     rc = \hyperlink{talker__mrp__client_8c_adb1f8eb8ae4f2e22f8c4219da68f2eb0}{send\_mrp\_msg}(msgbuf, 1500, ctx);
503     \hyperlink{_memory_leak_detector_malloc_macros_8h_aa7157aa9480bb73f090dca36776419bf}{free}(msgbuf);
504     \textcolor{keywordflow}{if} (rc != 1500)
505         \textcolor{keywordflow}{return} -1;
506 
507     \textcolor{comment}{/* either already there ... or need to wait ... */}
508     \textcolor{keywordflow}{while} (!ctx->\hyperlink{structmrp__talker__ctx_a7c8176263e9704aa667fc335cc818a3f}{halt\_tx} && (ctx->\hyperlink{structmrp__talker__ctx_a70763450542106f6508fd1051eade47d}{listeners} == 0))
509         usleep(20000);
510 
511     \textcolor{keywordflow}{return} 0;
512 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=297pt]{talker__mrp__client_8h_af1c01cfeeb99c9ebffcbc301aa5784e2_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=252pt]{talker__mrp__client_8h_af1c01cfeeb99c9ebffcbc301aa5784e2_icgraph}
\end{center}
\end{figure}


\index{talker\+\_\+mrp\+\_\+client.\+h@{talker\+\_\+mrp\+\_\+client.\+h}!mrp\+\_\+connect@{mrp\+\_\+connect}}
\index{mrp\+\_\+connect@{mrp\+\_\+connect}!talker\+\_\+mrp\+\_\+client.\+h@{talker\+\_\+mrp\+\_\+client.\+h}}
\subsubsection[{\texorpdfstring{mrp\+\_\+connect(struct mrp\+\_\+talker\+\_\+ctx $\ast$ctx)}{mrp_connect(struct mrp_talker_ctx *ctx)}}]{\setlength{\rightskip}{0pt plus 5cm}int mrp\+\_\+connect (
\begin{DoxyParamCaption}
\item[{struct {\bf mrp\+\_\+talker\+\_\+ctx} $\ast$}]{ctx}
\end{DoxyParamCaption}
)}\hypertarget{talker__mrp__client_8h_aa94a906b50f9aca85cb00a18235c627f}{}\label{talker__mrp__client_8h_aa94a906b50f9aca85cb00a18235c627f}


talker\+\_\+mrp\+\_\+client.\+c 파일의 350 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
351 \{
352     \textcolor{keyword}{struct }sockaddr\_in addr;
353     \textcolor{keywordtype}{int} sock\_fd = -1;
354     \textcolor{keywordtype}{int} rc;
355     sock\_fd = socket(AF\_INET, SOCK\_DGRAM, IPPROTO\_UDP);
356     \textcolor{keywordflow}{if} (sock\_fd < 0)
357         \textcolor{keywordflow}{goto} \hyperlink{jack__listener_8c_a1cdcf0ac9be9edf74b8fcedb01e26cf3}{out};
358     memset(&addr, 0, \textcolor{keyword}{sizeof}(addr));
359     addr.sin\_family = AF\_INET;
360     addr.sin\_port = htons(\hyperlink{mrpd_8h_a957ecb95a01b342339073f6422eb2bf9}{MRPD\_PORT\_DEFAULT});
361     inet\_aton(\textcolor{stringliteral}{"127.0.0.1"}, &addr.sin\_addr);
362     memset(&addr, 0, \textcolor{keyword}{sizeof}(addr));
363     ctx->\hyperlink{structmrp__talker__ctx_ab16a0c776c464dcfb5cf8a013a137647}{control\_socket} = sock\_fd;
364     rc = pthread\_attr\_init(&\hyperlink{talker__mrp__client_8c_a6c7e3f190d4c6369f0a70172f95416dd}{monitor\_attr});
365     rc |= pthread\_create(&\hyperlink{talker__mrp__client_8c_afbd6fc6e0ab3c1a04a518f19c21d4503}{monitor\_thread}, \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}, 
      \hyperlink{talker__mrp__client_8c_afdd2d7bcf3cde2ab45b078d253558c2d}{mrp\_monitor\_thread}, ctx);
366     \textcolor{keywordflow}{return} rc;
367     \textcolor{keywordflow}{return} 0;
368  \hyperlink{jack__listener_8c_a1cdcf0ac9be9edf74b8fcedb01e26cf3}{out}:    \textcolor{keywordflow}{if} (sock\_fd != -1)
369         close(sock\_fd);
370     sock\_fd = -1;
371     \textcolor{keywordflow}{return} -1;
372 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{talker__mrp__client_8h_aa94a906b50f9aca85cb00a18235c627f_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{talker__mrp__client_8h_aa94a906b50f9aca85cb00a18235c627f_icgraph}
\end{center}
\end{figure}


\index{talker\+\_\+mrp\+\_\+client.\+h@{talker\+\_\+mrp\+\_\+client.\+h}!mrp\+\_\+disconnect@{mrp\+\_\+disconnect}}
\index{mrp\+\_\+disconnect@{mrp\+\_\+disconnect}!talker\+\_\+mrp\+\_\+client.\+h@{talker\+\_\+mrp\+\_\+client.\+h}}
\subsubsection[{\texorpdfstring{mrp\+\_\+disconnect(struct mrp\+\_\+talker\+\_\+ctx $\ast$ctx)}{mrp_disconnect(struct mrp_talker_ctx *ctx)}}]{\setlength{\rightskip}{0pt plus 5cm}int mrp\+\_\+disconnect (
\begin{DoxyParamCaption}
\item[{struct {\bf mrp\+\_\+talker\+\_\+ctx} $\ast$}]{ctx}
\end{DoxyParamCaption}
)}\hypertarget{talker__mrp__client_8h_a9c244bc9e37fdc937cd38b09307003d7}{}\label{talker__mrp__client_8h_a9c244bc9e37fdc937cd38b09307003d7}


talker\+\_\+mrp\+\_\+client.\+c 파일의 374 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
375 \{
376     \textcolor{keywordtype}{char} *\hyperlink{mrp_validate_8c_a3820841c4bbf28f04505bea65d6b84f7}{msgbuf};
377     \textcolor{keywordtype}{int} rc;
378 
379     msgbuf = \hyperlink{_memory_leak_detector_malloc_macros_8h_ab8b25cd8f16d4a6552afe4e65c4f082d}{malloc}(1500);
380     \textcolor{keywordflow}{if} (\hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} == msgbuf)
381         \textcolor{keywordflow}{return} -1;
382     memset(msgbuf, 0, 64);
383     sprintf(msgbuf, \textcolor{stringliteral}{"BYE"});
384     \hyperlink{talker__mrp__client_8c_a5238adacbd2c4d99b6238f3e4ad554ca}{mrp\_okay} = 0;
385     rc = \hyperlink{talker__mrp__client_8c_adb1f8eb8ae4f2e22f8c4219da68f2eb0}{send\_mrp\_msg}(msgbuf, 1500, ctx);
386     \hyperlink{_memory_leak_detector_malloc_macros_8h_aa7157aa9480bb73f090dca36776419bf}{free}(msgbuf);
387 
388     \textcolor{keywordflow}{if} (rc != 1500)
389         \textcolor{keywordflow}{return} -1;
390     \textcolor{keywordflow}{else}
391         \textcolor{keywordflow}{return} 0;
392 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=285pt]{talker__mrp__client_8h_a9c244bc9e37fdc937cd38b09307003d7_cgraph}
\end{center}
\end{figure}


\index{talker\+\_\+mrp\+\_\+client.\+h@{talker\+\_\+mrp\+\_\+client.\+h}!mrp\+\_\+get\+\_\+domain@{mrp\+\_\+get\+\_\+domain}}
\index{mrp\+\_\+get\+\_\+domain@{mrp\+\_\+get\+\_\+domain}!talker\+\_\+mrp\+\_\+client.\+h@{talker\+\_\+mrp\+\_\+client.\+h}}
\subsubsection[{\texorpdfstring{mrp\+\_\+get\+\_\+domain(struct mrp\+\_\+talker\+\_\+ctx $\ast$ctx, struct mrp\+\_\+domain\+\_\+attr $\ast$class\+\_\+a, struct mrp\+\_\+domain\+\_\+attr $\ast$class\+\_\+b)}{mrp_get_domain(struct mrp_talker_ctx *ctx, struct mrp_domain_attr *class_a, struct mrp_domain_attr *class_b)}}]{\setlength{\rightskip}{0pt plus 5cm}int mrp\+\_\+get\+\_\+domain (
\begin{DoxyParamCaption}
\item[{struct {\bf mrp\+\_\+talker\+\_\+ctx} $\ast$}]{ctx, }
\item[{struct {\bf mrp\+\_\+domain\+\_\+attr} $\ast$}]{class\+\_\+a, }
\item[{struct {\bf mrp\+\_\+domain\+\_\+attr} $\ast$}]{class\+\_\+b}
\end{DoxyParamCaption}
)}\hypertarget{talker__mrp__client_8h_aeb2be83ee100a0241552a07a7d91f4e0}{}\label{talker__mrp__client_8h_aeb2be83ee100a0241552a07a7d91f4e0}


talker\+\_\+mrp\+\_\+client.\+c 파일의 518 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
519 \{
520     \textcolor{keywordtype}{char} *\hyperlink{mrp_validate_8c_a3820841c4bbf28f04505bea65d6b84f7}{msgbuf};
521     \textcolor{keywordtype}{int} ret;
522 
523     \textcolor{comment}{/* we may not get a notification if we are joining late,}
524 \textcolor{comment}{     * so query for what is already there ...}
525 \textcolor{comment}{     */}
526     msgbuf = \hyperlink{_memory_leak_detector_malloc_macros_8h_ab8b25cd8f16d4a6552afe4e65c4f082d}{malloc}(1500);
527     \textcolor{keywordflow}{if} (\hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} == msgbuf)
528         \textcolor{keywordflow}{return} -1;
529     memset(msgbuf, 0, 1500);
530     sprintf(msgbuf, \textcolor{stringliteral}{"S??"});
531     ret = \hyperlink{talker__mrp__client_8c_adb1f8eb8ae4f2e22f8c4219da68f2eb0}{send\_mrp\_msg}(msgbuf, 1500, ctx);
532     \hyperlink{_memory_leak_detector_malloc_macros_8h_aa7157aa9480bb73f090dca36776419bf}{free}(msgbuf);
533     \textcolor{keywordflow}{if} (ret != 1500)
534         \textcolor{keywordflow}{return} -1;
535     \textcolor{keywordflow}{while} (!ctx->\hyperlink{structmrp__talker__ctx_a7c8176263e9704aa667fc335cc818a3f}{halt\_tx} && (ctx->\hyperlink{structmrp__talker__ctx_ae3be05692572d8c757174629541e2d91}{domain\_a\_valid} == 0) && (ctx->
      \hyperlink{structmrp__talker__ctx_add1f58f9a17de764566dbf2e352b907f}{domain\_b\_valid} == 0))
536         usleep(20000);
537     class\_a->\hyperlink{structmrp__domain__attr_a7441ef0865bcb3db9b8064dd7375c1ea}{id} = 0;
538     class\_a->\hyperlink{structmrp__domain__attr_acec9ce2df15222151ad66fcb1d74eb9f}{priority} = 0;
539     class\_a->\hyperlink{structmrp__domain__attr_a066fae47f1854479570ecc0bf7e488c3}{vid} = 0;
540     class\_b->\hyperlink{structmrp__domain__attr_a7441ef0865bcb3db9b8064dd7375c1ea}{id} = 0;
541     class\_b->\hyperlink{structmrp__domain__attr_acec9ce2df15222151ad66fcb1d74eb9f}{priority} = 0;
542     class\_b->\hyperlink{structmrp__domain__attr_a066fae47f1854479570ecc0bf7e488c3}{vid} = 0;
543     \textcolor{keywordflow}{if} (ctx->\hyperlink{structmrp__talker__ctx_ae3be05692572d8c757174629541e2d91}{domain\_a\_valid}) \{
544         class\_a->\hyperlink{structmrp__domain__attr_a7441ef0865bcb3db9b8064dd7375c1ea}{id} = ctx->\hyperlink{structmrp__talker__ctx_a6e4374793667e90915abfe73f0e6201c}{domain\_class\_a\_id};
545         class\_a->\hyperlink{structmrp__domain__attr_acec9ce2df15222151ad66fcb1d74eb9f}{priority} = ctx->\hyperlink{structmrp__talker__ctx_ac98b99ec0ffd190c1da93e6caffe36d4}{domain\_class\_a\_priority};
546         class\_a->\hyperlink{structmrp__domain__attr_a066fae47f1854479570ecc0bf7e488c3}{vid} = ctx->\hyperlink{structmrp__talker__ctx_ac575246135a50baaf0c802ef29aa2779}{domain\_class\_a\_vid};
547     \}
548     \textcolor{keywordflow}{if} (ctx->\hyperlink{structmrp__talker__ctx_add1f58f9a17de764566dbf2e352b907f}{domain\_b\_valid}) \{
549         class\_b->\hyperlink{structmrp__domain__attr_a7441ef0865bcb3db9b8064dd7375c1ea}{id} = ctx->\hyperlink{structmrp__talker__ctx_a058aabd498c78e32b6610fd06f90fc43}{domain\_class\_b\_id};
550         class\_b->\hyperlink{structmrp__domain__attr_acec9ce2df15222151ad66fcb1d74eb9f}{priority} = ctx->\hyperlink{structmrp__talker__ctx_a90efafdfc3b16f51cc0f67aa65796a3c}{domain\_class\_b\_priority};
551         class\_b->\hyperlink{structmrp__domain__attr_a066fae47f1854479570ecc0bf7e488c3}{vid} = ctx->\hyperlink{structmrp__talker__ctx_a153312a7212b932f60b49a67309f2053}{domain\_class\_b\_vid};
552     \}
553     \textcolor{keywordflow}{return} 0;
554 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=288pt]{talker__mrp__client_8h_aeb2be83ee100a0241552a07a7d91f4e0_cgraph}
\end{center}
\end{figure}


\index{talker\+\_\+mrp\+\_\+client.\+h@{talker\+\_\+mrp\+\_\+client.\+h}!mrp\+\_\+join\+\_\+vlan@{mrp\+\_\+join\+\_\+vlan}}
\index{mrp\+\_\+join\+\_\+vlan@{mrp\+\_\+join\+\_\+vlan}!talker\+\_\+mrp\+\_\+client.\+h@{talker\+\_\+mrp\+\_\+client.\+h}}
\subsubsection[{\texorpdfstring{mrp\+\_\+join\+\_\+vlan(struct mrp\+\_\+domain\+\_\+attr $\ast$reg\+\_\+class, struct mrp\+\_\+talker\+\_\+ctx $\ast$ctx)}{mrp_join_vlan(struct mrp_domain_attr *reg_class, struct mrp_talker_ctx *ctx)}}]{\setlength{\rightskip}{0pt plus 5cm}int mrp\+\_\+join\+\_\+vlan (
\begin{DoxyParamCaption}
\item[{struct {\bf mrp\+\_\+domain\+\_\+attr} $\ast$}]{reg\+\_\+class, }
\item[{struct {\bf mrp\+\_\+talker\+\_\+ctx} $\ast$}]{ctx}
\end{DoxyParamCaption}
)}\hypertarget{talker__mrp__client_8h_a5a1dbea67f6c32ce5de65b8f5d51c2de}{}\label{talker__mrp__client_8h_a5a1dbea67f6c32ce5de65b8f5d51c2de}


talker\+\_\+mrp\+\_\+client.\+c 파일의 556 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
557 \{
558     \textcolor{keywordtype}{char} *\hyperlink{mrp_validate_8c_a3820841c4bbf28f04505bea65d6b84f7}{msgbuf};
559     \textcolor{keywordtype}{int} rc;
560 
561     msgbuf = \hyperlink{_memory_leak_detector_malloc_macros_8h_ab8b25cd8f16d4a6552afe4e65c4f082d}{malloc}(1500);
562     \textcolor{keywordflow}{if} (\hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} == msgbuf)
563         \textcolor{keywordflow}{return} -1;
564     memset(msgbuf, 0, 1500);
565     sprintf(msgbuf, \textcolor{stringliteral}{"V++:I=%04x\(\backslash\)n"},reg\_class->\hyperlink{structmrp__domain__attr_a066fae47f1854479570ecc0bf7e488c3}{vid});
566     rc = \hyperlink{talker__mrp__client_8c_adb1f8eb8ae4f2e22f8c4219da68f2eb0}{send\_mrp\_msg}(msgbuf, 1500, ctx);
567     \hyperlink{_memory_leak_detector_malloc_macros_8h_aa7157aa9480bb73f090dca36776419bf}{free}(msgbuf);
568 
569     \textcolor{keywordflow}{if} (rc != 1500)
570         \textcolor{keywordflow}{return} -1;
571     \textcolor{keywordflow}{else}
572         \textcolor{keywordflow}{return} 0;
573 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=276pt]{talker__mrp__client_8h_a5a1dbea67f6c32ce5de65b8f5d51c2de_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{talker__mrp__client_8h_a5a1dbea67f6c32ce5de65b8f5d51c2de_icgraph}
\end{center}
\end{figure}


\index{talker\+\_\+mrp\+\_\+client.\+h@{talker\+\_\+mrp\+\_\+client.\+h}!mrp\+\_\+register\+\_\+domain@{mrp\+\_\+register\+\_\+domain}}
\index{mrp\+\_\+register\+\_\+domain@{mrp\+\_\+register\+\_\+domain}!talker\+\_\+mrp\+\_\+client.\+h@{talker\+\_\+mrp\+\_\+client.\+h}}
\subsubsection[{\texorpdfstring{mrp\+\_\+register\+\_\+domain(struct mrp\+\_\+domain\+\_\+attr $\ast$reg\+\_\+class, struct mrp\+\_\+talker\+\_\+ctx $\ast$ctx)}{mrp_register_domain(struct mrp_domain_attr *reg_class, struct mrp_talker_ctx *ctx)}}]{\setlength{\rightskip}{0pt plus 5cm}int mrp\+\_\+register\+\_\+domain (
\begin{DoxyParamCaption}
\item[{struct {\bf mrp\+\_\+domain\+\_\+attr} $\ast$}]{reg\+\_\+class, }
\item[{struct {\bf mrp\+\_\+talker\+\_\+ctx} $\ast$}]{ctx}
\end{DoxyParamCaption}
)}\hypertarget{talker__mrp__client_8h_ad06b236726820804f4273102e9177efd}{}\label{talker__mrp__client_8h_ad06b236726820804f4273102e9177efd}


talker\+\_\+mrp\+\_\+client.\+c 파일의 402 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
403 \{
404     \textcolor{keywordtype}{char} *\hyperlink{mrp_validate_8c_a3820841c4bbf28f04505bea65d6b84f7}{msgbuf};
405     \textcolor{keywordtype}{int} rc;
406 
407     msgbuf = \hyperlink{_memory_leak_detector_malloc_macros_8h_ab8b25cd8f16d4a6552afe4e65c4f082d}{malloc}(1500);
408     \textcolor{keywordflow}{if} (\hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} == msgbuf)
409         \textcolor{keywordflow}{return} -1;
410     memset(msgbuf, 0, 1500);
411 
412     sprintf(msgbuf, \textcolor{stringliteral}{"S+D:C=%d,P=%d,V=%04x"}, reg\_class->\hyperlink{structmrp__domain__attr_a7441ef0865bcb3db9b8064dd7375c1ea}{id}, reg\_class->\hyperlink{structmrp__domain__attr_acec9ce2df15222151ad66fcb1d74eb9f}{priority}, reg\_class->
      \hyperlink{structmrp__domain__attr_a066fae47f1854479570ecc0bf7e488c3}{vid});
413     \hyperlink{talker__mrp__client_8c_a5238adacbd2c4d99b6238f3e4ad554ca}{mrp\_okay} = 0;
414     rc = \hyperlink{talker__mrp__client_8c_adb1f8eb8ae4f2e22f8c4219da68f2eb0}{send\_mrp\_msg}(msgbuf, 1500, ctx);
415     \hyperlink{_memory_leak_detector_malloc_macros_8h_aa7157aa9480bb73f090dca36776419bf}{free}(msgbuf);
416 
417     \textcolor{keywordflow}{if} (rc != 1500)
418         \textcolor{keywordflow}{return} -1;
419     \textcolor{keywordflow}{else}
420         \textcolor{keywordflow}{return} 0;
421 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=306pt]{talker__mrp__client_8h_ad06b236726820804f4273102e9177efd_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{talker__mrp__client_8h_ad06b236726820804f4273102e9177efd_icgraph}
\end{center}
\end{figure}


\index{talker\+\_\+mrp\+\_\+client.\+h@{talker\+\_\+mrp\+\_\+client.\+h}!mrp\+\_\+talker\+\_\+client\+\_\+init@{mrp\+\_\+talker\+\_\+client\+\_\+init}}
\index{mrp\+\_\+talker\+\_\+client\+\_\+init@{mrp\+\_\+talker\+\_\+client\+\_\+init}!talker\+\_\+mrp\+\_\+client.\+h@{talker\+\_\+mrp\+\_\+client.\+h}}
\subsubsection[{\texorpdfstring{mrp\+\_\+talker\+\_\+client\+\_\+init(struct mrp\+\_\+talker\+\_\+ctx $\ast$ctx)}{mrp_talker_client_init(struct mrp_talker_ctx *ctx)}}]{\setlength{\rightskip}{0pt plus 5cm}int mrp\+\_\+talker\+\_\+client\+\_\+init (
\begin{DoxyParamCaption}
\item[{struct {\bf mrp\+\_\+talker\+\_\+ctx} $\ast$}]{ctx}
\end{DoxyParamCaption}
)}\hypertarget{talker__mrp__client_8h_a74c2fc24c07fa72e2fd10a3a98f9dc9d}{}\label{talker__mrp__client_8h_a74c2fc24c07fa72e2fd10a3a98f9dc9d}


talker\+\_\+mrp\+\_\+client.\+c 파일의 49 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
50 \{
51     \textcolor{keywordtype}{int} i;
52     ctx->\hyperlink{structmrp__talker__ctx_ab16a0c776c464dcfb5cf8a013a137647}{control\_socket} = -1;
53     ctx->\hyperlink{structmrp__talker__ctx_a7c8176263e9704aa667fc335cc818a3f}{halt\_tx} = 0;
54     ctx->\hyperlink{structmrp__talker__ctx_a70763450542106f6508fd1051eade47d}{listeners} = 0;
55     ctx->\hyperlink{structmrp__talker__ctx_ae3be05692572d8c757174629541e2d91}{domain\_a\_valid} = 0;
56     ctx->\hyperlink{structmrp__talker__ctx_a6e4374793667e90915abfe73f0e6201c}{domain\_class\_a\_id} = 0;
57     ctx->\hyperlink{structmrp__talker__ctx_ac98b99ec0ffd190c1da93e6caffe36d4}{domain\_class\_a\_priority} = 0;
58     ctx->\hyperlink{structmrp__talker__ctx_ac575246135a50baaf0c802ef29aa2779}{domain\_class\_a\_vid} = 0;
59     ctx->\hyperlink{structmrp__talker__ctx_add1f58f9a17de764566dbf2e352b907f}{domain\_b\_valid} = 0;
60     ctx->\hyperlink{structmrp__talker__ctx_a058aabd498c78e32b6610fd06f90fc43}{domain\_class\_b\_id} = 0;
61     ctx->\hyperlink{structmrp__talker__ctx_a90efafdfc3b16f51cc0f67aa65796a3c}{domain\_class\_b\_priority} = 0;
62     ctx->\hyperlink{structmrp__talker__ctx_a153312a7212b932f60b49a67309f2053}{domain\_class\_b\_vid} = 0;
63     \textcolor{keywordflow}{for} (i=0;i<8;i++)
64     \{
65         ctx->\hyperlink{structmrp__talker__ctx_a0be105011a16541a479847730d7321c9}{monitor\_stream\_id}[i] = 0;
66     \}
67     \textcolor{keywordflow}{return} 0;
68 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=263pt]{talker__mrp__client_8h_a74c2fc24c07fa72e2fd10a3a98f9dc9d_icgraph}
\end{center}
\end{figure}


\index{talker\+\_\+mrp\+\_\+client.\+h@{talker\+\_\+mrp\+\_\+client.\+h}!mrp\+\_\+unadvertise\+\_\+stream@{mrp\+\_\+unadvertise\+\_\+stream}}
\index{mrp\+\_\+unadvertise\+\_\+stream@{mrp\+\_\+unadvertise\+\_\+stream}!talker\+\_\+mrp\+\_\+client.\+h@{talker\+\_\+mrp\+\_\+client.\+h}}
\subsubsection[{\texorpdfstring{mrp\+\_\+unadvertise\+\_\+stream(uint8\+\_\+t $\ast$streamid, uint8\+\_\+t $\ast$destaddr, int pktsz, int interval, int latency, struct mrp\+\_\+talker\+\_\+ctx $\ast$ctx)}{mrp_unadvertise_stream(uint8_t *streamid, uint8_t *destaddr, int pktsz, int interval, int latency, struct mrp_talker_ctx *ctx)}}]{\setlength{\rightskip}{0pt plus 5cm}int mrp\+\_\+unadvertise\+\_\+stream (
\begin{DoxyParamCaption}
\item[{{\bf uint8\+\_\+t} $\ast$}]{streamid, }
\item[{{\bf uint8\+\_\+t} $\ast$}]{destaddr, }
\item[{int}]{pktsz, }
\item[{int}]{interval, }
\item[{int}]{latency, }
\item[{struct {\bf mrp\+\_\+talker\+\_\+ctx} $\ast$}]{ctx}
\end{DoxyParamCaption}
)}\hypertarget{talker__mrp__client_8h_ad07070e607ae7c6127ffb3cc3e6e1d7b}{}\label{talker__mrp__client_8h_ad07070e607ae7c6127ffb3cc3e6e1d7b}


talker\+\_\+mrp\+\_\+client.\+c 파일의 459 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
462 \{
463     \textcolor{keywordtype}{char} *\hyperlink{mrp_validate_8c_a3820841c4bbf28f04505bea65d6b84f7}{msgbuf};
464     \textcolor{keywordtype}{int} rc;
465     msgbuf = \hyperlink{_memory_leak_detector_malloc_macros_8h_ab8b25cd8f16d4a6552afe4e65c4f082d}{malloc}(1500);
466     \textcolor{keywordflow}{if} (\hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} == msgbuf)
467         \textcolor{keywordflow}{return} -1;
468     memset(msgbuf, 0, 1500);
469     sprintf(msgbuf, \textcolor{stringliteral}{"S--:S=%02X%02X%02X%02X%02X%02X%02X%02X"}
470         \textcolor{stringliteral}{",A=%02X%02X%02X%02X%02X%02X"}
471         \textcolor{stringliteral}{",V=%04X"}
472         \textcolor{stringliteral}{",Z=%d"}
473         \textcolor{stringliteral}{",I=%d"}
474         \textcolor{stringliteral}{",P=%d"}
475         \textcolor{stringliteral}{",L=%d"}, streamid[0], streamid[1], streamid[2],
476         streamid[3], streamid[4], streamid[5], streamid[6],
477         streamid[7], destaddr[0], destaddr[1], destaddr[2],
478         destaddr[3], destaddr[4], destaddr[5], ctx->\hyperlink{structmrp__talker__ctx_ac575246135a50baaf0c802ef29aa2779}{domain\_class\_a\_vid}, pktsz,
479         interval, ctx->\hyperlink{structmrp__talker__ctx_ac98b99ec0ffd190c1da93e6caffe36d4}{domain\_class\_a\_priority} << 5, latency);
480     \hyperlink{talker__mrp__client_8c_a5238adacbd2c4d99b6238f3e4ad554ca}{mrp\_okay} = 0;
481     rc = \hyperlink{talker__mrp__client_8c_adb1f8eb8ae4f2e22f8c4219da68f2eb0}{send\_mrp\_msg}(msgbuf, 1500, ctx);
482     \hyperlink{_memory_leak_detector_malloc_macros_8h_aa7157aa9480bb73f090dca36776419bf}{free}(msgbuf);
483 
484     \textcolor{keywordflow}{if} (rc != 1500)
485         \textcolor{keywordflow}{return} -1;
486     \textcolor{keywordflow}{else}
487         \textcolor{keywordflow}{return} 0;
488 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=323pt]{talker__mrp__client_8h_ad07070e607ae7c6127ffb3cc3e6e1d7b_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{talker__mrp__client_8h_ad07070e607ae7c6127ffb3cc3e6e1d7b_icgraph}
\end{center}
\end{figure}




\subsection{변수 문서화}
\index{talker\+\_\+mrp\+\_\+client.\+h@{talker\+\_\+mrp\+\_\+client.\+h}!mrp\+\_\+error@{mrp\+\_\+error}}
\index{mrp\+\_\+error@{mrp\+\_\+error}!talker\+\_\+mrp\+\_\+client.\+h@{talker\+\_\+mrp\+\_\+client.\+h}}
\subsubsection[{\texorpdfstring{mrp\+\_\+error}{mrp_error}}]{\setlength{\rightskip}{0pt plus 5cm}volatile int mrp\+\_\+error}\hypertarget{talker__mrp__client_8h_a7e0861f30a3dba1eb162e77371fe9c21}{}\label{talker__mrp__client_8h_a7e0861f30a3dba1eb162e77371fe9c21}


talker\+\_\+mrp\+\_\+client.\+c 파일의 40 번째 라인에서 정의되었습니다.

