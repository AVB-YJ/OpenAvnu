\hypertarget{eui64set_8c}{}\section{daemons/common/eui64set.c 파일 참조}
\label{eui64set_8c}\index{daemons/common/eui64set.\+c@{daemons/common/eui64set.\+c}}
{\ttfamily \#include $<$stdlib.\+h$>$}\\*
{\ttfamily \#include \char`\"{}eui64set.\+h\char`\"{}}\\*
eui64set.\+c에 대한 include 의존 그래프
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=232pt]{eui64set_8c__incl}
\end{center}
\end{figure}
\subsection*{함수}
\begin{DoxyCompactItemize}
\item 
\hyperlink{parse_8c_aec6fcb673ff035718c238c8c9d544c47}{uint64\+\_\+t} \hyperlink{eui64set_8c_a9e02507022ac2dc8b15405c07f95bd36}{eui64\+\_\+read} (const \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} network\+\_\+order\+\_\+buf\mbox{[}8\mbox{]})
\item 
void \hyperlink{eui64set_8c_a768ae76e5718339e9a3c96617ca475f2}{eui64\+\_\+write} (\hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} network\+\_\+order\+\_\+buf\mbox{[}8\mbox{]}, \hyperlink{parse_8c_aec6fcb673ff035718c238c8c9d544c47}{uint64\+\_\+t} v)
\item 
int \hyperlink{eui64set_8c_aa8465ef360165e86c8b69f3018082f39}{eui64set\+\_\+compare} (const void $\ast$lhs, const void $\ast$rhs)
\item 
int \hyperlink{eui64set_8c_ad8c59e8a5c7fdf2c0058e9e903d0b832}{eui64set\+\_\+init} (struct \hyperlink{structeui64set}{eui64set} $\ast$self, int max\+\_\+entries)
\item 
void \hyperlink{eui64set_8c_ae543ad67f4be3090b148e8d46b93f56d}{eui64set\+\_\+free} (struct \hyperlink{structeui64set}{eui64set} $\ast$self)
\item 
void \hyperlink{eui64set_8c_afc744baf3ea6cc3892550d7f93d55ea1}{eui64set\+\_\+clear} (struct \hyperlink{structeui64set}{eui64set} $\ast$self)
\item 
int \hyperlink{eui64set_8c_ae5cb65b5d47249fd6d83df78a9ba5657}{eui64set\+\_\+num\+\_\+entries} (struct \hyperlink{structeui64set}{eui64set} $\ast$self)
\item 
int \hyperlink{eui64set_8c_ad67e06485d8f012f4a8c7152f1fca5a6}{eui64set\+\_\+is\+\_\+full} (struct \hyperlink{structeui64set}{eui64set} $\ast$self)
\item 
int \hyperlink{eui64set_8c_a9ca76c2db111c7007960e9babb8d3321}{eui64set\+\_\+insert} (struct \hyperlink{structeui64set}{eui64set} $\ast$self, \hyperlink{parse_8c_aec6fcb673ff035718c238c8c9d544c47}{uint64\+\_\+t} value, void $\ast$p)
\item 
void \hyperlink{eui64set_8c_a1ce638b9c230ff24e27766ad272ada32}{eui64set\+\_\+sort} (struct \hyperlink{structeui64set}{eui64set} $\ast$self)
\item 
int \hyperlink{eui64set_8c_aa77f4331ee0a81d173d24451d8427fa6}{eui64set\+\_\+insert\+\_\+and\+\_\+sort} (struct \hyperlink{structeui64set}{eui64set} $\ast$self, \hyperlink{parse_8c_aec6fcb673ff035718c238c8c9d544c47}{uint64\+\_\+t} value, void $\ast$p)
\item 
const struct \hyperlink{structeui64set__entry}{eui64set\+\_\+entry} $\ast$ \hyperlink{eui64set_8c_a71cf81d10f8097ea3a243f1f0f223d12}{eui64set\+\_\+find} (const struct \hyperlink{structeui64set}{eui64set} $\ast$self, \hyperlink{parse_8c_aec6fcb673ff035718c238c8c9d544c47}{uint64\+\_\+t} value)
\item 
int \hyperlink{eui64set_8c_a18d3bfef233cc07c43f67f2706c99fa8}{eui64set\+\_\+remove\+\_\+and\+\_\+sort} (struct \hyperlink{structeui64set}{eui64set} $\ast$self, \hyperlink{parse_8c_aec6fcb673ff035718c238c8c9d544c47}{uint64\+\_\+t} value)
\end{DoxyCompactItemize}


\subsection{함수 문서화}
\index{eui64set.\+c@{eui64set.\+c}!eui64\+\_\+read@{eui64\+\_\+read}}
\index{eui64\+\_\+read@{eui64\+\_\+read}!eui64set.\+c@{eui64set.\+c}}
\subsubsection[{\texorpdfstring{eui64\+\_\+read(const uint8\+\_\+t network\+\_\+order\+\_\+buf[8])}{eui64_read(const uint8_t network_order_buf[8])}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint64\+\_\+t} eui64\+\_\+read (
\begin{DoxyParamCaption}
\item[{const {\bf uint8\+\_\+t}}]{network\+\_\+order\+\_\+buf\mbox{[}8\mbox{]}}
\end{DoxyParamCaption}
)}\hypertarget{eui64set_8c_a9e02507022ac2dc8b15405c07f95bd36}{}\label{eui64set_8c_a9e02507022ac2dc8b15405c07f95bd36}
eui64\+\_\+read Read a eui64 in network order Returns uint64\+\_\+t 

eui64set.\+c 파일의 36 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
37 \{
38     \hyperlink{parse_8c_aec6fcb673ff035718c238c8c9d544c47}{uint64\_t} v = 0;
39 
40     v = (((\hyperlink{parse_8c_aec6fcb673ff035718c238c8c9d544c47}{uint64\_t}) network\_order\_buf[0]) << 56)
41         + (((\hyperlink{parse_8c_aec6fcb673ff035718c238c8c9d544c47}{uint64\_t}) network\_order\_buf[1]) << 48)
42         + (((\hyperlink{parse_8c_aec6fcb673ff035718c238c8c9d544c47}{uint64\_t}) network\_order\_buf[2]) << 40)
43         + (((\hyperlink{parse_8c_aec6fcb673ff035718c238c8c9d544c47}{uint64\_t}) network\_order\_buf[3]) << 32)
44         + (((\hyperlink{parse_8c_aec6fcb673ff035718c238c8c9d544c47}{uint64\_t}) network\_order\_buf[4]) << 24)
45         + (((\hyperlink{parse_8c_aec6fcb673ff035718c238c8c9d544c47}{uint64\_t}) network\_order\_buf[5]) << 16)
46         + (((\hyperlink{parse_8c_aec6fcb673ff035718c238c8c9d544c47}{uint64\_t}) network\_order\_buf[6]) << 8)
47         + (((\hyperlink{parse_8c_aec6fcb673ff035718c238c8c9d544c47}{uint64\_t}) network\_order\_buf[7]) << 0);
48 
49     \textcolor{keywordflow}{return} v;
50 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{eui64set_8c_a9e02507022ac2dc8b15405c07f95bd36_icgraph}
\end{center}
\end{figure}


\index{eui64set.\+c@{eui64set.\+c}!eui64\+\_\+write@{eui64\+\_\+write}}
\index{eui64\+\_\+write@{eui64\+\_\+write}!eui64set.\+c@{eui64set.\+c}}
\subsubsection[{\texorpdfstring{eui64\+\_\+write(uint8\+\_\+t network\+\_\+order\+\_\+buf[8], uint64\+\_\+t v)}{eui64_write(uint8_t network_order_buf[8], uint64_t v)}}]{\setlength{\rightskip}{0pt plus 5cm}void eui64\+\_\+write (
\begin{DoxyParamCaption}
\item[{{\bf uint8\+\_\+t}}]{network\+\_\+order\+\_\+buf\mbox{[}8\mbox{]}, }
\item[{{\bf uint64\+\_\+t}}]{v}
\end{DoxyParamCaption}
)}\hypertarget{eui64set_8c_a768ae76e5718339e9a3c96617ca475f2}{}\label{eui64set_8c_a768ae76e5718339e9a3c96617ca475f2}
eui64\+\_\+write Converts an eui64 in uint64\+\_\+t into network byte order 

eui64set.\+c 파일의 52 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
53 \{
54     network\_order\_buf[0] = (\hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t}) ((v >> 56) & 0xff);
55     network\_order\_buf[1] = (\hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t}) ((v >> 48) & 0xff);
56     network\_order\_buf[2] = (\hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t}) ((v >> 40) & 0xff);
57     network\_order\_buf[3] = (\hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t}) ((v >> 32) & 0xff);
58     network\_order\_buf[4] = (\hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t}) ((v >> 24) & 0xff);
59     network\_order\_buf[5] = (\hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t}) ((v >> 16) & 0xff);
60     network\_order\_buf[6] = (\hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t}) ((v >> 8) & 0xff);
61     network\_order\_buf[7] = (\hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t}) ((v >> 0) & 0xff);
62 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=224pt]{eui64set_8c_a768ae76e5718339e9a3c96617ca475f2_icgraph}
\end{center}
\end{figure}


\index{eui64set.\+c@{eui64set.\+c}!eui64set\+\_\+clear@{eui64set\+\_\+clear}}
\index{eui64set\+\_\+clear@{eui64set\+\_\+clear}!eui64set.\+c@{eui64set.\+c}}
\subsubsection[{\texorpdfstring{eui64set\+\_\+clear(struct eui64set $\ast$self)}{eui64set_clear(struct eui64set *self)}}]{\setlength{\rightskip}{0pt plus 5cm}void eui64set\+\_\+clear (
\begin{DoxyParamCaption}
\item[{struct {\bf eui64set} $\ast$}]{self}
\end{DoxyParamCaption}
)}\hypertarget{eui64set_8c_afc744baf3ea6cc3892550d7f93d55ea1}{}\label{eui64set_8c_afc744baf3ea6cc3892550d7f93d55ea1}
Clear all entries in a \hyperlink{structeui64set}{eui64set} structure. 

eui64set.\+c 파일의 107 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
108 \{
109     \textcolor{keyword}{self}->num\_entries = 0;
110 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{eui64set_8c_afc744baf3ea6cc3892550d7f93d55ea1_icgraph}
\end{center}
\end{figure}


\index{eui64set.\+c@{eui64set.\+c}!eui64set\+\_\+compare@{eui64set\+\_\+compare}}
\index{eui64set\+\_\+compare@{eui64set\+\_\+compare}!eui64set.\+c@{eui64set.\+c}}
\subsubsection[{\texorpdfstring{eui64set\+\_\+compare(const void $\ast$lhs, const void $\ast$rhs)}{eui64set_compare(const void *lhs, const void *rhs)}}]{\setlength{\rightskip}{0pt plus 5cm}int eui64set\+\_\+compare (
\begin{DoxyParamCaption}
\item[{const void $\ast$}]{lhs, }
\item[{const void $\ast$}]{rhs}
\end{DoxyParamCaption}
)}\hypertarget{eui64set_8c_aa8465ef360165e86c8b69f3018082f39}{}\label{eui64set_8c_aa8465ef360165e86c8b69f3018082f39}
Compare two eui64 values\+: lhs and rhs Returns -\/1 if lhs $<$ rhs Returns 0 if lhs == rhs Returns 1 if lhs $>$ rhs 

eui64set.\+c 파일의 64 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
65 \{
66     \textcolor{keywordtype}{int} r = 0;
67     \textcolor{keyword}{const} \textcolor{keyword}{struct }\hyperlink{structeui64set__entry}{eui64set\_entry} *lhsv = (\textcolor{keyword}{const} \textcolor{keyword}{struct }
      \hyperlink{structeui64set__entry}{eui64set\_entry} *)lhs;
68     \textcolor{keyword}{const} \textcolor{keyword}{struct }\hyperlink{structeui64set__entry}{eui64set\_entry} *rhsv = (\textcolor{keyword}{const} \textcolor{keyword}{struct }
      \hyperlink{structeui64set__entry}{eui64set\_entry} *)rhs;
69 
70     \textcolor{keywordflow}{if} (lhsv->\hyperlink{structeui64set__entry_a1fcd42f07fb4db9e8b582c788572ed38}{eui64} < rhsv->\hyperlink{structeui64set__entry_a1fcd42f07fb4db9e8b582c788572ed38}{eui64}) \{
71         r = -1;
72     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (lhsv->\hyperlink{structeui64set__entry_a1fcd42f07fb4db9e8b582c788572ed38}{eui64} > rhsv->\hyperlink{structeui64set__entry_a1fcd42f07fb4db9e8b582c788572ed38}{eui64}) \{
73         r = 1;
74     \}
75     \textcolor{keywordflow}{return} r;
76 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{eui64set_8c_aa8465ef360165e86c8b69f3018082f39_icgraph}
\end{center}
\end{figure}


\index{eui64set.\+c@{eui64set.\+c}!eui64set\+\_\+find@{eui64set\+\_\+find}}
\index{eui64set\+\_\+find@{eui64set\+\_\+find}!eui64set.\+c@{eui64set.\+c}}
\subsubsection[{\texorpdfstring{eui64set\+\_\+find(const struct eui64set $\ast$self, uint64\+\_\+t value)}{eui64set_find(const struct eui64set *self, uint64_t value)}}]{\setlength{\rightskip}{0pt plus 5cm}const struct {\bf eui64set\+\_\+entry}$\ast$ eui64set\+\_\+find (
\begin{DoxyParamCaption}
\item[{const struct {\bf eui64set} $\ast$}]{self, }
\item[{{\bf uint64\+\_\+t}}]{value}
\end{DoxyParamCaption}
)}\hypertarget{eui64set_8c_a71cf81d10f8097ea3a243f1f0f223d12}{}\label{eui64set_8c_a71cf81d10f8097ea3a243f1f0f223d12}
Find a eui64 in the \hyperlink{structeui64set}{eui64set} structure. Returns a pointer to the \hyperlink{structeui64set__entry}{eui64set\+\_\+entry}, or 0 if not found. 

eui64set.\+c 파일의 157 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
159 \{
160     \textcolor{keyword}{const} \textcolor{keyword}{struct }\hyperlink{structeui64set__entry}{eui64set\_entry} *result;
161     \textcolor{keyword}{struct }\hyperlink{structeui64set__entry}{eui64set\_entry} key;
162     key.\hyperlink{structeui64set__entry_a1fcd42f07fb4db9e8b582c788572ed38}{eui64} = value;
163     key.p = 0;
164     result = bsearch(&key,
165              self->\hyperlink{structeui64set_a91b846e2ce1674f8b282c22afcbd7906}{storage},
166              self->\hyperlink{structeui64set_afb132bf5c80cf684818f5a032257faa3}{num\_entries}, \textcolor{keyword}{sizeof}(key), \hyperlink{eui64set_8c_aa8465ef360165e86c8b69f3018082f39}{eui64set\_compare});
167     \textcolor{keywordflow}{return} result;
168 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=286pt]{eui64set_8c_a71cf81d10f8097ea3a243f1f0f223d12_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{eui64set_8c_a71cf81d10f8097ea3a243f1f0f223d12_icgraph}
\end{center}
\end{figure}


\index{eui64set.\+c@{eui64set.\+c}!eui64set\+\_\+free@{eui64set\+\_\+free}}
\index{eui64set\+\_\+free@{eui64set\+\_\+free}!eui64set.\+c@{eui64set.\+c}}
\subsubsection[{\texorpdfstring{eui64set\+\_\+free(struct eui64set $\ast$self)}{eui64set_free(struct eui64set *self)}}]{\setlength{\rightskip}{0pt plus 5cm}void eui64set\+\_\+free (
\begin{DoxyParamCaption}
\item[{struct {\bf eui64set} $\ast$}]{self}
\end{DoxyParamCaption}
)}\hypertarget{eui64set_8c_ae543ad67f4be3090b148e8d46b93f56d}{}\label{eui64set_8c_ae543ad67f4be3090b148e8d46b93f56d}
Free memory allocated for the \hyperlink{structeui64set}{eui64set} 

eui64set.\+c 파일의 98 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
99 \{
100     \textcolor{keywordflow}{if} (\textcolor{keyword}{self}) \{
101         \textcolor{keywordflow}{if} (self->\hyperlink{structeui64set_a91b846e2ce1674f8b282c22afcbd7906}{storage}) \{
102             \hyperlink{_memory_leak_detector_malloc_macros_8h_aa7157aa9480bb73f090dca36776419bf}{free}(self->\hyperlink{structeui64set_a91b846e2ce1674f8b282c22afcbd7906}{storage});
103         \}
104     \}
105 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{eui64set_8c_ae543ad67f4be3090b148e8d46b93f56d_icgraph}
\end{center}
\end{figure}


\index{eui64set.\+c@{eui64set.\+c}!eui64set\+\_\+init@{eui64set\+\_\+init}}
\index{eui64set\+\_\+init@{eui64set\+\_\+init}!eui64set.\+c@{eui64set.\+c}}
\subsubsection[{\texorpdfstring{eui64set\+\_\+init(struct eui64set $\ast$self, int max\+\_\+entries)}{eui64set_init(struct eui64set *self, int max_entries)}}]{\setlength{\rightskip}{0pt plus 5cm}int eui64set\+\_\+init (
\begin{DoxyParamCaption}
\item[{struct {\bf eui64set} $\ast$}]{self, }
\item[{int}]{max\+\_\+entries}
\end{DoxyParamCaption}
)}\hypertarget{eui64set_8c_ad8c59e8a5c7fdf2c0058e9e903d0b832}{}\label{eui64set_8c_ad8c59e8a5c7fdf2c0058e9e903d0b832}
Initialize an \hyperlink{structeui64set}{eui64set} structure using the specified storage buffer. Returns -\/1 on error, 0 on success 

eui64set.\+c 파일의 78 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
79 \{
80     \textcolor{keywordtype}{int} r = 0;
81     \textcolor{keyword}{self}->num\_entries = 0;
82     \textcolor{keyword}{self}->max\_entries = max\_entries;
83     \textcolor{keyword}{self}->storage = 0;
84     \textcolor{comment}{/* Are we to allocate storage? */}
85     \textcolor{keywordflow}{if} (max\_entries > 0) \{
86         \textcolor{comment}{/* Yes, try */}
87         \textcolor{keyword}{self}->storage =
88             (\textcolor{keyword}{struct }\hyperlink{structeui64set__entry}{eui64set\_entry} *)
89             \hyperlink{_memory_leak_detector_malloc_macros_8h_a7cbb7b79af9d539af55b59dfc3598390}{calloc}(\textcolor{keyword}{sizeof}(\textcolor{keyword}{struct} \hyperlink{structeui64set__entry}{eui64set\_entry}), max\_entries);
90         \textcolor{keywordflow}{if} (self->\hyperlink{structeui64set_a91b846e2ce1674f8b282c22afcbd7906}{storage} == 0) \{
91             \textcolor{comment}{/* Failure to allocate storage */}
92             r = -1;
93         \}
94     \}
95     \textcolor{keywordflow}{return} r;
96 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{eui64set_8c_ad8c59e8a5c7fdf2c0058e9e903d0b832_icgraph}
\end{center}
\end{figure}


\index{eui64set.\+c@{eui64set.\+c}!eui64set\+\_\+insert@{eui64set\+\_\+insert}}
\index{eui64set\+\_\+insert@{eui64set\+\_\+insert}!eui64set.\+c@{eui64set.\+c}}
\subsubsection[{\texorpdfstring{eui64set\+\_\+insert(struct eui64set $\ast$self, uint64\+\_\+t value, void $\ast$p)}{eui64set_insert(struct eui64set *self, uint64_t value, void *p)}}]{\setlength{\rightskip}{0pt plus 5cm}int eui64set\+\_\+insert (
\begin{DoxyParamCaption}
\item[{struct {\bf eui64set} $\ast$}]{self, }
\item[{{\bf uint64\+\_\+t}}]{value, }
\item[{void $\ast$}]{p}
\end{DoxyParamCaption}
)}\hypertarget{eui64set_8c_a9ca76c2db111c7007960e9babb8d3321}{}\label{eui64set_8c_a9ca76c2db111c7007960e9babb8d3321}
Insert an eui64 into the \hyperlink{structeui64set}{eui64set} structure, without re-\/sorting it. If you have multiple eui64\textquotesingle{}s to add at a time call this for each eui64 and then sort it once at the end. Returns 1 on success Returns 0 if the storage area was full 

eui64set.\+c 파일의 126 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
127 \{
128     \textcolor{keywordtype}{int} r = 0;
129     \textcolor{comment}{/* Do we have space? */}
130     \textcolor{keywordflow}{if} (self->\hyperlink{structeui64set_afb132bf5c80cf684818f5a032257faa3}{num\_entries} < self->\hyperlink{structeui64set_aa71009e2224e8733f65e5d7c09f0a1a8}{max\_entries}) \{
131         \textcolor{keyword}{self}->storage[\textcolor{keyword}{self}->num\_entries].eui64 = value;
132         \textcolor{keyword}{self}->storage[\textcolor{keyword}{self}->num\_entries].p = \hyperlink{structeui64set__entry_a117104b82864d3b23ec174af6d392709}{p};
133         ++\textcolor{keyword}{self}->num\_entries;
134         r = 1;
135     \}
136     \textcolor{keywordflow}{return} r;
137 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{eui64set_8c_a9ca76c2db111c7007960e9babb8d3321_icgraph}
\end{center}
\end{figure}


\index{eui64set.\+c@{eui64set.\+c}!eui64set\+\_\+insert\+\_\+and\+\_\+sort@{eui64set\+\_\+insert\+\_\+and\+\_\+sort}}
\index{eui64set\+\_\+insert\+\_\+and\+\_\+sort@{eui64set\+\_\+insert\+\_\+and\+\_\+sort}!eui64set.\+c@{eui64set.\+c}}
\subsubsection[{\texorpdfstring{eui64set\+\_\+insert\+\_\+and\+\_\+sort(struct eui64set $\ast$self, uint64\+\_\+t value, void $\ast$p)}{eui64set_insert_and_sort(struct eui64set *self, uint64_t value, void *p)}}]{\setlength{\rightskip}{0pt plus 5cm}int eui64set\+\_\+insert\+\_\+and\+\_\+sort (
\begin{DoxyParamCaption}
\item[{struct {\bf eui64set} $\ast$}]{self, }
\item[{{\bf uint64\+\_\+t}}]{value, }
\item[{void $\ast$}]{p}
\end{DoxyParamCaption}
)}\hypertarget{eui64set_8c_aa77f4331ee0a81d173d24451d8427fa6}{}\label{eui64set_8c_aa77f4331ee0a81d173d24451d8427fa6}
Insert a single eui64 into a \hyperlink{structeui64set}{eui64set} structure and sort it afterwards. Returns 1 on success Returns 0 if the storage area was full 

eui64set.\+c 파일의 146 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
147 \{
148     \textcolor{keywordtype}{int} r;
149 
150     r = \hyperlink{eui64set_8c_a9ca76c2db111c7007960e9babb8d3321}{eui64set\_insert}(\textcolor{keyword}{self}, value, \hyperlink{structeui64set__entry_a117104b82864d3b23ec174af6d392709}{p});
151     \textcolor{keywordflow}{if} (1 == r) \{
152         \hyperlink{eui64set_8c_a1ce638b9c230ff24e27766ad272ada32}{eui64set\_sort}(\textcolor{keyword}{self});
153     \}
154     \textcolor{keywordflow}{return} r;
155 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{eui64set_8c_aa77f4331ee0a81d173d24451d8427fa6_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{eui64set_8c_aa77f4331ee0a81d173d24451d8427fa6_icgraph}
\end{center}
\end{figure}


\index{eui64set.\+c@{eui64set.\+c}!eui64set\+\_\+is\+\_\+full@{eui64set\+\_\+is\+\_\+full}}
\index{eui64set\+\_\+is\+\_\+full@{eui64set\+\_\+is\+\_\+full}!eui64set.\+c@{eui64set.\+c}}
\subsubsection[{\texorpdfstring{eui64set\+\_\+is\+\_\+full(struct eui64set $\ast$self)}{eui64set_is_full(struct eui64set *self)}}]{\setlength{\rightskip}{0pt plus 5cm}int eui64set\+\_\+is\+\_\+full (
\begin{DoxyParamCaption}
\item[{struct {\bf eui64set} $\ast$}]{self}
\end{DoxyParamCaption}
)}\hypertarget{eui64set_8c_ad67e06485d8f012f4a8c7152f1fca5a6}{}\label{eui64set_8c_ad67e06485d8f012f4a8c7152f1fca5a6}
Test if the \hyperlink{structeui64set}{eui64set} is full. Returns 1 if the \hyperlink{structeui64set}{eui64set} is full Returns 0 if the \hyperlink{structeui64set}{eui64set} is not full 

eui64set.\+c 파일의 121 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
122 \{
123     \textcolor{keywordflow}{return} \textcolor{keyword}{self}->num\_entries >= \textcolor{keyword}{self}->max\_entries;
124 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=242pt]{eui64set_8c_ad67e06485d8f012f4a8c7152f1fca5a6_icgraph}
\end{center}
\end{figure}


\index{eui64set.\+c@{eui64set.\+c}!eui64set\+\_\+num\+\_\+entries@{eui64set\+\_\+num\+\_\+entries}}
\index{eui64set\+\_\+num\+\_\+entries@{eui64set\+\_\+num\+\_\+entries}!eui64set.\+c@{eui64set.\+c}}
\subsubsection[{\texorpdfstring{eui64set\+\_\+num\+\_\+entries(struct eui64set $\ast$self)}{eui64set_num_entries(struct eui64set *self)}}]{\setlength{\rightskip}{0pt plus 5cm}int eui64set\+\_\+num\+\_\+entries (
\begin{DoxyParamCaption}
\item[{struct {\bf eui64set} $\ast$}]{self}
\end{DoxyParamCaption}
)}\hypertarget{eui64set_8c_ae5cb65b5d47249fd6d83df78a9ba5657}{}\label{eui64set_8c_ae5cb65b5d47249fd6d83df78a9ba5657}
Return the number of entries in a \hyperlink{structeui64set}{eui64set} structure. 

eui64set.\+c 파일의 112 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
113 \{
114     \textcolor{keywordflow}{return} \textcolor{keyword}{self}->num\_entries;
115 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{eui64set_8c_ae5cb65b5d47249fd6d83df78a9ba5657_icgraph}
\end{center}
\end{figure}


\index{eui64set.\+c@{eui64set.\+c}!eui64set\+\_\+remove\+\_\+and\+\_\+sort@{eui64set\+\_\+remove\+\_\+and\+\_\+sort}}
\index{eui64set\+\_\+remove\+\_\+and\+\_\+sort@{eui64set\+\_\+remove\+\_\+and\+\_\+sort}!eui64set.\+c@{eui64set.\+c}}
\subsubsection[{\texorpdfstring{eui64set\+\_\+remove\+\_\+and\+\_\+sort(struct eui64set $\ast$self, uint64\+\_\+t value)}{eui64set_remove_and_sort(struct eui64set *self, uint64_t value)}}]{\setlength{\rightskip}{0pt plus 5cm}int eui64set\+\_\+remove\+\_\+and\+\_\+sort (
\begin{DoxyParamCaption}
\item[{struct {\bf eui64set} $\ast$}]{self, }
\item[{{\bf uint64\+\_\+t}}]{value}
\end{DoxyParamCaption}
)}\hypertarget{eui64set_8c_a18d3bfef233cc07c43f67f2706c99fa8}{}\label{eui64set_8c_a18d3bfef233cc07c43f67f2706c99fa8}
Remove the specified eui64 from the \hyperlink{structeui64set}{eui64set} structure and frees any associated p data

Returns 1 if found and removed.

Returns 0 if not found. 

eui64set.\+c 파일의 170 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
171 \{
172     \textcolor{keywordtype}{int} r = 0;
173     \textcolor{keyword}{struct }\hyperlink{structeui64set__entry}{eui64set\_entry} *item;
174     \textcolor{keyword}{struct }\hyperlink{structeui64set__entry}{eui64set\_entry} key;
175     key.\hyperlink{structeui64set__entry_a1fcd42f07fb4db9e8b582c788572ed38}{eui64} = value;
176     key.p = 0;
177     item = bsearch(&key,
178                self->\hyperlink{structeui64set_a91b846e2ce1674f8b282c22afcbd7906}{storage},
179                self->\hyperlink{structeui64set_afb132bf5c80cf684818f5a032257faa3}{num\_entries}, \textcolor{keyword}{sizeof}(key), \hyperlink{eui64set_8c_aa8465ef360165e86c8b69f3018082f39}{eui64set\_compare});
180     \textcolor{keywordflow}{if} (item) \{
181         \textcolor{comment}{// Set value to highest value}
182         item->\hyperlink{structeui64set__entry_a1fcd42f07fb4db9e8b582c788572ed38}{eui64} = ~((\hyperlink{parse_8c_aec6fcb673ff035718c238c8c9d544c47}{uint64\_t}) 0);
183         \textcolor{keywordflow}{if} (item->\hyperlink{structeui64set__entry_a117104b82864d3b23ec174af6d392709}{p}) \{
184             \hyperlink{_memory_leak_detector_malloc_macros_8h_aa7157aa9480bb73f090dca36776419bf}{free}(item->\hyperlink{structeui64set__entry_a117104b82864d3b23ec174af6d392709}{p});
185         \}
186 
187         \hyperlink{eui64set_8c_a1ce638b9c230ff24e27766ad272ada32}{eui64set\_sort}(\textcolor{keyword}{self});
188         --\textcolor{keyword}{self}->num\_entries;
189         r = 1;
190     \}
191     \textcolor{keywordflow}{return} r;
192 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{eui64set_8c_a18d3bfef233cc07c43f67f2706c99fa8_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{eui64set_8c_a18d3bfef233cc07c43f67f2706c99fa8_icgraph}
\end{center}
\end{figure}


\index{eui64set.\+c@{eui64set.\+c}!eui64set\+\_\+sort@{eui64set\+\_\+sort}}
\index{eui64set\+\_\+sort@{eui64set\+\_\+sort}!eui64set.\+c@{eui64set.\+c}}
\subsubsection[{\texorpdfstring{eui64set\+\_\+sort(struct eui64set $\ast$self)}{eui64set_sort(struct eui64set *self)}}]{\setlength{\rightskip}{0pt plus 5cm}void eui64set\+\_\+sort (
\begin{DoxyParamCaption}
\item[{struct {\bf eui64set} $\ast$}]{self}
\end{DoxyParamCaption}
)}\hypertarget{eui64set_8c_a1ce638b9c230ff24e27766ad272ada32}{}\label{eui64set_8c_a1ce638b9c230ff24e27766ad272ada32}
Sort a \hyperlink{structeui64set}{eui64set} structure 

eui64set.\+c 파일의 139 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
140 \{
141     qsort(self->\hyperlink{structeui64set_a91b846e2ce1674f8b282c22afcbd7906}{storage},
142           self->\hyperlink{structeui64set_afb132bf5c80cf684818f5a032257faa3}{num\_entries},
143           \textcolor{keyword}{sizeof}(\textcolor{keyword}{struct} \hyperlink{structeui64set__entry}{eui64set\_entry}), \hyperlink{eui64set_8c_aa8465ef360165e86c8b69f3018082f39}{eui64set\_compare});
144 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=287pt]{eui64set_8c_a1ce638b9c230ff24e27766ad272ada32_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{eui64set_8c_a1ce638b9c230ff24e27766ad272ada32_icgraph}
\end{center}
\end{figure}


