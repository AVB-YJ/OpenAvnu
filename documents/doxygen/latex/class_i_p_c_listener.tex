\hypertarget{class_i_p_c_listener}{}\section{I\+P\+C\+Listener 클래스 참조}
\label{class_i_p_c_listener}\index{I\+P\+C\+Listener@{I\+P\+C\+Listener}}


Provides an interface for the I\+PC Listener.  




{\ttfamily \#include $<$I\+P\+C\+Listener.\+hpp$>$}



I\+P\+C\+Listener에 대한 상속 다이어그램 \+: 
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=205pt]{class_i_p_c_listener__inherit__graph}
\end{center}
\end{figure}


I\+P\+C\+Listener에 대한 협력 다이어그램\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=205pt]{class_i_p_c_listener__coll__graph}
\end{center}
\end{figure}
\subsection*{Public 멤버 함수}
\begin{DoxyCompactItemize}
\item 
\hyperlink{avb__gptp_8h_af6a258d8f3ee5206d682d799316314b1}{bool} \hyperlink{class_i_p_c_listener_ad040984cedd269133c991f17be8808fc}{start} (\hyperlink{class_i_p_c_shared_data}{I\+P\+C\+Shared\+Data} data)
\begin{DoxyCompactList}\small\item\em Starts the listener loop in a new thread. \end{DoxyCompactList}\item 
\hyperlink{class_i_p_c_listener_acfa0b4a5593a47073f27b94016382d63}{$\sim$\+I\+P\+C\+Listener} ()
\begin{DoxyCompactList}\small\item\em Destroys the I\+PC listener interface. \end{DoxyCompactList}\item 
\hyperlink{avb__gptp_8h_af6a258d8f3ee5206d682d799316314b1}{bool} \hyperlink{class_stoppable_a68a350717fe6bf9012843e7c977d87b2}{stop} ()
\begin{DoxyCompactList}\small\item\em Stops thread. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected 속성}
\begin{DoxyCompactItemize}
\item 
\hyperlink{avb__gptp_8h_af6a258d8f3ee5206d682d799316314b1}{bool} \hyperlink{class_stoppable_ae0c3c0996c39797d309663cd3a2633d3}{exit\+\_\+waiting}
\item 
H\+A\+N\+D\+LE \hyperlink{class_stoppable_adf8b62c27edd1f6b7641bb7bb7f60275}{thread}
\end{DoxyCompactItemize}
\subsection*{Private 멤버 함수}
\begin{DoxyCompactItemize}
\item 
D\+W\+O\+RD W\+I\+N\+A\+PI \hyperlink{class_i_p_c_listener_a5a355dec31c967a46b8ce6209cea9927}{I\+P\+C\+Listener\+Loop} (\hyperlink{class_i_p_c_shared_data}{I\+P\+C\+Shared\+Data} $\ast$arg)
\end{DoxyCompactItemize}
\subsection*{정적 Private 멤버 함수}
\begin{DoxyCompactItemize}
\item 
static D\+W\+O\+RD W\+I\+N\+A\+PI \hyperlink{class_i_p_c_listener_a8417631db8279b7e41c87c5503c38a9e}{I\+P\+C\+Listener\+Loop\+Wrap} (L\+P\+V\+O\+ID arg)
\end{DoxyCompactItemize}


\subsection{상세한 설명}
Provides an interface for the I\+PC Listener. 

I\+P\+C\+Listener.\+hpp 파일의 100 번째 라인에서 정의되었습니다.



\subsection{생성자 \& 소멸자 문서화}
\index{I\+P\+C\+Listener@{I\+P\+C\+Listener}!````~I\+P\+C\+Listener@{$\sim$\+I\+P\+C\+Listener}}
\index{````~I\+P\+C\+Listener@{$\sim$\+I\+P\+C\+Listener}!I\+P\+C\+Listener@{I\+P\+C\+Listener}}
\subsubsection[{\texorpdfstring{$\sim$\+I\+P\+C\+Listener()}{~IPCListener()}}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf I\+P\+C\+Listener} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{class_i_p_c_listener_acfa0b4a5593a47073f27b94016382d63}{}\label{class_i_p_c_listener_acfa0b4a5593a47073f27b94016382d63}


Destroys the I\+PC listener interface. 



I\+P\+C\+Listener.\+hpp 파일의 132 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
132 \{\}
\end{DoxyCode}


\subsection{멤버 함수 문서화}
\index{I\+P\+C\+Listener@{I\+P\+C\+Listener}!I\+P\+C\+Listener\+Loop@{I\+P\+C\+Listener\+Loop}}
\index{I\+P\+C\+Listener\+Loop@{I\+P\+C\+Listener\+Loop}!I\+P\+C\+Listener@{I\+P\+C\+Listener}}
\subsubsection[{\texorpdfstring{I\+P\+C\+Listener\+Loop(\+I\+P\+C\+Shared\+Data $\ast$arg)}{IPCListenerLoop(IPCSharedData *arg)}}]{\setlength{\rightskip}{0pt plus 5cm}D\+W\+O\+RD W\+I\+N\+A\+PI I\+P\+C\+Listener\+Loop (
\begin{DoxyParamCaption}
\item[{{\bf I\+P\+C\+Shared\+Data} $\ast$}]{arg}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_i_p_c_listener_a5a355dec31c967a46b8ce6209cea9927}{}\label{class_i_p_c_listener_a5a355dec31c967a46b8ce6209cea9927}


I\+P\+C\+Listener.\+cpp 파일의 38 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
38                                                               \{
39     \hyperlink{class_peer_list}{PeerList} *list = arg->\hyperlink{class_i_p_c_shared_data_a0db886605e19248f347d4200c0152391}{list};
40     \hyperlink{class_lockable_offset}{LockableOffset} *loffset = arg->\hyperlink{class_i_p_c_shared_data_a8e8c05aa69387039d0ea0ecffcae87ce}{offset};
41     HANDLE pipe = INVALID\_HANDLE\_VALUE;
42 
43     \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t} tmp[\hyperlink{windows__ipc_8hpp_a066dd79b53c24f69b77c614e4f12eb6b}{NPIPE\_MAX\_MSG\_SZ}];
44     OVERLAPPED pipe\_ol;
45     HANDLE ol\_event;
46     \textcolor{keyword}{enum} \{ PIPE\_CLOSED, PIPE\_UNCONNECT, PIPE\_CONNECT\_PENDING, PIPE\_CONNECT, PIPE\_READ\_PENDING \} pipe\_state;
47 
48     \textcolor{comment}{// Open named pipe}
49     \textcolor{keywordtype}{char} pipename[64];
50     strncpy\_s( pipename, 64, \hyperlink{windows__ipc_8hpp_ae95469fea7cc97edfa1e2d02a45a2c25}{PIPE\_PREFIX}, 63 );
51     strncpy\_s( pipename+strlen(pipename), 64-strlen(pipename), \hyperlink{windows__ipc_8hpp_ab5e537c0bda471d560b869b99671ac80}{P802\_1AS\_PIPENAME}, 63-
      strlen(pipename) );
52     ol\_event = CreateEvent( \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}, \textcolor{keyword}{true}, \textcolor{keyword}{false}, \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} );
53     pipe\_state = PIPE\_CLOSED;
54 
55     DWORD retval = -1;
56 
57     \textcolor{keywordflow}{while}( !\hyperlink{class_stoppable_ae0c3c0996c39797d309663cd3a2633d3}{exit\_waiting} ) \{
58         \textcolor{keywordtype}{int} \hyperlink{gst__avb__playbin_8c_a6ce68847c12434f60d1b2654a3dc3409}{err};
59         DWORD ret;
60         \textcolor{keywordflow}{if}( pipe\_state < PIPE\_UNCONNECT ) \{
61             \textcolor{keywordflow}{if}( pipe != INVALID\_HANDLE\_VALUE ) \{
62                 DisconnectNamedPipe( pipe );
63                 CloseHandle( pipe );
64             \}
65             pipe = CreateNamedPipe( pipename, PIPE\_ACCESS\_DUPLEX | FILE\_FLAG\_OVERLAPPED, PIPE\_TYPE\_BYTE | 
      PIPE\_READMODE\_BYTE , PIPE\_UNLIMITED\_INSTANCES,
66                 \hyperlink{windows__ipc_8hpp_a6c3bee465a747c831cfe55aced80c18b}{OUTSTANDING\_MESSAGES}*\hyperlink{windows__ipc_8hpp_a201af7e7d364550b0ef600d94cbfd635}{NPIPE\_MAX\_SERVER\_MSG\_SZ}, 
      \hyperlink{windows__ipc_8hpp_a6c3bee465a747c831cfe55aced80c18b}{OUTSTANDING\_MESSAGES}*\hyperlink{windows__ipc_8hpp_a066dd79b53c24f69b77c614e4f12eb6b}{NPIPE\_MAX\_MSG\_SZ}, 0, 
      \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} );
67             \textcolor{keywordflow}{if}( pipe == INVALID\_HANDLE\_VALUE ) \{
68                 \hyperlink{gptp__log_8hpp_afefbb1009717c128012bfeed94842987}{GPTP\_LOG\_ERROR}( \textcolor{stringliteral}{"Open pipe error (%s): %d"}, pipename, GetLastError() );
69                 \textcolor{keywordflow}{goto} do\_error;
70             \}
71             pipe\_state = PIPE\_UNCONNECT;
72         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( pipe\_state < PIPE\_CONNECT ) \{
73             \textcolor{keywordflow}{if}( pipe\_state != PIPE\_CONNECT\_PENDING ) \{
74                 memset( &pipe\_ol, 0, \textcolor{keyword}{sizeof}( pipe\_ol ));
75                 pipe\_ol.hEvent = ol\_event;
76                 \textcolor{keywordflow}{if}( ResetEvent( ol\_event ) == 0 ) \textcolor{keywordflow}{goto} do\_error;
77                 \textcolor{keywordflow}{if}( ConnectNamedPipe( pipe, &pipe\_ol ) != 0 ) \{
78                     \textcolor{comment}{// Successfully connected}
79                     pipe\_state = PIPE\_CONNECT;
80                     \textcolor{keywordflow}{continue};
81                 \} \textcolor{keywordflow}{else} \{
82                     err = GetLastError();
83                     \textcolor{keywordflow}{switch}( err ) \{
84                     \textcolor{keywordflow}{default}:
85                         \hyperlink{gptp__log_8hpp_afefbb1009717c128012bfeed94842987}{GPTP\_LOG\_ERROR}( \textcolor{stringliteral}{"Attempt to connect on Pipe failed, %d"}, err );
86                         \textcolor{keywordflow}{goto} do\_error;
87                     \textcolor{keywordflow}{case} ERROR\_PIPE\_CONNECTED:
88                         pipe\_state = PIPE\_CONNECT;
89                         \textcolor{keywordflow}{continue};
90                     \textcolor{keywordflow}{case} ERROR\_IO\_PENDING:
91                         pipe\_state = PIPE\_CONNECT\_PENDING;
92                     \}
93                 \}
94             \}
95             ret = WaitForSingleObject( ol\_event, 200 );
96             \textcolor{keywordflow}{switch}( ret ) \{
97             \textcolor{keywordflow}{case} WAIT\_OBJECT\_0:
98                 pipe\_state = PIPE\_CONNECT;
99             \textcolor{keywordflow}{case} WAIT\_TIMEOUT:
100                 \textcolor{keywordflow}{continue};
101             \textcolor{keywordflow}{default}:
102                 \textcolor{keywordflow}{goto} do\_error;
103             \}
104         \} \textcolor{keywordflow}{else} \{
105             \textcolor{comment}{// We're connected}
106             \textcolor{keywordtype}{long} readlen;
107             \textcolor{keywordflow}{if}( pipe\_state < PIPE\_READ\_PENDING ) \{
108                 \textcolor{comment}{// Wait for message - Read Base Message}
109                 ((\hyperlink{class_windows_n_pipe_message}{WindowsNPipeMessage} *)tmp)->init();
110                 \textcolor{keywordflow}{if}( ResetEvent( ol\_event ) == 0 ) \textcolor{keywordflow}{goto} do\_error;
111                 \textcolor{keywordflow}{if}(( readlen =  ((\hyperlink{class_windows_n_pipe_message}{WindowsNPipeMessage} *)tmp)->read\_ol( pipe, 0, ol\_event
       )) == -1 ) \{
112                     err = GetLastError();
113                     \textcolor{keywordflow}{switch}( err ) \{
114                     \textcolor{keywordflow}{default}:
115                         \hyperlink{gptp__log_8hpp_afefbb1009717c128012bfeed94842987}{GPTP\_LOG\_ERROR}( \textcolor{stringliteral}{"Failed to read from pipe @%u,%d"}, \_\_LINE\_\_, err );
116                         \textcolor{keywordflow}{goto} do\_error;
117                     \textcolor{keywordflow}{case} ERROR\_BROKEN\_PIPE:
118                         pipe\_state = PIPE\_CLOSED;
119                         \textcolor{keywordflow}{continue};
120                     \textcolor{keywordflow}{case} ERROR\_IO\_PENDING:
121                         ;
122                     \}
123                 \}
124                 \textcolor{comment}{// Fall through to here whether data is available or not}
125                 pipe\_state = PIPE\_READ\_PENDING;
126             \}
127             ret = WaitForSingleObject( ol\_event, 200 );
128             \textcolor{keywordflow}{switch}( ret ) \{
129             \textcolor{keywordflow}{default}:
130                 \textcolor{keywordflow}{goto} do\_error;
131             \textcolor{keywordflow}{case} WAIT\_TIMEOUT:
132                 \textcolor{keywordflow}{continue};
133             \textcolor{keywordflow}{case} WAIT\_OBJECT\_0:
134                 \textcolor{keywordflow}{if}(( readlen = ((\hyperlink{class_win_n_pipe_ctrl_message}{WinNPipeCtrlMessage} *)tmp)->read\_ol\_complete( pipe )) 
      == -1 ) \{
135                     err = GetLastError();
136                     \textcolor{keywordflow}{if}( err == ERROR\_BROKEN\_PIPE ) \{
137                         pipe\_state = PIPE\_CLOSED;
138                         \textcolor{keywordflow}{continue};
139                     \}
140                     \hyperlink{gptp__log_8hpp_afefbb1009717c128012bfeed94842987}{GPTP\_LOG\_ERROR}( \textcolor{stringliteral}{"Failed to read from pipe @%u,%d"}, \_\_LINE\_\_, err );
141                     \textcolor{keywordflow}{goto} do\_error;
142                 \}
143                 \textcolor{keywordflow}{switch}( ((\hyperlink{class_windows_n_pipe_message}{WindowsNPipeMessage} *)tmp)->getType() ) \{
144                 \textcolor{keywordflow}{case} \hyperlink{windows__ipc_8hpp_a5a7d5ebd4af251aa73a4afcce1dc68a1a9755a42b5cc0f5f0e6afdc1f28f8857d}{CTRL\_MSG}:
145                     ((\hyperlink{class_win_n_pipe_ctrl_message}{WinNPipeCtrlMessage} *)tmp)->init();
146                     \textcolor{keywordflow}{if}(( readlen = ((\hyperlink{class_win_n_pipe_ctrl_message}{WinNPipeCtrlMessage} *)tmp)->read( pipe, readlen )) 
      == -1 ) \{
147                         \hyperlink{gptp__log_8hpp_afefbb1009717c128012bfeed94842987}{GPTP\_LOG\_ERROR}( \textcolor{stringliteral}{"Failed to read from pipe @%u"}, \_\_LINE\_\_ );
148                         \textcolor{keywordflow}{goto} do\_error;
149                     \}
150                     \textcolor{comment}{//readlen may not be set properly ??}
151                     \textcolor{comment}{// Attempt to add or remove from the list}
152                     \textcolor{keywordflow}{switch}( ((\hyperlink{class_win_n_pipe_ctrl_message}{WinNPipeCtrlMessage} *)tmp)->getCtrlWhich() ) \{
153                     \textcolor{keywordflow}{default}:
154                         \hyperlink{gptp__log_8hpp_afefbb1009717c128012bfeed94842987}{GPTP\_LOG\_ERROR}( \textcolor{stringliteral}{"Recvd CTRL cmd specifying illegal operation @%u"}, 
      \_\_LINE\_\_ );
155                         \textcolor{keywordflow}{goto} do\_error;
156                     \textcolor{keywordflow}{case} \hyperlink{windows__ipc_8hpp_a584396bb9236c4d39596e9f285a43313aeb15db62ee9d692bbcb21bfb7bd8af6a}{ADD\_PEER}:
157                         \textcolor{keywordflow}{if}( !list->\hyperlink{class_peer_list_a6a5257615fcc122ba0dfbfde6c8a80e5}{IsReady}() || !list->\hyperlink{class_peer_list_a318d888e6a0754f216228f6664bed3ea}{add}( ((
      \hyperlink{class_win_n_pipe_ctrl_message}{WinNPipeCtrlMessage} *)tmp)->getPeerAddr() ) ) \{
158                             \hyperlink{gptp__log_8hpp_afefbb1009717c128012bfeed94842987}{GPTP\_LOG\_ERROR}( \textcolor{stringliteral}{"Failed to add peer @%u"}, \_\_LINE\_\_ );
159                         \}
160                         \textcolor{keywordflow}{break};
161                     \textcolor{keywordflow}{case} \hyperlink{windows__ipc_8hpp_a584396bb9236c4d39596e9f285a43313a0dfb7f186cb914b369e7058612fdff68}{REMOVE\_PEER}:
162                         \textcolor{keywordflow}{if}( !list->\hyperlink{class_peer_list_a6a5257615fcc122ba0dfbfde6c8a80e5}{IsReady}() || !list->\hyperlink{class_peer_list_aecf651d7b2b4ad4974fb47624a64aee7}{remove}( ((
      \hyperlink{class_win_n_pipe_ctrl_message}{WinNPipeCtrlMessage} *)tmp)->getPeerAddr() ) ) \{
163                             \hyperlink{gptp__log_8hpp_afefbb1009717c128012bfeed94842987}{GPTP\_LOG\_ERROR}( \textcolor{stringliteral}{"Failed to remove peer @%u"}, \_\_LINE\_\_ );
164                         \}
165                         \textcolor{keywordflow}{break};
166                     \}
167                     \textcolor{keywordflow}{break};
168                 \textcolor{keywordflow}{case} \hyperlink{windows__ipc_8hpp_a5a7d5ebd4af251aa73a4afcce1dc68a1a78180330e3d243311b27fe8452de354b}{OFFSET\_MSG}:
169                     ((\hyperlink{class_win_n_pipe_query_message}{WinNPipeQueryMessage} *)tmp)->init();
170                     \textcolor{keywordflow}{if}(( readlen = ((\hyperlink{class_win_n_pipe_query_message}{WinNPipeQueryMessage} *)tmp)->read( pipe, readlen )
      ) == -1 ) \{
171                         \hyperlink{gptp__log_8hpp_afefbb1009717c128012bfeed94842987}{GPTP\_LOG\_ERROR}( \textcolor{stringliteral}{"Failed to read from pipe @%u"}, \_\_LINE\_\_ );
172                         \textcolor{keywordflow}{goto} do\_error;
173                     \}
174                     \textcolor{comment}{// Create an offset message and send it}
175                     loffset->\hyperlink{class_lockable_a5a8046fd4b22dbe2b30ef4d18c5ac64e}{get}();
176                     \textcolor{keywordflow}{if}( loffset->\hyperlink{class_lockable_offset_acbed040576a7a18e2d9c46b2f15e0162}{isReady}() ) ((
      \hyperlink{class_win_n_pipe_offset_update_message}{WinNPipeOffsetUpdateMessage} *)tmp)->init((\hyperlink{class_offset}{Offset} *)loffset);
177                     \textcolor{keywordflow}{else} ((\hyperlink{class_win_n_pipe_offset_update_message}{WinNPipeOffsetUpdateMessage} *)tmp)->init();
178                     loffset->\hyperlink{class_lockable_a760567729cc565fd13d414937a558a89}{put}();
179                     ((\hyperlink{class_win_n_pipe_offset_update_message}{WinNPipeOffsetUpdateMessage} *)tmp)->write(pipe);
180                     \textcolor{keywordflow}{break};
181                 \textcolor{keywordflow}{default}:
182                     \hyperlink{gptp__log_8hpp_afefbb1009717c128012bfeed94842987}{GPTP\_LOG\_ERROR}( \textcolor{stringliteral}{"Recvd Unknown Message"} );
183                     \textcolor{comment}{// Is this recoverable?}
184                     \textcolor{keywordflow}{goto} do\_error;
185                 \}
186                 pipe\_state = PIPE\_CONNECT;
187             \}
188         \}
189     \}
190 
191 
192     retval = 0; \textcolor{comment}{// Exit normally}
193 do\_error:
194     \textcolor{comment}{// Close Named Pipe}
195     \textcolor{keywordflow}{if}( pipe != INVALID\_HANDLE\_VALUE ) CloseHandle( pipe );
196 
197     \textcolor{keywordflow}{return} retval;
198 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=330pt]{class_i_p_c_listener_a5a355dec31c967a46b8ce6209cea9927_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=318pt]{class_i_p_c_listener_a5a355dec31c967a46b8ce6209cea9927_icgraph}
\end{center}
\end{figure}


\index{I\+P\+C\+Listener@{I\+P\+C\+Listener}!I\+P\+C\+Listener\+Loop\+Wrap@{I\+P\+C\+Listener\+Loop\+Wrap}}
\index{I\+P\+C\+Listener\+Loop\+Wrap@{I\+P\+C\+Listener\+Loop\+Wrap}!I\+P\+C\+Listener@{I\+P\+C\+Listener}}
\subsubsection[{\texorpdfstring{I\+P\+C\+Listener\+Loop\+Wrap(\+L\+P\+V\+O\+I\+D arg)}{IPCListenerLoopWrap(LPVOID arg)}}]{\setlength{\rightskip}{0pt plus 5cm}static D\+W\+O\+RD W\+I\+N\+A\+PI I\+P\+C\+Listener\+Loop\+Wrap (
\begin{DoxyParamCaption}
\item[{L\+P\+V\+O\+ID}]{arg}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}, {\ttfamily [private]}}\hypertarget{class_i_p_c_listener_a8417631db8279b7e41c87c5503c38a9e}{}\label{class_i_p_c_listener_a8417631db8279b7e41c87c5503c38a9e}


I\+P\+C\+Listener.\+hpp 파일의 102 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
102                                                           \{
103         DWORD ret;
104         LPVOID *argl = (LPVOID *) arg;
105         \hyperlink{class_i_p_c_listener}{IPCListener} *this0 = (\hyperlink{class_i_p_c_listener}{IPCListener} *) argl[0];
106         ret = this0->\hyperlink{class_i_p_c_listener_a5a355dec31c967a46b8ce6209cea9927}{IPCListenerLoop}((\hyperlink{class_i_p_c_shared_data}{IPCSharedData} *) argl[1] );
107         \textcolor{keyword}{delete} argl[1];
108         \textcolor{keyword}{delete} [] argl;
109         \textcolor{keywordflow}{return} ret;
110     \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_i_p_c_listener_a8417631db8279b7e41c87c5503c38a9e_cgraph}
\end{center}
\end{figure}


\index{I\+P\+C\+Listener@{I\+P\+C\+Listener}!start@{start}}
\index{start@{start}!I\+P\+C\+Listener@{I\+P\+C\+Listener}}
\subsubsection[{\texorpdfstring{start(\+I\+P\+C\+Shared\+Data data)}{start(IPCSharedData data)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf bool} start (
\begin{DoxyParamCaption}
\item[{{\bf I\+P\+C\+Shared\+Data}}]{data}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{class_i_p_c_listener_ad040984cedd269133c991f17be8808fc}{}\label{class_i_p_c_listener_ad040984cedd269133c991f17be8808fc}


Starts the listener loop in a new thread. 

\begin{DoxyReturn}{반환값}
T\+R\+UE in case of success, F\+A\+L\+SE in case of error 
\end{DoxyReturn}


I\+P\+C\+Listener.\+hpp 파일의 117 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
117                                      \{
118         LPVOID *arg = \textcolor{keyword}{new} LPVOID[2];
119         \textcolor{keywordflow}{if}( \hyperlink{class_stoppable_adf8b62c27edd1f6b7641bb7bb7f60275}{thread} != \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} ) \{
120             \textcolor{keywordflow}{return} \textcolor{keyword}{false};
121         \}
122         arg[1] = (\textcolor{keywordtype}{void} *) \hyperlink{_memory_leak_detector_malloc_macros_8h_ab8b25cd8f16d4a6552afe4e65c4f082d}{malloc}((\textcolor{keywordtype}{size\_t}) \textcolor{keyword}{sizeof}(\hyperlink{class_i_p_c_shared_data}{IPCSharedData}));
123         arg[0] = \textcolor{keyword}{this};
124         *((\hyperlink{class_i_p_c_shared_data}{IPCSharedData} *) arg[1]) = data;
125         \hyperlink{class_stoppable_adf8b62c27edd1f6b7641bb7bb7f60275}{thread} = CreateThread( \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}, 0, &\hyperlink{class_i_p_c_listener_a8417631db8279b7e41c87c5503c38a9e}{IPCListenerLoopWrap}, arg, 0, 
      \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} );
126         \textcolor{keywordflow}{if}( \hyperlink{class_stoppable_adf8b62c27edd1f6b7641bb7bb7f60275}{thread} != \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} ) \textcolor{keywordflow}{return} \textcolor{keyword}{true};
127         \textcolor{keywordflow}{else} \textcolor{keywordflow}{return} \textcolor{keyword}{false};
128     \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_i_p_c_listener_ad040984cedd269133c991f17be8808fc_icgraph}
\end{center}
\end{figure}


\index{I\+P\+C\+Listener@{I\+P\+C\+Listener}!stop@{stop}}
\index{stop@{stop}!I\+P\+C\+Listener@{I\+P\+C\+Listener}}
\subsubsection[{\texorpdfstring{stop()}{stop()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf bool} stop (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [inherited]}}\hypertarget{class_stoppable_a68a350717fe6bf9012843e7c977d87b2}{}\label{class_stoppable_a68a350717fe6bf9012843e7c977d87b2}


Stops thread. 

\begin{DoxyReturn}{반환값}
T\+R\+UE in case of success. F\+A\+L\+SE otherwise. 
\end{DoxyReturn}


Stoppable.\+hpp 파일의 58 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
58                 \{
59         \textcolor{keywordflow}{if}( \hyperlink{class_stoppable_adf8b62c27edd1f6b7641bb7bb7f60275}{thread} == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} ) \textcolor{keywordflow}{return} \textcolor{keyword}{false};
60         \hyperlink{class_stoppable_ae0c3c0996c39797d309663cd3a2633d3}{exit\_waiting} = \textcolor{keyword}{true};
61         \textcolor{keywordflow}{if}( WaitForSingleObject( \hyperlink{class_stoppable_adf8b62c27edd1f6b7641bb7bb7f60275}{thread}, INFINITE ) == WAIT\_FAILED ) \{
62             \textcolor{keywordtype}{char} *errstr;
63             \hyperlink{gptp__log_8hpp_afefbb1009717c128012bfeed94842987}{GPTP\_LOG\_ERROR}( \textcolor{stringliteral}{"Wait for thread exit failed %s"}, errstr );
64             \textcolor{keyword}{delete} errstr;
65         \}
66         \hyperlink{class_stoppable_ae0c3c0996c39797d309663cd3a2633d3}{exit\_waiting} = \textcolor{keyword}{false};
67         \textcolor{keywordflow}{return} \textcolor{keyword}{true};
68     \}
\end{DoxyCode}


\subsection{필드 문서화}
\index{I\+P\+C\+Listener@{I\+P\+C\+Listener}!exit\+\_\+waiting@{exit\+\_\+waiting}}
\index{exit\+\_\+waiting@{exit\+\_\+waiting}!I\+P\+C\+Listener@{I\+P\+C\+Listener}}
\subsubsection[{\texorpdfstring{exit\+\_\+waiting}{exit_waiting}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf bool} exit\+\_\+waiting\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [inherited]}}\hypertarget{class_stoppable_ae0c3c0996c39797d309663cd3a2633d3}{}\label{class_stoppable_ae0c3c0996c39797d309663cd3a2633d3}
Waiting to exit 

Stoppable.\+hpp 파일의 47 번째 라인에서 정의되었습니다.

\index{I\+P\+C\+Listener@{I\+P\+C\+Listener}!thread@{thread}}
\index{thread@{thread}!I\+P\+C\+Listener@{I\+P\+C\+Listener}}
\subsubsection[{\texorpdfstring{thread}{thread}}]{\setlength{\rightskip}{0pt plus 5cm}H\+A\+N\+D\+LE thread\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [inherited]}}\hypertarget{class_stoppable_adf8b62c27edd1f6b7641bb7bb7f60275}{}\label{class_stoppable_adf8b62c27edd1f6b7641bb7bb7f60275}
Thread handler 

Stoppable.\+hpp 파일의 48 번째 라인에서 정의되었습니다.



이 클래스에 대한 문서화 페이지는 다음의 파일들로부터 생성되었습니다.\+:\begin{DoxyCompactItemize}
\item 
daemons/gptp/windows/daemon\+\_\+cl/\hyperlink{_i_p_c_listener_8hpp}{I\+P\+C\+Listener.\+hpp}\item 
daemons/gptp/windows/daemon\+\_\+cl/\hyperlink{_i_p_c_listener_8cpp}{I\+P\+C\+Listener.\+cpp}\end{DoxyCompactItemize}
