\hypertarget{listener__mrp__client_8c}{}\section{examples/common/listener\+\_\+mrp\+\_\+client.c 파일 참조}
\label{listener__mrp__client_8c}\index{examples/common/listener\+\_\+mrp\+\_\+client.\+c@{examples/common/listener\+\_\+mrp\+\_\+client.\+c}}
{\ttfamily \#include \char`\"{}listener\+\_\+mrp\+\_\+client.\+h\char`\"{}}\\*
listener\+\_\+mrp\+\_\+client.\+c에 대한 include 의존 그래프
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{listener__mrp__client_8c__incl}
\end{center}
\end{figure}
\subsection*{함수}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{listener__mrp__client_8c_a6c13af7ba5d48d218f1504b9a14314c0}{mrp\+\_\+listener\+\_\+client\+\_\+init} (struct \hyperlink{structmrp__listener__ctx}{mrp\+\_\+listener\+\_\+ctx} $\ast$\hyperlink{jack_8h_a1cde2a2cf8a56164b5e83159035be03b}{ctx})
\item 
int \hyperlink{listener__mrp__client_8c_a925f75b25e5ea1ed0e082c771f9d6242}{send\+\_\+msg} (char $\ast$data, int data\+\_\+len, struct \hyperlink{structmrp__listener__ctx}{mrp\+\_\+listener\+\_\+ctx} $\ast$\hyperlink{jack_8h_a1cde2a2cf8a56164b5e83159035be03b}{ctx})
\item 
int \hyperlink{listener__mrp__client_8c_a2f5369074acd8aa23c34c272c0b2bf31}{msg\+\_\+process} (char $\ast$buf, int buflen, struct \hyperlink{structmrp__listener__ctx}{mrp\+\_\+listener\+\_\+ctx} $\ast$\hyperlink{jack_8h_a1cde2a2cf8a56164b5e83159035be03b}{ctx})
\item 
int \hyperlink{listener__mrp__client_8c_abe45eedd55d5b13ad817c1adce0a5c7b}{create\+\_\+socket} (struct \hyperlink{structmrp__listener__ctx}{mrp\+\_\+listener\+\_\+ctx} $\ast$\hyperlink{jack_8h_a1cde2a2cf8a56164b5e83159035be03b}{ctx})
\item 
void $\ast$ \hyperlink{listener__mrp__client_8c_afdd2d7bcf3cde2ab45b078d253558c2d}{mrp\+\_\+monitor\+\_\+thread} (void $\ast$arg)
\item 
int \hyperlink{listener__mrp__client_8c_ac298236801a3836999c032e006e55493}{mrp\+\_\+monitor} (struct \hyperlink{structmrp__listener__ctx}{mrp\+\_\+listener\+\_\+ctx} $\ast$\hyperlink{jack_8h_a1cde2a2cf8a56164b5e83159035be03b}{ctx})
\item 
int \hyperlink{listener__mrp__client_8c_a0ae45edb27d4d77bb4bf8d0c4d01f74e}{report\+\_\+domain\+\_\+status} (struct \hyperlink{structmrp__domain__attr}{mrp\+\_\+domain\+\_\+attr} $\ast$class\+\_\+a, struct \hyperlink{structmrp__listener__ctx}{mrp\+\_\+listener\+\_\+ctx} $\ast$\hyperlink{jack_8h_a1cde2a2cf8a56164b5e83159035be03b}{ctx})
\item 
int \hyperlink{listener__mrp__client_8c_ad9e5734b8f3e186460f459b6c3c395b5}{mrp\+\_\+get\+\_\+domain} (struct \hyperlink{structmrp__listener__ctx}{mrp\+\_\+listener\+\_\+ctx} $\ast$\hyperlink{jack_8h_a1cde2a2cf8a56164b5e83159035be03b}{ctx}, struct \hyperlink{structmrp__domain__attr}{mrp\+\_\+domain\+\_\+attr} $\ast$class\+\_\+a, struct \hyperlink{structmrp__domain__attr}{mrp\+\_\+domain\+\_\+attr} $\ast$class\+\_\+b)
\item 
int \hyperlink{listener__mrp__client_8c_a8036792ded75b687be4467c42ed21535}{join\+\_\+vlan} (struct \hyperlink{structmrp__domain__attr}{mrp\+\_\+domain\+\_\+attr} $\ast$class\+\_\+a, struct \hyperlink{structmrp__listener__ctx}{mrp\+\_\+listener\+\_\+ctx} $\ast$\hyperlink{jack_8h_a1cde2a2cf8a56164b5e83159035be03b}{ctx})
\item 
int \hyperlink{listener__mrp__client_8c_ab5307bd3ef0032cd28d4f98e85e45345}{await\+\_\+talker} (struct \hyperlink{structmrp__listener__ctx}{mrp\+\_\+listener\+\_\+ctx} $\ast$\hyperlink{jack_8h_a1cde2a2cf8a56164b5e83159035be03b}{ctx})
\item 
int \hyperlink{listener__mrp__client_8c_a41c898fcba8bc3bc312e1a10b66b620c}{send\+\_\+ready} (struct \hyperlink{structmrp__listener__ctx}{mrp\+\_\+listener\+\_\+ctx} $\ast$\hyperlink{jack_8h_a1cde2a2cf8a56164b5e83159035be03b}{ctx})
\item 
int \hyperlink{listener__mrp__client_8c_a8dc430f53ecc32196e67faeb2de9049d}{send\+\_\+leave} (struct \hyperlink{structmrp__listener__ctx}{mrp\+\_\+listener\+\_\+ctx} $\ast$\hyperlink{jack_8h_a1cde2a2cf8a56164b5e83159035be03b}{ctx})
\item 
int \hyperlink{listener__mrp__client_8c_a0057e5ce95d0d8ea29077cbb7bc03bb6}{mrp\+\_\+disconnect} (struct \hyperlink{structmrp__listener__ctx}{mrp\+\_\+listener\+\_\+ctx} $\ast$\hyperlink{jack_8h_a1cde2a2cf8a56164b5e83159035be03b}{ctx})
\end{DoxyCompactItemize}
\subsection*{변수}
\begin{DoxyCompactItemize}
\item 
pthread\+\_\+t \hyperlink{listener__mrp__client_8c_afbd6fc6e0ab3c1a04a518f19c21d4503}{monitor\+\_\+thread}
\item 
pthread\+\_\+attr\+\_\+t \hyperlink{listener__mrp__client_8c_a6c7e3f190d4c6369f0a70172f95416dd}{monitor\+\_\+attr}
\end{DoxyCompactItemize}


\subsection{함수 문서화}
\index{listener\+\_\+mrp\+\_\+client.\+c@{listener\+\_\+mrp\+\_\+client.\+c}!await\+\_\+talker@{await\+\_\+talker}}
\index{await\+\_\+talker@{await\+\_\+talker}!listener\+\_\+mrp\+\_\+client.\+c@{listener\+\_\+mrp\+\_\+client.\+c}}
\subsubsection[{\texorpdfstring{await\+\_\+talker(struct mrp\+\_\+listener\+\_\+ctx $\ast$ctx)}{await_talker(struct mrp_listener_ctx *ctx)}}]{\setlength{\rightskip}{0pt plus 5cm}int await\+\_\+talker (
\begin{DoxyParamCaption}
\item[{struct {\bf mrp\+\_\+listener\+\_\+ctx} $\ast$}]{ctx}
\end{DoxyParamCaption}
)}\hypertarget{listener__mrp__client_8c_ab5307bd3ef0032cd28d4f98e85e45345}{}\label{listener__mrp__client_8c_ab5307bd3ef0032cd28d4f98e85e45345}


listener\+\_\+mrp\+\_\+client.\+c 파일의 302 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
303 \{
304     \textcolor{keywordflow}{while} (0 == ctx->\hyperlink{structmrp__listener__ctx_afd1cfb96f67ad1b881b86ccbbf7af341}{talker})
305         ;
306     \textcolor{keywordflow}{return} 0;
307 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=223pt]{listener__mrp__client_8c_ab5307bd3ef0032cd28d4f98e85e45345_icgraph}
\end{center}
\end{figure}


\index{listener\+\_\+mrp\+\_\+client.\+c@{listener\+\_\+mrp\+\_\+client.\+c}!create\+\_\+socket@{create\+\_\+socket}}
\index{create\+\_\+socket@{create\+\_\+socket}!listener\+\_\+mrp\+\_\+client.\+c@{listener\+\_\+mrp\+\_\+client.\+c}}
\subsubsection[{\texorpdfstring{create\+\_\+socket(struct mrp\+\_\+listener\+\_\+ctx $\ast$ctx)}{create_socket(struct mrp_listener_ctx *ctx)}}]{\setlength{\rightskip}{0pt plus 5cm}int create\+\_\+socket (
\begin{DoxyParamCaption}
\item[{struct {\bf mrp\+\_\+listener\+\_\+ctx} $\ast$}]{ctx}
\end{DoxyParamCaption}
)}\hypertarget{listener__mrp__client_8c_abe45eedd55d5b13ad817c1adce0a5c7b}{}\label{listener__mrp__client_8c_abe45eedd55d5b13ad817c1adce0a5c7b}
in P\+O\+S\+IX fd 0,1,2 are reserved 

listener\+\_\+mrp\+\_\+client.\+c 파일의 143 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
144 \{
145     \textcolor{keyword}{struct }sockaddr\_in addr;
146     ctx->\hyperlink{structmrp__listener__ctx_ab16a0c776c464dcfb5cf8a013a137647}{control\_socket} = socket(AF\_INET, SOCK\_DGRAM, 0);
147 
149     \textcolor{keywordflow}{if} (2 > ctx->\hyperlink{structmrp__listener__ctx_ab16a0c776c464dcfb5cf8a013a137647}{control\_socket})
150     \{
151         \textcolor{keywordflow}{if} (-1 > ctx->\hyperlink{structmrp__listener__ctx_ab16a0c776c464dcfb5cf8a013a137647}{control\_socket})
152             close(ctx->\hyperlink{structmrp__listener__ctx_ab16a0c776c464dcfb5cf8a013a137647}{control\_socket});
153     \textcolor{keywordflow}{return} -1;
154     \}
155 
156     memset(&addr, 0, \textcolor{keyword}{sizeof}(addr));
157     addr.sin\_family = AF\_INET;
158     addr.sin\_port = htons(0);
159 
160     \textcolor{keywordflow}{if}(0 > (bind(ctx->\hyperlink{structmrp__listener__ctx_ab16a0c776c464dcfb5cf8a013a137647}{control\_socket}, (\textcolor{keyword}{struct} sockaddr*)&addr, \textcolor{keyword}{sizeof}(addr))))
161     \{
162         fprintf(stderr, \textcolor{stringliteral}{"Could not bind socket.\(\backslash\)n"});
163         close(ctx->\hyperlink{structmrp__listener__ctx_ab16a0c776c464dcfb5cf8a013a137647}{control\_socket});
164         \textcolor{keywordflow}{return} -1;
165     \}
166     \textcolor{keywordflow}{return} 0;
167 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=319pt]{listener__mrp__client_8c_abe45eedd55d5b13ad817c1adce0a5c7b_icgraph}
\end{center}
\end{figure}


\index{listener\+\_\+mrp\+\_\+client.\+c@{listener\+\_\+mrp\+\_\+client.\+c}!join\+\_\+vlan@{join\+\_\+vlan}}
\index{join\+\_\+vlan@{join\+\_\+vlan}!listener\+\_\+mrp\+\_\+client.\+c@{listener\+\_\+mrp\+\_\+client.\+c}}
\subsubsection[{\texorpdfstring{join\+\_\+vlan(struct mrp\+\_\+domain\+\_\+attr $\ast$class\+\_\+a, struct mrp\+\_\+listener\+\_\+ctx $\ast$ctx)}{join_vlan(struct mrp_domain_attr *class_a, struct mrp_listener_ctx *ctx)}}]{\setlength{\rightskip}{0pt plus 5cm}int join\+\_\+vlan (
\begin{DoxyParamCaption}
\item[{struct {\bf mrp\+\_\+domain\+\_\+attr} $\ast$}]{class\+\_\+a, }
\item[{struct {\bf mrp\+\_\+listener\+\_\+ctx} $\ast$}]{ctx}
\end{DoxyParamCaption}
)}\hypertarget{listener__mrp__client_8c_a8036792ded75b687be4467c42ed21535}{}\label{listener__mrp__client_8c_a8036792ded75b687be4467c42ed21535}


listener\+\_\+mrp\+\_\+client.\+c 파일의 282 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
283 \{
284     \textcolor{keywordtype}{char} *\hyperlink{mrp_validate_8c_a3820841c4bbf28f04505bea65d6b84f7}{msgbuf};
285     \textcolor{keywordtype}{int} rc;
286 
287     msgbuf = \hyperlink{_memory_leak_detector_malloc_macros_8h_ab8b25cd8f16d4a6552afe4e65c4f082d}{malloc}(1500);
288     \textcolor{keywordflow}{if} (\hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} == msgbuf)
289         \textcolor{keywordflow}{return} -1;
290     memset(msgbuf, 0, 1500);
291     sprintf(msgbuf, \textcolor{stringliteral}{"V++:I=%04x\(\backslash\)n"},class\_a->\hyperlink{structmrp__domain__attr_a066fae47f1854479570ecc0bf7e488c3}{vid});
292     printf(\textcolor{stringliteral}{"Joing VLAN %s\(\backslash\)n"},msgbuf);
293     rc = \hyperlink{listener__mrp__client_8c_a925f75b25e5ea1ed0e082c771f9d6242}{send\_msg}(msgbuf, 1500, ctx);
294     \hyperlink{_memory_leak_detector_malloc_macros_8h_aa7157aa9480bb73f090dca36776419bf}{free}(msgbuf);
295 
296     \textcolor{keywordflow}{if} (rc != 1500)
297         \textcolor{keywordflow}{return} -1;
298     \textcolor{keywordflow}{else}
299         \textcolor{keywordflow}{return} 0;
300 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=233pt]{listener__mrp__client_8c_a8036792ded75b687be4467c42ed21535_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=296pt]{listener__mrp__client_8c_a8036792ded75b687be4467c42ed21535_icgraph}
\end{center}
\end{figure}


\index{listener\+\_\+mrp\+\_\+client.\+c@{listener\+\_\+mrp\+\_\+client.\+c}!mrp\+\_\+disconnect@{mrp\+\_\+disconnect}}
\index{mrp\+\_\+disconnect@{mrp\+\_\+disconnect}!listener\+\_\+mrp\+\_\+client.\+c@{listener\+\_\+mrp\+\_\+client.\+c}}
\subsubsection[{\texorpdfstring{mrp\+\_\+disconnect(struct mrp\+\_\+listener\+\_\+ctx $\ast$ctx)}{mrp_disconnect(struct mrp_listener_ctx *ctx)}}]{\setlength{\rightskip}{0pt plus 5cm}int mrp\+\_\+disconnect (
\begin{DoxyParamCaption}
\item[{struct {\bf mrp\+\_\+listener\+\_\+ctx} $\ast$}]{ctx}
\end{DoxyParamCaption}
)}\hypertarget{listener__mrp__client_8c_a0057e5ce95d0d8ea29077cbb7bc03bb6}{}\label{listener__mrp__client_8c_a0057e5ce95d0d8ea29077cbb7bc03bb6}


listener\+\_\+mrp\+\_\+client.\+c 파일의 355 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
356 \{
357     \textcolor{keywordtype}{int} rc;
358     \textcolor{keywordtype}{char} *\hyperlink{mrp_validate_8c_a3820841c4bbf28f04505bea65d6b84f7}{msgbuf} = \hyperlink{_memory_leak_detector_malloc_macros_8h_ab8b25cd8f16d4a6552afe4e65c4f082d}{malloc}(1500);
359 
360     \textcolor{keywordflow}{if} (\hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} == msgbuf)
361         \textcolor{keywordflow}{return} -1;
362     memset(msgbuf, 0, 1500);
363 
364     sprintf(msgbuf, \textcolor{stringliteral}{"BYE"});
365     rc = \hyperlink{listener__mrp__client_8c_a925f75b25e5ea1ed0e082c771f9d6242}{send\_msg}(msgbuf, 1500, ctx);
366     \hyperlink{_memory_leak_detector_malloc_macros_8h_aa7157aa9480bb73f090dca36776419bf}{free}(msgbuf);
367 
368     \textcolor{keywordflow}{if} (rc != 1500)
369         \textcolor{keywordflow}{return} -1;
370     \textcolor{keywordflow}{else}
371         \textcolor{keywordflow}{return} 0;
372 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=264pt]{listener__mrp__client_8c_a0057e5ce95d0d8ea29077cbb7bc03bb6_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{listener__mrp__client_8c_a0057e5ce95d0d8ea29077cbb7bc03bb6_icgraph}
\end{center}
\end{figure}


\index{listener\+\_\+mrp\+\_\+client.\+c@{listener\+\_\+mrp\+\_\+client.\+c}!mrp\+\_\+get\+\_\+domain@{mrp\+\_\+get\+\_\+domain}}
\index{mrp\+\_\+get\+\_\+domain@{mrp\+\_\+get\+\_\+domain}!listener\+\_\+mrp\+\_\+client.\+c@{listener\+\_\+mrp\+\_\+client.\+c}}
\subsubsection[{\texorpdfstring{mrp\+\_\+get\+\_\+domain(struct mrp\+\_\+listener\+\_\+ctx $\ast$ctx, struct mrp\+\_\+domain\+\_\+attr $\ast$class\+\_\+a, struct mrp\+\_\+domain\+\_\+attr $\ast$class\+\_\+b)}{mrp_get_domain(struct mrp_listener_ctx *ctx, struct mrp_domain_attr *class_a, struct mrp_domain_attr *class_b)}}]{\setlength{\rightskip}{0pt plus 5cm}int mrp\+\_\+get\+\_\+domain (
\begin{DoxyParamCaption}
\item[{struct {\bf mrp\+\_\+listener\+\_\+ctx} $\ast$}]{ctx, }
\item[{struct {\bf mrp\+\_\+domain\+\_\+attr} $\ast$}]{class\+\_\+a, }
\item[{struct {\bf mrp\+\_\+domain\+\_\+attr} $\ast$}]{class\+\_\+b}
\end{DoxyParamCaption}
)}\hypertarget{listener__mrp__client_8c_ad9e5734b8f3e186460f459b6c3c395b5}{}\label{listener__mrp__client_8c_ad9e5734b8f3e186460f459b6c3c395b5}


listener\+\_\+mrp\+\_\+client.\+c 파일의 244 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
245 \{
246     \textcolor{keywordtype}{char} *\hyperlink{mrp_validate_8c_a3820841c4bbf28f04505bea65d6b84f7}{msgbuf};
247     \textcolor{keywordtype}{int} ret;
248 
249     \textcolor{comment}{/* we may not get a notification if we are joining late,}
250 \textcolor{comment}{     * so query for what is already there ...}
251 \textcolor{comment}{     */}
252     msgbuf = \hyperlink{_memory_leak_detector_malloc_macros_8h_ab8b25cd8f16d4a6552afe4e65c4f082d}{malloc}(1500);
253     \textcolor{keywordflow}{if} (\hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} == msgbuf)
254         \textcolor{keywordflow}{return} -1;
255     memset(msgbuf, 0, 1500);
256     sprintf(msgbuf, \textcolor{stringliteral}{"S??"});
257     ret = \hyperlink{listener__mrp__client_8c_a925f75b25e5ea1ed0e082c771f9d6242}{send\_msg}(msgbuf, 1500, ctx);
258     \hyperlink{_memory_leak_detector_malloc_macros_8h_aa7157aa9480bb73f090dca36776419bf}{free}(msgbuf);
259     \textcolor{keywordflow}{if} (ret != 1500)
260         \textcolor{keywordflow}{return} -1;
261     \textcolor{keywordflow}{while} (!ctx->\hyperlink{structmrp__listener__ctx_a7c8176263e9704aa667fc335cc818a3f}{halt\_tx} && (ctx->\hyperlink{structmrp__listener__ctx_ae3be05692572d8c757174629541e2d91}{domain\_a\_valid} == 0) && (ctx->
      \hyperlink{structmrp__listener__ctx_add1f58f9a17de764566dbf2e352b907f}{domain\_b\_valid} == 0))
262         usleep(20000);
263     class\_a->\hyperlink{structmrp__domain__attr_a7441ef0865bcb3db9b8064dd7375c1ea}{id} = 0;
264     class\_a->\hyperlink{structmrp__domain__attr_acec9ce2df15222151ad66fcb1d74eb9f}{priority} = 0;
265     class\_a->\hyperlink{structmrp__domain__attr_a066fae47f1854479570ecc0bf7e488c3}{vid} = 0;
266     class\_b->\hyperlink{structmrp__domain__attr_a7441ef0865bcb3db9b8064dd7375c1ea}{id} = 0;
267     class\_b->\hyperlink{structmrp__domain__attr_acec9ce2df15222151ad66fcb1d74eb9f}{priority} = 0;
268     class\_b->\hyperlink{structmrp__domain__attr_a066fae47f1854479570ecc0bf7e488c3}{vid} = 0;
269     \textcolor{keywordflow}{if} (ctx->\hyperlink{structmrp__listener__ctx_ae3be05692572d8c757174629541e2d91}{domain\_a\_valid}) \{
270         class\_a->\hyperlink{structmrp__domain__attr_a7441ef0865bcb3db9b8064dd7375c1ea}{id} = ctx->\hyperlink{structmrp__listener__ctx_a6e4374793667e90915abfe73f0e6201c}{domain\_class\_a\_id};
271         class\_a->\hyperlink{structmrp__domain__attr_acec9ce2df15222151ad66fcb1d74eb9f}{priority} = ctx->\hyperlink{structmrp__listener__ctx_ac98b99ec0ffd190c1da93e6caffe36d4}{domain\_class\_a\_priority};
272         class\_a->\hyperlink{structmrp__domain__attr_a066fae47f1854479570ecc0bf7e488c3}{vid} = ctx->\hyperlink{structmrp__listener__ctx_ac575246135a50baaf0c802ef29aa2779}{domain\_class\_a\_vid};
273     \}
274     \textcolor{keywordflow}{if} (ctx->\hyperlink{structmrp__listener__ctx_add1f58f9a17de764566dbf2e352b907f}{domain\_b\_valid}) \{
275         class\_b->\hyperlink{structmrp__domain__attr_a7441ef0865bcb3db9b8064dd7375c1ea}{id} = ctx->\hyperlink{structmrp__listener__ctx_a058aabd498c78e32b6610fd06f90fc43}{domain\_class\_b\_id};
276         class\_b->\hyperlink{structmrp__domain__attr_acec9ce2df15222151ad66fcb1d74eb9f}{priority} = ctx->\hyperlink{structmrp__listener__ctx_a90efafdfc3b16f51cc0f67aa65796a3c}{domain\_class\_b\_priority};
277         class\_b->\hyperlink{structmrp__domain__attr_a066fae47f1854479570ecc0bf7e488c3}{vid} = ctx->\hyperlink{structmrp__listener__ctx_a153312a7212b932f60b49a67309f2053}{domain\_class\_b\_vid};
278     \}
279     \textcolor{keywordflow}{return} 0;
280 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=267pt]{listener__mrp__client_8c_ad9e5734b8f3e186460f459b6c3c395b5_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{listener__mrp__client_8c_ad9e5734b8f3e186460f459b6c3c395b5_icgraph}
\end{center}
\end{figure}


\index{listener\+\_\+mrp\+\_\+client.\+c@{listener\+\_\+mrp\+\_\+client.\+c}!mrp\+\_\+listener\+\_\+client\+\_\+init@{mrp\+\_\+listener\+\_\+client\+\_\+init}}
\index{mrp\+\_\+listener\+\_\+client\+\_\+init@{mrp\+\_\+listener\+\_\+client\+\_\+init}!listener\+\_\+mrp\+\_\+client.\+c@{listener\+\_\+mrp\+\_\+client.\+c}}
\subsubsection[{\texorpdfstring{mrp\+\_\+listener\+\_\+client\+\_\+init(struct mrp\+\_\+listener\+\_\+ctx $\ast$ctx)}{mrp_listener_client_init(struct mrp_listener_ctx *ctx)}}]{\setlength{\rightskip}{0pt plus 5cm}int mrp\+\_\+listener\+\_\+client\+\_\+init (
\begin{DoxyParamCaption}
\item[{struct {\bf mrp\+\_\+listener\+\_\+ctx} $\ast$}]{ctx}
\end{DoxyParamCaption}
)}\hypertarget{listener__mrp__client_8c_a6c13af7ba5d48d218f1504b9a14314c0}{}\label{listener__mrp__client_8c_a6c13af7ba5d48d218f1504b9a14314c0}


listener\+\_\+mrp\+\_\+client.\+c 파일의 37 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
38 \{
39     \textcolor{keywordtype}{int} i;
40     ctx->\hyperlink{structmrp__listener__ctx_ab16a0c776c464dcfb5cf8a013a137647}{control\_socket}=-1;
41     ctx->\hyperlink{structmrp__listener__ctx_afd1cfb96f67ad1b881b86ccbbf7af341}{talker} = 0;
42     ctx->\hyperlink{structmrp__listener__ctx_a7c8176263e9704aa667fc335cc818a3f}{halt\_tx} = 0;
43     ctx->\hyperlink{structmrp__listener__ctx_ae3be05692572d8c757174629541e2d91}{domain\_a\_valid} = 0;
44     ctx->\hyperlink{structmrp__listener__ctx_a6e4374793667e90915abfe73f0e6201c}{domain\_class\_a\_id} = 0;
45     ctx->\hyperlink{structmrp__listener__ctx_ac98b99ec0ffd190c1da93e6caffe36d4}{domain\_class\_a\_priority} = 0;
46     ctx->\hyperlink{structmrp__listener__ctx_ac575246135a50baaf0c802ef29aa2779}{domain\_class\_a\_vid} = 0;
47     ctx->\hyperlink{structmrp__listener__ctx_add1f58f9a17de764566dbf2e352b907f}{domain\_b\_valid} = 0;
48     ctx->\hyperlink{structmrp__listener__ctx_a058aabd498c78e32b6610fd06f90fc43}{domain\_class\_b\_id} = 0;
49     ctx->\hyperlink{structmrp__listener__ctx_a90efafdfc3b16f51cc0f67aa65796a3c}{domain\_class\_b\_priority} = 0;
50     ctx->\hyperlink{structmrp__listener__ctx_a153312a7212b932f60b49a67309f2053}{domain\_class\_b\_vid} = 0;
51     \textcolor{keywordflow}{for} (i=0;i<8;i++)
52     \{
53         ctx->\hyperlink{structmrp__listener__ctx_a190ce42cbfefb20ada402ce90519cc32}{stream\_id}[i]=0;
54     \}
55     \textcolor{keywordflow}{for} (i=0;i<6;i++)
56     \{
57         ctx->\hyperlink{structmrp__listener__ctx_adfd737d7370a81c521ecc86600c9922a}{dst\_mac}[i]=0;
58     \}
59     \textcolor{keywordflow}{return} 0;
60 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{listener__mrp__client_8c_a6c13af7ba5d48d218f1504b9a14314c0_icgraph}
\end{center}
\end{figure}


\index{listener\+\_\+mrp\+\_\+client.\+c@{listener\+\_\+mrp\+\_\+client.\+c}!mrp\+\_\+monitor@{mrp\+\_\+monitor}}
\index{mrp\+\_\+monitor@{mrp\+\_\+monitor}!listener\+\_\+mrp\+\_\+client.\+c@{listener\+\_\+mrp\+\_\+client.\+c}}
\subsubsection[{\texorpdfstring{mrp\+\_\+monitor(struct mrp\+\_\+listener\+\_\+ctx $\ast$ctx)}{mrp_monitor(struct mrp_listener_ctx *ctx)}}]{\setlength{\rightskip}{0pt plus 5cm}int mrp\+\_\+monitor (
\begin{DoxyParamCaption}
\item[{struct {\bf mrp\+\_\+listener\+\_\+ctx} $\ast$}]{ctx}
\end{DoxyParamCaption}
)}\hypertarget{listener__mrp__client_8c_ac298236801a3836999c032e006e55493}{}\label{listener__mrp__client_8c_ac298236801a3836999c032e006e55493}


listener\+\_\+mrp\+\_\+client.\+c 파일의 217 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
218 \{
219     \textcolor{keywordtype}{int} rc;
220     rc = pthread\_attr\_init(&\hyperlink{listener__mrp__client_8c_a6c7e3f190d4c6369f0a70172f95416dd}{monitor\_attr});
221     rc |= pthread\_create(&\hyperlink{listener__mrp__client_8c_afbd6fc6e0ab3c1a04a518f19c21d4503}{monitor\_thread}, \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}, 
      \hyperlink{listener__mrp__client_8c_afdd2d7bcf3cde2ab45b078d253558c2d}{mrp\_monitor\_thread}, ctx);
222     \textcolor{keywordflow}{return} rc;
223 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{listener__mrp__client_8c_ac298236801a3836999c032e006e55493_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{listener__mrp__client_8c_ac298236801a3836999c032e006e55493_icgraph}
\end{center}
\end{figure}


\index{listener\+\_\+mrp\+\_\+client.\+c@{listener\+\_\+mrp\+\_\+client.\+c}!mrp\+\_\+monitor\+\_\+thread@{mrp\+\_\+monitor\+\_\+thread}}
\index{mrp\+\_\+monitor\+\_\+thread@{mrp\+\_\+monitor\+\_\+thread}!listener\+\_\+mrp\+\_\+client.\+c@{listener\+\_\+mrp\+\_\+client.\+c}}
\subsubsection[{\texorpdfstring{mrp\+\_\+monitor\+\_\+thread(void $\ast$arg)}{mrp_monitor_thread(void *arg)}}]{\setlength{\rightskip}{0pt plus 5cm}void$\ast$ mrp\+\_\+monitor\+\_\+thread (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{arg}
\end{DoxyParamCaption}
)}\hypertarget{listener__mrp__client_8c_afdd2d7bcf3cde2ab45b078d253558c2d}{}\label{listener__mrp__client_8c_afdd2d7bcf3cde2ab45b078d253558c2d}


listener\+\_\+mrp\+\_\+client.\+c 파일의 169 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
170 \{
171     \textcolor{keywordtype}{char} *\hyperlink{mrp_validate_8c_a3820841c4bbf28f04505bea65d6b84f7}{msgbuf};
172     \textcolor{keyword}{struct }sockaddr\_in client\_addr;
173     \textcolor{keyword}{struct }msghdr \hyperlink{maap__log__linux_8c_a0c7e58a50354c4a4d6dad428d0e47029}{msg};
174     \textcolor{keyword}{struct }iovec iov;
175     \textcolor{keywordtype}{int} bytes = 0;
176     \textcolor{keyword}{struct }pollfd \hyperlink{openavb__avdecc__msg__server__osal_8c_ae18b289099c8c9be5f76acee6311699a}{fds};
177     \textcolor{keywordtype}{int} rc;
178     \textcolor{keyword}{struct }\hyperlink{structmrp__listener__ctx}{mrp\_listener\_ctx} *\hyperlink{jack_8h_a1cde2a2cf8a56164b5e83159035be03b}{ctx} = (\textcolor{keyword}{struct }\hyperlink{structmrp__listener__ctx}{mrp\_listener\_ctx}*) arg;
179 
180     msgbuf = (\textcolor{keywordtype}{char} *)\hyperlink{_memory_leak_detector_malloc_macros_8h_ab8b25cd8f16d4a6552afe4e65c4f082d}{malloc}(\hyperlink{mrpd_8h_a63a4db05a55163366a16c61994e77a6f}{MAX\_MRPD\_CMDSZ});
181     \textcolor{keywordflow}{if} (\hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} == msgbuf)
182         \textcolor{keywordflow}{return} \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
183     \textcolor{keywordflow}{while} (!ctx->\hyperlink{structmrp__listener__ctx_a7c8176263e9704aa667fc335cc818a3f}{halt\_tx}) \{
184         \hyperlink{openavb__avdecc__msg__server__osal_8c_ae18b289099c8c9be5f76acee6311699a}{fds}.fd = ctx->\hyperlink{structmrp__listener__ctx_ab16a0c776c464dcfb5cf8a013a137647}{control\_socket};
185         \hyperlink{openavb__avdecc__msg__server__osal_8c_ae18b289099c8c9be5f76acee6311699a}{fds}.events = POLLIN;
186         \hyperlink{openavb__avdecc__msg__server__osal_8c_ae18b289099c8c9be5f76acee6311699a}{fds}.revents = 0;
187         rc = poll(&\hyperlink{openavb__avdecc__msg__server__osal_8c_ae18b289099c8c9be5f76acee6311699a}{fds}, 1, 100);
188         \textcolor{keywordflow}{if} (rc < 0) \{
189             \hyperlink{_memory_leak_detector_malloc_macros_8h_aa7157aa9480bb73f090dca36776419bf}{free}(msgbuf);
190             pthread\_exit(\hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL});
191         \}
192         \textcolor{keywordflow}{if} (rc == 0)
193             \textcolor{keywordflow}{continue};
194         \textcolor{keywordflow}{if} ((\hyperlink{openavb__avdecc__msg__server__osal_8c_ae18b289099c8c9be5f76acee6311699a}{fds}.revents & POLLIN) == 0) \{
195             \hyperlink{_memory_leak_detector_malloc_macros_8h_aa7157aa9480bb73f090dca36776419bf}{free}(msgbuf);
196             pthread\_exit(\hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL});
197         \}
198         memset(&\hyperlink{maap__log__linux_8c_a0c7e58a50354c4a4d6dad428d0e47029}{msg}, 0, \textcolor{keyword}{sizeof}(\hyperlink{maap__log__linux_8c_a0c7e58a50354c4a4d6dad428d0e47029}{msg}));
199         memset(&client\_addr, 0, \textcolor{keyword}{sizeof}(client\_addr));
200         memset(msgbuf, 0, \hyperlink{mrpd_8h_a63a4db05a55163366a16c61994e77a6f}{MAX\_MRPD\_CMDSZ});
201         iov.iov\_len = \hyperlink{mrpd_8h_a63a4db05a55163366a16c61994e77a6f}{MAX\_MRPD\_CMDSZ};
202         iov.iov\_base = \hyperlink{mrp_validate_8c_a3820841c4bbf28f04505bea65d6b84f7}{msgbuf};
203         \hyperlink{maap__log__linux_8c_a0c7e58a50354c4a4d6dad428d0e47029}{msg}.msg\_name = &client\_addr;
204         \hyperlink{maap__log__linux_8c_a0c7e58a50354c4a4d6dad428d0e47029}{msg}.msg\_namelen = \textcolor{keyword}{sizeof}(client\_addr);
205         \hyperlink{maap__log__linux_8c_a0c7e58a50354c4a4d6dad428d0e47029}{msg}.msg\_iov = &iov;
206         \hyperlink{maap__log__linux_8c_a0c7e58a50354c4a4d6dad428d0e47029}{msg}.msg\_iovlen = 1;
207         bytes = recvmsg(ctx->\hyperlink{structmrp__listener__ctx_ab16a0c776c464dcfb5cf8a013a137647}{control\_socket}, &\hyperlink{maap__log__linux_8c_a0c7e58a50354c4a4d6dad428d0e47029}{msg}, 0);
208         \textcolor{keywordflow}{if} (bytes < 0)
209             \textcolor{keywordflow}{continue};
210         \hyperlink{listener__mrp__client_8c_a2f5369074acd8aa23c34c272c0b2bf31}{msg\_process}(msgbuf, bytes, ctx);
211     \}
212     \hyperlink{_memory_leak_detector_malloc_macros_8h_aa7157aa9480bb73f090dca36776419bf}{free}(msgbuf);
213     pthread\_exit(\hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL});
214 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=294pt]{listener__mrp__client_8c_afdd2d7bcf3cde2ab45b078d253558c2d_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{listener__mrp__client_8c_afdd2d7bcf3cde2ab45b078d253558c2d_icgraph}
\end{center}
\end{figure}


\index{listener\+\_\+mrp\+\_\+client.\+c@{listener\+\_\+mrp\+\_\+client.\+c}!msg\+\_\+process@{msg\+\_\+process}}
\index{msg\+\_\+process@{msg\+\_\+process}!listener\+\_\+mrp\+\_\+client.\+c@{listener\+\_\+mrp\+\_\+client.\+c}}
\subsubsection[{\texorpdfstring{msg\+\_\+process(char $\ast$buf, int buflen, struct mrp\+\_\+listener\+\_\+ctx $\ast$ctx)}{msg_process(char *buf, int buflen, struct mrp_listener_ctx *ctx)}}]{\setlength{\rightskip}{0pt plus 5cm}int msg\+\_\+process (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{buf, }
\item[{int}]{buflen, }
\item[{struct {\bf mrp\+\_\+listener\+\_\+ctx} $\ast$}]{ctx}
\end{DoxyParamCaption}
)}\hypertarget{listener__mrp__client_8c_a2f5369074acd8aa23c34c272c0b2bf31}{}\label{listener__mrp__client_8c_a2f5369074acd8aa23c34c272c0b2bf31}


listener\+\_\+mrp\+\_\+client.\+c 파일의 80 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
81 \{
82     \hyperlink{parse_8c_a6eb1e68cc391dd753bc8ce896dbb8315}{uint32\_t} id;
83     \textcolor{keywordtype}{int} j, l=0;
84     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} vid;
85     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \hyperlink{aaf-talker_8c_acec9ce2df15222151ad66fcb1d74eb9f}{priority};
86 
87     fprintf(stderr, \textcolor{stringliteral}{"Msg: %s\(\backslash\)n"}, buf);
88 
89     \textcolor{keywordflow}{if} (strncmp(buf, \textcolor{stringliteral}{"SNE T:"}, 6) == 0 || strncmp(buf, \textcolor{stringliteral}{"SJO T:"}, 6) == 0)
90     \{
91         l = 6; \textcolor{comment}{/* skip "Sxx T:" */}
92         \textcolor{keywordflow}{while} ((l < buflen) && (\textcolor{charliteral}{'S'} != buf[l++]));
93         \textcolor{keywordflow}{if} (l == buflen)
94             \textcolor{keywordflow}{return} -1;
95         l++;
96         \textcolor{keywordflow}{for}(j = 0; j < 8 ; l+=2, j++)
97         \{
98             sscanf(&buf[l],\textcolor{stringliteral}{"%02x"},&\textcolor{keywordtype}{id});
99             ctx->\hyperlink{structmrp__listener__ctx_a190ce42cbfefb20ada402ce90519cc32}{stream\_id}[j] = (\textcolor{keywordtype}{unsigned} char)\textcolor{keywordtype}{id};
100         \}
101         l+=3;
102         \textcolor{keywordflow}{for}(j = 0; j < 6 ; l+=2, j++)
103         \{
104             sscanf(&buf[l],\textcolor{stringliteral}{"%02x"},&\textcolor{keywordtype}{id});
105             ctx->\hyperlink{structmrp__listener__ctx_adfd737d7370a81c521ecc86600c9922a}{dst\_mac}[j] = (\textcolor{keywordtype}{unsigned} char)\textcolor{keywordtype}{id};
106         \}
107         ctx->\hyperlink{structmrp__listener__ctx_afd1cfb96f67ad1b881b86ccbbf7af341}{talker} = 1;
108     \}
109 
110     \textcolor{keywordflow}{if} (strncmp(buf, \textcolor{stringliteral}{"SJO D:"}, 6) == 0)
111     \{
112         l=8;
113         sscanf(&(buf[l]), \textcolor{stringliteral}{"%d"}, &\textcolor{keywordtype}{id});
114         l=l+4;
115         sscanf(&(buf[l]), \textcolor{stringliteral}{"%d"}, &priority);
116         l=l+4;
117         sscanf(&(buf[l]), \textcolor{stringliteral}{"%x"}, &vid);
118 
119         \textcolor{keywordflow}{if} (\textcolor{keywordtype}{id} == 6)
120         \{
121             ctx->\hyperlink{structmrp__listener__ctx_a6e4374793667e90915abfe73f0e6201c}{domain\_class\_a\_id} = id;
122             ctx->\hyperlink{structmrp__listener__ctx_ac98b99ec0ffd190c1da93e6caffe36d4}{domain\_class\_a\_priority} = \hyperlink{aaf-talker_8c_acec9ce2df15222151ad66fcb1d74eb9f}{priority};
123             ctx->\hyperlink{structmrp__listener__ctx_ac575246135a50baaf0c802ef29aa2779}{domain\_class\_a\_vid} = vid;
124             ctx->\hyperlink{structmrp__listener__ctx_ae3be05692572d8c757174629541e2d91}{domain\_a\_valid} = 1;
125         \}
126         \textcolor{keywordflow}{else}
127         \{
128             ctx->\hyperlink{structmrp__listener__ctx_a058aabd498c78e32b6610fd06f90fc43}{domain\_class\_b\_id} = id;
129             ctx->\hyperlink{structmrp__listener__ctx_a90efafdfc3b16f51cc0f67aa65796a3c}{domain\_class\_b\_priority} = \hyperlink{aaf-talker_8c_acec9ce2df15222151ad66fcb1d74eb9f}{priority};
130             ctx->\hyperlink{structmrp__listener__ctx_a153312a7212b932f60b49a67309f2053}{domain\_class\_b\_vid} = vid;
131             ctx->\hyperlink{structmrp__listener__ctx_add1f58f9a17de764566dbf2e352b907f}{domain\_b\_valid} = 1;
132         \}
133         l+=4;
134 
135     \}
136     \textcolor{keywordflow}{return} 0;
137 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{listener__mrp__client_8c_a2f5369074acd8aa23c34c272c0b2bf31_icgraph}
\end{center}
\end{figure}


\index{listener\+\_\+mrp\+\_\+client.\+c@{listener\+\_\+mrp\+\_\+client.\+c}!report\+\_\+domain\+\_\+status@{report\+\_\+domain\+\_\+status}}
\index{report\+\_\+domain\+\_\+status@{report\+\_\+domain\+\_\+status}!listener\+\_\+mrp\+\_\+client.\+c@{listener\+\_\+mrp\+\_\+client.\+c}}
\subsubsection[{\texorpdfstring{report\+\_\+domain\+\_\+status(struct mrp\+\_\+domain\+\_\+attr $\ast$class\+\_\+a, struct mrp\+\_\+listener\+\_\+ctx $\ast$ctx)}{report_domain_status(struct mrp_domain_attr *class_a, struct mrp_listener_ctx *ctx)}}]{\setlength{\rightskip}{0pt plus 5cm}int report\+\_\+domain\+\_\+status (
\begin{DoxyParamCaption}
\item[{struct {\bf mrp\+\_\+domain\+\_\+attr} $\ast$}]{class\+\_\+a, }
\item[{struct {\bf mrp\+\_\+listener\+\_\+ctx} $\ast$}]{ctx}
\end{DoxyParamCaption}
)}\hypertarget{listener__mrp__client_8c_a0ae45edb27d4d77bb4bf8d0c4d01f74e}{}\label{listener__mrp__client_8c_a0ae45edb27d4d77bb4bf8d0c4d01f74e}


listener\+\_\+mrp\+\_\+client.\+c 파일의 225 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
226 \{
227     \textcolor{keywordtype}{char}* \hyperlink{mrp_validate_8c_a3820841c4bbf28f04505bea65d6b84f7}{msgbuf};
228     \textcolor{keywordtype}{int} rc;
229 
230     msgbuf = \hyperlink{_memory_leak_detector_malloc_macros_8h_ab8b25cd8f16d4a6552afe4e65c4f082d}{malloc}(1500);
231     \textcolor{keywordflow}{if} (\hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} == msgbuf)
232         \textcolor{keywordflow}{return} -1;
233     memset(msgbuf, 0, 1500);
234     sprintf(msgbuf, \textcolor{stringliteral}{"S+D:C=%d,P=%d,V=%04x"}, class\_a->\hyperlink{structmrp__domain__attr_a7441ef0865bcb3db9b8064dd7375c1ea}{id}, class\_a->\hyperlink{structmrp__domain__attr_acec9ce2df15222151ad66fcb1d74eb9f}{priority}, class\_a->
      \hyperlink{structmrp__domain__attr_a066fae47f1854479570ecc0bf7e488c3}{vid});
235     rc = \hyperlink{listener__mrp__client_8c_a925f75b25e5ea1ed0e082c771f9d6242}{send\_msg}(msgbuf, 1500, ctx);
236     \hyperlink{_memory_leak_detector_malloc_macros_8h_aa7157aa9480bb73f090dca36776419bf}{free}(msgbuf);
237 
238     \textcolor{keywordflow}{if} (rc != 1500)
239         \textcolor{keywordflow}{return} -1;
240     \textcolor{keywordflow}{else}
241         \textcolor{keywordflow}{return} 0;
242 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=288pt]{listener__mrp__client_8c_a0ae45edb27d4d77bb4bf8d0c4d01f74e_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{listener__mrp__client_8c_a0ae45edb27d4d77bb4bf8d0c4d01f74e_icgraph}
\end{center}
\end{figure}


\index{listener\+\_\+mrp\+\_\+client.\+c@{listener\+\_\+mrp\+\_\+client.\+c}!send\+\_\+leave@{send\+\_\+leave}}
\index{send\+\_\+leave@{send\+\_\+leave}!listener\+\_\+mrp\+\_\+client.\+c@{listener\+\_\+mrp\+\_\+client.\+c}}
\subsubsection[{\texorpdfstring{send\+\_\+leave(struct mrp\+\_\+listener\+\_\+ctx $\ast$ctx)}{send_leave(struct mrp_listener_ctx *ctx)}}]{\setlength{\rightskip}{0pt plus 5cm}int send\+\_\+leave (
\begin{DoxyParamCaption}
\item[{struct {\bf mrp\+\_\+listener\+\_\+ctx} $\ast$}]{ctx}
\end{DoxyParamCaption}
)}\hypertarget{listener__mrp__client_8c_a8dc430f53ecc32196e67faeb2de9049d}{}\label{listener__mrp__client_8c_a8dc430f53ecc32196e67faeb2de9049d}


listener\+\_\+mrp\+\_\+client.\+c 파일의 332 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
333 \{
334     \textcolor{keywordtype}{char} *databuf;
335     \textcolor{keywordtype}{int} rc;
336 
337     databuf = \hyperlink{_memory_leak_detector_malloc_macros_8h_ab8b25cd8f16d4a6552afe4e65c4f082d}{malloc}(1500);
338     \textcolor{keywordflow}{if} (\hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} == databuf)
339         \textcolor{keywordflow}{return} -1;
340     memset(databuf, 0, 1500);
341     sprintf(databuf, \textcolor{stringliteral}{"S-L:L=%02x%02x%02x%02x%02x%02x%02x%02x, D=3"},
342              ctx->\hyperlink{structmrp__listener__ctx_a190ce42cbfefb20ada402ce90519cc32}{stream\_id}[0], ctx->\hyperlink{structmrp__listener__ctx_a190ce42cbfefb20ada402ce90519cc32}{stream\_id}[1],
343              ctx->\hyperlink{structmrp__listener__ctx_a190ce42cbfefb20ada402ce90519cc32}{stream\_id}[2], ctx->\hyperlink{structmrp__listener__ctx_a190ce42cbfefb20ada402ce90519cc32}{stream\_id}[3],
344              ctx->\hyperlink{structmrp__listener__ctx_a190ce42cbfefb20ada402ce90519cc32}{stream\_id}[4], ctx->\hyperlink{structmrp__listener__ctx_a190ce42cbfefb20ada402ce90519cc32}{stream\_id}[5],
345              ctx->\hyperlink{structmrp__listener__ctx_a190ce42cbfefb20ada402ce90519cc32}{stream\_id}[6], ctx->\hyperlink{structmrp__listener__ctx_a190ce42cbfefb20ada402ce90519cc32}{stream\_id}[7]);
346     rc = \hyperlink{listener__mrp__client_8c_a925f75b25e5ea1ed0e082c771f9d6242}{send\_msg}(databuf, 1500, ctx);
347     \hyperlink{_memory_leak_detector_malloc_macros_8h_aa7157aa9480bb73f090dca36776419bf}{free}(databuf);
348 
349     \textcolor{keywordflow}{if} (rc != 1500)
350         \textcolor{keywordflow}{return} -1;
351     \textcolor{keywordflow}{else}
352         \textcolor{keywordflow}{return} 0;
353 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=244pt]{listener__mrp__client_8c_a8dc430f53ecc32196e67faeb2de9049d_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{listener__mrp__client_8c_a8dc430f53ecc32196e67faeb2de9049d_icgraph}
\end{center}
\end{figure}


\index{listener\+\_\+mrp\+\_\+client.\+c@{listener\+\_\+mrp\+\_\+client.\+c}!send\+\_\+msg@{send\+\_\+msg}}
\index{send\+\_\+msg@{send\+\_\+msg}!listener\+\_\+mrp\+\_\+client.\+c@{listener\+\_\+mrp\+\_\+client.\+c}}
\subsubsection[{\texorpdfstring{send\+\_\+msg(char $\ast$data, int data\+\_\+len, struct mrp\+\_\+listener\+\_\+ctx $\ast$ctx)}{send_msg(char *data, int data_len, struct mrp_listener_ctx *ctx)}}]{\setlength{\rightskip}{0pt plus 5cm}int send\+\_\+msg (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{data, }
\item[{int}]{data\+\_\+len, }
\item[{struct {\bf mrp\+\_\+listener\+\_\+ctx} $\ast$}]{ctx}
\end{DoxyParamCaption}
)}\hypertarget{listener__mrp__client_8c_a925f75b25e5ea1ed0e082c771f9d6242}{}\label{listener__mrp__client_8c_a925f75b25e5ea1ed0e082c771f9d6242}


listener\+\_\+mrp\+\_\+client.\+c 파일의 62 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
63 \{
64     \textcolor{keyword}{struct }sockaddr\_in addr;
65 
66     \textcolor{keywordflow}{if} (ctx->\hyperlink{structmrp__listener__ctx_ab16a0c776c464dcfb5cf8a013a137647}{control\_socket} == -1)
67         \textcolor{keywordflow}{return} -1;
68     \textcolor{keywordflow}{if} (data == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
69         \textcolor{keywordflow}{return} -1;
70 
71     memset(&addr, 0, \textcolor{keyword}{sizeof}(addr));
72     addr.sin\_family = AF\_INET;
73     addr.sin\_port = htons(\hyperlink{mrpd_8h_a957ecb95a01b342339073f6422eb2bf9}{MRPD\_PORT\_DEFAULT});
74     addr.sin\_addr.s\_addr = inet\_addr(\textcolor{stringliteral}{"127.0.0.1"});
75     inet\_aton(\textcolor{stringliteral}{"127.0.0.1"}, &addr.sin\_addr);
76     \textcolor{keywordflow}{return} sendto(ctx->\hyperlink{structmrp__listener__ctx_ab16a0c776c464dcfb5cf8a013a137647}{control\_socket}, data, data\_len, 0,
77         (\textcolor{keyword}{struct} sockaddr*)&addr, (socklen\_t)\textcolor{keyword}{sizeof}(addr));
78 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{listener__mrp__client_8c_a925f75b25e5ea1ed0e082c771f9d6242_icgraph}
\end{center}
\end{figure}


\index{listener\+\_\+mrp\+\_\+client.\+c@{listener\+\_\+mrp\+\_\+client.\+c}!send\+\_\+ready@{send\+\_\+ready}}
\index{send\+\_\+ready@{send\+\_\+ready}!listener\+\_\+mrp\+\_\+client.\+c@{listener\+\_\+mrp\+\_\+client.\+c}}
\subsubsection[{\texorpdfstring{send\+\_\+ready(struct mrp\+\_\+listener\+\_\+ctx $\ast$ctx)}{send_ready(struct mrp_listener_ctx *ctx)}}]{\setlength{\rightskip}{0pt plus 5cm}int send\+\_\+ready (
\begin{DoxyParamCaption}
\item[{struct {\bf mrp\+\_\+listener\+\_\+ctx} $\ast$}]{ctx}
\end{DoxyParamCaption}
)}\hypertarget{listener__mrp__client_8c_a41c898fcba8bc3bc312e1a10b66b620c}{}\label{listener__mrp__client_8c_a41c898fcba8bc3bc312e1a10b66b620c}


listener\+\_\+mrp\+\_\+client.\+c 파일의 309 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
310 \{
311     \textcolor{keywordtype}{char} *databuf;
312     \textcolor{keywordtype}{int} rc;
313 
314     databuf = \hyperlink{_memory_leak_detector_malloc_macros_8h_ab8b25cd8f16d4a6552afe4e65c4f082d}{malloc}(1500);
315     \textcolor{keywordflow}{if} (\hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} == databuf)
316         \textcolor{keywordflow}{return} -1;
317     memset(databuf, 0, 1500);
318     sprintf(databuf, \textcolor{stringliteral}{"S+L:L=%02x%02x%02x%02x%02x%02x%02x%02x, D=2"},
319              ctx->\hyperlink{structmrp__listener__ctx_a190ce42cbfefb20ada402ce90519cc32}{stream\_id}[0], ctx->\hyperlink{structmrp__listener__ctx_a190ce42cbfefb20ada402ce90519cc32}{stream\_id}[1],
320              ctx->\hyperlink{structmrp__listener__ctx_a190ce42cbfefb20ada402ce90519cc32}{stream\_id}[2], ctx->\hyperlink{structmrp__listener__ctx_a190ce42cbfefb20ada402ce90519cc32}{stream\_id}[3],
321              ctx->\hyperlink{structmrp__listener__ctx_a190ce42cbfefb20ada402ce90519cc32}{stream\_id}[4], ctx->\hyperlink{structmrp__listener__ctx_a190ce42cbfefb20ada402ce90519cc32}{stream\_id}[5],
322              ctx->\hyperlink{structmrp__listener__ctx_a190ce42cbfefb20ada402ce90519cc32}{stream\_id}[6], ctx->\hyperlink{structmrp__listener__ctx_a190ce42cbfefb20ada402ce90519cc32}{stream\_id}[7]);
323     rc = \hyperlink{listener__mrp__client_8c_a925f75b25e5ea1ed0e082c771f9d6242}{send\_msg}(databuf, 1500, ctx);
324     \hyperlink{_memory_leak_detector_malloc_macros_8h_aa7157aa9480bb73f090dca36776419bf}{free}(databuf);
325 
326     \textcolor{keywordflow}{if} (rc != 1500)
327         \textcolor{keywordflow}{return} -1;
328     \textcolor{keywordflow}{else}
329         \textcolor{keywordflow}{return} 0;
330 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=245pt]{listener__mrp__client_8c_a41c898fcba8bc3bc312e1a10b66b620c_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=221pt]{listener__mrp__client_8c_a41c898fcba8bc3bc312e1a10b66b620c_icgraph}
\end{center}
\end{figure}




\subsection{변수 문서화}
\index{listener\+\_\+mrp\+\_\+client.\+c@{listener\+\_\+mrp\+\_\+client.\+c}!monitor\+\_\+attr@{monitor\+\_\+attr}}
\index{monitor\+\_\+attr@{monitor\+\_\+attr}!listener\+\_\+mrp\+\_\+client.\+c@{listener\+\_\+mrp\+\_\+client.\+c}}
\subsubsection[{\texorpdfstring{monitor\+\_\+attr}{monitor_attr}}]{\setlength{\rightskip}{0pt plus 5cm}pthread\+\_\+attr\+\_\+t monitor\+\_\+attr}\hypertarget{listener__mrp__client_8c_a6c7e3f190d4c6369f0a70172f95416dd}{}\label{listener__mrp__client_8c_a6c7e3f190d4c6369f0a70172f95416dd}


listener\+\_\+mrp\+\_\+client.\+c 파일의 31 번째 라인에서 정의되었습니다.

\index{listener\+\_\+mrp\+\_\+client.\+c@{listener\+\_\+mrp\+\_\+client.\+c}!monitor\+\_\+thread@{monitor\+\_\+thread}}
\index{monitor\+\_\+thread@{monitor\+\_\+thread}!listener\+\_\+mrp\+\_\+client.\+c@{listener\+\_\+mrp\+\_\+client.\+c}}
\subsubsection[{\texorpdfstring{monitor\+\_\+thread}{monitor_thread}}]{\setlength{\rightskip}{0pt plus 5cm}pthread\+\_\+t monitor\+\_\+thread}\hypertarget{listener__mrp__client_8c_afbd6fc6e0ab3c1a04a518f19c21d4503}{}\label{listener__mrp__client_8c_afbd6fc6e0ab3c1a04a518f19c21d4503}


listener\+\_\+mrp\+\_\+client.\+c 파일의 30 번째 라인에서 정의되었습니다.

