\hypertarget{struct_memory_leak_detector_list}{}\section{Memory\+Leak\+Detector\+List 구조체 참조}
\label{struct_memory_leak_detector_list}\index{Memory\+Leak\+Detector\+List@{Memory\+Leak\+Detector\+List}}


{\ttfamily \#include $<$Memory\+Leak\+Detector.\+h$>$}



Memory\+Leak\+Detector\+List에 대한 협력 다이어그램\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=550pt]{struct_memory_leak_detector_list__coll__graph}
\end{center}
\end{figure}
\subsection*{Public 멤버 함수}
\begin{DoxyCompactItemize}
\item 
\hyperlink{struct_memory_leak_detector_list_aa7ac333862f86ab90ba352b96d81f32c}{Memory\+Leak\+Detector\+List} ()
\item 
void \hyperlink{struct_memory_leak_detector_list_a78f2e89c0db3e4216dcd2061d70dea84}{add\+New\+Node} (\hyperlink{struct_memory_leak_detector_node}{Memory\+Leak\+Detector\+Node} $\ast$node)
\item 
\hyperlink{struct_memory_leak_detector_node}{Memory\+Leak\+Detector\+Node} $\ast$ \hyperlink{struct_memory_leak_detector_list_aa1655267a6cde38557847aca1e545a77}{retrieve\+Node} (char $\ast$memory)
\item 
\hyperlink{struct_memory_leak_detector_node}{Memory\+Leak\+Detector\+Node} $\ast$ \hyperlink{struct_memory_leak_detector_list_aaa0452383ce806d8a7248cb567813f84}{remove\+Node} (char $\ast$memory)
\item 
\hyperlink{struct_memory_leak_detector_node}{Memory\+Leak\+Detector\+Node} $\ast$ \hyperlink{struct_memory_leak_detector_list_a1b95cd1a5e8372a8f795f2d3387ae065}{get\+First\+Leak} (\hyperlink{_memory_leak_detector_8h_ab248e6cc6c6699b88b002286d8a3ed76}{Mem\+Leak\+Period} period)
\item 
\hyperlink{struct_memory_leak_detector_node}{Memory\+Leak\+Detector\+Node} $\ast$ \hyperlink{struct_memory_leak_detector_list_a7dc392fbd7a84bba7ce02a5586939537}{get\+Next\+Leak} (\hyperlink{struct_memory_leak_detector_node}{Memory\+Leak\+Detector\+Node} $\ast$node, \hyperlink{_memory_leak_detector_8h_ab248e6cc6c6699b88b002286d8a3ed76}{Mem\+Leak\+Period} period)
\item 
\hyperlink{struct_memory_leak_detector_node}{Memory\+Leak\+Detector\+Node} $\ast$ \hyperlink{struct_memory_leak_detector_list_a2fce71dedaaf8904e1fa5b220587d18f}{get\+Leak\+From} (\hyperlink{struct_memory_leak_detector_node}{Memory\+Leak\+Detector\+Node} $\ast$node, \hyperlink{_memory_leak_detector_8h_ab248e6cc6c6699b88b002286d8a3ed76}{Mem\+Leak\+Period} period)
\item 
int \hyperlink{struct_memory_leak_detector_list_ae203c76563a188474a816e4ef8d8aa06}{get\+Total\+Leaks} (\hyperlink{_memory_leak_detector_8h_ab248e6cc6c6699b88b002286d8a3ed76}{Mem\+Leak\+Period} period)
\item 
void \hyperlink{struct_memory_leak_detector_list_a6c18f981e1c2139528a10aa573ffeaa9}{clear\+All\+Accounting} (\hyperlink{_memory_leak_detector_8h_ab248e6cc6c6699b88b002286d8a3ed76}{Mem\+Leak\+Period} period)
\item 
\hyperlink{avb__gptp_8h_af6a258d8f3ee5206d682d799316314b1}{bool} \hyperlink{struct_memory_leak_detector_list_af38972a8d54f899a1233d80ff0d6f52b}{is\+In\+Period} (\hyperlink{struct_memory_leak_detector_node}{Memory\+Leak\+Detector\+Node} $\ast$node, \hyperlink{_memory_leak_detector_8h_ab248e6cc6c6699b88b002286d8a3ed76}{Mem\+Leak\+Period} period)
\end{DoxyCompactItemize}
\subsection*{Private 속성}
\begin{DoxyCompactItemize}
\item 
\hyperlink{struct_memory_leak_detector_node}{Memory\+Leak\+Detector\+Node} $\ast$ \hyperlink{struct_memory_leak_detector_list_a8f541a6917dfc908c587dd3f7e86c990}{head\+\_\+}
\end{DoxyCompactItemize}


\subsection{상세한 설명}


Memory\+Leak\+Detector.\+h 파일의 139 번째 라인에서 정의되었습니다.



\subsection{생성자 \& 소멸자 문서화}
\index{Memory\+Leak\+Detector\+List@{Memory\+Leak\+Detector\+List}!Memory\+Leak\+Detector\+List@{Memory\+Leak\+Detector\+List}}
\index{Memory\+Leak\+Detector\+List@{Memory\+Leak\+Detector\+List}!Memory\+Leak\+Detector\+List@{Memory\+Leak\+Detector\+List}}
\subsubsection[{\texorpdfstring{Memory\+Leak\+Detector\+List()}{MemoryLeakDetectorList()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Memory\+Leak\+Detector\+List} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{struct_memory_leak_detector_list_aa7ac333862f86ab90ba352b96d81f32c}{}\label{struct_memory_leak_detector_list_aa7ac333862f86ab90ba352b96d81f32c}


Memory\+Leak\+Detector.\+h 파일의 141 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
141                              :
142         \hyperlink{struct_memory_leak_detector_list_a8f541a6917dfc908c587dd3f7e86c990}{head\_}(0)
143     \{\}
\end{DoxyCode}


\subsection{멤버 함수 문서화}
\index{Memory\+Leak\+Detector\+List@{Memory\+Leak\+Detector\+List}!add\+New\+Node@{add\+New\+Node}}
\index{add\+New\+Node@{add\+New\+Node}!Memory\+Leak\+Detector\+List@{Memory\+Leak\+Detector\+List}}
\subsubsection[{\texorpdfstring{add\+New\+Node(\+Memory\+Leak\+Detector\+Node $\ast$node)}{addNewNode(MemoryLeakDetectorNode *node)}}]{\setlength{\rightskip}{0pt plus 5cm}void add\+New\+Node (
\begin{DoxyParamCaption}
\item[{{\bf Memory\+Leak\+Detector\+Node} $\ast$}]{node}
\end{DoxyParamCaption}
)}\hypertarget{struct_memory_leak_detector_list_a78f2e89c0db3e4216dcd2061d70dea84}{}\label{struct_memory_leak_detector_list_a78f2e89c0db3e4216dcd2061d70dea84}


Memory\+Leak\+Detector.\+cpp 파일의 295 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
296 \{
297     node->\hyperlink{struct_memory_leak_detector_node_a6a718fbf408f23d29c6ef9167005968c}{next\_} = \hyperlink{struct_memory_leak_detector_list_a8f541a6917dfc908c587dd3f7e86c990}{head\_};
298     \hyperlink{struct_memory_leak_detector_list_a8f541a6917dfc908c587dd3f7e86c990}{head\_} = node;
299 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=234pt]{struct_memory_leak_detector_list_a78f2e89c0db3e4216dcd2061d70dea84_icgraph}
\end{center}
\end{figure}


\index{Memory\+Leak\+Detector\+List@{Memory\+Leak\+Detector\+List}!clear\+All\+Accounting@{clear\+All\+Accounting}}
\index{clear\+All\+Accounting@{clear\+All\+Accounting}!Memory\+Leak\+Detector\+List@{Memory\+Leak\+Detector\+List}}
\subsubsection[{\texorpdfstring{clear\+All\+Accounting(\+Mem\+Leak\+Period period)}{clearAllAccounting(MemLeakPeriod period)}}]{\setlength{\rightskip}{0pt plus 5cm}void clear\+All\+Accounting (
\begin{DoxyParamCaption}
\item[{{\bf Mem\+Leak\+Period}}]{period}
\end{DoxyParamCaption}
)}\hypertarget{struct_memory_leak_detector_list_a6c18f981e1c2139528a10aa573ffeaa9}{}\label{struct_memory_leak_detector_list_a6c18f981e1c2139528a10aa573ffeaa9}


Memory\+Leak\+Detector.\+cpp 파일의 273 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
274 \{
275     \hyperlink{struct_memory_leak_detector_node}{MemoryLeakDetectorNode}* cur = \hyperlink{struct_memory_leak_detector_list_a8f541a6917dfc908c587dd3f7e86c990}{head\_};
276     \hyperlink{struct_memory_leak_detector_node}{MemoryLeakDetectorNode}* prev = 0;
277 
278     \textcolor{keywordflow}{while} (cur) \{
279         \textcolor{keywordflow}{if} (\hyperlink{struct_memory_leak_detector_list_af38972a8d54f899a1233d80ff0d6f52b}{isInPeriod}(cur, period)) \{
280             \textcolor{keywordflow}{if} (prev) \{
281                 prev->\hyperlink{struct_memory_leak_detector_node_a6a718fbf408f23d29c6ef9167005968c}{next\_} = cur->\hyperlink{struct_memory_leak_detector_node_a6a718fbf408f23d29c6ef9167005968c}{next\_};
282                 cur = prev;
283             \}
284             \textcolor{keywordflow}{else} \{
285                 \hyperlink{struct_memory_leak_detector_list_a8f541a6917dfc908c587dd3f7e86c990}{head\_} = cur->\hyperlink{struct_memory_leak_detector_node_a6a718fbf408f23d29c6ef9167005968c}{next\_};
286                 cur = \hyperlink{struct_memory_leak_detector_list_a8f541a6917dfc908c587dd3f7e86c990}{head\_};
287                 \textcolor{keywordflow}{continue};
288             \}
289         \}
290         prev = cur;
291         cur = cur->\hyperlink{struct_memory_leak_detector_node_a6a718fbf408f23d29c6ef9167005968c}{next\_};
292     \}
293 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=256pt]{struct_memory_leak_detector_list_a6c18f981e1c2139528a10aa573ffeaa9_icgraph}
\end{center}
\end{figure}


\index{Memory\+Leak\+Detector\+List@{Memory\+Leak\+Detector\+List}!get\+First\+Leak@{get\+First\+Leak}}
\index{get\+First\+Leak@{get\+First\+Leak}!Memory\+Leak\+Detector\+List@{Memory\+Leak\+Detector\+List}}
\subsubsection[{\texorpdfstring{get\+First\+Leak(\+Mem\+Leak\+Period period)}{getFirstLeak(MemLeakPeriod period)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Memory\+Leak\+Detector\+Node} $\ast$ get\+First\+Leak (
\begin{DoxyParamCaption}
\item[{{\bf Mem\+Leak\+Period}}]{period}
\end{DoxyParamCaption}
)}\hypertarget{struct_memory_leak_detector_list_a1b95cd1a5e8372a8f795f2d3387ae065}{}\label{struct_memory_leak_detector_list_a1b95cd1a5e8372a8f795f2d3387ae065}


Memory\+Leak\+Detector.\+cpp 파일의 340 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
341 \{
342     \textcolor{keywordflow}{return} \hyperlink{struct_memory_leak_detector_list_a2fce71dedaaf8904e1fa5b220587d18f}{getLeakFrom}(\hyperlink{struct_memory_leak_detector_list_a8f541a6917dfc908c587dd3f7e86c990}{head\_}, period);
343 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=229pt]{struct_memory_leak_detector_list_a1b95cd1a5e8372a8f795f2d3387ae065_icgraph}
\end{center}
\end{figure}


\index{Memory\+Leak\+Detector\+List@{Memory\+Leak\+Detector\+List}!get\+Leak\+From@{get\+Leak\+From}}
\index{get\+Leak\+From@{get\+Leak\+From}!Memory\+Leak\+Detector\+List@{Memory\+Leak\+Detector\+List}}
\subsubsection[{\texorpdfstring{get\+Leak\+From(\+Memory\+Leak\+Detector\+Node $\ast$node, Mem\+Leak\+Period period)}{getLeakFrom(MemoryLeakDetectorNode *node, MemLeakPeriod period)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Memory\+Leak\+Detector\+Node} $\ast$ get\+Leak\+From (
\begin{DoxyParamCaption}
\item[{{\bf Memory\+Leak\+Detector\+Node} $\ast$}]{node, }
\item[{{\bf Mem\+Leak\+Period}}]{period}
\end{DoxyParamCaption}
)}\hypertarget{struct_memory_leak_detector_list_a2fce71dedaaf8904e1fa5b220587d18f}{}\label{struct_memory_leak_detector_list_a2fce71dedaaf8904e1fa5b220587d18f}


Memory\+Leak\+Detector.\+cpp 파일의 333 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
334 \{
335     \textcolor{keywordflow}{for} (\hyperlink{struct_memory_leak_detector_node}{MemoryLeakDetectorNode}* cur = node; cur; cur = cur->
      \hyperlink{struct_memory_leak_detector_node_a6a718fbf408f23d29c6ef9167005968c}{next\_})
336         \textcolor{keywordflow}{if} (\hyperlink{struct_memory_leak_detector_list_af38972a8d54f899a1233d80ff0d6f52b}{isInPeriod}(cur, period)) \textcolor{keywordflow}{return} cur;
337     \textcolor{keywordflow}{return} 0;
338 \}
\end{DoxyCode}
\index{Memory\+Leak\+Detector\+List@{Memory\+Leak\+Detector\+List}!get\+Next\+Leak@{get\+Next\+Leak}}
\index{get\+Next\+Leak@{get\+Next\+Leak}!Memory\+Leak\+Detector\+List@{Memory\+Leak\+Detector\+List}}
\subsubsection[{\texorpdfstring{get\+Next\+Leak(\+Memory\+Leak\+Detector\+Node $\ast$node, Mem\+Leak\+Period period)}{getNextLeak(MemoryLeakDetectorNode *node, MemLeakPeriod period)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Memory\+Leak\+Detector\+Node} $\ast$ get\+Next\+Leak (
\begin{DoxyParamCaption}
\item[{{\bf Memory\+Leak\+Detector\+Node} $\ast$}]{node, }
\item[{{\bf Mem\+Leak\+Period}}]{period}
\end{DoxyParamCaption}
)}\hypertarget{struct_memory_leak_detector_list_a7dc392fbd7a84bba7ce02a5586939537}{}\label{struct_memory_leak_detector_list_a7dc392fbd7a84bba7ce02a5586939537}


Memory\+Leak\+Detector.\+cpp 파일의 345 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
346 \{
347     \textcolor{keywordflow}{return} \hyperlink{struct_memory_leak_detector_list_a2fce71dedaaf8904e1fa5b220587d18f}{getLeakFrom}(node->\hyperlink{struct_memory_leak_detector_node_a6a718fbf408f23d29c6ef9167005968c}{next\_}, period);
348 \}
\end{DoxyCode}
\index{Memory\+Leak\+Detector\+List@{Memory\+Leak\+Detector\+List}!get\+Total\+Leaks@{get\+Total\+Leaks}}
\index{get\+Total\+Leaks@{get\+Total\+Leaks}!Memory\+Leak\+Detector\+List@{Memory\+Leak\+Detector\+List}}
\subsubsection[{\texorpdfstring{get\+Total\+Leaks(\+Mem\+Leak\+Period period)}{getTotalLeaks(MemLeakPeriod period)}}]{\setlength{\rightskip}{0pt plus 5cm}int get\+Total\+Leaks (
\begin{DoxyParamCaption}
\item[{{\bf Mem\+Leak\+Period}}]{period}
\end{DoxyParamCaption}
)}\hypertarget{struct_memory_leak_detector_list_ae203c76563a188474a816e4ef8d8aa06}{}\label{struct_memory_leak_detector_list_ae203c76563a188474a816e4ef8d8aa06}


Memory\+Leak\+Detector.\+cpp 파일의 350 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
351 \{
352     \textcolor{keywordtype}{int} total\_leaks = 0;
353     \textcolor{keywordflow}{for} (\hyperlink{struct_memory_leak_detector_node}{MemoryLeakDetectorNode}* node = \hyperlink{struct_memory_leak_detector_list_a8f541a6917dfc908c587dd3f7e86c990}{head\_}; node; node = node->
      \hyperlink{struct_memory_leak_detector_node_a6a718fbf408f23d29c6ef9167005968c}{next\_}) \{
354         \textcolor{keywordflow}{if} (\hyperlink{struct_memory_leak_detector_list_af38972a8d54f899a1233d80ff0d6f52b}{isInPeriod}(node, period)) total\_leaks++;
355     \}
356     \textcolor{keywordflow}{return} total\_leaks;
357 \}
\end{DoxyCode}
\index{Memory\+Leak\+Detector\+List@{Memory\+Leak\+Detector\+List}!is\+In\+Period@{is\+In\+Period}}
\index{is\+In\+Period@{is\+In\+Period}!Memory\+Leak\+Detector\+List@{Memory\+Leak\+Detector\+List}}
\subsubsection[{\texorpdfstring{is\+In\+Period(\+Memory\+Leak\+Detector\+Node $\ast$node, Mem\+Leak\+Period period)}{isInPeriod(MemoryLeakDetectorNode *node, MemLeakPeriod period)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf bool} is\+In\+Period (
\begin{DoxyParamCaption}
\item[{{\bf Memory\+Leak\+Detector\+Node} $\ast$}]{node, }
\item[{{\bf Mem\+Leak\+Period}}]{period}
\end{DoxyParamCaption}
)}\hypertarget{struct_memory_leak_detector_list_af38972a8d54f899a1233d80ff0d6f52b}{}\label{struct_memory_leak_detector_list_af38972a8d54f899a1233d80ff0d6f52b}


Memory\+Leak\+Detector.\+cpp 파일의 268 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
269 \{
270     \textcolor{keywordflow}{return} period == \hyperlink{_memory_leak_detector_8h_ab248e6cc6c6699b88b002286d8a3ed76ac1b677674aa34f597ff5dd4756c1e667}{mem\_leak\_period\_all} || node->\hyperlink{struct_memory_leak_detector_node_a4b296dc99cd64623a83ce9027f70e0e7}{period\_} == period || (node->
      \hyperlink{struct_memory_leak_detector_node_a4b296dc99cd64623a83ce9027f70e0e7}{period\_} != \hyperlink{_memory_leak_detector_8h_ab248e6cc6c6699b88b002286d8a3ed76a486ca2e142f018cbf5f8f6b5561b4c48}{mem\_leak\_period\_disabled} && period == 
      \hyperlink{_memory_leak_detector_8h_ab248e6cc6c6699b88b002286d8a3ed76af44afdfdc843b0c299b8b0a9585a0f32}{mem\_leak\_period\_enabled});
271 \}
\end{DoxyCode}
\index{Memory\+Leak\+Detector\+List@{Memory\+Leak\+Detector\+List}!remove\+Node@{remove\+Node}}
\index{remove\+Node@{remove\+Node}!Memory\+Leak\+Detector\+List@{Memory\+Leak\+Detector\+List}}
\subsubsection[{\texorpdfstring{remove\+Node(char $\ast$memory)}{removeNode(char *memory)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Memory\+Leak\+Detector\+Node} $\ast$ remove\+Node (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{memory}
\end{DoxyParamCaption}
)}\hypertarget{struct_memory_leak_detector_list_aaa0452383ce806d8a7248cb567813f84}{}\label{struct_memory_leak_detector_list_aaa0452383ce806d8a7248cb567813f84}


Memory\+Leak\+Detector.\+cpp 파일의 301 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
302 \{
303     \hyperlink{struct_memory_leak_detector_node}{MemoryLeakDetectorNode}* cur = \hyperlink{struct_memory_leak_detector_list_a8f541a6917dfc908c587dd3f7e86c990}{head\_};
304     \hyperlink{struct_memory_leak_detector_node}{MemoryLeakDetectorNode}* prev = 0;
305     \textcolor{keywordflow}{while} (cur) \{
306         \textcolor{keywordflow}{if} (cur->\hyperlink{struct_memory_leak_detector_node_a6cdb5ad30702010eaf86e4e5f26defce}{memory\_} == memory) \{
307             \textcolor{keywordflow}{if} (prev) \{
308                 prev->\hyperlink{struct_memory_leak_detector_node_a6a718fbf408f23d29c6ef9167005968c}{next\_} = cur->\hyperlink{struct_memory_leak_detector_node_a6a718fbf408f23d29c6ef9167005968c}{next\_};
309                 \textcolor{keywordflow}{return} cur;
310             \}
311             \textcolor{keywordflow}{else} \{
312                 \hyperlink{struct_memory_leak_detector_list_a8f541a6917dfc908c587dd3f7e86c990}{head\_} = cur->\hyperlink{struct_memory_leak_detector_node_a6a718fbf408f23d29c6ef9167005968c}{next\_};
313                 \textcolor{keywordflow}{return} cur;
314             \}
315         \}
316         prev = cur;
317         cur = cur->\hyperlink{struct_memory_leak_detector_node_a6a718fbf408f23d29c6ef9167005968c}{next\_};
318     \}
319     \textcolor{keywordflow}{return} 0;
320 \}
\end{DoxyCode}
\index{Memory\+Leak\+Detector\+List@{Memory\+Leak\+Detector\+List}!retrieve\+Node@{retrieve\+Node}}
\index{retrieve\+Node@{retrieve\+Node}!Memory\+Leak\+Detector\+List@{Memory\+Leak\+Detector\+List}}
\subsubsection[{\texorpdfstring{retrieve\+Node(char $\ast$memory)}{retrieveNode(char *memory)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Memory\+Leak\+Detector\+Node} $\ast$ retrieve\+Node (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{memory}
\end{DoxyParamCaption}
)}\hypertarget{struct_memory_leak_detector_list_aa1655267a6cde38557847aca1e545a77}{}\label{struct_memory_leak_detector_list_aa1655267a6cde38557847aca1e545a77}


Memory\+Leak\+Detector.\+cpp 파일의 322 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
323 \{
324   \hyperlink{struct_memory_leak_detector_node}{MemoryLeakDetectorNode}* cur = \hyperlink{struct_memory_leak_detector_list_a8f541a6917dfc908c587dd3f7e86c990}{head\_};
325   \textcolor{keywordflow}{while} (cur) \{
326     \textcolor{keywordflow}{if} (cur->\hyperlink{struct_memory_leak_detector_node_a6cdb5ad30702010eaf86e4e5f26defce}{memory\_} == memory)
327       \textcolor{keywordflow}{return} cur;
328     cur = cur->\hyperlink{struct_memory_leak_detector_node_a6a718fbf408f23d29c6ef9167005968c}{next\_};
329   \}
330   \textcolor{keywordflow}{return} \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
331 \}
\end{DoxyCode}


\subsection{필드 문서화}
\index{Memory\+Leak\+Detector\+List@{Memory\+Leak\+Detector\+List}!head\+\_\+@{head\+\_\+}}
\index{head\+\_\+@{head\+\_\+}!Memory\+Leak\+Detector\+List@{Memory\+Leak\+Detector\+List}}
\subsubsection[{\texorpdfstring{head\+\_\+}{head_}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Memory\+Leak\+Detector\+Node}$\ast$ head\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{struct_memory_leak_detector_list_a8f541a6917dfc908c587dd3f7e86c990}{}\label{struct_memory_leak_detector_list_a8f541a6917dfc908c587dd3f7e86c990}


Memory\+Leak\+Detector.\+h 파일의 161 번째 라인에서 정의되었습니다.



이 구조체에 대한 문서화 페이지는 다음의 파일들로부터 생성되었습니다.\+:\begin{DoxyCompactItemize}
\item 
thirdparty/cpputest/include/\+Cpp\+U\+Test/\hyperlink{_memory_leak_detector_8h}{Memory\+Leak\+Detector.\+h}\item 
thirdparty/cpputest/src/\+Cpp\+U\+Test/\hyperlink{_memory_leak_detector_8cpp}{Memory\+Leak\+Detector.\+cpp}\end{DoxyCompactItemize}
