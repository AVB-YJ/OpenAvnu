\hypertarget{talker__mrp__client_8c}{}\section{examples/common/talker\+\_\+mrp\+\_\+client.c 파일 참조}
\label{talker__mrp__client_8c}\index{examples/common/talker\+\_\+mrp\+\_\+client.\+c@{examples/common/talker\+\_\+mrp\+\_\+client.\+c}}
{\ttfamily \#include \char`\"{}talker\+\_\+mrp\+\_\+client.\+h\char`\"{}}\\*
talker\+\_\+mrp\+\_\+client.\+c에 대한 include 의존 그래프
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{talker__mrp__client_8c__incl}
\end{center}
\end{figure}
\subsection*{함수}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{talker__mrp__client_8c_a74c2fc24c07fa72e2fd10a3a98f9dc9d}{mrp\+\_\+talker\+\_\+client\+\_\+init} (struct \hyperlink{structmrp__talker__ctx}{mrp\+\_\+talker\+\_\+ctx} $\ast$\hyperlink{jack_8h_a1cde2a2cf8a56164b5e83159035be03b}{ctx})
\item 
int \hyperlink{talker__mrp__client_8c_adb1f8eb8ae4f2e22f8c4219da68f2eb0}{send\+\_\+mrp\+\_\+msg} (char $\ast$notify\+\_\+data, int notify\+\_\+len, struct \hyperlink{structmrp__talker__ctx}{mrp\+\_\+talker\+\_\+ctx} $\ast$\hyperlink{jack_8h_a1cde2a2cf8a56164b5e83159035be03b}{ctx})
\item 
int \hyperlink{talker__mrp__client_8c_ac27e48d61b63306dbfe0a27c3c5e13a9}{process\+\_\+mrp\+\_\+msg} (char $\ast$buf, int buflen, struct \hyperlink{structmrp__talker__ctx}{mrp\+\_\+talker\+\_\+ctx} $\ast$\hyperlink{jack_8h_a1cde2a2cf8a56164b5e83159035be03b}{ctx})
\item 
void $\ast$ \hyperlink{talker__mrp__client_8c_afdd2d7bcf3cde2ab45b078d253558c2d}{mrp\+\_\+monitor\+\_\+thread} (void $\ast$arg)
\item 
int \hyperlink{talker__mrp__client_8c_aa94a906b50f9aca85cb00a18235c627f}{mrp\+\_\+connect} (struct \hyperlink{structmrp__talker__ctx}{mrp\+\_\+talker\+\_\+ctx} $\ast$\hyperlink{jack_8h_a1cde2a2cf8a56164b5e83159035be03b}{ctx})
\item 
int \hyperlink{talker__mrp__client_8c_a9c244bc9e37fdc937cd38b09307003d7}{mrp\+\_\+disconnect} (struct \hyperlink{structmrp__talker__ctx}{mrp\+\_\+talker\+\_\+ctx} $\ast$\hyperlink{jack_8h_a1cde2a2cf8a56164b5e83159035be03b}{ctx})
\item 
int \hyperlink{talker__mrp__client_8c_acc997d17445fa9c83b587029363c785d}{mrp\+\_\+monitor} (void)
\item 
int \hyperlink{talker__mrp__client_8c_ad06b236726820804f4273102e9177efd}{mrp\+\_\+register\+\_\+domain} (struct \hyperlink{structmrp__domain__attr}{mrp\+\_\+domain\+\_\+attr} $\ast$reg\+\_\+class, struct \hyperlink{structmrp__talker__ctx}{mrp\+\_\+talker\+\_\+ctx} $\ast$\hyperlink{jack_8h_a1cde2a2cf8a56164b5e83159035be03b}{ctx})
\item 
int \hyperlink{talker__mrp__client_8c_a3677b13e5eb218df9fd6b310313439da}{mrp\+\_\+advertise\+\_\+stream} (\hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} $\ast$streamid, \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} $\ast$destaddr, int pktsz, int interval, int latency, struct \hyperlink{structmrp__talker__ctx}{mrp\+\_\+talker\+\_\+ctx} $\ast$\hyperlink{jack_8h_a1cde2a2cf8a56164b5e83159035be03b}{ctx})
\item 
int \hyperlink{talker__mrp__client_8c_ad07070e607ae7c6127ffb3cc3e6e1d7b}{mrp\+\_\+unadvertise\+\_\+stream} (\hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} $\ast$streamid, \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} $\ast$destaddr, int pktsz, int interval, int latency, struct \hyperlink{structmrp__talker__ctx}{mrp\+\_\+talker\+\_\+ctx} $\ast$\hyperlink{jack_8h_a1cde2a2cf8a56164b5e83159035be03b}{ctx})
\item 
int \hyperlink{talker__mrp__client_8c_af1c01cfeeb99c9ebffcbc301aa5784e2}{mrp\+\_\+await\+\_\+listener} (unsigned char $\ast$streamid, struct \hyperlink{structmrp__talker__ctx}{mrp\+\_\+talker\+\_\+ctx} $\ast$\hyperlink{jack_8h_a1cde2a2cf8a56164b5e83159035be03b}{ctx})
\item 
int \hyperlink{talker__mrp__client_8c_aeb2be83ee100a0241552a07a7d91f4e0}{mrp\+\_\+get\+\_\+domain} (struct \hyperlink{structmrp__talker__ctx}{mrp\+\_\+talker\+\_\+ctx} $\ast$\hyperlink{jack_8h_a1cde2a2cf8a56164b5e83159035be03b}{ctx}, struct \hyperlink{structmrp__domain__attr}{mrp\+\_\+domain\+\_\+attr} $\ast$class\+\_\+a, struct \hyperlink{structmrp__domain__attr}{mrp\+\_\+domain\+\_\+attr} $\ast$class\+\_\+b)
\item 
int \hyperlink{talker__mrp__client_8c_a5a1dbea67f6c32ce5de65b8f5d51c2de}{mrp\+\_\+join\+\_\+vlan} (struct \hyperlink{structmrp__domain__attr}{mrp\+\_\+domain\+\_\+attr} $\ast$reg\+\_\+class, struct \hyperlink{structmrp__talker__ctx}{mrp\+\_\+talker\+\_\+ctx} $\ast$\hyperlink{jack_8h_a1cde2a2cf8a56164b5e83159035be03b}{ctx})
\item 
int \hyperlink{talker__mrp__client_8c_a363563519c23ffe143b574310ee58b55}{recv\+\_\+mrp\+\_\+okay} ()
\end{DoxyCompactItemize}
\subsection*{변수}
\begin{DoxyCompactItemize}
\item 
volatile int \hyperlink{talker__mrp__client_8c_a5238adacbd2c4d99b6238f3e4ad554ca}{mrp\+\_\+okay}
\item 
volatile int \hyperlink{talker__mrp__client_8c_a7e0861f30a3dba1eb162e77371fe9c21}{mrp\+\_\+error} = 0
\item 
pthread\+\_\+t \hyperlink{talker__mrp__client_8c_afbd6fc6e0ab3c1a04a518f19c21d4503}{monitor\+\_\+thread}
\item 
pthread\+\_\+attr\+\_\+t \hyperlink{talker__mrp__client_8c_a6c7e3f190d4c6369f0a70172f95416dd}{monitor\+\_\+attr}
\end{DoxyCompactItemize}


\subsection{함수 문서화}
\index{talker\+\_\+mrp\+\_\+client.\+c@{talker\+\_\+mrp\+\_\+client.\+c}!mrp\+\_\+advertise\+\_\+stream@{mrp\+\_\+advertise\+\_\+stream}}
\index{mrp\+\_\+advertise\+\_\+stream@{mrp\+\_\+advertise\+\_\+stream}!talker\+\_\+mrp\+\_\+client.\+c@{talker\+\_\+mrp\+\_\+client.\+c}}
\subsubsection[{\texorpdfstring{mrp\+\_\+advertise\+\_\+stream(uint8\+\_\+t $\ast$streamid, uint8\+\_\+t $\ast$destaddr, int pktsz, int interval, int latency, struct mrp\+\_\+talker\+\_\+ctx $\ast$ctx)}{mrp_advertise_stream(uint8_t *streamid, uint8_t *destaddr, int pktsz, int interval, int latency, struct mrp_talker_ctx *ctx)}}]{\setlength{\rightskip}{0pt plus 5cm}int mrp\+\_\+advertise\+\_\+stream (
\begin{DoxyParamCaption}
\item[{{\bf uint8\+\_\+t} $\ast$}]{streamid, }
\item[{{\bf uint8\+\_\+t} $\ast$}]{destaddr, }
\item[{int}]{pktsz, }
\item[{int}]{interval, }
\item[{int}]{latency, }
\item[{struct {\bf mrp\+\_\+talker\+\_\+ctx} $\ast$}]{ctx}
\end{DoxyParamCaption}
)}\hypertarget{talker__mrp__client_8c_a3677b13e5eb218df9fd6b310313439da}{}\label{talker__mrp__client_8c_a3677b13e5eb218df9fd6b310313439da}


talker\+\_\+mrp\+\_\+client.\+c 파일의 425 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
428 \{
429     \textcolor{keywordtype}{char} *\hyperlink{mrp_validate_8c_a3820841c4bbf28f04505bea65d6b84f7}{msgbuf};
430     \textcolor{keywordtype}{int} rc;
431 
432     msgbuf = \hyperlink{_memory_leak_detector_malloc_macros_8h_ab8b25cd8f16d4a6552afe4e65c4f082d}{malloc}(1500);
433     \textcolor{keywordflow}{if} (\hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} == msgbuf)
434         \textcolor{keywordflow}{return} -1;
435     memset(msgbuf, 0, 1500);
436 
437     sprintf(msgbuf, \textcolor{stringliteral}{"S++:S=%02X%02X%02X%02X%02X%02X%02X%02X"}
438         \textcolor{stringliteral}{",A=%02X%02X%02X%02X%02X%02X"}
439         \textcolor{stringliteral}{",V=%04X"}
440         \textcolor{stringliteral}{",Z=%d"}
441         \textcolor{stringliteral}{",I=%d"}
442         \textcolor{stringliteral}{",P=%d"}
443         \textcolor{stringliteral}{",L=%d"}, streamid[0], streamid[1], streamid[2],
444         streamid[3], streamid[4], streamid[5], streamid[6],
445         streamid[7], destaddr[0], destaddr[1], destaddr[2],
446         destaddr[3], destaddr[4], destaddr[5], ctx->\hyperlink{structmrp__talker__ctx_ac575246135a50baaf0c802ef29aa2779}{domain\_class\_a\_vid}, pktsz,
447         interval, ctx->\hyperlink{structmrp__talker__ctx_ac98b99ec0ffd190c1da93e6caffe36d4}{domain\_class\_a\_priority} << 5, latency);
448     \hyperlink{talker__mrp__client_8c_a5238adacbd2c4d99b6238f3e4ad554ca}{mrp\_okay} = 0;
449     rc = \hyperlink{talker__mrp__client_8c_adb1f8eb8ae4f2e22f8c4219da68f2eb0}{send\_mrp\_msg}(msgbuf, 1500, ctx);
450     \hyperlink{_memory_leak_detector_malloc_macros_8h_aa7157aa9480bb73f090dca36776419bf}{free}(msgbuf);
451 
452     \textcolor{keywordflow}{if} (rc != 1500)
453         \textcolor{keywordflow}{return} -1;
454     \textcolor{keywordflow}{else}
455         \textcolor{keywordflow}{return} 0;
456 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=312pt]{talker__mrp__client_8c_a3677b13e5eb218df9fd6b310313439da_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{talker__mrp__client_8c_a3677b13e5eb218df9fd6b310313439da_icgraph}
\end{center}
\end{figure}


\index{talker\+\_\+mrp\+\_\+client.\+c@{talker\+\_\+mrp\+\_\+client.\+c}!mrp\+\_\+await\+\_\+listener@{mrp\+\_\+await\+\_\+listener}}
\index{mrp\+\_\+await\+\_\+listener@{mrp\+\_\+await\+\_\+listener}!talker\+\_\+mrp\+\_\+client.\+c@{talker\+\_\+mrp\+\_\+client.\+c}}
\subsubsection[{\texorpdfstring{mrp\+\_\+await\+\_\+listener(unsigned char $\ast$streamid, struct mrp\+\_\+talker\+\_\+ctx $\ast$ctx)}{mrp_await_listener(unsigned char *streamid, struct mrp_talker_ctx *ctx)}}]{\setlength{\rightskip}{0pt plus 5cm}int mrp\+\_\+await\+\_\+listener (
\begin{DoxyParamCaption}
\item[{unsigned char $\ast$}]{streamid, }
\item[{struct {\bf mrp\+\_\+talker\+\_\+ctx} $\ast$}]{ctx}
\end{DoxyParamCaption}
)}\hypertarget{talker__mrp__client_8c_af1c01cfeeb99c9ebffcbc301aa5784e2}{}\label{talker__mrp__client_8c_af1c01cfeeb99c9ebffcbc301aa5784e2}


talker\+\_\+mrp\+\_\+client.\+c 파일의 491 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
492 \{
493     \textcolor{keywordtype}{char} *\hyperlink{mrp_validate_8c_a3820841c4bbf28f04505bea65d6b84f7}{msgbuf};
494     \textcolor{keywordtype}{int} rc;
495 
496     memcpy(ctx->\hyperlink{structmrp__talker__ctx_a0be105011a16541a479847730d7321c9}{monitor\_stream\_id}, streamid, \textcolor{keyword}{sizeof}(ctx->
      \hyperlink{structmrp__talker__ctx_a0be105011a16541a479847730d7321c9}{monitor\_stream\_id}));
497     msgbuf = \hyperlink{_memory_leak_detector_malloc_macros_8h_ab8b25cd8f16d4a6552afe4e65c4f082d}{malloc}(1500);
498     \textcolor{keywordflow}{if} (\hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} == msgbuf)
499         \textcolor{keywordflow}{return} -1;
500     memset(msgbuf, 0, 1500);
501     sprintf(msgbuf, \textcolor{stringliteral}{"S??"});
502     rc = \hyperlink{talker__mrp__client_8c_adb1f8eb8ae4f2e22f8c4219da68f2eb0}{send\_mrp\_msg}(msgbuf, 1500, ctx);
503     \hyperlink{_memory_leak_detector_malloc_macros_8h_aa7157aa9480bb73f090dca36776419bf}{free}(msgbuf);
504     \textcolor{keywordflow}{if} (rc != 1500)
505         \textcolor{keywordflow}{return} -1;
506 
507     \textcolor{comment}{/* either already there ... or need to wait ... */}
508     \textcolor{keywordflow}{while} (!ctx->\hyperlink{structmrp__talker__ctx_a7c8176263e9704aa667fc335cc818a3f}{halt\_tx} && (ctx->\hyperlink{structmrp__talker__ctx_a70763450542106f6508fd1051eade47d}{listeners} == 0))
509         usleep(20000);
510 
511     \textcolor{keywordflow}{return} 0;
512 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=297pt]{talker__mrp__client_8c_af1c01cfeeb99c9ebffcbc301aa5784e2_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=252pt]{talker__mrp__client_8c_af1c01cfeeb99c9ebffcbc301aa5784e2_icgraph}
\end{center}
\end{figure}


\index{talker\+\_\+mrp\+\_\+client.\+c@{talker\+\_\+mrp\+\_\+client.\+c}!mrp\+\_\+connect@{mrp\+\_\+connect}}
\index{mrp\+\_\+connect@{mrp\+\_\+connect}!talker\+\_\+mrp\+\_\+client.\+c@{talker\+\_\+mrp\+\_\+client.\+c}}
\subsubsection[{\texorpdfstring{mrp\+\_\+connect(struct mrp\+\_\+talker\+\_\+ctx $\ast$ctx)}{mrp_connect(struct mrp_talker_ctx *ctx)}}]{\setlength{\rightskip}{0pt plus 5cm}int mrp\+\_\+connect (
\begin{DoxyParamCaption}
\item[{struct {\bf mrp\+\_\+talker\+\_\+ctx} $\ast$}]{ctx}
\end{DoxyParamCaption}
)}\hypertarget{talker__mrp__client_8c_aa94a906b50f9aca85cb00a18235c627f}{}\label{talker__mrp__client_8c_aa94a906b50f9aca85cb00a18235c627f}


talker\+\_\+mrp\+\_\+client.\+c 파일의 350 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
351 \{
352     \textcolor{keyword}{struct }sockaddr\_in addr;
353     \textcolor{keywordtype}{int} sock\_fd = -1;
354     \textcolor{keywordtype}{int} rc;
355     sock\_fd = socket(AF\_INET, SOCK\_DGRAM, IPPROTO\_UDP);
356     \textcolor{keywordflow}{if} (sock\_fd < 0)
357         \textcolor{keywordflow}{goto} \hyperlink{jack__listener_8c_a1cdcf0ac9be9edf74b8fcedb01e26cf3}{out};
358     memset(&addr, 0, \textcolor{keyword}{sizeof}(addr));
359     addr.sin\_family = AF\_INET;
360     addr.sin\_port = htons(\hyperlink{mrpd_8h_a957ecb95a01b342339073f6422eb2bf9}{MRPD\_PORT\_DEFAULT});
361     inet\_aton(\textcolor{stringliteral}{"127.0.0.1"}, &addr.sin\_addr);
362     memset(&addr, 0, \textcolor{keyword}{sizeof}(addr));
363     ctx->\hyperlink{structmrp__talker__ctx_ab16a0c776c464dcfb5cf8a013a137647}{control\_socket} = sock\_fd;
364     rc = pthread\_attr\_init(&\hyperlink{talker__mrp__client_8c_a6c7e3f190d4c6369f0a70172f95416dd}{monitor\_attr});
365     rc |= pthread\_create(&\hyperlink{talker__mrp__client_8c_afbd6fc6e0ab3c1a04a518f19c21d4503}{monitor\_thread}, \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}, 
      \hyperlink{talker__mrp__client_8c_afdd2d7bcf3cde2ab45b078d253558c2d}{mrp\_monitor\_thread}, ctx);
366     \textcolor{keywordflow}{return} rc;
367     \textcolor{keywordflow}{return} 0;
368  \hyperlink{jack__listener_8c_a1cdcf0ac9be9edf74b8fcedb01e26cf3}{out}:    \textcolor{keywordflow}{if} (sock\_fd != -1)
369         close(sock\_fd);
370     sock\_fd = -1;
371     \textcolor{keywordflow}{return} -1;
372 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{talker__mrp__client_8c_aa94a906b50f9aca85cb00a18235c627f_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{talker__mrp__client_8c_aa94a906b50f9aca85cb00a18235c627f_icgraph}
\end{center}
\end{figure}


\index{talker\+\_\+mrp\+\_\+client.\+c@{talker\+\_\+mrp\+\_\+client.\+c}!mrp\+\_\+disconnect@{mrp\+\_\+disconnect}}
\index{mrp\+\_\+disconnect@{mrp\+\_\+disconnect}!talker\+\_\+mrp\+\_\+client.\+c@{talker\+\_\+mrp\+\_\+client.\+c}}
\subsubsection[{\texorpdfstring{mrp\+\_\+disconnect(struct mrp\+\_\+talker\+\_\+ctx $\ast$ctx)}{mrp_disconnect(struct mrp_talker_ctx *ctx)}}]{\setlength{\rightskip}{0pt plus 5cm}int mrp\+\_\+disconnect (
\begin{DoxyParamCaption}
\item[{struct {\bf mrp\+\_\+talker\+\_\+ctx} $\ast$}]{ctx}
\end{DoxyParamCaption}
)}\hypertarget{talker__mrp__client_8c_a9c244bc9e37fdc937cd38b09307003d7}{}\label{talker__mrp__client_8c_a9c244bc9e37fdc937cd38b09307003d7}


talker\+\_\+mrp\+\_\+client.\+c 파일의 374 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
375 \{
376     \textcolor{keywordtype}{char} *\hyperlink{mrp_validate_8c_a3820841c4bbf28f04505bea65d6b84f7}{msgbuf};
377     \textcolor{keywordtype}{int} rc;
378 
379     msgbuf = \hyperlink{_memory_leak_detector_malloc_macros_8h_ab8b25cd8f16d4a6552afe4e65c4f082d}{malloc}(1500);
380     \textcolor{keywordflow}{if} (\hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} == msgbuf)
381         \textcolor{keywordflow}{return} -1;
382     memset(msgbuf, 0, 64);
383     sprintf(msgbuf, \textcolor{stringliteral}{"BYE"});
384     \hyperlink{talker__mrp__client_8c_a5238adacbd2c4d99b6238f3e4ad554ca}{mrp\_okay} = 0;
385     rc = \hyperlink{talker__mrp__client_8c_adb1f8eb8ae4f2e22f8c4219da68f2eb0}{send\_mrp\_msg}(msgbuf, 1500, ctx);
386     \hyperlink{_memory_leak_detector_malloc_macros_8h_aa7157aa9480bb73f090dca36776419bf}{free}(msgbuf);
387 
388     \textcolor{keywordflow}{if} (rc != 1500)
389         \textcolor{keywordflow}{return} -1;
390     \textcolor{keywordflow}{else}
391         \textcolor{keywordflow}{return} 0;
392 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=285pt]{talker__mrp__client_8c_a9c244bc9e37fdc937cd38b09307003d7_cgraph}
\end{center}
\end{figure}


\index{talker\+\_\+mrp\+\_\+client.\+c@{talker\+\_\+mrp\+\_\+client.\+c}!mrp\+\_\+get\+\_\+domain@{mrp\+\_\+get\+\_\+domain}}
\index{mrp\+\_\+get\+\_\+domain@{mrp\+\_\+get\+\_\+domain}!talker\+\_\+mrp\+\_\+client.\+c@{talker\+\_\+mrp\+\_\+client.\+c}}
\subsubsection[{\texorpdfstring{mrp\+\_\+get\+\_\+domain(struct mrp\+\_\+talker\+\_\+ctx $\ast$ctx, struct mrp\+\_\+domain\+\_\+attr $\ast$class\+\_\+a, struct mrp\+\_\+domain\+\_\+attr $\ast$class\+\_\+b)}{mrp_get_domain(struct mrp_talker_ctx *ctx, struct mrp_domain_attr *class_a, struct mrp_domain_attr *class_b)}}]{\setlength{\rightskip}{0pt plus 5cm}int mrp\+\_\+get\+\_\+domain (
\begin{DoxyParamCaption}
\item[{struct {\bf mrp\+\_\+talker\+\_\+ctx} $\ast$}]{ctx, }
\item[{struct {\bf mrp\+\_\+domain\+\_\+attr} $\ast$}]{class\+\_\+a, }
\item[{struct {\bf mrp\+\_\+domain\+\_\+attr} $\ast$}]{class\+\_\+b}
\end{DoxyParamCaption}
)}\hypertarget{talker__mrp__client_8c_aeb2be83ee100a0241552a07a7d91f4e0}{}\label{talker__mrp__client_8c_aeb2be83ee100a0241552a07a7d91f4e0}


talker\+\_\+mrp\+\_\+client.\+c 파일의 518 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
519 \{
520     \textcolor{keywordtype}{char} *\hyperlink{mrp_validate_8c_a3820841c4bbf28f04505bea65d6b84f7}{msgbuf};
521     \textcolor{keywordtype}{int} ret;
522 
523     \textcolor{comment}{/* we may not get a notification if we are joining late,}
524 \textcolor{comment}{     * so query for what is already there ...}
525 \textcolor{comment}{     */}
526     msgbuf = \hyperlink{_memory_leak_detector_malloc_macros_8h_ab8b25cd8f16d4a6552afe4e65c4f082d}{malloc}(1500);
527     \textcolor{keywordflow}{if} (\hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} == msgbuf)
528         \textcolor{keywordflow}{return} -1;
529     memset(msgbuf, 0, 1500);
530     sprintf(msgbuf, \textcolor{stringliteral}{"S??"});
531     ret = \hyperlink{talker__mrp__client_8c_adb1f8eb8ae4f2e22f8c4219da68f2eb0}{send\_mrp\_msg}(msgbuf, 1500, ctx);
532     \hyperlink{_memory_leak_detector_malloc_macros_8h_aa7157aa9480bb73f090dca36776419bf}{free}(msgbuf);
533     \textcolor{keywordflow}{if} (ret != 1500)
534         \textcolor{keywordflow}{return} -1;
535     \textcolor{keywordflow}{while} (!ctx->\hyperlink{structmrp__talker__ctx_a7c8176263e9704aa667fc335cc818a3f}{halt\_tx} && (ctx->\hyperlink{structmrp__talker__ctx_ae3be05692572d8c757174629541e2d91}{domain\_a\_valid} == 0) && (ctx->
      \hyperlink{structmrp__talker__ctx_add1f58f9a17de764566dbf2e352b907f}{domain\_b\_valid} == 0))
536         usleep(20000);
537     class\_a->\hyperlink{structmrp__domain__attr_a7441ef0865bcb3db9b8064dd7375c1ea}{id} = 0;
538     class\_a->\hyperlink{structmrp__domain__attr_acec9ce2df15222151ad66fcb1d74eb9f}{priority} = 0;
539     class\_a->\hyperlink{structmrp__domain__attr_a066fae47f1854479570ecc0bf7e488c3}{vid} = 0;
540     class\_b->\hyperlink{structmrp__domain__attr_a7441ef0865bcb3db9b8064dd7375c1ea}{id} = 0;
541     class\_b->\hyperlink{structmrp__domain__attr_acec9ce2df15222151ad66fcb1d74eb9f}{priority} = 0;
542     class\_b->\hyperlink{structmrp__domain__attr_a066fae47f1854479570ecc0bf7e488c3}{vid} = 0;
543     \textcolor{keywordflow}{if} (ctx->\hyperlink{structmrp__talker__ctx_ae3be05692572d8c757174629541e2d91}{domain\_a\_valid}) \{
544         class\_a->\hyperlink{structmrp__domain__attr_a7441ef0865bcb3db9b8064dd7375c1ea}{id} = ctx->\hyperlink{structmrp__talker__ctx_a6e4374793667e90915abfe73f0e6201c}{domain\_class\_a\_id};
545         class\_a->\hyperlink{structmrp__domain__attr_acec9ce2df15222151ad66fcb1d74eb9f}{priority} = ctx->\hyperlink{structmrp__talker__ctx_ac98b99ec0ffd190c1da93e6caffe36d4}{domain\_class\_a\_priority};
546         class\_a->\hyperlink{structmrp__domain__attr_a066fae47f1854479570ecc0bf7e488c3}{vid} = ctx->\hyperlink{structmrp__talker__ctx_ac575246135a50baaf0c802ef29aa2779}{domain\_class\_a\_vid};
547     \}
548     \textcolor{keywordflow}{if} (ctx->\hyperlink{structmrp__talker__ctx_add1f58f9a17de764566dbf2e352b907f}{domain\_b\_valid}) \{
549         class\_b->\hyperlink{structmrp__domain__attr_a7441ef0865bcb3db9b8064dd7375c1ea}{id} = ctx->\hyperlink{structmrp__talker__ctx_a058aabd498c78e32b6610fd06f90fc43}{domain\_class\_b\_id};
550         class\_b->\hyperlink{structmrp__domain__attr_acec9ce2df15222151ad66fcb1d74eb9f}{priority} = ctx->\hyperlink{structmrp__talker__ctx_a90efafdfc3b16f51cc0f67aa65796a3c}{domain\_class\_b\_priority};
551         class\_b->\hyperlink{structmrp__domain__attr_a066fae47f1854479570ecc0bf7e488c3}{vid} = ctx->\hyperlink{structmrp__talker__ctx_a153312a7212b932f60b49a67309f2053}{domain\_class\_b\_vid};
552     \}
553     \textcolor{keywordflow}{return} 0;
554 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=288pt]{talker__mrp__client_8c_aeb2be83ee100a0241552a07a7d91f4e0_cgraph}
\end{center}
\end{figure}


\index{talker\+\_\+mrp\+\_\+client.\+c@{talker\+\_\+mrp\+\_\+client.\+c}!mrp\+\_\+join\+\_\+vlan@{mrp\+\_\+join\+\_\+vlan}}
\index{mrp\+\_\+join\+\_\+vlan@{mrp\+\_\+join\+\_\+vlan}!talker\+\_\+mrp\+\_\+client.\+c@{talker\+\_\+mrp\+\_\+client.\+c}}
\subsubsection[{\texorpdfstring{mrp\+\_\+join\+\_\+vlan(struct mrp\+\_\+domain\+\_\+attr $\ast$reg\+\_\+class, struct mrp\+\_\+talker\+\_\+ctx $\ast$ctx)}{mrp_join_vlan(struct mrp_domain_attr *reg_class, struct mrp_talker_ctx *ctx)}}]{\setlength{\rightskip}{0pt plus 5cm}int mrp\+\_\+join\+\_\+vlan (
\begin{DoxyParamCaption}
\item[{struct {\bf mrp\+\_\+domain\+\_\+attr} $\ast$}]{reg\+\_\+class, }
\item[{struct {\bf mrp\+\_\+talker\+\_\+ctx} $\ast$}]{ctx}
\end{DoxyParamCaption}
)}\hypertarget{talker__mrp__client_8c_a5a1dbea67f6c32ce5de65b8f5d51c2de}{}\label{talker__mrp__client_8c_a5a1dbea67f6c32ce5de65b8f5d51c2de}


talker\+\_\+mrp\+\_\+client.\+c 파일의 556 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
557 \{
558     \textcolor{keywordtype}{char} *\hyperlink{mrp_validate_8c_a3820841c4bbf28f04505bea65d6b84f7}{msgbuf};
559     \textcolor{keywordtype}{int} rc;
560 
561     msgbuf = \hyperlink{_memory_leak_detector_malloc_macros_8h_ab8b25cd8f16d4a6552afe4e65c4f082d}{malloc}(1500);
562     \textcolor{keywordflow}{if} (\hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} == msgbuf)
563         \textcolor{keywordflow}{return} -1;
564     memset(msgbuf, 0, 1500);
565     sprintf(msgbuf, \textcolor{stringliteral}{"V++:I=%04x\(\backslash\)n"},reg\_class->\hyperlink{structmrp__domain__attr_a066fae47f1854479570ecc0bf7e488c3}{vid});
566     rc = \hyperlink{talker__mrp__client_8c_adb1f8eb8ae4f2e22f8c4219da68f2eb0}{send\_mrp\_msg}(msgbuf, 1500, ctx);
567     \hyperlink{_memory_leak_detector_malloc_macros_8h_aa7157aa9480bb73f090dca36776419bf}{free}(msgbuf);
568 
569     \textcolor{keywordflow}{if} (rc != 1500)
570         \textcolor{keywordflow}{return} -1;
571     \textcolor{keywordflow}{else}
572         \textcolor{keywordflow}{return} 0;
573 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=276pt]{talker__mrp__client_8c_a5a1dbea67f6c32ce5de65b8f5d51c2de_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{talker__mrp__client_8c_a5a1dbea67f6c32ce5de65b8f5d51c2de_icgraph}
\end{center}
\end{figure}


\index{talker\+\_\+mrp\+\_\+client.\+c@{talker\+\_\+mrp\+\_\+client.\+c}!mrp\+\_\+monitor@{mrp\+\_\+monitor}}
\index{mrp\+\_\+monitor@{mrp\+\_\+monitor}!talker\+\_\+mrp\+\_\+client.\+c@{talker\+\_\+mrp\+\_\+client.\+c}}
\subsubsection[{\texorpdfstring{mrp\+\_\+monitor(void)}{mrp_monitor(void)}}]{\setlength{\rightskip}{0pt plus 5cm}int mrp\+\_\+monitor (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{talker__mrp__client_8c_acc997d17445fa9c83b587029363c785d}{}\label{talker__mrp__client_8c_acc997d17445fa9c83b587029363c785d}


talker\+\_\+mrp\+\_\+client.\+c 파일의 394 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
395 \{
396     \textcolor{keywordtype}{int} rc;
397     rc = pthread\_attr\_init(&\hyperlink{talker__mrp__client_8c_a6c7e3f190d4c6369f0a70172f95416dd}{monitor\_attr});
398     rc |= pthread\_create(&\hyperlink{talker__mrp__client_8c_afbd6fc6e0ab3c1a04a518f19c21d4503}{monitor\_thread}, \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}, 
      \hyperlink{talker__mrp__client_8c_afdd2d7bcf3cde2ab45b078d253558c2d}{mrp\_monitor\_thread}, \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL});
399     \textcolor{keywordflow}{return} rc;
400 \}
\end{DoxyCode}
\index{talker\+\_\+mrp\+\_\+client.\+c@{talker\+\_\+mrp\+\_\+client.\+c}!mrp\+\_\+monitor\+\_\+thread@{mrp\+\_\+monitor\+\_\+thread}}
\index{mrp\+\_\+monitor\+\_\+thread@{mrp\+\_\+monitor\+\_\+thread}!talker\+\_\+mrp\+\_\+client.\+c@{talker\+\_\+mrp\+\_\+client.\+c}}
\subsubsection[{\texorpdfstring{mrp\+\_\+monitor\+\_\+thread(void $\ast$arg)}{mrp_monitor_thread(void *arg)}}]{\setlength{\rightskip}{0pt plus 5cm}void$\ast$ mrp\+\_\+monitor\+\_\+thread (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{arg}
\end{DoxyParamCaption}
)}\hypertarget{talker__mrp__client_8c_afdd2d7bcf3cde2ab45b078d253558c2d}{}\label{talker__mrp__client_8c_afdd2d7bcf3cde2ab45b078d253558c2d}


talker\+\_\+mrp\+\_\+client.\+c 파일의 299 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
300 \{
301     \textcolor{keywordtype}{char} *\hyperlink{mrp_validate_8c_a3820841c4bbf28f04505bea65d6b84f7}{msgbuf};
302     \textcolor{keyword}{struct }sockaddr\_in client\_addr;
303     \textcolor{keyword}{struct }msghdr \hyperlink{maap__log__linux_8c_a0c7e58a50354c4a4d6dad428d0e47029}{msg};
304     \textcolor{keyword}{struct }iovec iov;
305     \textcolor{keywordtype}{int} bytes = 0;
306     \textcolor{keyword}{struct }pollfd \hyperlink{openavb__avdecc__msg__server__osal_8c_ae18b289099c8c9be5f76acee6311699a}{fds};
307     \textcolor{keywordtype}{int} rc;
308     \textcolor{keyword}{struct }\hyperlink{structmrp__talker__ctx}{mrp\_talker\_ctx} *\hyperlink{jack_8h_a1cde2a2cf8a56164b5e83159035be03b}{ctx} = (\textcolor{keyword}{struct }\hyperlink{structmrp__talker__ctx}{mrp\_talker\_ctx}*) arg;
309 
310     msgbuf = (\textcolor{keywordtype}{char} *)\hyperlink{_memory_leak_detector_malloc_macros_8h_ab8b25cd8f16d4a6552afe4e65c4f082d}{malloc}(\hyperlink{mrpd_8h_a63a4db05a55163366a16c61994e77a6f}{MAX\_MRPD\_CMDSZ});
311     \textcolor{keywordflow}{if} (\hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} == msgbuf)
312         \textcolor{keywordflow}{return} \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
313     \textcolor{keywordflow}{while} (!ctx->\hyperlink{structmrp__talker__ctx_a7c8176263e9704aa667fc335cc818a3f}{halt\_tx}) \{
314         \hyperlink{openavb__avdecc__msg__server__osal_8c_ae18b289099c8c9be5f76acee6311699a}{fds}.fd = ctx->\hyperlink{structmrp__talker__ctx_ab16a0c776c464dcfb5cf8a013a137647}{control\_socket};
315         \hyperlink{openavb__avdecc__msg__server__osal_8c_ae18b289099c8c9be5f76acee6311699a}{fds}.events = POLLIN;
316         \hyperlink{openavb__avdecc__msg__server__osal_8c_ae18b289099c8c9be5f76acee6311699a}{fds}.revents = 0;
317         rc = poll(&\hyperlink{openavb__avdecc__msg__server__osal_8c_ae18b289099c8c9be5f76acee6311699a}{fds}, 1, 100);
318         \textcolor{keywordflow}{if} (rc < 0) \{
319             \hyperlink{_memory_leak_detector_malloc_macros_8h_aa7157aa9480bb73f090dca36776419bf}{free}(msgbuf);
320             pthread\_exit(\hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL});
321         \}
322         \textcolor{keywordflow}{if} (rc == 0)
323             \textcolor{keywordflow}{continue};
324         \textcolor{keywordflow}{if} ((\hyperlink{openavb__avdecc__msg__server__osal_8c_ae18b289099c8c9be5f76acee6311699a}{fds}.revents & POLLIN) == 0) \{
325             \hyperlink{_memory_leak_detector_malloc_macros_8h_aa7157aa9480bb73f090dca36776419bf}{free}(msgbuf);
326             pthread\_exit(\hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL});
327         \}
328         memset(&\hyperlink{maap__log__linux_8c_a0c7e58a50354c4a4d6dad428d0e47029}{msg}, 0, \textcolor{keyword}{sizeof}(\hyperlink{maap__log__linux_8c_a0c7e58a50354c4a4d6dad428d0e47029}{msg}));
329         memset(&client\_addr, 0, \textcolor{keyword}{sizeof}(client\_addr));
330         memset(msgbuf, 0, \hyperlink{mrpd_8h_a63a4db05a55163366a16c61994e77a6f}{MAX\_MRPD\_CMDSZ});
331         iov.iov\_len = \hyperlink{mrpd_8h_a63a4db05a55163366a16c61994e77a6f}{MAX\_MRPD\_CMDSZ};
332         iov.iov\_base = \hyperlink{mrp_validate_8c_a3820841c4bbf28f04505bea65d6b84f7}{msgbuf};
333         \hyperlink{maap__log__linux_8c_a0c7e58a50354c4a4d6dad428d0e47029}{msg}.msg\_name = &client\_addr;
334         \hyperlink{maap__log__linux_8c_a0c7e58a50354c4a4d6dad428d0e47029}{msg}.msg\_namelen = \textcolor{keyword}{sizeof}(client\_addr);
335         \hyperlink{maap__log__linux_8c_a0c7e58a50354c4a4d6dad428d0e47029}{msg}.msg\_iov = &iov;
336         \hyperlink{maap__log__linux_8c_a0c7e58a50354c4a4d6dad428d0e47029}{msg}.msg\_iovlen = 1;
337         bytes = recvmsg(ctx->\hyperlink{structmrp__talker__ctx_ab16a0c776c464dcfb5cf8a013a137647}{control\_socket}, &\hyperlink{maap__log__linux_8c_a0c7e58a50354c4a4d6dad428d0e47029}{msg}, 0);
338         \textcolor{keywordflow}{if} (bytes < 0)
339             \textcolor{keywordflow}{continue};
340         \hyperlink{talker__mrp__client_8c_ac27e48d61b63306dbfe0a27c3c5e13a9}{process\_mrp\_msg}(msgbuf, bytes, ctx);
341     \}
342     \hyperlink{_memory_leak_detector_malloc_macros_8h_aa7157aa9480bb73f090dca36776419bf}{free}(msgbuf);
343     pthread\_exit(\hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL});
344 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=316pt]{talker__mrp__client_8c_afdd2d7bcf3cde2ab45b078d253558c2d_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{talker__mrp__client_8c_afdd2d7bcf3cde2ab45b078d253558c2d_icgraph}
\end{center}
\end{figure}


\index{talker\+\_\+mrp\+\_\+client.\+c@{talker\+\_\+mrp\+\_\+client.\+c}!mrp\+\_\+register\+\_\+domain@{mrp\+\_\+register\+\_\+domain}}
\index{mrp\+\_\+register\+\_\+domain@{mrp\+\_\+register\+\_\+domain}!talker\+\_\+mrp\+\_\+client.\+c@{talker\+\_\+mrp\+\_\+client.\+c}}
\subsubsection[{\texorpdfstring{mrp\+\_\+register\+\_\+domain(struct mrp\+\_\+domain\+\_\+attr $\ast$reg\+\_\+class, struct mrp\+\_\+talker\+\_\+ctx $\ast$ctx)}{mrp_register_domain(struct mrp_domain_attr *reg_class, struct mrp_talker_ctx *ctx)}}]{\setlength{\rightskip}{0pt plus 5cm}int mrp\+\_\+register\+\_\+domain (
\begin{DoxyParamCaption}
\item[{struct {\bf mrp\+\_\+domain\+\_\+attr} $\ast$}]{reg\+\_\+class, }
\item[{struct {\bf mrp\+\_\+talker\+\_\+ctx} $\ast$}]{ctx}
\end{DoxyParamCaption}
)}\hypertarget{talker__mrp__client_8c_ad06b236726820804f4273102e9177efd}{}\label{talker__mrp__client_8c_ad06b236726820804f4273102e9177efd}


talker\+\_\+mrp\+\_\+client.\+c 파일의 402 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
403 \{
404     \textcolor{keywordtype}{char} *\hyperlink{mrp_validate_8c_a3820841c4bbf28f04505bea65d6b84f7}{msgbuf};
405     \textcolor{keywordtype}{int} rc;
406 
407     msgbuf = \hyperlink{_memory_leak_detector_malloc_macros_8h_ab8b25cd8f16d4a6552afe4e65c4f082d}{malloc}(1500);
408     \textcolor{keywordflow}{if} (\hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} == msgbuf)
409         \textcolor{keywordflow}{return} -1;
410     memset(msgbuf, 0, 1500);
411 
412     sprintf(msgbuf, \textcolor{stringliteral}{"S+D:C=%d,P=%d,V=%04x"}, reg\_class->\hyperlink{structmrp__domain__attr_a7441ef0865bcb3db9b8064dd7375c1ea}{id}, reg\_class->\hyperlink{structmrp__domain__attr_acec9ce2df15222151ad66fcb1d74eb9f}{priority}, reg\_class->
      \hyperlink{structmrp__domain__attr_a066fae47f1854479570ecc0bf7e488c3}{vid});
413     \hyperlink{talker__mrp__client_8c_a5238adacbd2c4d99b6238f3e4ad554ca}{mrp\_okay} = 0;
414     rc = \hyperlink{talker__mrp__client_8c_adb1f8eb8ae4f2e22f8c4219da68f2eb0}{send\_mrp\_msg}(msgbuf, 1500, ctx);
415     \hyperlink{_memory_leak_detector_malloc_macros_8h_aa7157aa9480bb73f090dca36776419bf}{free}(msgbuf);
416 
417     \textcolor{keywordflow}{if} (rc != 1500)
418         \textcolor{keywordflow}{return} -1;
419     \textcolor{keywordflow}{else}
420         \textcolor{keywordflow}{return} 0;
421 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=306pt]{talker__mrp__client_8c_ad06b236726820804f4273102e9177efd_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{talker__mrp__client_8c_ad06b236726820804f4273102e9177efd_icgraph}
\end{center}
\end{figure}


\index{talker\+\_\+mrp\+\_\+client.\+c@{talker\+\_\+mrp\+\_\+client.\+c}!mrp\+\_\+talker\+\_\+client\+\_\+init@{mrp\+\_\+talker\+\_\+client\+\_\+init}}
\index{mrp\+\_\+talker\+\_\+client\+\_\+init@{mrp\+\_\+talker\+\_\+client\+\_\+init}!talker\+\_\+mrp\+\_\+client.\+c@{talker\+\_\+mrp\+\_\+client.\+c}}
\subsubsection[{\texorpdfstring{mrp\+\_\+talker\+\_\+client\+\_\+init(struct mrp\+\_\+talker\+\_\+ctx $\ast$ctx)}{mrp_talker_client_init(struct mrp_talker_ctx *ctx)}}]{\setlength{\rightskip}{0pt plus 5cm}int mrp\+\_\+talker\+\_\+client\+\_\+init (
\begin{DoxyParamCaption}
\item[{struct {\bf mrp\+\_\+talker\+\_\+ctx} $\ast$}]{ctx}
\end{DoxyParamCaption}
)}\hypertarget{talker__mrp__client_8c_a74c2fc24c07fa72e2fd10a3a98f9dc9d}{}\label{talker__mrp__client_8c_a74c2fc24c07fa72e2fd10a3a98f9dc9d}


talker\+\_\+mrp\+\_\+client.\+c 파일의 49 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
50 \{
51     \textcolor{keywordtype}{int} i;
52     ctx->\hyperlink{structmrp__talker__ctx_ab16a0c776c464dcfb5cf8a013a137647}{control\_socket} = -1;
53     ctx->\hyperlink{structmrp__talker__ctx_a7c8176263e9704aa667fc335cc818a3f}{halt\_tx} = 0;
54     ctx->\hyperlink{structmrp__talker__ctx_a70763450542106f6508fd1051eade47d}{listeners} = 0;
55     ctx->\hyperlink{structmrp__talker__ctx_ae3be05692572d8c757174629541e2d91}{domain\_a\_valid} = 0;
56     ctx->\hyperlink{structmrp__talker__ctx_a6e4374793667e90915abfe73f0e6201c}{domain\_class\_a\_id} = 0;
57     ctx->\hyperlink{structmrp__talker__ctx_ac98b99ec0ffd190c1da93e6caffe36d4}{domain\_class\_a\_priority} = 0;
58     ctx->\hyperlink{structmrp__talker__ctx_ac575246135a50baaf0c802ef29aa2779}{domain\_class\_a\_vid} = 0;
59     ctx->\hyperlink{structmrp__talker__ctx_add1f58f9a17de764566dbf2e352b907f}{domain\_b\_valid} = 0;
60     ctx->\hyperlink{structmrp__talker__ctx_a058aabd498c78e32b6610fd06f90fc43}{domain\_class\_b\_id} = 0;
61     ctx->\hyperlink{structmrp__talker__ctx_a90efafdfc3b16f51cc0f67aa65796a3c}{domain\_class\_b\_priority} = 0;
62     ctx->\hyperlink{structmrp__talker__ctx_a153312a7212b932f60b49a67309f2053}{domain\_class\_b\_vid} = 0;
63     \textcolor{keywordflow}{for} (i=0;i<8;i++)
64     \{
65         ctx->\hyperlink{structmrp__talker__ctx_a0be105011a16541a479847730d7321c9}{monitor\_stream\_id}[i] = 0;
66     \}
67     \textcolor{keywordflow}{return} 0;
68 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=263pt]{talker__mrp__client_8c_a74c2fc24c07fa72e2fd10a3a98f9dc9d_icgraph}
\end{center}
\end{figure}


\index{talker\+\_\+mrp\+\_\+client.\+c@{talker\+\_\+mrp\+\_\+client.\+c}!mrp\+\_\+unadvertise\+\_\+stream@{mrp\+\_\+unadvertise\+\_\+stream}}
\index{mrp\+\_\+unadvertise\+\_\+stream@{mrp\+\_\+unadvertise\+\_\+stream}!talker\+\_\+mrp\+\_\+client.\+c@{talker\+\_\+mrp\+\_\+client.\+c}}
\subsubsection[{\texorpdfstring{mrp\+\_\+unadvertise\+\_\+stream(uint8\+\_\+t $\ast$streamid, uint8\+\_\+t $\ast$destaddr, int pktsz, int interval, int latency, struct mrp\+\_\+talker\+\_\+ctx $\ast$ctx)}{mrp_unadvertise_stream(uint8_t *streamid, uint8_t *destaddr, int pktsz, int interval, int latency, struct mrp_talker_ctx *ctx)}}]{\setlength{\rightskip}{0pt plus 5cm}int mrp\+\_\+unadvertise\+\_\+stream (
\begin{DoxyParamCaption}
\item[{{\bf uint8\+\_\+t} $\ast$}]{streamid, }
\item[{{\bf uint8\+\_\+t} $\ast$}]{destaddr, }
\item[{int}]{pktsz, }
\item[{int}]{interval, }
\item[{int}]{latency, }
\item[{struct {\bf mrp\+\_\+talker\+\_\+ctx} $\ast$}]{ctx}
\end{DoxyParamCaption}
)}\hypertarget{talker__mrp__client_8c_ad07070e607ae7c6127ffb3cc3e6e1d7b}{}\label{talker__mrp__client_8c_ad07070e607ae7c6127ffb3cc3e6e1d7b}


talker\+\_\+mrp\+\_\+client.\+c 파일의 459 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
462 \{
463     \textcolor{keywordtype}{char} *\hyperlink{mrp_validate_8c_a3820841c4bbf28f04505bea65d6b84f7}{msgbuf};
464     \textcolor{keywordtype}{int} rc;
465     msgbuf = \hyperlink{_memory_leak_detector_malloc_macros_8h_ab8b25cd8f16d4a6552afe4e65c4f082d}{malloc}(1500);
466     \textcolor{keywordflow}{if} (\hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} == msgbuf)
467         \textcolor{keywordflow}{return} -1;
468     memset(msgbuf, 0, 1500);
469     sprintf(msgbuf, \textcolor{stringliteral}{"S--:S=%02X%02X%02X%02X%02X%02X%02X%02X"}
470         \textcolor{stringliteral}{",A=%02X%02X%02X%02X%02X%02X"}
471         \textcolor{stringliteral}{",V=%04X"}
472         \textcolor{stringliteral}{",Z=%d"}
473         \textcolor{stringliteral}{",I=%d"}
474         \textcolor{stringliteral}{",P=%d"}
475         \textcolor{stringliteral}{",L=%d"}, streamid[0], streamid[1], streamid[2],
476         streamid[3], streamid[4], streamid[5], streamid[6],
477         streamid[7], destaddr[0], destaddr[1], destaddr[2],
478         destaddr[3], destaddr[4], destaddr[5], ctx->\hyperlink{structmrp__talker__ctx_ac575246135a50baaf0c802ef29aa2779}{domain\_class\_a\_vid}, pktsz,
479         interval, ctx->\hyperlink{structmrp__talker__ctx_ac98b99ec0ffd190c1da93e6caffe36d4}{domain\_class\_a\_priority} << 5, latency);
480     \hyperlink{talker__mrp__client_8c_a5238adacbd2c4d99b6238f3e4ad554ca}{mrp\_okay} = 0;
481     rc = \hyperlink{talker__mrp__client_8c_adb1f8eb8ae4f2e22f8c4219da68f2eb0}{send\_mrp\_msg}(msgbuf, 1500, ctx);
482     \hyperlink{_memory_leak_detector_malloc_macros_8h_aa7157aa9480bb73f090dca36776419bf}{free}(msgbuf);
483 
484     \textcolor{keywordflow}{if} (rc != 1500)
485         \textcolor{keywordflow}{return} -1;
486     \textcolor{keywordflow}{else}
487         \textcolor{keywordflow}{return} 0;
488 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=323pt]{talker__mrp__client_8c_ad07070e607ae7c6127ffb3cc3e6e1d7b_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{talker__mrp__client_8c_ad07070e607ae7c6127ffb3cc3e6e1d7b_icgraph}
\end{center}
\end{figure}


\index{talker\+\_\+mrp\+\_\+client.\+c@{talker\+\_\+mrp\+\_\+client.\+c}!process\+\_\+mrp\+\_\+msg@{process\+\_\+mrp\+\_\+msg}}
\index{process\+\_\+mrp\+\_\+msg@{process\+\_\+mrp\+\_\+msg}!talker\+\_\+mrp\+\_\+client.\+c@{talker\+\_\+mrp\+\_\+client.\+c}}
\subsubsection[{\texorpdfstring{process\+\_\+mrp\+\_\+msg(char $\ast$buf, int buflen, struct mrp\+\_\+talker\+\_\+ctx $\ast$ctx)}{process_mrp_msg(char *buf, int buflen, struct mrp_talker_ctx *ctx)}}]{\setlength{\rightskip}{0pt plus 5cm}int process\+\_\+mrp\+\_\+msg (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{buf, }
\item[{int}]{buflen, }
\item[{struct {\bf mrp\+\_\+talker\+\_\+ctx} $\ast$}]{ctx}
\end{DoxyParamCaption}
)}\hypertarget{talker__mrp__client_8c_ac27e48d61b63306dbfe0a27c3c5e13a9}{}\label{talker__mrp__client_8c_ac27e48d61b63306dbfe0a27c3c5e13a9}


talker\+\_\+mrp\+\_\+client.\+c 파일의 89 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
90 \{
91 
92     \textcolor{comment}{/*}
93 \textcolor{comment}{     * 1st character indicates application}
94 \textcolor{comment}{     * [MVS] - MAC, VLAN or STREAM}
95 \textcolor{comment}{     */}
96     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} id;
97     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \hyperlink{aaf-talker_8c_acec9ce2df15222151ad66fcb1d74eb9f}{priority};
98     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} vid;
99     \textcolor{keywordtype}{int} i, j, k;
100     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} substate;
101     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} recovered\_streamid[8];
102     k = 0;
103  next\_line:\textcolor{keywordflow}{if} (k >= buflen)
104         \textcolor{keywordflow}{return} 0;
105     \textcolor{keywordflow}{switch} (buf[k]) \{
106     \textcolor{keywordflow}{case} \textcolor{charliteral}{'E'}:
107         printf(\textcolor{stringliteral}{"%s from mrpd\(\backslash\)n"}, buf);
108         fflush(stdout);
109         \hyperlink{talker__mrp__client_8c_a7e0861f30a3dba1eb162e77371fe9c21}{mrp\_error} = 1;
110         \textcolor{keywordflow}{break};
111     \textcolor{keywordflow}{case} \textcolor{charliteral}{'O'}:
112         \hyperlink{talker__mrp__client_8c_a5238adacbd2c4d99b6238f3e4ad554ca}{mrp\_okay} = 1;
113         \textcolor{keywordflow}{break};
114     \textcolor{keywordflow}{case} \textcolor{charliteral}{'M'}:
115     \textcolor{keywordflow}{case} \textcolor{charliteral}{'V'}:
116         printf(\textcolor{stringliteral}{"%s unhandled from mrpd\(\backslash\)n"}, buf);
117         fflush(stdout);
118 
119         \textcolor{comment}{/* unhandled for now */}
120         \textcolor{keywordflow}{break};
121     \textcolor{keywordflow}{case} \textcolor{charliteral}{'L'}:
122 
123         \textcolor{comment}{/* parse a listener attribute - see if it matches our monitor\_stream\_id */}
124         i = k;
125         \textcolor{keywordflow}{while} (buf[i] != \textcolor{charliteral}{'D'})
126             i++;
127         i += 2;     \textcolor{comment}{/* skip the ':' */}
128         sscanf(&(buf[i]), \textcolor{stringliteral}{"%d"}, &substate);
129         \textcolor{keywordflow}{while} (buf[i] != \textcolor{charliteral}{'S'})
130             i++;
131         i += 2;     \textcolor{comment}{/* skip the ':' */}
132         \textcolor{keywordflow}{for} (j = 0; j < 8; j++) \{
133             sscanf(&(buf[i + 2 * j]), \textcolor{stringliteral}{"%02x"}, &\textcolor{keywordtype}{id});
134             recovered\_streamid[j] = (\textcolor{keywordtype}{unsigned} char)\textcolor{keywordtype}{id};
135         \} printf
136             (\textcolor{stringliteral}{"FOUND STREAM ID=%02x%02x%02x%02x%02x%02x%02x%02x "},
137              recovered\_streamid[0], recovered\_streamid[1],
138              recovered\_streamid[2], recovered\_streamid[3],
139              recovered\_streamid[4], recovered\_streamid[5],
140              recovered\_streamid[6], recovered\_streamid[7]);
141         \textcolor{keywordflow}{switch} (substate) \{
142         \textcolor{keywordflow}{case} 0:
143             printf(\textcolor{stringliteral}{"with state ignore\(\backslash\)n"});
144             \textcolor{keywordflow}{break};
145         \textcolor{keywordflow}{case} 1:
146             printf(\textcolor{stringliteral}{"with state askfailed\(\backslash\)n"});
147             \textcolor{keywordflow}{break};
148         \textcolor{keywordflow}{case} 2:
149             printf(\textcolor{stringliteral}{"with state ready\(\backslash\)n"});
150             \textcolor{keywordflow}{break};
151         \textcolor{keywordflow}{case} 3:
152             printf(\textcolor{stringliteral}{"with state readyfail\(\backslash\)n"});
153             \textcolor{keywordflow}{break};
154         \textcolor{keywordflow}{default}:
155             printf(\textcolor{stringliteral}{"with state UNKNOWN (%d)\(\backslash\)n"}, substate);
156             \textcolor{keywordflow}{break};
157         \}
158         \textcolor{keywordflow}{if} (substate > \hyperlink{msrp_8h_a17407a06557d3b5b82c67cad6973353b}{MSRP\_LISTENER\_ASKFAILED}) \{
159             \textcolor{keywordflow}{if} (memcmp
160                 (recovered\_streamid, ctx->\hyperlink{structmrp__talker__ctx_a0be105011a16541a479847730d7321c9}{monitor\_stream\_id},
161                  \textcolor{keyword}{sizeof}(recovered\_streamid)) == 0) \{
162                 ctx->\hyperlink{structmrp__talker__ctx_a70763450542106f6508fd1051eade47d}{listeners} = 1;
163                 printf(\textcolor{stringliteral}{"added listener\(\backslash\)n"});
164             \}
165         \}
166         fflush(stdout);
167 
168         \textcolor{comment}{/* try to find a newline ... */}
169         \textcolor{keywordflow}{while} ((i < buflen) && (buf[i] != \textcolor{charliteral}{'\(\backslash\)n'}) && (buf[i] != \textcolor{charliteral}{'\(\backslash\)0'}))
170             i++;
171         \textcolor{keywordflow}{if} (i == buflen)
172             \textcolor{keywordflow}{return} 0;
173         \textcolor{keywordflow}{if} (buf[i] == \textcolor{charliteral}{'\(\backslash\)0'})
174             \textcolor{keywordflow}{return} 0;
175         i++;
176         k = i;
177         \textcolor{keywordflow}{goto} next\_line;
178         \textcolor{keywordflow}{break};
179     \textcolor{keywordflow}{case} \textcolor{charliteral}{'D'}:
180         i = k + 4;
181 
182         \textcolor{comment}{/* save the domain attribute */}
183         sscanf(&(buf[i]), \textcolor{stringliteral}{"%d"}, &\textcolor{keywordtype}{id});
184         \textcolor{keywordflow}{while} (buf[i] != \textcolor{charliteral}{'P'})
185             i++;
186         i += 2;     \textcolor{comment}{/* skip the ':' */}
187         sscanf(&(buf[i]), \textcolor{stringliteral}{"%d"}, &priority);
188         \textcolor{keywordflow}{while} (buf[i] != \textcolor{charliteral}{'V'})
189             i++;
190         i += 2;     \textcolor{comment}{/* skip the ':' */}
191         sscanf(&(buf[i]), \textcolor{stringliteral}{"%x"}, &vid);
192         \textcolor{keywordflow}{if} (\textcolor{keywordtype}{id} == 6) \{
193             ctx->\hyperlink{structmrp__talker__ctx_a6e4374793667e90915abfe73f0e6201c}{domain\_class\_a\_id} = id;
194             ctx->\hyperlink{structmrp__talker__ctx_ac98b99ec0ffd190c1da93e6caffe36d4}{domain\_class\_a\_priority} = \hyperlink{aaf-talker_8c_acec9ce2df15222151ad66fcb1d74eb9f}{priority};
195             ctx->\hyperlink{structmrp__talker__ctx_ac575246135a50baaf0c802ef29aa2779}{domain\_class\_a\_vid} = vid;
196             ctx->\hyperlink{structmrp__talker__ctx_ae3be05692572d8c757174629541e2d91}{domain\_a\_valid} = 1;
197         \} \textcolor{keywordflow}{else} \{
198             ctx->\hyperlink{structmrp__talker__ctx_a058aabd498c78e32b6610fd06f90fc43}{domain\_class\_b\_id} = id;
199             ctx->\hyperlink{structmrp__talker__ctx_a90efafdfc3b16f51cc0f67aa65796a3c}{domain\_class\_b\_priority} = \hyperlink{aaf-talker_8c_acec9ce2df15222151ad66fcb1d74eb9f}{priority};
200             ctx->\hyperlink{structmrp__talker__ctx_a153312a7212b932f60b49a67309f2053}{domain\_class\_b\_vid} = vid;
201             ctx->\hyperlink{structmrp__talker__ctx_add1f58f9a17de764566dbf2e352b907f}{domain\_b\_valid} = 1;
202         \}
203         \textcolor{keywordflow}{while} ((i < buflen) && (buf[i] != \textcolor{charliteral}{'\(\backslash\)n'}) && (buf[i] != \textcolor{charliteral}{'\(\backslash\)0'}))
204             i++;
205         \textcolor{keywordflow}{if} ((i == buflen) || (buf[i] == \textcolor{charliteral}{'\(\backslash\)0'}))
206             \textcolor{keywordflow}{return} 0;
207         i++;
208         k = i;
209         \textcolor{keywordflow}{goto} next\_line;
210         \textcolor{keywordflow}{break};
211     \textcolor{keywordflow}{case} \textcolor{charliteral}{'T'}:
212 
213         \textcolor{comment}{/* as simple\_talker we don't care about other talkers */}
214         i = k;
215         \textcolor{keywordflow}{while} ((i < buflen) && (buf[i] != \textcolor{charliteral}{'\(\backslash\)n'}) && (buf[i] != \textcolor{charliteral}{'\(\backslash\)0'}))
216             i++;
217         \textcolor{keywordflow}{if} (i == buflen)
218             \textcolor{keywordflow}{return} 0;
219         \textcolor{keywordflow}{if} (buf[i] == \textcolor{charliteral}{'\(\backslash\)0'})
220             \textcolor{keywordflow}{return} 0;
221         i++;
222         k = i;
223         \textcolor{keywordflow}{goto} next\_line;
224         \textcolor{keywordflow}{break};
225     \textcolor{keywordflow}{case} \textcolor{charliteral}{'S'}:
226 
227         \textcolor{comment}{/* handle the leave/join events */}
228         \textcolor{keywordflow}{switch} (buf[k + 4]) \{
229         \textcolor{keywordflow}{case} \textcolor{charliteral}{'L'}:
230             i = k + 5;
231             \textcolor{keywordflow}{while} (buf[i] != \textcolor{charliteral}{'D'})
232                 i++;
233             i += 2; \textcolor{comment}{/* skip the ':' */}
234             sscanf(&(buf[i]), \textcolor{stringliteral}{"%d"}, &substate);
235             \textcolor{keywordflow}{while} (buf[i] != \textcolor{charliteral}{'S'})
236                 i++;
237             i += 2; \textcolor{comment}{/* skip the ':' */}
238             \textcolor{keywordflow}{for} (j = 0; j < 8; j++) \{
239                 sscanf(&(buf[i + 2 * j]), \textcolor{stringliteral}{"%02x"}, &\textcolor{keywordtype}{id});
240                 recovered\_streamid[j] = (\textcolor{keywordtype}{unsigned} char)\textcolor{keywordtype}{id};
241             \} printf
242                 (\textcolor{stringliteral}{"EVENT on STREAM ID=%02x%02x%02x%02x%02x%02x%02x%02x "},
243                  recovered\_streamid[0], recovered\_streamid[1],
244                  recovered\_streamid[2], recovered\_streamid[3],
245                  recovered\_streamid[4], recovered\_streamid[5],
246                  recovered\_streamid[6], recovered\_streamid[7]);
247             \textcolor{keywordflow}{switch} (substate) \{
248             \textcolor{keywordflow}{case} 0:
249                 printf(\textcolor{stringliteral}{"with state ignore\(\backslash\)n"});
250                 \textcolor{keywordflow}{break};
251             \textcolor{keywordflow}{case} 1:
252                 printf(\textcolor{stringliteral}{"with state askfailed\(\backslash\)n"});
253                 \textcolor{keywordflow}{break};
254             \textcolor{keywordflow}{case} 2:
255                 printf(\textcolor{stringliteral}{"with state ready\(\backslash\)n"});
256                 \textcolor{keywordflow}{break};
257             \textcolor{keywordflow}{case} 3:
258                 printf(\textcolor{stringliteral}{"with state readyfail\(\backslash\)n"});
259                 \textcolor{keywordflow}{break};
260             \textcolor{keywordflow}{default}:
261                 printf(\textcolor{stringliteral}{"with state UNKNOWN (%d)\(\backslash\)n"}, substate);
262                 \textcolor{keywordflow}{break};
263             \}
264             \textcolor{keywordflow}{switch} (buf[k + 1]) \{
265             \textcolor{keywordflow}{case} \textcolor{charliteral}{'L'}:
266                 printf(\textcolor{stringliteral}{"got a leave indication\(\backslash\)n"});
267                 \textcolor{keywordflow}{if} (memcmp
268                     (recovered\_streamid, ctx->\hyperlink{structmrp__talker__ctx_a0be105011a16541a479847730d7321c9}{monitor\_stream\_id},
269                      \textcolor{keyword}{sizeof}(recovered\_streamid)) == 0) \{
270                     ctx->\hyperlink{structmrp__talker__ctx_a70763450542106f6508fd1051eade47d}{listeners} = 0;
271                     printf(\textcolor{stringliteral}{"listener left\(\backslash\)n"});
272                 \}
273                 \textcolor{keywordflow}{break};
274             \textcolor{keywordflow}{case} \textcolor{charliteral}{'J'}:
275             \textcolor{keywordflow}{case} \textcolor{charliteral}{'N'}:
276                 printf(\textcolor{stringliteral}{"got a new/join indication\(\backslash\)n"});
277                 \textcolor{keywordflow}{if} (substate > \hyperlink{msrp_8h_a17407a06557d3b5b82c67cad6973353b}{MSRP\_LISTENER\_ASKFAILED}) \{
278                     \textcolor{keywordflow}{if} (memcmp
279                         (recovered\_streamid,
280                          ctx->\hyperlink{structmrp__talker__ctx_a0be105011a16541a479847730d7321c9}{monitor\_stream\_id},
281                          \textcolor{keyword}{sizeof}(recovered\_streamid)) == 0)
282                         ctx->\hyperlink{structmrp__talker__ctx_a70763450542106f6508fd1051eade47d}{listeners} = 1;
283                 \}
284                 \textcolor{keywordflow}{break};
285             \}
286 
287             \textcolor{comment}{/* only care about listeners ... */}
288         \textcolor{keywordflow}{default}:
289             \textcolor{keywordflow}{return} 0;
290             \textcolor{keywordflow}{break};
291         \}
292         \textcolor{keywordflow}{break};
293     \textcolor{keywordflow}{case} \textcolor{charliteral}{'\(\backslash\)0'}:
294         \textcolor{keywordflow}{break};
295     \}
296     \textcolor{keywordflow}{return} 0;
297 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{talker__mrp__client_8c_ac27e48d61b63306dbfe0a27c3c5e13a9_icgraph}
\end{center}
\end{figure}


\index{talker\+\_\+mrp\+\_\+client.\+c@{talker\+\_\+mrp\+\_\+client.\+c}!recv\+\_\+mrp\+\_\+okay@{recv\+\_\+mrp\+\_\+okay}}
\index{recv\+\_\+mrp\+\_\+okay@{recv\+\_\+mrp\+\_\+okay}!talker\+\_\+mrp\+\_\+client.\+c@{talker\+\_\+mrp\+\_\+client.\+c}}
\subsubsection[{\texorpdfstring{recv\+\_\+mrp\+\_\+okay()}{recv_mrp_okay()}}]{\setlength{\rightskip}{0pt plus 5cm}int recv\+\_\+mrp\+\_\+okay (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{talker__mrp__client_8c_a363563519c23ffe143b574310ee58b55}{}\label{talker__mrp__client_8c_a363563519c23ffe143b574310ee58b55}


talker\+\_\+mrp\+\_\+client.\+c 파일의 577 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
578 \{
579     \textcolor{keywordflow}{while} ((\hyperlink{talker__mrp__client_8c_a5238adacbd2c4d99b6238f3e4ad554ca}{mrp\_okay} == 0) && (\hyperlink{talker__mrp__client_8c_a7e0861f30a3dba1eb162e77371fe9c21}{mrp\_error} == 0))
580         usleep(20000);
581     \textcolor{keywordflow}{return} 0;
582 \}
\end{DoxyCode}
\index{talker\+\_\+mrp\+\_\+client.\+c@{talker\+\_\+mrp\+\_\+client.\+c}!send\+\_\+mrp\+\_\+msg@{send\+\_\+mrp\+\_\+msg}}
\index{send\+\_\+mrp\+\_\+msg@{send\+\_\+mrp\+\_\+msg}!talker\+\_\+mrp\+\_\+client.\+c@{talker\+\_\+mrp\+\_\+client.\+c}}
\subsubsection[{\texorpdfstring{send\+\_\+mrp\+\_\+msg(char $\ast$notify\+\_\+data, int notify\+\_\+len, struct mrp\+\_\+talker\+\_\+ctx $\ast$ctx)}{send_mrp_msg(char *notify_data, int notify_len, struct mrp_talker_ctx *ctx)}}]{\setlength{\rightskip}{0pt plus 5cm}int send\+\_\+mrp\+\_\+msg (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{notify\+\_\+data, }
\item[{int}]{notify\+\_\+len, }
\item[{struct {\bf mrp\+\_\+talker\+\_\+ctx} $\ast$}]{ctx}
\end{DoxyParamCaption}
)}\hypertarget{talker__mrp__client_8c_adb1f8eb8ae4f2e22f8c4219da68f2eb0}{}\label{talker__mrp__client_8c_adb1f8eb8ae4f2e22f8c4219da68f2eb0}


talker\+\_\+mrp\+\_\+client.\+c 파일의 70 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
71 \{
72     \textcolor{keyword}{struct }sockaddr\_in addr;
73     socklen\_t addr\_len;
74 
75     \textcolor{keywordflow}{if} (ctx->\hyperlink{structmrp__talker__ctx_ab16a0c776c464dcfb5cf8a013a137647}{control\_socket} == -1)
76         \textcolor{keywordflow}{return} -1;
77     \textcolor{keywordflow}{if} (notify\_data == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
78         \textcolor{keywordflow}{return} -1;
79 
80     memset(&addr, 0, \textcolor{keyword}{sizeof}(addr));
81     addr.sin\_family = AF\_INET;
82     addr.sin\_port = htons(\hyperlink{mrpd_8h_a957ecb95a01b342339073f6422eb2bf9}{MRPD\_PORT\_DEFAULT});
83     inet\_aton(\textcolor{stringliteral}{"127.0.0.1"}, &addr.sin\_addr);
84     addr\_len = \textcolor{keyword}{sizeof}(addr);
85     \textcolor{keywordflow}{return} sendto(ctx->\hyperlink{structmrp__talker__ctx_ab16a0c776c464dcfb5cf8a013a137647}{control\_socket}, notify\_data, notify\_len, 0,
86              (\textcolor{keyword}{struct} sockaddr *)&addr, addr\_len);
87 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{talker__mrp__client_8c_adb1f8eb8ae4f2e22f8c4219da68f2eb0_icgraph}
\end{center}
\end{figure}




\subsection{변수 문서화}
\index{talker\+\_\+mrp\+\_\+client.\+c@{talker\+\_\+mrp\+\_\+client.\+c}!monitor\+\_\+attr@{monitor\+\_\+attr}}
\index{monitor\+\_\+attr@{monitor\+\_\+attr}!talker\+\_\+mrp\+\_\+client.\+c@{talker\+\_\+mrp\+\_\+client.\+c}}
\subsubsection[{\texorpdfstring{monitor\+\_\+attr}{monitor_attr}}]{\setlength{\rightskip}{0pt plus 5cm}pthread\+\_\+attr\+\_\+t monitor\+\_\+attr}\hypertarget{talker__mrp__client_8c_a6c7e3f190d4c6369f0a70172f95416dd}{}\label{talker__mrp__client_8c_a6c7e3f190d4c6369f0a70172f95416dd}


talker\+\_\+mrp\+\_\+client.\+c 파일의 42 번째 라인에서 정의되었습니다.

\index{talker\+\_\+mrp\+\_\+client.\+c@{talker\+\_\+mrp\+\_\+client.\+c}!monitor\+\_\+thread@{monitor\+\_\+thread}}
\index{monitor\+\_\+thread@{monitor\+\_\+thread}!talker\+\_\+mrp\+\_\+client.\+c@{talker\+\_\+mrp\+\_\+client.\+c}}
\subsubsection[{\texorpdfstring{monitor\+\_\+thread}{monitor_thread}}]{\setlength{\rightskip}{0pt plus 5cm}pthread\+\_\+t monitor\+\_\+thread}\hypertarget{talker__mrp__client_8c_afbd6fc6e0ab3c1a04a518f19c21d4503}{}\label{talker__mrp__client_8c_afbd6fc6e0ab3c1a04a518f19c21d4503}


talker\+\_\+mrp\+\_\+client.\+c 파일의 40 번째 라인에서 정의되었습니다.

\index{talker\+\_\+mrp\+\_\+client.\+c@{talker\+\_\+mrp\+\_\+client.\+c}!mrp\+\_\+error@{mrp\+\_\+error}}
\index{mrp\+\_\+error@{mrp\+\_\+error}!talker\+\_\+mrp\+\_\+client.\+c@{talker\+\_\+mrp\+\_\+client.\+c}}
\subsubsection[{\texorpdfstring{mrp\+\_\+error}{mrp_error}}]{\setlength{\rightskip}{0pt plus 5cm}volatile int mrp\+\_\+error = 0}\hypertarget{talker__mrp__client_8c_a7e0861f30a3dba1eb162e77371fe9c21}{}\label{talker__mrp__client_8c_a7e0861f30a3dba1eb162e77371fe9c21}


talker\+\_\+mrp\+\_\+client.\+c 파일의 40 번째 라인에서 정의되었습니다.

\index{talker\+\_\+mrp\+\_\+client.\+c@{talker\+\_\+mrp\+\_\+client.\+c}!mrp\+\_\+okay@{mrp\+\_\+okay}}
\index{mrp\+\_\+okay@{mrp\+\_\+okay}!talker\+\_\+mrp\+\_\+client.\+c@{talker\+\_\+mrp\+\_\+client.\+c}}
\subsubsection[{\texorpdfstring{mrp\+\_\+okay}{mrp_okay}}]{\setlength{\rightskip}{0pt plus 5cm}volatile int mrp\+\_\+okay}\hypertarget{talker__mrp__client_8c_a5238adacbd2c4d99b6238f3e4ad554ca}{}\label{talker__mrp__client_8c_a5238adacbd2c4d99b6238f3e4ad554ca}


talker\+\_\+mrp\+\_\+client.\+c 파일의 39 번째 라인에서 정의되었습니다.

