\hypertarget{class_allocator_for_memory_leak_detection_test}{}\section{Allocator\+For\+Memory\+Leak\+Detection\+Test 클래스 참조}
\label{class_allocator_for_memory_leak_detection_test}\index{Allocator\+For\+Memory\+Leak\+Detection\+Test@{Allocator\+For\+Memory\+Leak\+Detection\+Test}}


Allocator\+For\+Memory\+Leak\+Detection\+Test에 대한 상속 다이어그램 \+: 
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=282pt]{class_allocator_for_memory_leak_detection_test__inherit__graph}
\end{center}
\end{figure}


Allocator\+For\+Memory\+Leak\+Detection\+Test에 대한 협력 다이어그램\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=282pt]{class_allocator_for_memory_leak_detection_test__coll__graph}
\end{center}
\end{figure}
\subsection*{Public 멤버 함수}
\begin{DoxyCompactItemize}
\item 
\hyperlink{class_allocator_for_memory_leak_detection_test_a16feb3ff47611a2e3548bfc5f75ec165}{Allocator\+For\+Memory\+Leak\+Detection\+Test} ()
\item 
char $\ast$ \hyperlink{class_allocator_for_memory_leak_detection_test_a96f1e3fb5f11e9df843ddfc1cf50bf98}{alloc\+\_\+memory} (size\+\_\+t \hyperlink{gst__avb__playbin_8c_a439227feff9d7f55384e8780cfc2eb82}{size}, const char $\ast$file, int line)
\item 
void \hyperlink{class_allocator_for_memory_leak_detection_test_a529ac9813d3b0836ce0b964449942534}{free\+\_\+memory} (char $\ast$memory, const char $\ast$file, int line)
\item 
char $\ast$ \hyperlink{class_allocator_for_memory_leak_detection_test_aac775b3e19729b16bad56a45ddfcf01c}{alloc\+Memory\+Leak\+Node} (size\+\_\+t \hyperlink{gst__avb__playbin_8c_a439227feff9d7f55384e8780cfc2eb82}{size})
\item 
void \hyperlink{class_allocator_for_memory_leak_detection_test_a10f2958f3b7378256e933896ccc93df0}{free\+Memory\+Leak\+Node} (char $\ast$memory)
\item 
\hyperlink{avb__gptp_8h_af6a258d8f3ee5206d682d799316314b1}{bool} \hyperlink{class_test_memory_allocator_ae26c82159ce24eb59770352585b402fd}{has\+Been\+Destroyed} ()
\item 
virtual const char $\ast$ \hyperlink{class_test_memory_allocator_a6a96605bec5749750a0b4be6e2d6e721}{name} ()
\item 
virtual const char $\ast$ \hyperlink{class_test_memory_allocator_afab6c44b5468c71a699c1efbd787e6e7}{alloc\+\_\+name} ()
\item 
virtual const char $\ast$ \hyperlink{class_test_memory_allocator_aac134aac79b30bc5903d0b2b7cc55b74}{free\+\_\+name} ()
\item 
virtual \hyperlink{avb__gptp_8h_af6a258d8f3ee5206d682d799316314b1}{bool} \hyperlink{class_test_memory_allocator_a3d6a5cc2f6b7a38b3f1d3e0567bf4f93}{is\+Of\+Equal\+Type} (\hyperlink{class_test_memory_allocator}{Test\+Memory\+Allocator} $\ast$\hyperlink{_memory_leak_warning_test_8cpp_a83fc2e9b9142613f7df2bcc3ff8292bc}{allocator})
\end{DoxyCompactItemize}
\subsection*{데이타 필드}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{class_allocator_for_memory_leak_detection_test_a2804c2bae21eb67c6534a07ff8bcb052}{alloc\+\_\+called}
\item 
int \hyperlink{class_allocator_for_memory_leak_detection_test_a52417195228fdceb143ea43d63e0b35c}{free\+\_\+called}
\item 
int \hyperlink{class_allocator_for_memory_leak_detection_test_aaf6f229fa8c54410237c483de6809563}{alloc\+Memory\+Leak\+Node\+Called}
\item 
int \hyperlink{class_allocator_for_memory_leak_detection_test_a26bd6f5a3dada2c70d5baf0efb03a551}{free\+Memory\+Leak\+Node\+Called}
\end{DoxyCompactItemize}
\subsection*{Protected 속성}
\begin{DoxyCompactItemize}
\item 
const char $\ast$ \hyperlink{class_test_memory_allocator_a7dac8366c11fbcad2f49d85fe8fc4fbe}{name\+\_\+}
\item 
const char $\ast$ \hyperlink{class_test_memory_allocator_ae5a98ff3b709da10db95a0ed03362548}{alloc\+\_\+name\+\_\+}
\item 
const char $\ast$ \hyperlink{class_test_memory_allocator_a4f7ece205625129df190e624cccf9286}{free\+\_\+name\+\_\+}
\item 
\hyperlink{avb__gptp_8h_af6a258d8f3ee5206d682d799316314b1}{bool} \hyperlink{class_test_memory_allocator_a971604f223534e64d5024d63396b397a}{has\+Been\+Destroyed\+\_\+}
\end{DoxyCompactItemize}


\subsection{상세한 설명}


Memory\+Leak\+Detector\+Test.\+cpp 파일의 71 번째 라인에서 정의되었습니다.



\subsection{생성자 \& 소멸자 문서화}
\index{Allocator\+For\+Memory\+Leak\+Detection\+Test@{Allocator\+For\+Memory\+Leak\+Detection\+Test}!Allocator\+For\+Memory\+Leak\+Detection\+Test@{Allocator\+For\+Memory\+Leak\+Detection\+Test}}
\index{Allocator\+For\+Memory\+Leak\+Detection\+Test@{Allocator\+For\+Memory\+Leak\+Detection\+Test}!Allocator\+For\+Memory\+Leak\+Detection\+Test@{Allocator\+For\+Memory\+Leak\+Detection\+Test}}
\subsubsection[{\texorpdfstring{Allocator\+For\+Memory\+Leak\+Detection\+Test()}{AllocatorForMemoryLeakDetectionTest()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Allocator\+For\+Memory\+Leak\+Detection\+Test} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{class_allocator_for_memory_leak_detection_test_a16feb3ff47611a2e3548bfc5f75ec165}{}\label{class_allocator_for_memory_leak_detection_test_a16feb3ff47611a2e3548bfc5f75ec165}


Memory\+Leak\+Detector\+Test.\+cpp 파일의 74 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
74                                           :
75         \hyperlink{class_allocator_for_memory_leak_detection_test_a2804c2bae21eb67c6534a07ff8bcb052}{alloc\_called}(0), \hyperlink{class_allocator_for_memory_leak_detection_test_a52417195228fdceb143ea43d63e0b35c}{free\_called}(0), 
      \hyperlink{class_allocator_for_memory_leak_detection_test_aaf6f229fa8c54410237c483de6809563}{allocMemoryLeakNodeCalled}(0), \hyperlink{class_allocator_for_memory_leak_detection_test_a26bd6f5a3dada2c70d5baf0efb03a551}{freeMemoryLeakNodeCalled}(0)
76     \{
77     \}
\end{DoxyCode}


\subsection{멤버 함수 문서화}
\index{Allocator\+For\+Memory\+Leak\+Detection\+Test@{Allocator\+For\+Memory\+Leak\+Detection\+Test}!alloc\+\_\+memory@{alloc\+\_\+memory}}
\index{alloc\+\_\+memory@{alloc\+\_\+memory}!Allocator\+For\+Memory\+Leak\+Detection\+Test@{Allocator\+For\+Memory\+Leak\+Detection\+Test}}
\subsubsection[{\texorpdfstring{alloc\+\_\+memory(size\+\_\+t size, const char $\ast$file, int line)}{alloc_memory(size_t size, const char *file, int line)}}]{\setlength{\rightskip}{0pt plus 5cm}char$\ast$ alloc\+\_\+memory (
\begin{DoxyParamCaption}
\item[{size\+\_\+t}]{size, }
\item[{const char $\ast$}]{file, }
\item[{int}]{line}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{class_allocator_for_memory_leak_detection_test_a96f1e3fb5f11e9df843ddfc1cf50bf98}{}\label{class_allocator_for_memory_leak_detection_test_a96f1e3fb5f11e9df843ddfc1cf50bf98}


\hyperlink{class_test_memory_allocator_a2ebbde51a1d514c74e9e2a09a21b0624}{Test\+Memory\+Allocator}(으)로부터 재구현되었습니다.



Memory\+Leak\+Detector\+Test.\+cpp 파일의 84 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
85     \{
86         \hyperlink{class_allocator_for_memory_leak_detection_test_a2804c2bae21eb67c6534a07ff8bcb052}{alloc\_called}++;
87         \textcolor{keywordflow}{return} \hyperlink{class_test_memory_allocator_a2ebbde51a1d514c74e9e2a09a21b0624}{TestMemoryAllocator::alloc\_memory}(
      \hyperlink{gst__avb__playbin_8c_a439227feff9d7f55384e8780cfc2eb82}{size}, file, line);
88     \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_allocator_for_memory_leak_detection_test_a96f1e3fb5f11e9df843ddfc1cf50bf98_cgraph}
\end{center}
\end{figure}


\index{Allocator\+For\+Memory\+Leak\+Detection\+Test@{Allocator\+For\+Memory\+Leak\+Detection\+Test}!alloc\+\_\+name@{alloc\+\_\+name}}
\index{alloc\+\_\+name@{alloc\+\_\+name}!Allocator\+For\+Memory\+Leak\+Detection\+Test@{Allocator\+For\+Memory\+Leak\+Detection\+Test}}
\subsubsection[{\texorpdfstring{alloc\+\_\+name()}{alloc_name()}}]{\setlength{\rightskip}{0pt plus 5cm}const char $\ast$ alloc\+\_\+name (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [inherited]}}\hypertarget{class_test_memory_allocator_afab6c44b5468c71a699c1efbd787e6e7}{}\label{class_test_memory_allocator_afab6c44b5468c71a699c1efbd787e6e7}


\hyperlink{class_memory_report_allocator_a62de9a48894a6e9b1381a3fbbb8fdca9}{Memory\+Report\+Allocator}에서 재구현되었습니다.



Test\+Memory\+Allocator.\+cpp 파일의 157 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
158 \{
159     \textcolor{keywordflow}{return} \hyperlink{class_test_memory_allocator_ae5a98ff3b709da10db95a0ed03362548}{alloc\_name\_};
160 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_test_memory_allocator_afab6c44b5468c71a699c1efbd787e6e7_icgraph}
\end{center}
\end{figure}


\index{Allocator\+For\+Memory\+Leak\+Detection\+Test@{Allocator\+For\+Memory\+Leak\+Detection\+Test}!alloc\+Memory\+Leak\+Node@{alloc\+Memory\+Leak\+Node}}
\index{alloc\+Memory\+Leak\+Node@{alloc\+Memory\+Leak\+Node}!Allocator\+For\+Memory\+Leak\+Detection\+Test@{Allocator\+For\+Memory\+Leak\+Detection\+Test}}
\subsubsection[{\texorpdfstring{alloc\+Memory\+Leak\+Node(size\+\_\+t size)}{allocMemoryLeakNode(size_t size)}}]{\setlength{\rightskip}{0pt plus 5cm}char$\ast$ alloc\+Memory\+Leak\+Node (
\begin{DoxyParamCaption}
\item[{size\+\_\+t}]{size}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{class_allocator_for_memory_leak_detection_test_aac775b3e19729b16bad56a45ddfcf01c}{}\label{class_allocator_for_memory_leak_detection_test_aac775b3e19729b16bad56a45ddfcf01c}


\hyperlink{class_test_memory_allocator_a1a786ad58b46528e82235a14fa667c1d}{Test\+Memory\+Allocator}(으)로부터 재구현되었습니다.



Memory\+Leak\+Detector\+Test.\+cpp 파일의 95 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
96     \{
97         \hyperlink{class_allocator_for_memory_leak_detection_test_aaf6f229fa8c54410237c483de6809563}{allocMemoryLeakNodeCalled}++;
98         \textcolor{keywordflow}{return} \hyperlink{class_test_memory_allocator_a2ebbde51a1d514c74e9e2a09a21b0624}{TestMemoryAllocator::alloc\_memory}(
      \hyperlink{gst__avb__playbin_8c_a439227feff9d7f55384e8780cfc2eb82}{size}, \_\_FILE\_\_, \_\_LINE\_\_);
99     \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_allocator_for_memory_leak_detection_test_aac775b3e19729b16bad56a45ddfcf01c_cgraph}
\end{center}
\end{figure}


\index{Allocator\+For\+Memory\+Leak\+Detection\+Test@{Allocator\+For\+Memory\+Leak\+Detection\+Test}!free\+\_\+memory@{free\+\_\+memory}}
\index{free\+\_\+memory@{free\+\_\+memory}!Allocator\+For\+Memory\+Leak\+Detection\+Test@{Allocator\+For\+Memory\+Leak\+Detection\+Test}}
\subsubsection[{\texorpdfstring{free\+\_\+memory(char $\ast$memory, const char $\ast$file, int line)}{free_memory(char *memory, const char *file, int line)}}]{\setlength{\rightskip}{0pt plus 5cm}void free\+\_\+memory (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{memory, }
\item[{const char $\ast$}]{file, }
\item[{int}]{line}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{class_allocator_for_memory_leak_detection_test_a529ac9813d3b0836ce0b964449942534}{}\label{class_allocator_for_memory_leak_detection_test_a529ac9813d3b0836ce0b964449942534}


\hyperlink{class_test_memory_allocator_a529ac9813d3b0836ce0b964449942534}{Test\+Memory\+Allocator}(으)로부터 재구현되었습니다.



Memory\+Leak\+Detector\+Test.\+cpp 파일의 89 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
90     \{
91         \hyperlink{class_allocator_for_memory_leak_detection_test_a52417195228fdceb143ea43d63e0b35c}{free\_called}++;
92         \hyperlink{class_test_memory_allocator_a529ac9813d3b0836ce0b964449942534}{TestMemoryAllocator::free\_memory}(memory, file, line);
93     \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=300pt]{class_allocator_for_memory_leak_detection_test_a529ac9813d3b0836ce0b964449942534_cgraph}
\end{center}
\end{figure}


\index{Allocator\+For\+Memory\+Leak\+Detection\+Test@{Allocator\+For\+Memory\+Leak\+Detection\+Test}!free\+\_\+name@{free\+\_\+name}}
\index{free\+\_\+name@{free\+\_\+name}!Allocator\+For\+Memory\+Leak\+Detection\+Test@{Allocator\+For\+Memory\+Leak\+Detection\+Test}}
\subsubsection[{\texorpdfstring{free\+\_\+name()}{free_name()}}]{\setlength{\rightskip}{0pt plus 5cm}const char $\ast$ free\+\_\+name (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [inherited]}}\hypertarget{class_test_memory_allocator_aac134aac79b30bc5903d0b2b7cc55b74}{}\label{class_test_memory_allocator_aac134aac79b30bc5903d0b2b7cc55b74}


\hyperlink{class_memory_report_allocator_ac80755bbbec0c8edcbc9072b3640b68c}{Memory\+Report\+Allocator}에서 재구현되었습니다.



Test\+Memory\+Allocator.\+cpp 파일의 162 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
163 \{
164     \textcolor{keywordflow}{return} \hyperlink{class_test_memory_allocator_a4f7ece205625129df190e624cccf9286}{free\_name\_};
165 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_test_memory_allocator_aac134aac79b30bc5903d0b2b7cc55b74_icgraph}
\end{center}
\end{figure}


\index{Allocator\+For\+Memory\+Leak\+Detection\+Test@{Allocator\+For\+Memory\+Leak\+Detection\+Test}!free\+Memory\+Leak\+Node@{free\+Memory\+Leak\+Node}}
\index{free\+Memory\+Leak\+Node@{free\+Memory\+Leak\+Node}!Allocator\+For\+Memory\+Leak\+Detection\+Test@{Allocator\+For\+Memory\+Leak\+Detection\+Test}}
\subsubsection[{\texorpdfstring{free\+Memory\+Leak\+Node(char $\ast$memory)}{freeMemoryLeakNode(char *memory)}}]{\setlength{\rightskip}{0pt plus 5cm}void free\+Memory\+Leak\+Node (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{memory}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{class_allocator_for_memory_leak_detection_test_a10f2958f3b7378256e933896ccc93df0}{}\label{class_allocator_for_memory_leak_detection_test_a10f2958f3b7378256e933896ccc93df0}


\hyperlink{class_test_memory_allocator_a10f2958f3b7378256e933896ccc93df0}{Test\+Memory\+Allocator}(으)로부터 재구현되었습니다.



Memory\+Leak\+Detector\+Test.\+cpp 파일의 101 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
102     \{
103         \hyperlink{class_allocator_for_memory_leak_detection_test_a26bd6f5a3dada2c70d5baf0efb03a551}{freeMemoryLeakNodeCalled}++;
104         \hyperlink{class_test_memory_allocator_a529ac9813d3b0836ce0b964449942534}{TestMemoryAllocator::free\_memory}(memory, \_\_FILE\_\_, \_\_LINE\_\_);
105     \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=339pt]{class_allocator_for_memory_leak_detection_test_a10f2958f3b7378256e933896ccc93df0_cgraph}
\end{center}
\end{figure}


\index{Allocator\+For\+Memory\+Leak\+Detection\+Test@{Allocator\+For\+Memory\+Leak\+Detection\+Test}!has\+Been\+Destroyed@{has\+Been\+Destroyed}}
\index{has\+Been\+Destroyed@{has\+Been\+Destroyed}!Allocator\+For\+Memory\+Leak\+Detection\+Test@{Allocator\+For\+Memory\+Leak\+Detection\+Test}}
\subsubsection[{\texorpdfstring{has\+Been\+Destroyed()}{hasBeenDestroyed()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf bool} has\+Been\+Destroyed (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inherited]}}\hypertarget{class_test_memory_allocator_ae26c82159ce24eb59770352585b402fd}{}\label{class_test_memory_allocator_ae26c82159ce24eb59770352585b402fd}


Test\+Memory\+Allocator.\+cpp 파일의 123 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
124 \{
125     \textcolor{keywordflow}{return} \hyperlink{class_test_memory_allocator_a971604f223534e64d5024d63396b397a}{hasBeenDestroyed\_};
126 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=326pt]{class_test_memory_allocator_ae26c82159ce24eb59770352585b402fd_icgraph}
\end{center}
\end{figure}


\index{Allocator\+For\+Memory\+Leak\+Detection\+Test@{Allocator\+For\+Memory\+Leak\+Detection\+Test}!is\+Of\+Equal\+Type@{is\+Of\+Equal\+Type}}
\index{is\+Of\+Equal\+Type@{is\+Of\+Equal\+Type}!Allocator\+For\+Memory\+Leak\+Detection\+Test@{Allocator\+For\+Memory\+Leak\+Detection\+Test}}
\subsubsection[{\texorpdfstring{is\+Of\+Equal\+Type(\+Test\+Memory\+Allocator $\ast$allocator)}{isOfEqualType(TestMemoryAllocator *allocator)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf bool} is\+Of\+Equal\+Type (
\begin{DoxyParamCaption}
\item[{{\bf Test\+Memory\+Allocator} $\ast$}]{allocator}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [inherited]}}\hypertarget{class_test_memory_allocator_a3d6a5cc2f6b7a38b3f1d3e0567bf4f93}{}\label{class_test_memory_allocator_a3d6a5cc2f6b7a38b3f1d3e0567bf4f93}


Test\+Memory\+Allocator.\+cpp 파일의 128 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
129 \{
130     \textcolor{keywordflow}{return} \hyperlink{class_simple_string_a0b7a8ae895cbde84a491b42c43de23a6}{SimpleString::StrCmp}(this->\hyperlink{class_test_memory_allocator_a6a96605bec5749750a0b4be6e2d6e721}{name}(), allocator->
      \hyperlink{class_test_memory_allocator_a6a96605bec5749750a0b4be6e2d6e721}{name}()) == 0;
131 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=309pt]{class_test_memory_allocator_a3d6a5cc2f6b7a38b3f1d3e0567bf4f93_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=307pt]{class_test_memory_allocator_a3d6a5cc2f6b7a38b3f1d3e0567bf4f93_icgraph}
\end{center}
\end{figure}


\index{Allocator\+For\+Memory\+Leak\+Detection\+Test@{Allocator\+For\+Memory\+Leak\+Detection\+Test}!name@{name}}
\index{name@{name}!Allocator\+For\+Memory\+Leak\+Detection\+Test@{Allocator\+For\+Memory\+Leak\+Detection\+Test}}
\subsubsection[{\texorpdfstring{name()}{name()}}]{\setlength{\rightskip}{0pt plus 5cm}const char $\ast$ name (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [inherited]}}\hypertarget{class_test_memory_allocator_a6a96605bec5749750a0b4be6e2d6e721}{}\label{class_test_memory_allocator_a6a96605bec5749750a0b4be6e2d6e721}


\hyperlink{class_memory_report_allocator_a90b3e100eca6e28565e6447326b1f7b0}{Memory\+Report\+Allocator}에서 재구현되었습니다.



Test\+Memory\+Allocator.\+cpp 파일의 152 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
153 \{
154     \textcolor{keywordflow}{return} \hyperlink{class_test_memory_allocator_a7dac8366c11fbcad2f49d85fe8fc4fbe}{name\_};
155 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_test_memory_allocator_a6a96605bec5749750a0b4be6e2d6e721_icgraph}
\end{center}
\end{figure}




\subsection{필드 문서화}
\index{Allocator\+For\+Memory\+Leak\+Detection\+Test@{Allocator\+For\+Memory\+Leak\+Detection\+Test}!alloc\+\_\+called@{alloc\+\_\+called}}
\index{alloc\+\_\+called@{alloc\+\_\+called}!Allocator\+For\+Memory\+Leak\+Detection\+Test@{Allocator\+For\+Memory\+Leak\+Detection\+Test}}
\subsubsection[{\texorpdfstring{alloc\+\_\+called}{alloc_called}}]{\setlength{\rightskip}{0pt plus 5cm}int alloc\+\_\+called}\hypertarget{class_allocator_for_memory_leak_detection_test_a2804c2bae21eb67c6534a07ff8bcb052}{}\label{class_allocator_for_memory_leak_detection_test_a2804c2bae21eb67c6534a07ff8bcb052}


Memory\+Leak\+Detector\+Test.\+cpp 파일의 79 번째 라인에서 정의되었습니다.

\index{Allocator\+For\+Memory\+Leak\+Detection\+Test@{Allocator\+For\+Memory\+Leak\+Detection\+Test}!alloc\+\_\+name\+\_\+@{alloc\+\_\+name\+\_\+}}
\index{alloc\+\_\+name\+\_\+@{alloc\+\_\+name\+\_\+}!Allocator\+For\+Memory\+Leak\+Detection\+Test@{Allocator\+For\+Memory\+Leak\+Detection\+Test}}
\subsubsection[{\texorpdfstring{alloc\+\_\+name\+\_\+}{alloc_name_}}]{\setlength{\rightskip}{0pt plus 5cm}const char$\ast$ alloc\+\_\+name\+\_\+\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [inherited]}}\hypertarget{class_test_memory_allocator_ae5a98ff3b709da10db95a0ed03362548}{}\label{class_test_memory_allocator_ae5a98ff3b709da10db95a0ed03362548}


Test\+Memory\+Allocator.\+h 파일의 71 번째 라인에서 정의되었습니다.

\index{Allocator\+For\+Memory\+Leak\+Detection\+Test@{Allocator\+For\+Memory\+Leak\+Detection\+Test}!alloc\+Memory\+Leak\+Node\+Called@{alloc\+Memory\+Leak\+Node\+Called}}
\index{alloc\+Memory\+Leak\+Node\+Called@{alloc\+Memory\+Leak\+Node\+Called}!Allocator\+For\+Memory\+Leak\+Detection\+Test@{Allocator\+For\+Memory\+Leak\+Detection\+Test}}
\subsubsection[{\texorpdfstring{alloc\+Memory\+Leak\+Node\+Called}{allocMemoryLeakNodeCalled}}]{\setlength{\rightskip}{0pt plus 5cm}int alloc\+Memory\+Leak\+Node\+Called}\hypertarget{class_allocator_for_memory_leak_detection_test_aaf6f229fa8c54410237c483de6809563}{}\label{class_allocator_for_memory_leak_detection_test_aaf6f229fa8c54410237c483de6809563}


Memory\+Leak\+Detector\+Test.\+cpp 파일의 81 번째 라인에서 정의되었습니다.

\index{Allocator\+For\+Memory\+Leak\+Detection\+Test@{Allocator\+For\+Memory\+Leak\+Detection\+Test}!free\+\_\+called@{free\+\_\+called}}
\index{free\+\_\+called@{free\+\_\+called}!Allocator\+For\+Memory\+Leak\+Detection\+Test@{Allocator\+For\+Memory\+Leak\+Detection\+Test}}
\subsubsection[{\texorpdfstring{free\+\_\+called}{free_called}}]{\setlength{\rightskip}{0pt plus 5cm}int free\+\_\+called}\hypertarget{class_allocator_for_memory_leak_detection_test_a52417195228fdceb143ea43d63e0b35c}{}\label{class_allocator_for_memory_leak_detection_test_a52417195228fdceb143ea43d63e0b35c}


Memory\+Leak\+Detector\+Test.\+cpp 파일의 80 번째 라인에서 정의되었습니다.

\index{Allocator\+For\+Memory\+Leak\+Detection\+Test@{Allocator\+For\+Memory\+Leak\+Detection\+Test}!free\+\_\+name\+\_\+@{free\+\_\+name\+\_\+}}
\index{free\+\_\+name\+\_\+@{free\+\_\+name\+\_\+}!Allocator\+For\+Memory\+Leak\+Detection\+Test@{Allocator\+For\+Memory\+Leak\+Detection\+Test}}
\subsubsection[{\texorpdfstring{free\+\_\+name\+\_\+}{free_name_}}]{\setlength{\rightskip}{0pt plus 5cm}const char$\ast$ free\+\_\+name\+\_\+\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [inherited]}}\hypertarget{class_test_memory_allocator_a4f7ece205625129df190e624cccf9286}{}\label{class_test_memory_allocator_a4f7ece205625129df190e624cccf9286}


Test\+Memory\+Allocator.\+h 파일의 72 번째 라인에서 정의되었습니다.

\index{Allocator\+For\+Memory\+Leak\+Detection\+Test@{Allocator\+For\+Memory\+Leak\+Detection\+Test}!free\+Memory\+Leak\+Node\+Called@{free\+Memory\+Leak\+Node\+Called}}
\index{free\+Memory\+Leak\+Node\+Called@{free\+Memory\+Leak\+Node\+Called}!Allocator\+For\+Memory\+Leak\+Detection\+Test@{Allocator\+For\+Memory\+Leak\+Detection\+Test}}
\subsubsection[{\texorpdfstring{free\+Memory\+Leak\+Node\+Called}{freeMemoryLeakNodeCalled}}]{\setlength{\rightskip}{0pt plus 5cm}int free\+Memory\+Leak\+Node\+Called}\hypertarget{class_allocator_for_memory_leak_detection_test_a26bd6f5a3dada2c70d5baf0efb03a551}{}\label{class_allocator_for_memory_leak_detection_test_a26bd6f5a3dada2c70d5baf0efb03a551}


Memory\+Leak\+Detector\+Test.\+cpp 파일의 82 번째 라인에서 정의되었습니다.

\index{Allocator\+For\+Memory\+Leak\+Detection\+Test@{Allocator\+For\+Memory\+Leak\+Detection\+Test}!has\+Been\+Destroyed\+\_\+@{has\+Been\+Destroyed\+\_\+}}
\index{has\+Been\+Destroyed\+\_\+@{has\+Been\+Destroyed\+\_\+}!Allocator\+For\+Memory\+Leak\+Detection\+Test@{Allocator\+For\+Memory\+Leak\+Detection\+Test}}
\subsubsection[{\texorpdfstring{has\+Been\+Destroyed\+\_\+}{hasBeenDestroyed_}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf bool} has\+Been\+Destroyed\+\_\+\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [inherited]}}\hypertarget{class_test_memory_allocator_a971604f223534e64d5024d63396b397a}{}\label{class_test_memory_allocator_a971604f223534e64d5024d63396b397a}


Test\+Memory\+Allocator.\+h 파일의 74 번째 라인에서 정의되었습니다.

\index{Allocator\+For\+Memory\+Leak\+Detection\+Test@{Allocator\+For\+Memory\+Leak\+Detection\+Test}!name\+\_\+@{name\+\_\+}}
\index{name\+\_\+@{name\+\_\+}!Allocator\+For\+Memory\+Leak\+Detection\+Test@{Allocator\+For\+Memory\+Leak\+Detection\+Test}}
\subsubsection[{\texorpdfstring{name\+\_\+}{name_}}]{\setlength{\rightskip}{0pt plus 5cm}const char$\ast$ name\+\_\+\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [inherited]}}\hypertarget{class_test_memory_allocator_a7dac8366c11fbcad2f49d85fe8fc4fbe}{}\label{class_test_memory_allocator_a7dac8366c11fbcad2f49d85fe8fc4fbe}


Test\+Memory\+Allocator.\+h 파일의 70 번째 라인에서 정의되었습니다.



이 클래스에 대한 문서화 페이지는 다음의 파일로부터 생성되었습니다.\+:\begin{DoxyCompactItemize}
\item 
thirdparty/cpputest/tests/\+Cpp\+U\+Test/\hyperlink{_memory_leak_detector_test_8cpp}{Memory\+Leak\+Detector\+Test.\+cpp}\end{DoxyCompactItemize}
