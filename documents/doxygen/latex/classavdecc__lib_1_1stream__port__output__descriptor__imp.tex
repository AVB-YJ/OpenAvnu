\hypertarget{classavdecc__lib_1_1stream__port__output__descriptor__imp}{}\section{stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp 클래스 참조}
\label{classavdecc__lib_1_1stream__port__output__descriptor__imp}\index{stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}


{\ttfamily \#include $<$stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp.\+h$>$}



stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp에 대한 상속 다이어그램 \+: 
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=550pt]{classavdecc__lib_1_1stream__port__output__descriptor__imp__inherit__graph}
\end{center}
\end{figure}


stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp에 대한 협력 다이어그램\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=550pt]{classavdecc__lib_1_1stream__port__output__descriptor__imp__coll__graph}
\end{center}
\end{figure}
\subsection*{Public 멤버 함수}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classavdecc__lib_1_1stream__port__output__descriptor__imp_a8fcc8b712d5e00f0a6fa5c66e476a454}{stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp} (\hyperlink{classavdecc__lib_1_1end__station__imp}{end\+\_\+station\+\_\+imp} $\ast$end\+\_\+station\+\_\+obj, const \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} $\ast$\hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, ssize\+\_\+t pos, size\+\_\+t frame\+\_\+len)
\item 
virtual \hyperlink{classavdecc__lib_1_1stream__port__output__descriptor__imp_a799548e5c924788c77f50d57c1f435e4}{$\sim$stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp} ()
\item 
\hyperlink{classavdecc__lib_1_1stream__port__output__descriptor__response}{stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+response} $\ast$S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1stream__port__output__descriptor__imp_ab6e468656996173ebca7287e32c06b97}{get\+\_\+stream\+\_\+port\+\_\+output\+\_\+response} ()
\item 
\hyperlink{classavdecc__lib_1_1stream__port__output__get__audio__map__response}{stream\+\_\+port\+\_\+output\+\_\+get\+\_\+audio\+\_\+map\+\_\+response} $\ast$S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1stream__port__output__descriptor__imp_a33e90ae5702c39b7a852cc347006ddb4}{get\+\_\+stream\+\_\+port\+\_\+output\+\_\+audio\+\_\+map\+\_\+response} ()
\item 
int S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1stream__port__output__descriptor__imp_a23b5816691c09ead5cc4a90a72222c9f}{send\+\_\+get\+\_\+audio\+\_\+map\+\_\+cmd} (void $\ast$notification\+\_\+id, uint16\+\_\+t mapping\+\_\+index)
\item 
int \hyperlink{classavdecc__lib_1_1stream__port__output__descriptor__imp_aadd7ab4cda0474cfe2444de48e5823fd}{proc\+\_\+get\+\_\+audio\+\_\+map\+\_\+resp} (void $\ast$\&notification\+\_\+id, const \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} $\ast$\hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, size\+\_\+t frame\+\_\+len, int \&status)
\item 
int S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1stream__port__output__descriptor__imp_a607418ce38a1e4cbb44bd670eb0f398b}{send\+\_\+add\+\_\+audio\+\_\+mappings\+\_\+cmd} (void $\ast$notification\+\_\+id)
\item 
int \hyperlink{classavdecc__lib_1_1stream__port__output__descriptor__imp_a70814551b88eadc6577730d6bc680723}{proc\+\_\+add\+\_\+audio\+\_\+mappings\+\_\+resp} (void $\ast$\&notification\+\_\+id, const \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} $\ast$\hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, size\+\_\+t frame\+\_\+len, int \&status)
\item 
int S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1stream__port__output__descriptor__imp_af6ad50a43367920f62229d2a1f942856}{send\+\_\+remove\+\_\+audio\+\_\+mappings\+\_\+cmd} (void $\ast$notification\+\_\+id)
\item 
int \hyperlink{classavdecc__lib_1_1stream__port__output__descriptor__imp_acb59e12bd075d86e8d9af20713a6e1fb}{proc\+\_\+remove\+\_\+audio\+\_\+mappings\+\_\+resp} (void $\ast$\&notification\+\_\+id, const \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} $\ast$\hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, size\+\_\+t frame\+\_\+len, int \&status)
\item 
int \hyperlink{classavdecc__lib_1_1stream__port__output__descriptor__imp_a8ca55047d151e78b3804fcdbf04282e8}{store\+\_\+pending\+\_\+map} (struct \hyperlink{structavdecc__lib_1_1audio__map__mapping}{audio\+\_\+map\+\_\+mapping} \&map)
\item 
size\+\_\+t \hyperlink{classavdecc__lib_1_1stream__port__output__descriptor__imp_a0cce5060371c58d067bbbdb7ebb2f883}{get\+\_\+number\+\_\+of\+\_\+pending\+\_\+maps} ()
\item 
int \hyperlink{classavdecc__lib_1_1stream__port__output__descriptor__imp_a785e11f2e5498626800112562d8a3cc5}{get\+\_\+pending\+\_\+maps} (size\+\_\+t index, struct \hyperlink{structavdecc__lib_1_1audio__map__mapping}{audio\+\_\+map\+\_\+mapping} \&map)
\item 
int \hyperlink{classavdecc__lib_1_1stream__port__output__descriptor__imp_a9ef8ad04a4da48c13c1d2275721bb440}{clear\+\_\+pending\+\_\+maps} ()
\item 
virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI uint16\+\_\+t S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base_a5112b70022171063ec5d3242bee9910e}{descriptor\+\_\+type} () const =0
\item 
virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI uint16\+\_\+t S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base_a7eed5583bffdf72d89021b188648c1b5}{descriptor\+\_\+index} () const =0
\item 
virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI size\+\_\+t S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base_ab1edf4996377ed957088a7b3b16aca7d}{field\+\_\+count} () const =0
\item 
virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI \hyperlink{classavdecc__lib_1_1descriptor__field}{descriptor\+\_\+field} $\ast$S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base_aa3716832eed0b6f6dcfba358c5d2c601}{field} (size\+\_\+t index) const =0
\item 
virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI uint16\+\_\+t S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base_a1fb9de45567df344090a1407aa6b775f}{localized\+\_\+description} ()=0
\item 
virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI \hyperlink{parse_8c_a6eb1e68cc391dd753bc8ce896dbb8315}{uint32\+\_\+t} S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base_a42f2a796375edd05c8d29856c018042d}{acquire\+\_\+entity\+\_\+flags} ()=0
\item 
virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI \hyperlink{parse_8c_aec6fcb673ff035718c238c8c9d544c47}{uint64\+\_\+t} S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base_a6480d803970d505ce7a9b429a6eb71bd}{acquire\+\_\+entity\+\_\+owner\+\_\+entity\+\_\+id} ()=0
\item 
virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI \hyperlink{parse_8c_a6eb1e68cc391dd753bc8ce896dbb8315}{uint32\+\_\+t} S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base_a757e66272bba4c52cefa914df8c60bb5}{lock\+\_\+entity\+\_\+flags} ()=0
\item 
virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI \hyperlink{parse_8c_aec6fcb673ff035718c238c8c9d544c47}{uint64\+\_\+t} S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base_a052b47529d0e60ca87894159fcb65e14}{lock\+\_\+entity\+\_\+locked\+\_\+entity\+\_\+id} ()=0
\item 
virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI int S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base_adfd0cf2a51bff7d762b0efc743480c48}{send\+\_\+acquire\+\_\+entity\+\_\+cmd} (void $\ast$notification\+\_\+id, \hyperlink{parse_8c_a6eb1e68cc391dd753bc8ce896dbb8315}{uint32\+\_\+t} acquire\+\_\+entity\+\_\+flag)=0
\item 
virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI int S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base_a1ac1f5c700f4eebd37b7c45498b36bbc}{send\+\_\+lock\+\_\+entity\+\_\+cmd} (void $\ast$notification\+\_\+id, \hyperlink{parse_8c_a6eb1e68cc391dd753bc8ce896dbb8315}{uint32\+\_\+t} lock\+\_\+entity\+\_\+flag)=0
\item 
virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI int S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base_a1618412a9b3d57a12044030b31cfd5a3}{send\+\_\+reboot\+\_\+cmd} (void $\ast$notification\+\_\+id)=0
\item 
virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI int S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base_a6a8c227d7a202f251c689107df7ede0b}{send\+\_\+set\+\_\+name\+\_\+cmd} (void $\ast$notification\+\_\+id, uint16\+\_\+t name\+\_\+index, uint16\+\_\+t config\+\_\+index, const struct \hyperlink{structavdecc__lib_1_1avdecc__lib__name__string64}{avdecc\+\_\+lib\+\_\+name\+\_\+string64} $\ast$new\+\_\+name)=0
\item 
virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI int S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base_a27ba9959456de53a8de18eead74806f7}{send\+\_\+get\+\_\+name\+\_\+cmd} (void $\ast$notification\+\_\+id, uint16\+\_\+t name\+\_\+index, uint16\+\_\+t config\+\_\+index)=0
\item 
virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI \hyperlink{classavdecc__lib_1_1descriptor__response__base}{descriptor\+\_\+response\+\_\+base} $\ast$S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base_ac64e6a5ee8781eeb9c781953e845b1be}{get\+\_\+descriptor\+\_\+response} ()=0
\item 
virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI \hyperlink{classavdecc__lib_1_1descriptor__base__get__name__response}{descriptor\+\_\+base\+\_\+get\+\_\+name\+\_\+response} $\ast$S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base_aba4bf8a81f90f5bf00d5c8b5a7330145}{get\+\_\+name\+\_\+response} ()=0
\item 
uint16\+\_\+t S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base__imp_aefc543029ab093823c3f5b9d84f0ccc4}{descriptor\+\_\+type} () const 
\item 
uint16\+\_\+t S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base__imp_ac23c0a35276c07cfce8c8660700c2135}{descriptor\+\_\+index} () const 
\item 
virtual uint16\+\_\+t S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base__imp_aa94307532fbb37e2f986fee8fec79373}{localized\+\_\+description} ()
\item 
size\+\_\+t S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a9b98d4f427a6c527e9080c938cfa9334}{field\+\_\+count} () const 
\item 
\hyperlink{classavdecc__lib_1_1descriptor__field}{descriptor\+\_\+field} $\ast$S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a5f8127d32e2aa54777ca03bf09e8d7b5}{field} (size\+\_\+t index) const 
\item 
virtual void S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a482fe95208e9e14885e28e73e7be2c49}{replace\+\_\+frame} (const \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} $\ast$\hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, ssize\+\_\+t pos, size\+\_\+t \hyperlink{gst__avb__playbin_8c_a439227feff9d7f55384e8780cfc2eb82}{size})
\item 
virtual void S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a8dbf7d4faedf36ec789d33f228e22039}{replace\+\_\+desc\+\_\+frame} (const \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} $\ast$\hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, ssize\+\_\+t pos, size\+\_\+t \hyperlink{gst__avb__playbin_8c_a439227feff9d7f55384e8780cfc2eb82}{size})
\item 
virtual \hyperlink{parse_8c_a6eb1e68cc391dd753bc8ce896dbb8315}{uint32\+\_\+t} S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2d270d205bcea948cf61311a1f8336c6}{acquire\+\_\+entity\+\_\+flags} ()
\item 
virtual \hyperlink{parse_8c_aec6fcb673ff035718c238c8c9d544c47}{uint64\+\_\+t} S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a507b250a984bb5611d2699cd26d60a51}{acquire\+\_\+entity\+\_\+owner\+\_\+entity\+\_\+id} ()
\item 
virtual \hyperlink{parse_8c_a6eb1e68cc391dd753bc8ce896dbb8315}{uint32\+\_\+t} S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base__imp_afe2564a2a32f83deced28efa17f332e2}{lock\+\_\+entity\+\_\+flags} ()
\item 
virtual \hyperlink{parse_8c_aec6fcb673ff035718c238c8c9d544c47}{uint64\+\_\+t} S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base__imp_aeb8f096d55f82522516cbf00a616246a}{lock\+\_\+entity\+\_\+locked\+\_\+entity\+\_\+id} ()
\item 
virtual int S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base__imp_aea9e3053b75477816c15487d3e9a6f70}{send\+\_\+acquire\+\_\+entity\+\_\+cmd} (void $\ast$notification\+\_\+id, \hyperlink{parse_8c_a6eb1e68cc391dd753bc8ce896dbb8315}{uint32\+\_\+t} acquire\+\_\+entity\+\_\+flag)
\item 
virtual int \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a934de13d0b017574d514ce276180a004}{proc\+\_\+acquire\+\_\+entity\+\_\+resp} (void $\ast$\&notification\+\_\+id, const \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} $\ast$\hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, size\+\_\+t frame\+\_\+len, int \&status)
\item 
int \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a4ee5f42b89a728627bf1340afebc7c82}{default\+\_\+send\+\_\+acquire\+\_\+entity\+\_\+cmd} (\hyperlink{classavdecc__lib_1_1descriptor__base__imp}{descriptor\+\_\+base\+\_\+imp} $\ast$desc\+\_\+base\+\_\+imp\+\_\+ref, void $\ast$notification\+\_\+id, \hyperlink{parse_8c_a6eb1e68cc391dd753bc8ce896dbb8315}{uint32\+\_\+t} acquire\+\_\+entity\+\_\+flag)
\item 
int \hyperlink{classavdecc__lib_1_1descriptor__base__imp_ad248d7d7060e28eb36c8dc37d2653c43}{default\+\_\+proc\+\_\+acquire\+\_\+entity\+\_\+resp} (struct \hyperlink{structjdksavdecc__aem__command__acquire__entity__response}{jdksavdecc\+\_\+aem\+\_\+command\+\_\+acquire\+\_\+entity\+\_\+response} \&aem\+\_\+cmd\+\_\+acquire\+\_\+entity\+\_\+resp, void $\ast$\&notification\+\_\+id, const \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} $\ast$\hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, size\+\_\+t frame\+\_\+len, int \&status)
\item 
virtual int S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a26fd66d8c409502eaa4dba47742ca7fa}{send\+\_\+lock\+\_\+entity\+\_\+cmd} (void $\ast$notification\+\_\+id, \hyperlink{parse_8c_a6eb1e68cc391dd753bc8ce896dbb8315}{uint32\+\_\+t} lock\+\_\+entity\+\_\+flag)
\item 
virtual int \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a6cd2b73ea95b18f07dbdc251140679b0}{proc\+\_\+lock\+\_\+entity\+\_\+resp} (void $\ast$\&notification\+\_\+id, const \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} $\ast$\hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, size\+\_\+t frame\+\_\+len, int \&status)
\item 
int \hyperlink{classavdecc__lib_1_1descriptor__base__imp_af40ac09b84feb7551bf0389a2a5db4ca}{default\+\_\+send\+\_\+lock\+\_\+entity\+\_\+cmd} (\hyperlink{classavdecc__lib_1_1descriptor__base__imp}{descriptor\+\_\+base\+\_\+imp} $\ast$descriptor\+\_\+base\+\_\+imp\+\_\+ref, void $\ast$notification\+\_\+id, \hyperlink{parse_8c_a6eb1e68cc391dd753bc8ce896dbb8315}{uint32\+\_\+t} lock\+\_\+entity\+\_\+flag)
\item 
int \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a3b3582020613e7f60efe96567679be7f}{default\+\_\+proc\+\_\+lock\+\_\+entity\+\_\+resp} (struct \hyperlink{structjdksavdecc__aem__command__lock__entity__response}{jdksavdecc\+\_\+aem\+\_\+command\+\_\+lock\+\_\+entity\+\_\+response} \&aem\+\_\+cmd\+\_\+lock\+\_\+entity\+\_\+resp, void $\ast$\&notification\+\_\+id, const \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} $\ast$\hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, size\+\_\+t frame\+\_\+len, int \&status)
\item 
virtual int S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a7579db44e8e86da0f8f94aa4680df795}{send\+\_\+reboot\+\_\+cmd} (void $\ast$notification\+\_\+id)
\item 
virtual int \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a8b3de398748e8299daf7296964f73c22}{proc\+\_\+reboot\+\_\+resp} (void $\ast$\&notification\+\_\+id, const \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} $\ast$\hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, size\+\_\+t frame\+\_\+len, int \&status)
\item 
int \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a14e3bd11c70e839a0594dc59dffcbf16}{default\+\_\+send\+\_\+reboot\+\_\+cmd} (\hyperlink{classavdecc__lib_1_1descriptor__base__imp}{descriptor\+\_\+base\+\_\+imp} $\ast$descriptor\+\_\+base\+\_\+imp\+\_\+ref, void $\ast$notification\+\_\+id)
\item 
int \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a774dc940e9918a60127b0b021582b32a}{default\+\_\+proc\+\_\+reboot\+\_\+resp} (struct \hyperlink{structjdksavdecc__aem__command__reboot__response}{jdksavdecc\+\_\+aem\+\_\+command\+\_\+reboot\+\_\+response} \&aem\+\_\+cmd\+\_\+reboot\+\_\+resp, void $\ast$\&notification\+\_\+id, const \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} $\ast$\hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, size\+\_\+t frame\+\_\+len, int \&status)
\item 
virtual int S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base__imp_af0bb05af3bf67f2ab0eb522096011592}{send\+\_\+set\+\_\+name\+\_\+cmd} (void $\ast$notification\+\_\+id, uint16\+\_\+t name\+\_\+index, uint16\+\_\+t config\+\_\+index, const struct \hyperlink{structavdecc__lib_1_1avdecc__lib__name__string64}{avdecc\+\_\+lib\+\_\+name\+\_\+string64} $\ast$new\+\_\+name)
\item 
virtual int \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a182c43d9f31980bb74f05956b1323624}{proc\+\_\+set\+\_\+name\+\_\+resp} (void $\ast$\&notification\+\_\+id, const \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} $\ast$\hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, size\+\_\+t frame\+\_\+len, int \&status)
\item 
int \hyperlink{classavdecc__lib_1_1descriptor__base__imp_aed899a0eaaaa06a02569135f844ffce8}{default\+\_\+send\+\_\+set\+\_\+name\+\_\+cmd} (\hyperlink{classavdecc__lib_1_1descriptor__base__imp}{descriptor\+\_\+base\+\_\+imp} $\ast$desc\+\_\+base\+\_\+imp\+\_\+ref, void $\ast$notification\+\_\+id, uint16\+\_\+t name\+\_\+index, uint16\+\_\+t config\+\_\+index, const struct \hyperlink{structavdecc__lib_1_1avdecc__lib__name__string64}{avdecc\+\_\+lib\+\_\+name\+\_\+string64} $\ast$name)
\item 
int \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2f52c3b9a7ad6f490bed0c96a9136bc3}{default\+\_\+proc\+\_\+set\+\_\+name\+\_\+resp} (struct \hyperlink{structjdksavdecc__aem__command__set__name__response}{jdksavdecc\+\_\+aem\+\_\+command\+\_\+set\+\_\+name\+\_\+response} \&aem\+\_\+cmd\+\_\+set\+\_\+name\+\_\+resp, void $\ast$\&notification\+\_\+id, const \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} $\ast$\hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, size\+\_\+t frame\+\_\+len, int \&status)
\item 
virtual int S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a4e8ce103baabbd5fc07deabfb95f791a}{send\+\_\+get\+\_\+name\+\_\+cmd} (void $\ast$notification\+\_\+id, uint16\+\_\+t name\+\_\+index, uint16\+\_\+t config\+\_\+index)
\item 
virtual int \hyperlink{classavdecc__lib_1_1descriptor__base__imp_ac4e290a88039a8e4915f7b9f8738881f}{proc\+\_\+get\+\_\+name\+\_\+resp} (void $\ast$\&notification\+\_\+id, const \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} $\ast$\hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, size\+\_\+t frame\+\_\+len, int \&status)
\item 
int \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a92f2c88d261418872a496a8145800751}{default\+\_\+send\+\_\+get\+\_\+name\+\_\+cmd} (\hyperlink{classavdecc__lib_1_1descriptor__base__imp}{descriptor\+\_\+base\+\_\+imp} $\ast$desc\+\_\+base\+\_\+imp\+\_\+ref, void $\ast$notification\+\_\+id, uint16\+\_\+t name\+\_\+index, uint16\+\_\+t config\+\_\+index)
\item 
int \hyperlink{classavdecc__lib_1_1descriptor__base__imp_acc8b1c1591bd54bc9a2d21d4f0db2e86}{default\+\_\+proc\+\_\+get\+\_\+name\+\_\+resp} (struct \hyperlink{structjdksavdecc__aem__command__get__name__response}{jdksavdecc\+\_\+aem\+\_\+command\+\_\+get\+\_\+name\+\_\+response} \&aem\+\_\+cmd\+\_\+get\+\_\+name\+\_\+resp, void $\ast$\&notification\+\_\+id, const \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} $\ast$\hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, size\+\_\+t frame\+\_\+len, int \&status)
\item 
\hyperlink{classavdecc__lib_1_1descriptor__response__base}{descriptor\+\_\+response\+\_\+base} $\ast$S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a8c64c9df60afbc144cf24eab5a42c009}{get\+\_\+descriptor\+\_\+response} ()
\item 
\hyperlink{classavdecc__lib_1_1descriptor__base__get__name__response}{descriptor\+\_\+base\+\_\+get\+\_\+name\+\_\+response} $\ast$S\+T\+D\+C\+A\+LL \hyperlink{classavdecc__lib_1_1descriptor__base__imp_abf130a286ee3ca9d1f41a7e2abbd0d33}{get\+\_\+name\+\_\+response} ()
\end{DoxyCompactItemize}
\subsection*{데이타 필드}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classavdecc__lib_1_1stream__port__output__descriptor__response__imp}{stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+response\+\_\+imp} $\ast$ \hyperlink{classavdecc__lib_1_1stream__port__output__descriptor__imp_a241ec2f535a1c6918e5a63c40f6a974b}{resp}
\item 
\hyperlink{classavdecc__lib_1_1stream__port__output__get__audio__map__response__imp}{stream\+\_\+port\+\_\+output\+\_\+get\+\_\+audio\+\_\+map\+\_\+response\+\_\+imp} $\ast$ \hyperlink{classavdecc__lib_1_1stream__port__output__descriptor__imp_a662a30a6f5184ddb2be3bd056cd0fecb}{audio\+\_\+map\+\_\+resp}
\end{DoxyCompactItemize}
\subsection*{Protected 속성}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classavdecc__lib_1_1descriptor__response__base__imp}{descriptor\+\_\+response\+\_\+base\+\_\+imp} $\ast$ \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a8b104da8319cda946944548ebb9552f4}{resp\+\_\+base}
\item 
\hyperlink{classavdecc__lib_1_1descriptor__base__get__name__response__imp}{descriptor\+\_\+base\+\_\+get\+\_\+name\+\_\+response\+\_\+imp} $\ast$ \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a7d3a410eb242dc2b7abe9862a1593458}{get\+\_\+name\+\_\+resp}
\item 
\hyperlink{classavdecc__lib_1_1end__station__imp}{end\+\_\+station\+\_\+imp} $\ast$ \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\+\_\+end\+\_\+station\+\_\+imp\+\_\+ref}
\item 
std\+::vector$<$ \hyperlink{classavdecc__lib_1_1descriptor__field__imp}{descriptor\+\_\+field\+\_\+imp} $\ast$ $>$ \hyperlink{classavdecc__lib_1_1descriptor__base__imp_adce67136eb9c66da9c189b730077b9cd}{m\+\_\+fields}
\item 
\hyperlink{classavdecc__lib_1_1response__frame}{response\+\_\+frame} $\ast$ \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2642e3a7c10d38553e7ff4a55e875346}{resp\+\_\+ref}
\item 
uint16\+\_\+t \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a9dada313309522d04f1e52fe887442b4}{desc\+\_\+type}
\item 
uint16\+\_\+t \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2bbd0d8f32f687ca36aaa543c06f764c}{desc\+\_\+index}
\end{DoxyCompactItemize}
\subsection*{Private 속성}
\begin{DoxyCompactItemize}
\item 
std\+::vector$<$ struct \hyperlink{structavdecc__lib_1_1audio__map__mapping}{audio\+\_\+map\+\_\+mapping} $>$ \hyperlink{classavdecc__lib_1_1stream__port__output__descriptor__imp_ae0c1781344cc1ecdf12d9624ae930ccd}{pending\+\_\+maps}
\end{DoxyCompactItemize}


\subsection{상세한 설명}


stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp.\+h 파일의 40 번째 라인에서 정의되었습니다.



\subsection{생성자 \& 소멸자 문서화}
\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\index{stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp(end\+\_\+station\+\_\+imp $\ast$end\+\_\+station\+\_\+obj, const uint8\+\_\+t $\ast$frame, ssize\+\_\+t pos, size\+\_\+t frame\+\_\+len)}{stream_port_output_descriptor_imp(end_station_imp *end_station_obj, const uint8_t *frame, ssize_t pos, size_t frame_len)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp} (
\begin{DoxyParamCaption}
\item[{{\bf end\+\_\+station\+\_\+imp} $\ast$}]{end\+\_\+station\+\_\+obj, }
\item[{const {\bf uint8\+\_\+t} $\ast$}]{frame, }
\item[{ssize\+\_\+t}]{pos, }
\item[{size\+\_\+t}]{frame\+\_\+len}
\end{DoxyParamCaption}
)}\hypertarget{classavdecc__lib_1_1stream__port__output__descriptor__imp_a8fcc8b712d5e00f0a6fa5c66e476a454}{}\label{classavdecc__lib_1_1stream__port__output__descriptor__imp_a8fcc8b712d5e00f0a6fa5c66e476a454}


stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp.\+cpp 파일의 41 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
41 : \hyperlink{classavdecc__lib_1_1descriptor__base__imp_afce4f89b7126c42e77054b5c76e21fc6}{descriptor\_base\_imp}(end\_station\_obj, \hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, frame\_len, pos) \{\}
\end{DoxyCode}
\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!````~stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{$\sim$stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\index{````~stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{$\sim$stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{$\sim$stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp()}{~stream_port_output_descriptor_imp()}}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classavdecc__lib_1_1stream__port__output__descriptor__imp_a799548e5c924788c77f50d57c1f435e4}{}\label{classavdecc__lib_1_1stream__port__output__descriptor__imp_a799548e5c924788c77f50d57c1f435e4}


stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp.\+cpp 파일의 43 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
43 \{\}
\end{DoxyCode}


\subsection{멤버 함수 문서화}
\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!acquire\+\_\+entity\+\_\+flags@{acquire\+\_\+entity\+\_\+flags}}
\index{acquire\+\_\+entity\+\_\+flags@{acquire\+\_\+entity\+\_\+flags}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{acquire\+\_\+entity\+\_\+flags()=0}{acquire_entity_flags()=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI {\bf uint32\+\_\+t} S\+T\+D\+C\+A\+LL acquire\+\_\+entity\+\_\+flags (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base_a42f2a796375edd05c8d29856c018042d}{}\label{classavdecc__lib_1_1descriptor__base_a42f2a796375edd05c8d29856c018042d}
\begin{DoxyReturn}{반환값}
The flags after sending a A\+C\+Q\+U\+I\+R\+E\+\_\+\+E\+N\+T\+I\+TY command and receiving a response back for the command. 
\end{DoxyReturn}


\hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2d270d205bcea948cf61311a1f8336c6}{descriptor\+\_\+base\+\_\+imp}, \hyperlink{classavdecc__lib_1_1entity__descriptor__imp_a2d270d205bcea948cf61311a1f8336c6}{entity\+\_\+descriptor\+\_\+imp}에서 구현되었습니다.



이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=312pt]{classavdecc__lib_1_1descriptor__base_a42f2a796375edd05c8d29856c018042d_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!acquire\+\_\+entity\+\_\+flags@{acquire\+\_\+entity\+\_\+flags}}
\index{acquire\+\_\+entity\+\_\+flags@{acquire\+\_\+entity\+\_\+flags}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{acquire\+\_\+entity\+\_\+flags()}{acquire_entity_flags()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\+\_\+t} S\+T\+D\+C\+A\+LL acquire\+\_\+entity\+\_\+flags (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_a2d270d205bcea948cf61311a1f8336c6}{}\label{classavdecc__lib_1_1descriptor__base__imp_a2d270d205bcea948cf61311a1f8336c6}
Get the flags after sending a A\+C\+Q\+U\+I\+R\+E\+\_\+\+E\+N\+T\+I\+TY command and receiving a response back for the command. 

\hyperlink{classavdecc__lib_1_1descriptor__base_a42f2a796375edd05c8d29856c018042d}{descriptor\+\_\+base}를 구현.



\hyperlink{classavdecc__lib_1_1entity__descriptor__imp_a2d270d205bcea948cf61311a1f8336c6}{entity\+\_\+descriptor\+\_\+imp}에서 재구현되었습니다.



descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 114 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
115 \{
116     \textcolor{keywordflow}{return} 0;
117 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=255pt]{classavdecc__lib_1_1descriptor__base__imp_a2d270d205bcea948cf61311a1f8336c6_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!acquire\+\_\+entity\+\_\+owner\+\_\+entity\+\_\+id@{acquire\+\_\+entity\+\_\+owner\+\_\+entity\+\_\+id}}
\index{acquire\+\_\+entity\+\_\+owner\+\_\+entity\+\_\+id@{acquire\+\_\+entity\+\_\+owner\+\_\+entity\+\_\+id}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{acquire\+\_\+entity\+\_\+owner\+\_\+entity\+\_\+id()=0}{acquire_entity_owner_entity_id()=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI {\bf uint64\+\_\+t} S\+T\+D\+C\+A\+LL acquire\+\_\+entity\+\_\+owner\+\_\+entity\+\_\+id (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base_a6480d803970d505ce7a9b429a6eb71bd}{}\label{classavdecc__lib_1_1descriptor__base_a6480d803970d505ce7a9b429a6eb71bd}
\begin{DoxyReturn}{반환값}
The owner id after sending a A\+C\+Q\+U\+I\+R\+E\+\_\+\+E\+N\+T\+I\+TY command and receiving a response back for the command. 
\end{DoxyReturn}


\hyperlink{classavdecc__lib_1_1descriptor__base__imp_a507b250a984bb5611d2699cd26d60a51}{descriptor\+\_\+base\+\_\+imp}, \hyperlink{classavdecc__lib_1_1entity__descriptor__imp_a507b250a984bb5611d2699cd26d60a51}{entity\+\_\+descriptor\+\_\+imp}에서 구현되었습니다.



이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=317pt]{classavdecc__lib_1_1descriptor__base_a6480d803970d505ce7a9b429a6eb71bd_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!acquire\+\_\+entity\+\_\+owner\+\_\+entity\+\_\+id@{acquire\+\_\+entity\+\_\+owner\+\_\+entity\+\_\+id}}
\index{acquire\+\_\+entity\+\_\+owner\+\_\+entity\+\_\+id@{acquire\+\_\+entity\+\_\+owner\+\_\+entity\+\_\+id}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{acquire\+\_\+entity\+\_\+owner\+\_\+entity\+\_\+id()}{acquire_entity_owner_entity_id()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint64\+\_\+t} S\+T\+D\+C\+A\+LL acquire\+\_\+entity\+\_\+owner\+\_\+entity\+\_\+id (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_a507b250a984bb5611d2699cd26d60a51}{}\label{classavdecc__lib_1_1descriptor__base__imp_a507b250a984bb5611d2699cd26d60a51}
Get the owner id after sending a A\+C\+Q\+U\+I\+R\+E\+\_\+\+E\+N\+T\+I\+TY command and receiving a response back for the command. 

\hyperlink{classavdecc__lib_1_1descriptor__base_a6480d803970d505ce7a9b429a6eb71bd}{descriptor\+\_\+base}를 구현.



\hyperlink{classavdecc__lib_1_1entity__descriptor__imp_a507b250a984bb5611d2699cd26d60a51}{entity\+\_\+descriptor\+\_\+imp}에서 재구현되었습니다.



descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 119 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
120 \{
121     \textcolor{keywordflow}{return} 0;
122 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=260pt]{classavdecc__lib_1_1descriptor__base__imp_a507b250a984bb5611d2699cd26d60a51_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!clear\+\_\+pending\+\_\+maps@{clear\+\_\+pending\+\_\+maps}}
\index{clear\+\_\+pending\+\_\+maps@{clear\+\_\+pending\+\_\+maps}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{clear\+\_\+pending\+\_\+maps()}{clear_pending_maps()}}]{\setlength{\rightskip}{0pt plus 5cm}int clear\+\_\+pending\+\_\+maps (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classavdecc__lib_1_1stream__port__output__descriptor__imp_a9ef8ad04a4da48c13c1d2275721bb440}{}\label{classavdecc__lib_1_1stream__port__output__descriptor__imp_a9ef8ad04a4da48c13c1d2275721bb440}
Clear pending audio mappings. 

\hyperlink{classavdecc__lib_1_1stream__port__output__descriptor_ad7e55593254a186706fcd8d861ccdef8}{stream\+\_\+port\+\_\+output\+\_\+descriptor}를 구현.



stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp.\+cpp 파일의 80 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
81 \{
82     \textcolor{keywordflow}{if} (\hyperlink{classavdecc__lib_1_1stream__port__output__descriptor__imp_ae0c1781344cc1ecdf12d9624ae930ccd}{pending\_maps}.size() == 0)
83     \{
84         \hyperlink{namespaceavdecc__lib_acbe3e2a96ae6524943ca532c87a28529}{log\_imp\_ref}->\hyperlink{classavdecc__lib_1_1log_a68139a6297697e4ccebf36ccfd02e44a}{post\_log\_msg}(\hyperlink{namespaceavdecc__lib_a501055c431e6872ef46f252ad13f85cdaf2c4481208273451a6f5c7bb9770ec8a}{LOGGING\_LEVEL\_ERROR}, \textcolor{stringliteral}{"No
       pending audio mappings.\(\backslash\)n"});
85     \}
86     \textcolor{keywordflow}{else}
87     \{
88         \hyperlink{classavdecc__lib_1_1stream__port__output__descriptor__imp_ae0c1781344cc1ecdf12d9624ae930ccd}{pending\_maps}.clear();
89     \}
90     \textcolor{keywordflow}{return} 0;
91 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1stream__port__output__descriptor__imp_a9ef8ad04a4da48c13c1d2275721bb440_cgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!default\+\_\+proc\+\_\+acquire\+\_\+entity\+\_\+resp@{default\+\_\+proc\+\_\+acquire\+\_\+entity\+\_\+resp}}
\index{default\+\_\+proc\+\_\+acquire\+\_\+entity\+\_\+resp@{default\+\_\+proc\+\_\+acquire\+\_\+entity\+\_\+resp}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{default\+\_\+proc\+\_\+acquire\+\_\+entity\+\_\+resp(struct jdksavdecc\+\_\+aem\+\_\+command\+\_\+acquire\+\_\+entity\+\_\+response \&aem\+\_\+cmd\+\_\+acquire\+\_\+entity\+\_\+resp, void $\ast$\&notification\+\_\+id, const uint8\+\_\+t $\ast$frame, size\+\_\+t frame\+\_\+len, int \&status)}{default_proc_acquire_entity_resp(struct jdksavdecc_aem_command_acquire_entity_response &aem_cmd_acquire_entity_resp, void *&notification_id, const uint8_t *frame, size_t frame_len, int &status)}}]{\setlength{\rightskip}{0pt plus 5cm}int default\+\_\+proc\+\_\+acquire\+\_\+entity\+\_\+resp (
\begin{DoxyParamCaption}
\item[{struct {\bf jdksavdecc\+\_\+aem\+\_\+command\+\_\+acquire\+\_\+entity\+\_\+response} \&}]{aem\+\_\+cmd\+\_\+acquire\+\_\+entity\+\_\+resp, }
\item[{void $\ast$\&}]{notification\+\_\+id, }
\item[{const {\bf uint8\+\_\+t} $\ast$}]{frame, }
\item[{size\+\_\+t}]{frame\+\_\+len, }
\item[{int \&}]{status}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_ad248d7d7060e28eb36c8dc37d2653c43}{}\label{classavdecc__lib_1_1descriptor__base__imp_ad248d7d7060e28eb36c8dc37d2653c43}


descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 196 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
201 \{
202     \textcolor{keyword}{struct }\hyperlink{structjdksavdecc__frame}{jdksavdecc\_frame} cmd\_frame;
203     ssize\_t aem\_cmd\_acquire\_entity\_resp\_returned;
204     \hyperlink{parse_8c_a6eb1e68cc391dd753bc8ce896dbb8315}{uint32\_t} msg\_type;
205     \textcolor{keywordtype}{bool} u\_field;
206 
207     memcpy(cmd\_frame.payload, \hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, frame\_len);
208 
209     aem\_cmd\_acquire\_entity\_resp\_returned = 
      \hyperlink{group__command__acquire__entity__response_ga2eba02e65645b4bd3367333fe0c99df5}{jdksavdecc\_aem\_command\_acquire\_entity\_response\_read}(&
      aem\_cmd\_acquire\_entity\_resp,
210                                                                                                
      \hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame},
211                                                                                                
      \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE},
212                                                                                                frame\_len);
213 
214     \textcolor{keywordflow}{if} (aem\_cmd\_acquire\_entity\_resp\_returned < 0)
215     \{
216         \hyperlink{namespaceavdecc__lib_acbe3e2a96ae6524943ca532c87a28529}{log\_imp\_ref}->\hyperlink{classavdecc__lib_1_1log_a68139a6297697e4ccebf36ccfd02e44a}{post\_log\_msg}(\hyperlink{namespaceavdecc__lib_a501055c431e6872ef46f252ad13f85cdaf2c4481208273451a6f5c7bb9770ec8a}{LOGGING\_LEVEL\_ERROR}, \textcolor{stringliteral}{"
      aem\_cmd\_acquire\_entity\_resp\_read error\(\backslash\)n"});
217         assert(aem\_cmd\_acquire\_entity\_resp\_returned >= 0);
218         \textcolor{keywordflow}{return} -1;
219     \}
220 
221     msg\_type = aem\_cmd\_acquire\_entity\_resp.\hyperlink{structjdksavdecc__aem__command__acquire__entity__response_ae1e77ccb75ff5021ad923221eab38294}{aem\_header}.\hyperlink{structjdksavdecc__aecpdu__aem_ae8460ae179666e7ce268ed1ef33d0de3}{aecpdu\_header}.
      \hyperlink{structjdksavdecc__aecpdu__common_a314cacb6a61bcf18749030c0b6fb7510}{header}.\hyperlink{structjdksavdecc__aecpdu__common__control__header_aeaaffeace8c23899e558022f62ce6de4}{message\_type};
222     status = aem\_cmd\_acquire\_entity\_resp.\hyperlink{structjdksavdecc__aem__command__acquire__entity__response_ae1e77ccb75ff5021ad923221eab38294}{aem\_header}.\hyperlink{structjdksavdecc__aecpdu__aem_ae8460ae179666e7ce268ed1ef33d0de3}{aecpdu\_header}.
      \hyperlink{structjdksavdecc__aecpdu__common_a314cacb6a61bcf18749030c0b6fb7510}{header}.\hyperlink{structjdksavdecc__aecpdu__common__control__header_ade818037fd6c985038ff29656089758d}{status};
223     u\_field = aem\_cmd\_acquire\_entity\_resp.\hyperlink{structjdksavdecc__aem__command__acquire__entity__response_ae1e77ccb75ff5021ad923221eab38294}{aem\_header}.\hyperlink{structjdksavdecc__aecpdu__aem_a07f7ee802870e9ae75f021832f59a8a9}{command\_type} >> 15 & 0x01; \textcolor{comment}{//
       u\_field = the msb of the uint16\_t command\_type}
224 
225     \hyperlink{namespaceavdecc__lib_a0b1b5aea3c0490f77cbfd9178af5be22}{aecp\_controller\_state\_machine\_ref}->
      \hyperlink{classavdecc__lib_1_1aecp__controller__state__machine_a997abd9786c330a5505e903e6443208e}{update\_inflight\_for\_rcvd\_resp}(notification\_id, msg\_type, u\_field, &cmd\_frame);
226 
227     \textcolor{keywordflow}{return} 0;
228 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_ad248d7d7060e28eb36c8dc37d2653c43_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_ad248d7d7060e28eb36c8dc37d2653c43_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!default\+\_\+proc\+\_\+get\+\_\+name\+\_\+resp@{default\+\_\+proc\+\_\+get\+\_\+name\+\_\+resp}}
\index{default\+\_\+proc\+\_\+get\+\_\+name\+\_\+resp@{default\+\_\+proc\+\_\+get\+\_\+name\+\_\+resp}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{default\+\_\+proc\+\_\+get\+\_\+name\+\_\+resp(struct jdksavdecc\+\_\+aem\+\_\+command\+\_\+get\+\_\+name\+\_\+response \&aem\+\_\+cmd\+\_\+get\+\_\+name\+\_\+resp, void $\ast$\&notification\+\_\+id, const uint8\+\_\+t $\ast$frame, size\+\_\+t frame\+\_\+len, int \&status)}{default_proc_get_name_resp(struct jdksavdecc_aem_command_get_name_response &aem_cmd_get_name_resp, void *&notification_id, const uint8_t *frame, size_t frame_len, int &status)}}]{\setlength{\rightskip}{0pt plus 5cm}int default\+\_\+proc\+\_\+get\+\_\+name\+\_\+resp (
\begin{DoxyParamCaption}
\item[{struct {\bf jdksavdecc\+\_\+aem\+\_\+command\+\_\+get\+\_\+name\+\_\+response} \&}]{aem\+\_\+cmd\+\_\+get\+\_\+name\+\_\+resp, }
\item[{void $\ast$\&}]{notification\+\_\+id, }
\item[{const {\bf uint8\+\_\+t} $\ast$}]{frame, }
\item[{size\+\_\+t}]{frame\+\_\+len, }
\item[{int \&}]{status}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_acc8b1c1591bd54bc9a2d21d4f0db2e86}{}\label{classavdecc__lib_1_1descriptor__base__imp_acc8b1c1591bd54bc9a2d21d4f0db2e86}


descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 582 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
587 \{
588     \textcolor{keyword}{struct }\hyperlink{structjdksavdecc__frame}{jdksavdecc\_frame} cmd\_frame;
589     ssize\_t aem\_cmd\_get\_name\_resp\_returned = 0;
590     \hyperlink{parse_8c_a6eb1e68cc391dd753bc8ce896dbb8315}{uint32\_t} msg\_type = 0;
591     \textcolor{keywordtype}{bool} u\_field = \textcolor{keyword}{false};
592 
593     memcpy(cmd\_frame.payload, \hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, frame\_len);
594 
595     aem\_cmd\_get\_name\_resp\_returned = 
      \hyperlink{group__command__get__name__response_ga0e8ecfaa03d14e2d8ade75cfec4d3bea}{jdksavdecc\_aem\_command\_get\_name\_response\_read}(&
      aem\_cmd\_get\_name\_resp,
596                                                                                    
      \hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame},
597                                                                                    
      \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE},
598                                                                                    frame\_len);
599 
600     \textcolor{keywordflow}{if} (aem\_cmd\_get\_name\_resp\_returned < 0)
601     \{
602         \hyperlink{namespaceavdecc__lib_acbe3e2a96ae6524943ca532c87a28529}{log\_imp\_ref}->\hyperlink{classavdecc__lib_1_1log_a68139a6297697e4ccebf36ccfd02e44a}{post\_log\_msg}(\hyperlink{namespaceavdecc__lib_a501055c431e6872ef46f252ad13f85cdaf2c4481208273451a6f5c7bb9770ec8a}{LOGGING\_LEVEL\_ERROR}, \textcolor{stringliteral}{"
      aem\_cmd\_get\_name\_resp\_read error\(\backslash\)n"});
603         assert(aem\_cmd\_get\_name\_resp\_returned >= 0);
604         \textcolor{keywordflow}{return} -1;
605     \}
606 
607     \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a482fe95208e9e14885e28e73e7be2c49}{replace\_frame}(\hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE}, frame\_len);
608 
609     msg\_type = aem\_cmd\_get\_name\_resp.\hyperlink{structjdksavdecc__aem__command__get__name__response_ae1e77ccb75ff5021ad923221eab38294}{aem\_header}.\hyperlink{structjdksavdecc__aecpdu__aem_ae8460ae179666e7ce268ed1ef33d0de3}{aecpdu\_header}.
      \hyperlink{structjdksavdecc__aecpdu__common_a314cacb6a61bcf18749030c0b6fb7510}{header}.\hyperlink{structjdksavdecc__aecpdu__common__control__header_aeaaffeace8c23899e558022f62ce6de4}{message\_type};
610     status = aem\_cmd\_get\_name\_resp.\hyperlink{structjdksavdecc__aem__command__get__name__response_ae1e77ccb75ff5021ad923221eab38294}{aem\_header}.\hyperlink{structjdksavdecc__aecpdu__aem_ae8460ae179666e7ce268ed1ef33d0de3}{aecpdu\_header}.
      \hyperlink{structjdksavdecc__aecpdu__common_a314cacb6a61bcf18749030c0b6fb7510}{header}.\hyperlink{structjdksavdecc__aecpdu__common__control__header_ade818037fd6c985038ff29656089758d}{status};
611     u\_field = aem\_cmd\_get\_name\_resp.\hyperlink{structjdksavdecc__aem__command__get__name__response_ae1e77ccb75ff5021ad923221eab38294}{aem\_header}.\hyperlink{structjdksavdecc__aecpdu__aem_a07f7ee802870e9ae75f021832f59a8a9}{command\_type} >> 15 & 0x01; \textcolor{comment}{// u\_field
       = the msb of the uint16\_t command\_type}
612 
613     \hyperlink{namespaceavdecc__lib_a0b1b5aea3c0490f77cbfd9178af5be22}{aecp\_controller\_state\_machine\_ref}->
      \hyperlink{classavdecc__lib_1_1aecp__controller__state__machine_a997abd9786c330a5505e903e6443208e}{update\_inflight\_for\_rcvd\_resp}(notification\_id, msg\_type, u\_field, &cmd\_frame);
614 
615     \textcolor{keywordflow}{return} 0;
616 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_acc8b1c1591bd54bc9a2d21d4f0db2e86_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_acc8b1c1591bd54bc9a2d21d4f0db2e86_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!default\+\_\+proc\+\_\+lock\+\_\+entity\+\_\+resp@{default\+\_\+proc\+\_\+lock\+\_\+entity\+\_\+resp}}
\index{default\+\_\+proc\+\_\+lock\+\_\+entity\+\_\+resp@{default\+\_\+proc\+\_\+lock\+\_\+entity\+\_\+resp}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{default\+\_\+proc\+\_\+lock\+\_\+entity\+\_\+resp(struct jdksavdecc\+\_\+aem\+\_\+command\+\_\+lock\+\_\+entity\+\_\+response \&aem\+\_\+cmd\+\_\+lock\+\_\+entity\+\_\+resp, void $\ast$\&notification\+\_\+id, const uint8\+\_\+t $\ast$frame, size\+\_\+t frame\+\_\+len, int \&status)}{default_proc_lock_entity_resp(struct jdksavdecc_aem_command_lock_entity_response &aem_cmd_lock_entity_resp, void *&notification_id, const uint8_t *frame, size_t frame_len, int &status)}}]{\setlength{\rightskip}{0pt plus 5cm}int default\+\_\+proc\+\_\+lock\+\_\+entity\+\_\+resp (
\begin{DoxyParamCaption}
\item[{struct {\bf jdksavdecc\+\_\+aem\+\_\+command\+\_\+lock\+\_\+entity\+\_\+response} \&}]{aem\+\_\+cmd\+\_\+lock\+\_\+entity\+\_\+resp, }
\item[{void $\ast$\&}]{notification\+\_\+id, }
\item[{const {\bf uint8\+\_\+t} $\ast$}]{frame, }
\item[{size\+\_\+t}]{frame\+\_\+len, }
\item[{int \&}]{status}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_a3b3582020613e7f60efe96567679be7f}{}\label{classavdecc__lib_1_1descriptor__base__imp_a3b3582020613e7f60efe96567679be7f}


descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 294 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
299 \{
300     \textcolor{keyword}{struct }\hyperlink{structjdksavdecc__frame}{jdksavdecc\_frame} cmd\_frame;
301     ssize\_t aem\_cmd\_lock\_entity\_resp\_returned = 0;
302     \hyperlink{parse_8c_a6eb1e68cc391dd753bc8ce896dbb8315}{uint32\_t} msg\_type = 0;
303     \textcolor{keywordtype}{bool} u\_field = \textcolor{keyword}{false};
304 
305     memcpy(cmd\_frame.payload, \hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, frame\_len);
306 
307     aem\_cmd\_lock\_entity\_resp\_returned = 
      \hyperlink{group__command__lock__entity__response_gabf8e59d01c0f0088b701f6191dd17b6d}{jdksavdecc\_aem\_command\_lock\_entity\_response\_read}(&
      aem\_cmd\_lock\_entity\_resp,
308                                                                                          
      \hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame},
309                                                                                          
      \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE},
310                                                                                          frame\_len);
311 
312     \textcolor{keywordflow}{if} (aem\_cmd\_lock\_entity\_resp\_returned < 0)
313     \{
314         \hyperlink{namespaceavdecc__lib_acbe3e2a96ae6524943ca532c87a28529}{log\_imp\_ref}->\hyperlink{classavdecc__lib_1_1log_a68139a6297697e4ccebf36ccfd02e44a}{post\_log\_msg}(\hyperlink{namespaceavdecc__lib_a501055c431e6872ef46f252ad13f85cdaf2c4481208273451a6f5c7bb9770ec8a}{LOGGING\_LEVEL\_ERROR}, \textcolor{stringliteral}{"
      aem\_cmd\_lock\_entity\_resp\_read error\(\backslash\)n"});
315         assert(aem\_cmd\_lock\_entity\_resp\_returned >= 0);
316         \textcolor{keywordflow}{return} -1;
317     \}
318 
319     msg\_type = aem\_cmd\_lock\_entity\_resp.\hyperlink{structjdksavdecc__aem__command__lock__entity__response_ae1e77ccb75ff5021ad923221eab38294}{aem\_header}.\hyperlink{structjdksavdecc__aecpdu__aem_ae8460ae179666e7ce268ed1ef33d0de3}{aecpdu\_header}.
      \hyperlink{structjdksavdecc__aecpdu__common_a314cacb6a61bcf18749030c0b6fb7510}{header}.\hyperlink{structjdksavdecc__aecpdu__common__control__header_aeaaffeace8c23899e558022f62ce6de4}{message\_type};
320     status = aem\_cmd\_lock\_entity\_resp.\hyperlink{structjdksavdecc__aem__command__lock__entity__response_ae1e77ccb75ff5021ad923221eab38294}{aem\_header}.\hyperlink{structjdksavdecc__aecpdu__aem_ae8460ae179666e7ce268ed1ef33d0de3}{aecpdu\_header}.
      \hyperlink{structjdksavdecc__aecpdu__common_a314cacb6a61bcf18749030c0b6fb7510}{header}.\hyperlink{structjdksavdecc__aecpdu__common__control__header_ade818037fd6c985038ff29656089758d}{status};
321     u\_field = aem\_cmd\_lock\_entity\_resp.\hyperlink{structjdksavdecc__aem__command__lock__entity__response_ae1e77ccb75ff5021ad923221eab38294}{aem\_header}.\hyperlink{structjdksavdecc__aecpdu__aem_a07f7ee802870e9ae75f021832f59a8a9}{command\_type} >> 15 & 0x01; \textcolor{comment}{//
       u\_field = the msb of the uint16\_t command\_type}
322 
323     \hyperlink{namespaceavdecc__lib_a0b1b5aea3c0490f77cbfd9178af5be22}{aecp\_controller\_state\_machine\_ref}->
      \hyperlink{classavdecc__lib_1_1aecp__controller__state__machine_a997abd9786c330a5505e903e6443208e}{update\_inflight\_for\_rcvd\_resp}(notification\_id, msg\_type, u\_field, &cmd\_frame);
324 
325     \textcolor{keywordflow}{return} 0;
326 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_a3b3582020613e7f60efe96567679be7f_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_a3b3582020613e7f60efe96567679be7f_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!default\+\_\+proc\+\_\+reboot\+\_\+resp@{default\+\_\+proc\+\_\+reboot\+\_\+resp}}
\index{default\+\_\+proc\+\_\+reboot\+\_\+resp@{default\+\_\+proc\+\_\+reboot\+\_\+resp}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{default\+\_\+proc\+\_\+reboot\+\_\+resp(struct jdksavdecc\+\_\+aem\+\_\+command\+\_\+reboot\+\_\+response \&aem\+\_\+cmd\+\_\+reboot\+\_\+resp, void $\ast$\&notification\+\_\+id, const uint8\+\_\+t $\ast$frame, size\+\_\+t frame\+\_\+len, int \&status)}{default_proc_reboot_resp(struct jdksavdecc_aem_command_reboot_response &aem_cmd_reboot_resp, void *&notification_id, const uint8_t *frame, size_t frame_len, int &status)}}]{\setlength{\rightskip}{0pt plus 5cm}int default\+\_\+proc\+\_\+reboot\+\_\+resp (
\begin{DoxyParamCaption}
\item[{struct {\bf jdksavdecc\+\_\+aem\+\_\+command\+\_\+reboot\+\_\+response} \&}]{aem\+\_\+cmd\+\_\+reboot\+\_\+resp, }
\item[{void $\ast$\&}]{notification\+\_\+id, }
\item[{const {\bf uint8\+\_\+t} $\ast$}]{frame, }
\item[{size\+\_\+t}]{frame\+\_\+len, }
\item[{int \&}]{status}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_a774dc940e9918a60127b0b021582b32a}{}\label{classavdecc__lib_1_1descriptor__base__imp_a774dc940e9918a60127b0b021582b32a}


descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 389 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
394 \{
395     \textcolor{keyword}{struct }\hyperlink{structjdksavdecc__frame}{jdksavdecc\_frame} cmd\_frame;
396     \hyperlink{parse_8c_a6eb1e68cc391dd753bc8ce896dbb8315}{uint32\_t} msg\_type = 0;
397     \textcolor{keywordtype}{bool} u\_field = \textcolor{keyword}{false};
398 
399     memcpy(cmd\_frame.payload, \hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, frame\_len);
400 
401     ssize\_t aem\_cmd\_reboot\_resp\_returned = 
      \hyperlink{group__command__reboot__response_ga4c55ee085228ad590101ad2c710834e0}{jdksavdecc\_aem\_command\_reboot\_response\_read}(&aem\_cmd\_reboot\_resp
      ,
402                                                                                        
      \hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame},
403                                                                                        
      \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE},
404                                                                                        frame\_len);
405 
406     \textcolor{keywordflow}{if} (aem\_cmd\_reboot\_resp\_returned < 0)
407     \{
408         \hyperlink{namespaceavdecc__lib_acbe3e2a96ae6524943ca532c87a28529}{log\_imp\_ref}->\hyperlink{classavdecc__lib_1_1log_a68139a6297697e4ccebf36ccfd02e44a}{post\_log\_msg}(\hyperlink{namespaceavdecc__lib_a501055c431e6872ef46f252ad13f85cdaf2c4481208273451a6f5c7bb9770ec8a}{LOGGING\_LEVEL\_ERROR}, \textcolor{stringliteral}{"
      aem\_cmd\_reboot\_resp\_read error\(\backslash\)n"});
409         \textcolor{keywordflow}{return} -1;
410     \}
411 
412     msg\_type = aem\_cmd\_reboot\_resp.\hyperlink{structjdksavdecc__aem__command__reboot__response_ae1e77ccb75ff5021ad923221eab38294}{aem\_header}.\hyperlink{structjdksavdecc__aecpdu__aem_ae8460ae179666e7ce268ed1ef33d0de3}{aecpdu\_header}.
      \hyperlink{structjdksavdecc__aecpdu__common_a314cacb6a61bcf18749030c0b6fb7510}{header}.\hyperlink{structjdksavdecc__aecpdu__common__control__header_aeaaffeace8c23899e558022f62ce6de4}{message\_type};
413     status = aem\_cmd\_reboot\_resp.\hyperlink{structjdksavdecc__aem__command__reboot__response_ae1e77ccb75ff5021ad923221eab38294}{aem\_header}.\hyperlink{structjdksavdecc__aecpdu__aem_ae8460ae179666e7ce268ed1ef33d0de3}{aecpdu\_header}.
      \hyperlink{structjdksavdecc__aecpdu__common_a314cacb6a61bcf18749030c0b6fb7510}{header}.\hyperlink{structjdksavdecc__aecpdu__common__control__header_ade818037fd6c985038ff29656089758d}{status};
414     u\_field = aem\_cmd\_reboot\_resp.\hyperlink{structjdksavdecc__aem__command__reboot__response_ae1e77ccb75ff5021ad923221eab38294}{aem\_header}.\hyperlink{structjdksavdecc__aecpdu__aem_a07f7ee802870e9ae75f021832f59a8a9}{command\_type} >> 15 & 0x01; \textcolor{comment}{// u\_field =
       the msb of the uint16\_t command\_type}
415 
416     \hyperlink{namespaceavdecc__lib_a0b1b5aea3c0490f77cbfd9178af5be22}{aecp\_controller\_state\_machine\_ref}->
      \hyperlink{classavdecc__lib_1_1aecp__controller__state__machine_a997abd9786c330a5505e903e6443208e}{update\_inflight\_for\_rcvd\_resp}(notification\_id, msg\_type, u\_field, &cmd\_frame);
417 
418     \textcolor{keywordflow}{return} 0;
419 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_a774dc940e9918a60127b0b021582b32a_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_a774dc940e9918a60127b0b021582b32a_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!default\+\_\+proc\+\_\+set\+\_\+name\+\_\+resp@{default\+\_\+proc\+\_\+set\+\_\+name\+\_\+resp}}
\index{default\+\_\+proc\+\_\+set\+\_\+name\+\_\+resp@{default\+\_\+proc\+\_\+set\+\_\+name\+\_\+resp}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{default\+\_\+proc\+\_\+set\+\_\+name\+\_\+resp(struct jdksavdecc\+\_\+aem\+\_\+command\+\_\+set\+\_\+name\+\_\+response \&aem\+\_\+cmd\+\_\+set\+\_\+name\+\_\+resp, void $\ast$\&notification\+\_\+id, const uint8\+\_\+t $\ast$frame, size\+\_\+t frame\+\_\+len, int \&status)}{default_proc_set_name_resp(struct jdksavdecc_aem_command_set_name_response &aem_cmd_set_name_resp, void *&notification_id, const uint8_t *frame, size_t frame_len, int &status)}}]{\setlength{\rightskip}{0pt plus 5cm}int default\+\_\+proc\+\_\+set\+\_\+name\+\_\+resp (
\begin{DoxyParamCaption}
\item[{struct {\bf jdksavdecc\+\_\+aem\+\_\+command\+\_\+set\+\_\+name\+\_\+response} \&}]{aem\+\_\+cmd\+\_\+set\+\_\+name\+\_\+resp, }
\item[{void $\ast$\&}]{notification\+\_\+id, }
\item[{const {\bf uint8\+\_\+t} $\ast$}]{frame, }
\item[{size\+\_\+t}]{frame\+\_\+len, }
\item[{int \&}]{status}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_a2f52c3b9a7ad6f490bed0c96a9136bc3}{}\label{classavdecc__lib_1_1descriptor__base__imp_a2f52c3b9a7ad6f490bed0c96a9136bc3}


descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 474 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
479 \{
480     \textcolor{keyword}{struct }\hyperlink{structjdksavdecc__frame}{jdksavdecc\_frame} cmd\_frame;
481     ssize\_t aem\_cmd\_set\_name\_resp\_returned = 0;
482     \hyperlink{parse_8c_a6eb1e68cc391dd753bc8ce896dbb8315}{uint32\_t} msg\_type = 0;
483     \textcolor{keywordtype}{bool} u\_field = \textcolor{keyword}{false};
484     uint16\_t \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a9dada313309522d04f1e52fe887442b4}{desc\_type} = 0;
485     \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t} * \hyperlink{_hello_test_8cpp_a8be6d469a7cd1c8d66cc6d2d1e10c65b}{buffer};
486 
487     memcpy(cmd\_frame.payload, \hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, frame\_len);
488 
489     aem\_cmd\_set\_name\_resp\_returned = 
      \hyperlink{group__command__set__name__response_gaef863bcb2206bfcbd21e95fe8f59869d}{jdksavdecc\_aem\_command\_set\_name\_response\_read}(&
      aem\_cmd\_set\_name\_resp,
490                                                                                    
      \hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame},
491                                                                                    
      \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE},
492                                                                                    frame\_len);
493 
494     \textcolor{keywordflow}{if} (aem\_cmd\_set\_name\_resp\_returned < 0)
495     \{
496         \hyperlink{namespaceavdecc__lib_acbe3e2a96ae6524943ca532c87a28529}{log\_imp\_ref}->\hyperlink{classavdecc__lib_1_1log_a68139a6297697e4ccebf36ccfd02e44a}{post\_log\_msg}(\hyperlink{namespaceavdecc__lib_a501055c431e6872ef46f252ad13f85cdaf2c4481208273451a6f5c7bb9770ec8a}{LOGGING\_LEVEL\_ERROR}, \textcolor{stringliteral}{"
      aem\_cmd\_set\_name\_resp\_read error\(\backslash\)n"});
497         assert(aem\_cmd\_set\_name\_resp\_returned >= 0);
498         \textcolor{keywordflow}{return} -1;
499     \}
500 
501     msg\_type = aem\_cmd\_set\_name\_resp.\hyperlink{structjdksavdecc__aem__command__set__name__response_ae1e77ccb75ff5021ad923221eab38294}{aem\_header}.\hyperlink{structjdksavdecc__aecpdu__aem_ae8460ae179666e7ce268ed1ef33d0de3}{aecpdu\_header}.
      \hyperlink{structjdksavdecc__aecpdu__common_a314cacb6a61bcf18749030c0b6fb7510}{header}.\hyperlink{structjdksavdecc__aecpdu__common__control__header_aeaaffeace8c23899e558022f62ce6de4}{message\_type};
502     status = aem\_cmd\_set\_name\_resp.\hyperlink{structjdksavdecc__aem__command__set__name__response_ae1e77ccb75ff5021ad923221eab38294}{aem\_header}.\hyperlink{structjdksavdecc__aecpdu__aem_ae8460ae179666e7ce268ed1ef33d0de3}{aecpdu\_header}.
      \hyperlink{structjdksavdecc__aecpdu__common_a314cacb6a61bcf18749030c0b6fb7510}{header}.\hyperlink{structjdksavdecc__aecpdu__common__control__header_ade818037fd6c985038ff29656089758d}{status};
503     u\_field = aem\_cmd\_set\_name\_resp.\hyperlink{structjdksavdecc__aem__command__set__name__response_ae1e77ccb75ff5021ad923221eab38294}{aem\_header}.\hyperlink{structjdksavdecc__aecpdu__aem_a07f7ee802870e9ae75f021832f59a8a9}{command\_type} >> 15 & 0x01; \textcolor{comment}{// u\_field
       = the msb of the uint16\_t command\_type}
504 
505     desc\_type = \hyperlink{group__command__set__name__response_ga3a95f51790a717c477cf1729aa02306e}{jdksavdecc\_aem\_command\_set\_name\_response\_get\_descriptor\_type}
      (\hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE});
506 
507     \textcolor{keywordflow}{if} (desc\_type == \hyperlink{namespaceavdecc__lib_ac7b7d227e46bc72b63ee9e9aae15902fac9ebb31a55e5894637f6c3c710ceceaf}{AEM\_DESC\_ENTITY})
508     \{
509         buffer = (\hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t} *)\hyperlink{_memory_leak_detector_malloc_macros_8h_ab8b25cd8f16d4a6552afe4e65c4f082d}{malloc}(\hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2642e3a7c10d38553e7ff4a55e875346}{resp\_ref}->\hyperlink{classavdecc__lib_1_1response__frame_a5302ae13c549f066040ce0e7c7d11ae6}{get\_desc\_size}() * \textcolor{keyword}{sizeof}(
      \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t})); \textcolor{comment}{//fetch current desc frame}
510         memcpy(buffer, \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2642e3a7c10d38553e7ff4a55e875346}{resp\_ref}->\hyperlink{classavdecc__lib_1_1response__frame_a87db6e7ad7e047437cf9c9eaab873626}{get\_desc\_buffer}(), 
      \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2642e3a7c10d38553e7ff4a55e875346}{resp\_ref}->\hyperlink{classavdecc__lib_1_1response__frame_a5302ae13c549f066040ce0e7c7d11ae6}{get\_desc\_size}());
511 
512         \textcolor{keywordflow}{if} (aem\_cmd\_set\_name\_resp.\hyperlink{structjdksavdecc__aem__command__set__name__response_a898a74ada625e0b227dadb02901404e6}{name\_index} == 0) \textcolor{comment}{//entity name}
513         \{
514             \hyperlink{group__descriptor__entity_gad94296ee558e018c5854af962b30b4a5}{jdksavdecc\_descriptor\_entity\_set\_entity\_name}(
      aem\_cmd\_set\_name\_resp.\hyperlink{structjdksavdecc__aem__command__set__name__response_a7e615b51b7768e9b59bfa450051e0f8e}{name}, buffer, \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2642e3a7c10d38553e7ff4a55e875346}{resp\_ref}->\hyperlink{classavdecc__lib_1_1response__frame_a6e6f6cc3d681d41c6de6139ca9cb79d9}{get\_desc\_pos}());
515         \}
516         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (aem\_cmd\_set\_name\_resp.\hyperlink{structjdksavdecc__aem__command__set__name__response_a898a74ada625e0b227dadb02901404e6}{name\_index} == 1) \textcolor{comment}{//group name}
517         \{
518             \hyperlink{group__descriptor__entity_gab440d6d94e09324c658e35852ea54045}{jdksavdecc\_descriptor\_entity\_set\_group\_name}(
      aem\_cmd\_set\_name\_resp.\hyperlink{structjdksavdecc__aem__command__set__name__response_a7e615b51b7768e9b59bfa450051e0f8e}{name}, buffer, \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2642e3a7c10d38553e7ff4a55e875346}{resp\_ref}->\hyperlink{classavdecc__lib_1_1response__frame_a6e6f6cc3d681d41c6de6139ca9cb79d9}{get\_desc\_pos}());
519         \}
520         \textcolor{keywordflow}{else}
521         \{
522             \hyperlink{namespaceavdecc__lib_acbe3e2a96ae6524943ca532c87a28529}{log\_imp\_ref}->\hyperlink{classavdecc__lib_1_1log_a68139a6297697e4ccebf36ccfd02e44a}{post\_log\_msg}(\hyperlink{namespaceavdecc__lib_a501055c431e6872ef46f252ad13f85cdaf2c4481208273451a6f5c7bb9770ec8a}{LOGGING\_LEVEL\_ERROR}, \textcolor{stringliteral}{"
      invalid SET\_NAME name index\(\backslash\)n"});
523         \}
524     \}
525     \textcolor{keywordflow}{else}
526     \{
527         buffer = (\hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t} *)\hyperlink{_memory_leak_detector_malloc_macros_8h_ab8b25cd8f16d4a6552afe4e65c4f082d}{malloc}(\hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2642e3a7c10d38553e7ff4a55e875346}{resp\_ref}->\hyperlink{classavdecc__lib_1_1response__frame_a5302ae13c549f066040ce0e7c7d11ae6}{get\_desc\_size}() * \textcolor{keyword}{sizeof}(
      \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t})); \textcolor{comment}{//fetch current desc frame}
528         memcpy(buffer, \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2642e3a7c10d38553e7ff4a55e875346}{resp\_ref}->\hyperlink{classavdecc__lib_1_1response__frame_a87db6e7ad7e047437cf9c9eaab873626}{get\_desc\_buffer}(), 
      \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2642e3a7c10d38553e7ff4a55e875346}{resp\_ref}->\hyperlink{classavdecc__lib_1_1response__frame_a5302ae13c549f066040ce0e7c7d11ae6}{get\_desc\_size}());
529 
530         \hyperlink{group__command__set__name_ga49b59c695339c3f6e2fcc1f83d6e410f}{jdksavdecc\_aem\_command\_set\_name\_set\_name}(
      aem\_cmd\_set\_name\_resp.\hyperlink{structjdksavdecc__aem__command__set__name__response_a7e615b51b7768e9b59bfa450051e0f8e}{name}, buffer, \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE});
531     \}
532 
533     \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a8dbf7d4faedf36ec789d33f228e22039}{replace\_desc\_frame}(buffer, \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2642e3a7c10d38553e7ff4a55e875346}{resp\_ref}->\hyperlink{classavdecc__lib_1_1response__frame_a6e6f6cc3d681d41c6de6139ca9cb79d9}{get\_desc\_pos}(), 
      \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2642e3a7c10d38553e7ff4a55e875346}{resp\_ref}->\hyperlink{classavdecc__lib_1_1response__frame_a5302ae13c549f066040ce0e7c7d11ae6}{get\_desc\_size}());
534 
535     \hyperlink{namespaceavdecc__lib_a0b1b5aea3c0490f77cbfd9178af5be22}{aecp\_controller\_state\_machine\_ref}->
      \hyperlink{classavdecc__lib_1_1aecp__controller__state__machine_a997abd9786c330a5505e903e6443208e}{update\_inflight\_for\_rcvd\_resp}(notification\_id, msg\_type, u\_field, &cmd\_frame);
536 
537     \hyperlink{_memory_leak_detector_malloc_macros_8h_aa7157aa9480bb73f090dca36776419bf}{free}(buffer);
538     \textcolor{keywordflow}{return} 0;
539 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_a2f52c3b9a7ad6f490bed0c96a9136bc3_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_a2f52c3b9a7ad6f490bed0c96a9136bc3_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!default\+\_\+send\+\_\+acquire\+\_\+entity\+\_\+cmd@{default\+\_\+send\+\_\+acquire\+\_\+entity\+\_\+cmd}}
\index{default\+\_\+send\+\_\+acquire\+\_\+entity\+\_\+cmd@{default\+\_\+send\+\_\+acquire\+\_\+entity\+\_\+cmd}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{default\+\_\+send\+\_\+acquire\+\_\+entity\+\_\+cmd(descriptor\+\_\+base\+\_\+imp $\ast$desc\+\_\+base\+\_\+imp\+\_\+ref, void $\ast$notification\+\_\+id, uint32\+\_\+t acquire\+\_\+entity\+\_\+flag)}{default_send_acquire_entity_cmd(descriptor_base_imp *desc_base_imp_ref, void *notification_id, uint32_t acquire_entity_flag)}}]{\setlength{\rightskip}{0pt plus 5cm}int default\+\_\+send\+\_\+acquire\+\_\+entity\+\_\+cmd (
\begin{DoxyParamCaption}
\item[{{\bf descriptor\+\_\+base\+\_\+imp} $\ast$}]{desc\+\_\+base\+\_\+imp\+\_\+ref, }
\item[{void $\ast$}]{notification\+\_\+id, }
\item[{{\bf uint32\+\_\+t}}]{acquire\+\_\+entity\+\_\+flag}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_a4ee5f42b89a728627bf1340afebc7c82}{}\label{classavdecc__lib_1_1descriptor__base__imp_a4ee5f42b89a728627bf1340afebc7c82}


descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 154 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
155 \{
156     \textcolor{keyword}{struct }\hyperlink{structjdksavdecc__frame}{jdksavdecc\_frame} cmd\_frame;
157     \textcolor{keyword}{struct }\hyperlink{structjdksavdecc__aem__command__acquire__entity}{jdksavdecc\_aem\_command\_acquire\_entity} 
      aem\_cmd\_acquire\_entity;
158     ssize\_t aem\_cmd\_acquire\_entity\_returned;
159 
160     \textcolor{comment}{/***************************************** AECP Common Data *******************************************
      **/}
161     aem\_cmd\_acquire\_entity.\hyperlink{structjdksavdecc__aem__command__acquire__entity_ae1e77ccb75ff5021ad923221eab38294}{aem\_header}.\hyperlink{structjdksavdecc__aecpdu__aem_ae8460ae179666e7ce268ed1ef33d0de3}{aecpdu\_header}.
      \hyperlink{structjdksavdecc__aecpdu__common_affc928ddb4fc62d1d04a775d36e5f2c8}{controller\_entity\_id} = \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\_end\_station\_imp\_ref}->
      \hyperlink{classavdecc__lib_1_1end__station__imp_a471a74540ce6182fad0c17dfd010107e}{get\_adp}()->\hyperlink{classavdecc__lib_1_1adp_a0c0959a46658c0a22e9530334b2912da}{get\_controller\_entity\_id}();
162     \textcolor{comment}{// Fill aem\_cmd\_acquire\_entity.sequence\_id in AEM Controller State Machine}
163     aem\_cmd\_acquire\_entity.aem\_header.command\_type = 
      \hyperlink{group__command_ga74ebee0a0531409bb10f7ce9e1216c04}{JDKSAVDECC\_AEM\_COMMAND\_ACQUIRE\_ENTITY};
164 
165     \textcolor{comment}{/************************* AECP Message Specific Data **************************/}
166     aem\_cmd\_acquire\_entity.aem\_acquire\_flags = acquire\_entity\_flag;
167     \hyperlink{group__eui64_ga6eda4ed21b6f0d526b180ac633eeba69}{jdksavdecc\_eui64\_init}(&aem\_cmd\_acquire\_entity.owner\_entity\_id);
168     aem\_cmd\_acquire\_entity.descriptor\_type = desc\_base\_imp\_ref->descriptor\_type();
169     aem\_cmd\_acquire\_entity.descriptor\_index = desc\_base\_imp\_ref->descriptor\_index();
170 
171     \textcolor{comment}{/**************************** Fill frame payload with AECP data and send the frame ********************
      **/}
172     \hyperlink{namespaceavdecc__lib_a0b1b5aea3c0490f77cbfd9178af5be22}{aecp\_controller\_state\_machine\_ref}->
      \hyperlink{classavdecc__lib_1_1aecp__controller__state__machine_a86ff947c5e6b799cfb877d3767bfa1f9}{ether\_frame\_init}(\hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\_end\_station\_imp\_ref}->
      \hyperlink{classavdecc__lib_1_1end__station__imp_a08e1bd1861b3b8f447ea374a65ac11f9}{mac}(), &cmd\_frame,
173                                                         \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE} + 
      \hyperlink{group__command__acquire__entity_gacd48c850101d4deef27e5c003f1c54cb}{JDKSAVDECC\_AEM\_COMMAND\_ACQUIRE\_ENTITY\_COMMAND\_LEN});
174     aem\_cmd\_acquire\_entity\_returned = 
      \hyperlink{group__command__acquire__entity_ga8f6285801e4769fe5ed789c57306f264}{jdksavdecc\_aem\_command\_acquire\_entity\_write}(&
      aem\_cmd\_acquire\_entity,
175                                                                                   cmd\_frame.payload,
176                                                                                   
      \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE},
177                                                                                   \textcolor{keyword}{sizeof}(cmd\_frame.payload)
      );
178 
179     \textcolor{keywordflow}{if} (aem\_cmd\_acquire\_entity\_returned < 0)
180     \{
181         \hyperlink{namespaceavdecc__lib_acbe3e2a96ae6524943ca532c87a28529}{log\_imp\_ref}->\hyperlink{classavdecc__lib_1_1log_a68139a6297697e4ccebf36ccfd02e44a}{post\_log\_msg}(\hyperlink{namespaceavdecc__lib_a501055c431e6872ef46f252ad13f85cdaf2c4481208273451a6f5c7bb9770ec8a}{LOGGING\_LEVEL\_ERROR}, \textcolor{stringliteral}{"
      aem\_cmd\_acquire\_entity\_write error\(\backslash\)n"});
182         assert(aem\_cmd\_acquire\_entity\_returned >= 0);
183         \textcolor{keywordflow}{return} -1;
184     \}
185 
186     \hyperlink{namespaceavdecc__lib_a0b1b5aea3c0490f77cbfd9178af5be22}{aecp\_controller\_state\_machine\_ref}->
      \hyperlink{classavdecc__lib_1_1aecp__controller__state__machine_aafc737d7ed17a62fed9df6528f18d3ec}{common\_hdr\_init}(\hyperlink{group__aecp__message__type_ga4625ce189cc209f42deb0629f48faf69}{JDKSAVDECC\_AECP\_MESSAGE\_TYPE\_AEM\_COMMAND}
      ,
187                                                        &cmd\_frame,
188                                                        \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\_end\_station\_imp\_ref}->
      \hyperlink{classavdecc__lib_1_1end__station__imp_a363b6c9664a0d701def9b17863e20ad3}{entity\_id}(),
189                                                        
      \hyperlink{group__command__acquire__entity_gacd48c850101d4deef27e5c003f1c54cb}{JDKSAVDECC\_AEM\_COMMAND\_ACQUIRE\_ENTITY\_COMMAND\_LEN} -
190                                                            
      \hyperlink{group__jdksavdecc__avtp__common__control__header_gaae84052886fb1bb42f3bc5f85b741dff}{JDKSAVDECC\_COMMON\_CONTROL\_HEADER\_LEN});
191     \hyperlink{namespaceavdecc__lib_a6dd511685627c0865a3442b539a4e8e9}{system\_queue\_tx}(notification\_id, \hyperlink{namespaceavdecc__lib_aabcadff06aa62be0ce47bc0646823604aba48b8a017e06fb240b650cdea965178}{CMD\_WITH\_NOTIFICATION}, cmd\_frame.
      payload, cmd\_frame.length);
192 
193     \textcolor{keywordflow}{return} 0;
194 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_a4ee5f42b89a728627bf1340afebc7c82_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=338pt]{classavdecc__lib_1_1descriptor__base__imp_a4ee5f42b89a728627bf1340afebc7c82_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!default\+\_\+send\+\_\+get\+\_\+name\+\_\+cmd@{default\+\_\+send\+\_\+get\+\_\+name\+\_\+cmd}}
\index{default\+\_\+send\+\_\+get\+\_\+name\+\_\+cmd@{default\+\_\+send\+\_\+get\+\_\+name\+\_\+cmd}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{default\+\_\+send\+\_\+get\+\_\+name\+\_\+cmd(descriptor\+\_\+base\+\_\+imp $\ast$desc\+\_\+base\+\_\+imp\+\_\+ref, void $\ast$notification\+\_\+id, uint16\+\_\+t name\+\_\+index, uint16\+\_\+t config\+\_\+index)}{default_send_get_name_cmd(descriptor_base_imp *desc_base_imp_ref, void *notification_id, uint16_t name_index, uint16_t config_index)}}]{\setlength{\rightskip}{0pt plus 5cm}int default\+\_\+send\+\_\+get\+\_\+name\+\_\+cmd (
\begin{DoxyParamCaption}
\item[{{\bf descriptor\+\_\+base\+\_\+imp} $\ast$}]{desc\+\_\+base\+\_\+imp\+\_\+ref, }
\item[{void $\ast$}]{notification\+\_\+id, }
\item[{uint16\+\_\+t}]{name\+\_\+index, }
\item[{uint16\+\_\+t}]{config\+\_\+index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_a92f2c88d261418872a496a8145800751}{}\label{classavdecc__lib_1_1descriptor__base__imp_a92f2c88d261418872a496a8145800751}


descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 541 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
542 \{
543     \textcolor{keyword}{struct }\hyperlink{structjdksavdecc__frame}{jdksavdecc\_frame} cmd\_frame;
544     \textcolor{keyword}{struct }\hyperlink{structjdksavdecc__aem__command__get__name}{jdksavdecc\_aem\_command\_get\_name} aem\_cmd\_get\_name;
545     ssize\_t aem\_cmd\_get\_name\_returned;
546 
547     \textcolor{comment}{/***************************************** AECP Common Data ******************************************/}
548     aem\_cmd\_get\_name.\hyperlink{structjdksavdecc__aem__command__get__name_ae1e77ccb75ff5021ad923221eab38294}{aem\_header}.\hyperlink{structjdksavdecc__aecpdu__aem_ae8460ae179666e7ce268ed1ef33d0de3}{aecpdu\_header}.
      \hyperlink{structjdksavdecc__aecpdu__common_affc928ddb4fc62d1d04a775d36e5f2c8}{controller\_entity\_id} = \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\_end\_station\_imp\_ref}->
      \hyperlink{classavdecc__lib_1_1end__station__imp_a471a74540ce6182fad0c17dfd010107e}{get\_adp}()->\hyperlink{classavdecc__lib_1_1adp_a0c0959a46658c0a22e9530334b2912da}{get\_controller\_entity\_id}();
549     \textcolor{comment}{// Fill aem\_cmd\_set\_name.sequence\_id in AEM Controller State Machine}
550     aem\_cmd\_get\_name.aem\_header.command\_type = \hyperlink{group__command_gab5a8244c35a72f9d4dcded988c51d8e3}{JDKSAVDECC\_AEM\_COMMAND\_GET\_NAME}
      ;
551 
552     \textcolor{comment}{/****************************** AECP Message Specific Data ****************************/}
553     aem\_cmd\_get\_name.descriptor\_type = desc\_base\_imp\_ref->descriptor\_type();
554     aem\_cmd\_get\_name.descriptor\_index = desc\_base\_imp\_ref->descriptor\_index();
555     aem\_cmd\_get\_name.configuration\_index = config\_index;
556     aem\_cmd\_get\_name.name\_index = \hyperlink{structjdksavdecc__aem__command__get__name_a898a74ada625e0b227dadb02901404e6}{name\_index};
557 
558     \textcolor{comment}{/**************************** Fill frame payload with AECP data and send the frame ********************
      **/}
559     \hyperlink{namespaceavdecc__lib_a0b1b5aea3c0490f77cbfd9178af5be22}{aecp\_controller\_state\_machine\_ref}->
      \hyperlink{classavdecc__lib_1_1aecp__controller__state__machine_a86ff947c5e6b799cfb877d3767bfa1f9}{ether\_frame\_init}(\hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\_end\_station\_imp\_ref}->
      \hyperlink{classavdecc__lib_1_1end__station__imp_a08e1bd1861b3b8f447ea374a65ac11f9}{mac}(), &cmd\_frame,
560                                                         \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE} + 
      \hyperlink{group__command__get__name_ga12d8b1a1daf6c9b805a6d84f5ecf92cb}{JDKSAVDECC\_AEM\_COMMAND\_GET\_NAME\_COMMAND\_LEN});
561     aem\_cmd\_get\_name\_returned = \hyperlink{group__command__get__name_ga61f178bb903a33dc13e23c5e55e2d89d}{jdksavdecc\_aem\_command\_get\_name\_write}(
      &aem\_cmd\_get\_name,
562                                                                       cmd\_frame.payload,
563                                                                       
      \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE},
564                                                                       \textcolor{keyword}{sizeof}(cmd\_frame.payload));
565 
566     \textcolor{keywordflow}{if} (aem\_cmd\_get\_name\_returned < 0)
567     \{
568         \hyperlink{namespaceavdecc__lib_acbe3e2a96ae6524943ca532c87a28529}{log\_imp\_ref}->\hyperlink{classavdecc__lib_1_1log_a68139a6297697e4ccebf36ccfd02e44a}{post\_log\_msg}(\hyperlink{namespaceavdecc__lib_a501055c431e6872ef46f252ad13f85cdaf2c4481208273451a6f5c7bb9770ec8a}{LOGGING\_LEVEL\_ERROR}, \textcolor{stringliteral}{"
      aem\_cmd\_get\_name\_write error\(\backslash\)n"});
569         assert(aem\_cmd\_get\_name\_returned >= 0);
570         \textcolor{keywordflow}{return} -1;
571     \}
572 
573     \hyperlink{namespaceavdecc__lib_a0b1b5aea3c0490f77cbfd9178af5be22}{aecp\_controller\_state\_machine\_ref}->
      \hyperlink{classavdecc__lib_1_1aecp__controller__state__machine_aafc737d7ed17a62fed9df6528f18d3ec}{common\_hdr\_init}(\hyperlink{group__aecp__message__type_ga4625ce189cc209f42deb0629f48faf69}{JDKSAVDECC\_AECP\_MESSAGE\_TYPE\_AEM\_COMMAND}
      ,
574                                                        &cmd\_frame,
575                                                        \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\_end\_station\_imp\_ref}->
      \hyperlink{classavdecc__lib_1_1end__station__imp_a363b6c9664a0d701def9b17863e20ad3}{entity\_id}(),
576                                                        
      \hyperlink{group__command__get__name_ga12d8b1a1daf6c9b805a6d84f5ecf92cb}{JDKSAVDECC\_AEM\_COMMAND\_GET\_NAME\_COMMAND\_LEN} -
577                                                            
      \hyperlink{group__jdksavdecc__avtp__common__control__header_gaae84052886fb1bb42f3bc5f85b741dff}{JDKSAVDECC\_COMMON\_CONTROL\_HEADER\_LEN});
578     \hyperlink{namespaceavdecc__lib_a6dd511685627c0865a3442b539a4e8e9}{system\_queue\_tx}(notification\_id, \hyperlink{namespaceavdecc__lib_aabcadff06aa62be0ce47bc0646823604aba48b8a017e06fb240b650cdea965178}{CMD\_WITH\_NOTIFICATION}, cmd\_frame.
      payload, cmd\_frame.length);
579     \textcolor{keywordflow}{return} 0;
580 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_a92f2c88d261418872a496a8145800751_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_a92f2c88d261418872a496a8145800751_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!default\+\_\+send\+\_\+lock\+\_\+entity\+\_\+cmd@{default\+\_\+send\+\_\+lock\+\_\+entity\+\_\+cmd}}
\index{default\+\_\+send\+\_\+lock\+\_\+entity\+\_\+cmd@{default\+\_\+send\+\_\+lock\+\_\+entity\+\_\+cmd}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{default\+\_\+send\+\_\+lock\+\_\+entity\+\_\+cmd(descriptor\+\_\+base\+\_\+imp $\ast$descriptor\+\_\+base\+\_\+imp\+\_\+ref, void $\ast$notification\+\_\+id, uint32\+\_\+t lock\+\_\+entity\+\_\+flag)}{default_send_lock_entity_cmd(descriptor_base_imp *descriptor_base_imp_ref, void *notification_id, uint32_t lock_entity_flag)}}]{\setlength{\rightskip}{0pt plus 5cm}int default\+\_\+send\+\_\+lock\+\_\+entity\+\_\+cmd (
\begin{DoxyParamCaption}
\item[{{\bf descriptor\+\_\+base\+\_\+imp} $\ast$}]{descriptor\+\_\+base\+\_\+imp\+\_\+ref, }
\item[{void $\ast$}]{notification\+\_\+id, }
\item[{{\bf uint32\+\_\+t}}]{lock\+\_\+entity\+\_\+flag}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_af40ac09b84feb7551bf0389a2a5db4ca}{}\label{classavdecc__lib_1_1descriptor__base__imp_af40ac09b84feb7551bf0389a2a5db4ca}


descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 252 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
253 \{
254     \textcolor{keyword}{struct }\hyperlink{structjdksavdecc__frame}{jdksavdecc\_frame} cmd\_frame;
255     \textcolor{keyword}{struct }\hyperlink{structjdksavdecc__aem__command__lock__entity}{jdksavdecc\_aem\_command\_lock\_entity} aem\_cmd\_lock\_entity;
256     ssize\_t aem\_cmd\_lock\_entity\_returned;
257 
258     \textcolor{comment}{/***************************************** AECP Common Data ******************************************/}
259     aem\_cmd\_lock\_entity.\hyperlink{structjdksavdecc__aem__command__lock__entity_ae1e77ccb75ff5021ad923221eab38294}{aem\_header}.\hyperlink{structjdksavdecc__aecpdu__aem_ae8460ae179666e7ce268ed1ef33d0de3}{aecpdu\_header}.
      \hyperlink{structjdksavdecc__aecpdu__common_affc928ddb4fc62d1d04a775d36e5f2c8}{controller\_entity\_id} = \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\_end\_station\_imp\_ref}->
      \hyperlink{classavdecc__lib_1_1end__station__imp_a471a74540ce6182fad0c17dfd010107e}{get\_adp}()->\hyperlink{classavdecc__lib_1_1adp_a0c0959a46658c0a22e9530334b2912da}{get\_controller\_entity\_id}();
260     \textcolor{comment}{// Fill aem\_cmd\_lock\_entity.sequence\_id in AEM Controller State Machine}
261     aem\_cmd\_lock\_entity.aem\_header.command\_type = 
      \hyperlink{group__command_ga96be22db90d10cec463db06ab42751c4}{JDKSAVDECC\_AEM\_COMMAND\_LOCK\_ENTITY};
262 
263     \textcolor{comment}{/****************************** AECP Message Specific Data ****************************/}
264     aem\_cmd\_lock\_entity.aem\_lock\_flags = lock\_entity\_flag;
265     \hyperlink{group__eui64_ga6eda4ed21b6f0d526b180ac633eeba69}{jdksavdecc\_eui64\_init}(&aem\_cmd\_lock\_entity.locked\_entity\_id);
266     aem\_cmd\_lock\_entity.descriptor\_type = descriptor\_base\_imp\_ref->descriptor\_type();
267     aem\_cmd\_lock\_entity.descriptor\_index = descriptor\_base\_imp\_ref->descriptor\_index();
268 
269     \textcolor{comment}{/**************************** Fill frame payload with AECP data and send the frame ********************
      **/}
270     \hyperlink{namespaceavdecc__lib_a0b1b5aea3c0490f77cbfd9178af5be22}{aecp\_controller\_state\_machine\_ref}->
      \hyperlink{classavdecc__lib_1_1aecp__controller__state__machine_a86ff947c5e6b799cfb877d3767bfa1f9}{ether\_frame\_init}(\hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\_end\_station\_imp\_ref}->
      \hyperlink{classavdecc__lib_1_1end__station__imp_a08e1bd1861b3b8f447ea374a65ac11f9}{mac}(), &cmd\_frame,
271                                                         \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE} + 
      \hyperlink{group__command__lock__entity_gaae9fdce1f4e3de3d6a0829b4b077b418}{JDKSAVDECC\_AEM\_COMMAND\_LOCK\_ENTITY\_COMMAND\_LEN});
272     aem\_cmd\_lock\_entity\_returned = \hyperlink{group__command__lock__entity_ga72e701eb5960e2b447364aab20d03b51}{jdksavdecc\_aem\_command\_lock\_entity\_write}
      (&aem\_cmd\_lock\_entity,
273                                                                             cmd\_frame.payload,
274                                                                             
      \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE},
275                                                                             \textcolor{keyword}{sizeof}(cmd\_frame.payload));
276 
277     \textcolor{keywordflow}{if} (aem\_cmd\_lock\_entity\_returned < 0)
278     \{
279         \hyperlink{namespaceavdecc__lib_acbe3e2a96ae6524943ca532c87a28529}{log\_imp\_ref}->\hyperlink{classavdecc__lib_1_1log_a68139a6297697e4ccebf36ccfd02e44a}{post\_log\_msg}(\hyperlink{namespaceavdecc__lib_a501055c431e6872ef46f252ad13f85cdaf2c4481208273451a6f5c7bb9770ec8a}{LOGGING\_LEVEL\_ERROR}, \textcolor{stringliteral}{"
      aem\_cmd\_lock\_entity\_write error\(\backslash\)n"});
280         assert(aem\_cmd\_lock\_entity\_returned >= 0);
281         \textcolor{keywordflow}{return} -1;
282     \}
283 
284     \hyperlink{namespaceavdecc__lib_a0b1b5aea3c0490f77cbfd9178af5be22}{aecp\_controller\_state\_machine\_ref}->
      \hyperlink{classavdecc__lib_1_1aecp__controller__state__machine_aafc737d7ed17a62fed9df6528f18d3ec}{common\_hdr\_init}(\hyperlink{group__aecp__message__type_ga4625ce189cc209f42deb0629f48faf69}{JDKSAVDECC\_AECP\_MESSAGE\_TYPE\_AEM\_COMMAND}
      ,
285                                                        &cmd\_frame,
286                                                        \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\_end\_station\_imp\_ref}->
      \hyperlink{classavdecc__lib_1_1end__station__imp_a363b6c9664a0d701def9b17863e20ad3}{entity\_id}(),
287                                                        
      \hyperlink{group__command__lock__entity_gaae9fdce1f4e3de3d6a0829b4b077b418}{JDKSAVDECC\_AEM\_COMMAND\_LOCK\_ENTITY\_COMMAND\_LEN} -
288                                                            
      \hyperlink{group__jdksavdecc__avtp__common__control__header_gaae84052886fb1bb42f3bc5f85b741dff}{JDKSAVDECC\_COMMON\_CONTROL\_HEADER\_LEN});
289     \hyperlink{namespaceavdecc__lib_a6dd511685627c0865a3442b539a4e8e9}{system\_queue\_tx}(notification\_id, \hyperlink{namespaceavdecc__lib_aabcadff06aa62be0ce47bc0646823604aba48b8a017e06fb240b650cdea965178}{CMD\_WITH\_NOTIFICATION}, cmd\_frame.
      payload, cmd\_frame.length);
290 
291     \textcolor{keywordflow}{return} 0;
292 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_af40ac09b84feb7551bf0389a2a5db4ca_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_af40ac09b84feb7551bf0389a2a5db4ca_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!default\+\_\+send\+\_\+reboot\+\_\+cmd@{default\+\_\+send\+\_\+reboot\+\_\+cmd}}
\index{default\+\_\+send\+\_\+reboot\+\_\+cmd@{default\+\_\+send\+\_\+reboot\+\_\+cmd}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{default\+\_\+send\+\_\+reboot\+\_\+cmd(descriptor\+\_\+base\+\_\+imp $\ast$descriptor\+\_\+base\+\_\+imp\+\_\+ref, void $\ast$notification\+\_\+id)}{default_send_reboot_cmd(descriptor_base_imp *descriptor_base_imp_ref, void *notification_id)}}]{\setlength{\rightskip}{0pt plus 5cm}int default\+\_\+send\+\_\+reboot\+\_\+cmd (
\begin{DoxyParamCaption}
\item[{{\bf descriptor\+\_\+base\+\_\+imp} $\ast$}]{descriptor\+\_\+base\+\_\+imp\+\_\+ref, }
\item[{void $\ast$}]{notification\+\_\+id}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_a14e3bd11c70e839a0594dc59dffcbf16}{}\label{classavdecc__lib_1_1descriptor__base__imp_a14e3bd11c70e839a0594dc59dffcbf16}


descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 349 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
350 \{
351     \textcolor{keyword}{struct }\hyperlink{structjdksavdecc__frame}{jdksavdecc\_frame} cmd\_frame;
352     \textcolor{keyword}{struct }\hyperlink{structjdksavdecc__aem__command__reboot}{jdksavdecc\_aem\_command\_reboot} aem\_cmd\_reboot;
353     memset(&aem\_cmd\_reboot, 0, \textcolor{keyword}{sizeof}(aem\_cmd\_reboot));
354 
355     \textcolor{comment}{/***************************************** AECP Common Data ******************************************/}
356     aem\_cmd\_reboot.aem\_header.aecpdu\_header.controller\_entity\_id = 
      \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\_end\_station\_imp\_ref}->\hyperlink{classavdecc__lib_1_1end__station__imp_a471a74540ce6182fad0c17dfd010107e}{get\_adp}()->
      \hyperlink{classavdecc__lib_1_1adp_a0c0959a46658c0a22e9530334b2912da}{get\_controller\_entity\_id}();
357     \textcolor{comment}{// Fill aem\_cmd\_reboot.sequence\_id in AEM Controller State Machine}
358     aem\_cmd\_reboot.aem\_header.command\_type = \hyperlink{group__command_ga859da6235182638521da6af153bc6d3c}{JDKSAVDECC\_AEM\_COMMAND\_REBOOT};
359 
360     \textcolor{comment}{/****************************** AECP Message Specific Data ****************************/}
361     aem\_cmd\_reboot.descriptor\_type = descriptor\_base\_imp\_ref->descriptor\_type();
362     aem\_cmd\_reboot.descriptor\_index = descriptor\_base\_imp\_ref->descriptor\_index();
363 
364     \textcolor{comment}{/**************************** Fill frame payload with AECP data and send the frame ********************
      **/}
365     \hyperlink{namespaceavdecc__lib_a0b1b5aea3c0490f77cbfd9178af5be22}{aecp\_controller\_state\_machine\_ref}->
      \hyperlink{classavdecc__lib_1_1aecp__controller__state__machine_a86ff947c5e6b799cfb877d3767bfa1f9}{ether\_frame\_init}(\hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\_end\_station\_imp\_ref}->
      \hyperlink{classavdecc__lib_1_1end__station__imp_a08e1bd1861b3b8f447ea374a65ac11f9}{mac}(), &cmd\_frame,
366                                                         \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE} + 
      \hyperlink{group__command__reboot_gaf5f6dbe8949b2bb7db6ad9e25e8bddf1}{JDKSAVDECC\_AEM\_COMMAND\_REBOOT\_COMMAND\_LEN});
367     ssize\_t aem\_cmd\_reboot\_entity\_returned = \hyperlink{group__command__reboot_ga47e876f80dcc650ced15fa1579fece63}{jdksavdecc\_aem\_command\_reboot\_write}
      (&aem\_cmd\_reboot,
368                                                                                  cmd\_frame.payload,
369                                                                                  
      \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE},
370                                                                                  \textcolor{keyword}{sizeof}(cmd\_frame.payload))
      ;
371 
372     \textcolor{keywordflow}{if} (aem\_cmd\_reboot\_entity\_returned < 0)
373     \{
374         \hyperlink{namespaceavdecc__lib_acbe3e2a96ae6524943ca532c87a28529}{log\_imp\_ref}->\hyperlink{classavdecc__lib_1_1log_a68139a6297697e4ccebf36ccfd02e44a}{post\_log\_msg}(\hyperlink{namespaceavdecc__lib_a501055c431e6872ef46f252ad13f85cdaf2c4481208273451a6f5c7bb9770ec8a}{LOGGING\_LEVEL\_ERROR}, \textcolor{stringliteral}{"
      aem\_cmd\_reboot\_write error\(\backslash\)n"});
375         assert(aem\_cmd\_reboot\_entity\_returned >= 0);
376         \textcolor{keywordflow}{return} -1;
377     \}
378 
379     \hyperlink{namespaceavdecc__lib_a0b1b5aea3c0490f77cbfd9178af5be22}{aecp\_controller\_state\_machine\_ref}->
      \hyperlink{classavdecc__lib_1_1aecp__controller__state__machine_aafc737d7ed17a62fed9df6528f18d3ec}{common\_hdr\_init}(\hyperlink{group__aecp__message__type_ga4625ce189cc209f42deb0629f48faf69}{JDKSAVDECC\_AECP\_MESSAGE\_TYPE\_AEM\_COMMAND}
      ,
380                                                        &cmd\_frame,
381                                                        \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\_end\_station\_imp\_ref}->
      \hyperlink{classavdecc__lib_1_1end__station__imp_a363b6c9664a0d701def9b17863e20ad3}{entity\_id}(),
382                                                        
      \hyperlink{group__command__reboot_gaf5f6dbe8949b2bb7db6ad9e25e8bddf1}{JDKSAVDECC\_AEM\_COMMAND\_REBOOT\_COMMAND\_LEN} -
383                                                            
      \hyperlink{group__jdksavdecc__avtp__common__control__header_gaae84052886fb1bb42f3bc5f85b741dff}{JDKSAVDECC\_COMMON\_CONTROL\_HEADER\_LEN});
384     \hyperlink{namespaceavdecc__lib_a6dd511685627c0865a3442b539a4e8e9}{system\_queue\_tx}(notification\_id, \hyperlink{namespaceavdecc__lib_aabcadff06aa62be0ce47bc0646823604aba48b8a017e06fb240b650cdea965178}{CMD\_WITH\_NOTIFICATION}, cmd\_frame.
      payload, cmd\_frame.length);
385 
386     \textcolor{keywordflow}{return} 0;
387 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_a14e3bd11c70e839a0594dc59dffcbf16_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_a14e3bd11c70e839a0594dc59dffcbf16_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!default\+\_\+send\+\_\+set\+\_\+name\+\_\+cmd@{default\+\_\+send\+\_\+set\+\_\+name\+\_\+cmd}}
\index{default\+\_\+send\+\_\+set\+\_\+name\+\_\+cmd@{default\+\_\+send\+\_\+set\+\_\+name\+\_\+cmd}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{default\+\_\+send\+\_\+set\+\_\+name\+\_\+cmd(descriptor\+\_\+base\+\_\+imp $\ast$desc\+\_\+base\+\_\+imp\+\_\+ref, void $\ast$notification\+\_\+id, uint16\+\_\+t name\+\_\+index, uint16\+\_\+t config\+\_\+index, const struct avdecc\+\_\+lib\+\_\+name\+\_\+string64 $\ast$name)}{default_send_set_name_cmd(descriptor_base_imp *desc_base_imp_ref, void *notification_id, uint16_t name_index, uint16_t config_index, const struct avdecc_lib_name_string64 *name)}}]{\setlength{\rightskip}{0pt plus 5cm}int default\+\_\+send\+\_\+set\+\_\+name\+\_\+cmd (
\begin{DoxyParamCaption}
\item[{{\bf descriptor\+\_\+base\+\_\+imp} $\ast$}]{desc\+\_\+base\+\_\+imp\+\_\+ref, }
\item[{void $\ast$}]{notification\+\_\+id, }
\item[{uint16\+\_\+t}]{name\+\_\+index, }
\item[{uint16\+\_\+t}]{config\+\_\+index, }
\item[{const struct {\bf avdecc\+\_\+lib\+\_\+name\+\_\+string64} $\ast$}]{name}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_aed899a0eaaaa06a02569135f844ffce8}{}\label{classavdecc__lib_1_1descriptor__base__imp_aed899a0eaaaa06a02569135f844ffce8}


descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 432 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
433 \{
434     \textcolor{keyword}{struct }\hyperlink{structjdksavdecc__frame}{jdksavdecc\_frame} cmd\_frame;
435     \textcolor{keyword}{struct }\hyperlink{structjdksavdecc__aem__command__set__name}{jdksavdecc\_aem\_command\_set\_name} aem\_cmd\_set\_name;
436     ssize\_t aem\_cmd\_set\_name\_returned;
437 
438     \textcolor{comment}{/***************************************** AECP Common Data ******************************************/}
439     aem\_cmd\_set\_name.\hyperlink{structjdksavdecc__aem__command__set__name_ae1e77ccb75ff5021ad923221eab38294}{aem\_header}.\hyperlink{structjdksavdecc__aecpdu__aem_ae8460ae179666e7ce268ed1ef33d0de3}{aecpdu\_header}.
      \hyperlink{structjdksavdecc__aecpdu__common_affc928ddb4fc62d1d04a775d36e5f2c8}{controller\_entity\_id} = \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\_end\_station\_imp\_ref}->
      \hyperlink{classavdecc__lib_1_1end__station__imp_a471a74540ce6182fad0c17dfd010107e}{get\_adp}()->\hyperlink{classavdecc__lib_1_1adp_a0c0959a46658c0a22e9530334b2912da}{get\_controller\_entity\_id}();
440     \textcolor{comment}{// Fill aem\_cmd\_set\_name.sequence\_id in AEM Controller State Machine}
441     aem\_cmd\_set\_name.aem\_header.command\_type = \hyperlink{group__command_ga67c447f46660cc499e4175923e99d32c}{JDKSAVDECC\_AEM\_COMMAND\_SET\_NAME}
      ;
442 
443     \textcolor{comment}{/****************************** AECP Message Specific Data ****************************/}
444     aem\_cmd\_set\_name.descriptor\_type = desc\_base\_imp\_ref->descriptor\_type();
445     aem\_cmd\_set\_name.descriptor\_index = desc\_base\_imp\_ref->descriptor\_index();
446     aem\_cmd\_set\_name.configuration\_index = config\_index;
447     aem\_cmd\_set\_name.name\_index = \hyperlink{structjdksavdecc__aem__command__set__name_a898a74ada625e0b227dadb02901404e6}{name\_index};
448     memcpy(aem\_cmd\_set\_name.name.value, \hyperlink{structjdksavdecc__aem__command__set__name_a7e615b51b7768e9b59bfa450051e0f8e}{name}->\hyperlink{structjdksavdecc__string_a7968db9d35aabae83b5c038723160e28}{value}, \textcolor{keyword}{sizeof}(aem\_cmd\_set\_name.name.value));
449 
450     \textcolor{comment}{/**************************** Fill frame payload with AECP data and send the frame ********************
      **/}
451     \hyperlink{namespaceavdecc__lib_a0b1b5aea3c0490f77cbfd9178af5be22}{aecp\_controller\_state\_machine\_ref}->
      \hyperlink{classavdecc__lib_1_1aecp__controller__state__machine_a86ff947c5e6b799cfb877d3767bfa1f9}{ether\_frame\_init}(\hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\_end\_station\_imp\_ref}->
      \hyperlink{classavdecc__lib_1_1end__station__imp_a08e1bd1861b3b8f447ea374a65ac11f9}{mac}(), &cmd\_frame,
452                                                         \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE} + 
      \hyperlink{group__command__set__name_ga133a28cbd2bc0e77c69d8135f36324f6}{JDKSAVDECC\_AEM\_COMMAND\_SET\_NAME\_COMMAND\_LEN});
453     aem\_cmd\_set\_name\_returned = \hyperlink{group__command__set__name_ga42e5da3685796fb973c5824f960eed2e}{jdksavdecc\_aem\_command\_set\_name\_write}(
      &aem\_cmd\_set\_name,
454                                                                       cmd\_frame.payload,
455                                                                       
      \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE},
456                                                                       \textcolor{keyword}{sizeof}(cmd\_frame.payload));
457 
458     \textcolor{keywordflow}{if} (aem\_cmd\_set\_name\_returned < 0)
459     \{
460         \hyperlink{namespaceavdecc__lib_acbe3e2a96ae6524943ca532c87a28529}{log\_imp\_ref}->\hyperlink{classavdecc__lib_1_1log_a68139a6297697e4ccebf36ccfd02e44a}{post\_log\_msg}(\hyperlink{namespaceavdecc__lib_a501055c431e6872ef46f252ad13f85cdaf2c4481208273451a6f5c7bb9770ec8a}{LOGGING\_LEVEL\_ERROR}, \textcolor{stringliteral}{"
      aem\_cmd\_set\_name\_write error\(\backslash\)n"});
461         assert(aem\_cmd\_set\_name\_returned >= 0);
462         \textcolor{keywordflow}{return} -1;
463     \}
464 
465     \hyperlink{namespaceavdecc__lib_a0b1b5aea3c0490f77cbfd9178af5be22}{aecp\_controller\_state\_machine\_ref}->
      \hyperlink{classavdecc__lib_1_1aecp__controller__state__machine_aafc737d7ed17a62fed9df6528f18d3ec}{common\_hdr\_init}(\hyperlink{group__aecp__message__type_ga4625ce189cc209f42deb0629f48faf69}{JDKSAVDECC\_AECP\_MESSAGE\_TYPE\_AEM\_COMMAND}
      ,
466                                                        &cmd\_frame,
467                                                        \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\_end\_station\_imp\_ref}->
      \hyperlink{classavdecc__lib_1_1end__station__imp_a363b6c9664a0d701def9b17863e20ad3}{entity\_id}(),
468                                                        
      \hyperlink{group__command__set__name_ga133a28cbd2bc0e77c69d8135f36324f6}{JDKSAVDECC\_AEM\_COMMAND\_SET\_NAME\_COMMAND\_LEN} -
469                                                            
      \hyperlink{group__jdksavdecc__avtp__common__control__header_gaae84052886fb1bb42f3bc5f85b741dff}{JDKSAVDECC\_COMMON\_CONTROL\_HEADER\_LEN});
470     \hyperlink{namespaceavdecc__lib_a6dd511685627c0865a3442b539a4e8e9}{system\_queue\_tx}(notification\_id, \hyperlink{namespaceavdecc__lib_aabcadff06aa62be0ce47bc0646823604aba48b8a017e06fb240b650cdea965178}{CMD\_WITH\_NOTIFICATION}, cmd\_frame.
      payload, cmd\_frame.length);
471     \textcolor{keywordflow}{return} 0;
472 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_aed899a0eaaaa06a02569135f844ffce8_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_aed899a0eaaaa06a02569135f844ffce8_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!descriptor\+\_\+index@{descriptor\+\_\+index}}
\index{descriptor\+\_\+index@{descriptor\+\_\+index}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{descriptor\+\_\+index() const =0}{descriptor_index() const =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI uint16\+\_\+t S\+T\+D\+C\+A\+LL descriptor\+\_\+index (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base_a7eed5583bffdf72d89021b188648c1b5}{}\label{classavdecc__lib_1_1descriptor__base_a7eed5583bffdf72d89021b188648c1b5}
\begin{DoxyReturn}{반환값}
The index of the descriptor. 
\end{DoxyReturn}


\hyperlink{classavdecc__lib_1_1configuration__descriptor__imp_ac23c0a35276c07cfce8c8660700c2135}{configuration\+\_\+descriptor\+\_\+imp}, \hyperlink{classavdecc__lib_1_1descriptor__base__imp_ac23c0a35276c07cfce8c8660700c2135}{descriptor\+\_\+base\+\_\+imp}에서 구현되었습니다.



이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base_a7eed5583bffdf72d89021b188648c1b5_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!descriptor\+\_\+index@{descriptor\+\_\+index}}
\index{descriptor\+\_\+index@{descriptor\+\_\+index}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{descriptor\+\_\+index() const }{descriptor_index() const }}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t S\+T\+D\+C\+A\+LL descriptor\+\_\+index (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_ac23c0a35276c07cfce8c8660700c2135}{}\label{classavdecc__lib_1_1descriptor__base__imp_ac23c0a35276c07cfce8c8660700c2135}
\begin{DoxyReturn}{반환값}
The index of the descriptor. 
\end{DoxyReturn}


\hyperlink{classavdecc__lib_1_1descriptor__base_a7eed5583bffdf72d89021b188648c1b5}{descriptor\+\_\+base}를 구현.



descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 104 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
105 \{
106     \textcolor{keywordflow}{return} \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2bbd0d8f32f687ca36aaa543c06f764c}{desc\_index};
107 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=550pt]{classavdecc__lib_1_1descriptor__base__imp_ac23c0a35276c07cfce8c8660700c2135_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!descriptor\+\_\+type@{descriptor\+\_\+type}}
\index{descriptor\+\_\+type@{descriptor\+\_\+type}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{descriptor\+\_\+type() const =0}{descriptor_type() const =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI uint16\+\_\+t S\+T\+D\+C\+A\+LL descriptor\+\_\+type (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base_a5112b70022171063ec5d3242bee9910e}{}\label{classavdecc__lib_1_1descriptor__base_a5112b70022171063ec5d3242bee9910e}
\begin{DoxyReturn}{반환값}
The type of the descriptor. 
\end{DoxyReturn}


\hyperlink{classavdecc__lib_1_1configuration__descriptor__imp_aefc543029ab093823c3f5b9d84f0ccc4}{configuration\+\_\+descriptor\+\_\+imp}, \hyperlink{classavdecc__lib_1_1descriptor__base__imp_aefc543029ab093823c3f5b9d84f0ccc4}{descriptor\+\_\+base\+\_\+imp}에서 구현되었습니다.



이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base_a5112b70022171063ec5d3242bee9910e_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!descriptor\+\_\+type@{descriptor\+\_\+type}}
\index{descriptor\+\_\+type@{descriptor\+\_\+type}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{descriptor\+\_\+type() const }{descriptor_type() const }}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t S\+T\+D\+C\+A\+LL descriptor\+\_\+type (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_aefc543029ab093823c3f5b9d84f0ccc4}{}\label{classavdecc__lib_1_1descriptor__base__imp_aefc543029ab093823c3f5b9d84f0ccc4}
\begin{DoxyReturn}{반환값}
The type of the descriptor. 
\end{DoxyReturn}


\hyperlink{classavdecc__lib_1_1descriptor__base_a5112b70022171063ec5d3242bee9910e}{descriptor\+\_\+base}를 구현.



descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 99 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
100 \{
101     \textcolor{keywordflow}{return} \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a9dada313309522d04f1e52fe887442b4}{desc\_type};
102 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=550pt]{classavdecc__lib_1_1descriptor__base__imp_aefc543029ab093823c3f5b9d84f0ccc4_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!field@{field}}
\index{field@{field}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{field(size\+\_\+t index) const =0}{field(size_t index) const =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI {\bf descriptor\+\_\+field}$\ast$ S\+T\+D\+C\+A\+LL field (
\begin{DoxyParamCaption}
\item[{size\+\_\+t}]{index}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base_aa3716832eed0b6f6dcfba358c5d2c601}{}\label{classavdecc__lib_1_1descriptor__base_aa3716832eed0b6f6dcfba358c5d2c601}
\begin{DoxyReturn}{반환값}
The indicated field in the descriptor. 
\end{DoxyReturn}


\hyperlink{classavdecc__lib_1_1descriptor__base__imp_a5f8127d32e2aa54777ca03bf09e8d7b5}{descriptor\+\_\+base\+\_\+imp}에서 구현되었습니다.



이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base_aa3716832eed0b6f6dcfba358c5d2c601_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!field@{field}}
\index{field@{field}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{field(size\+\_\+t index) const }{field(size_t index) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf descriptor\+\_\+field}$\ast$ S\+T\+D\+C\+A\+LL field (
\begin{DoxyParamCaption}
\item[{size\+\_\+t}]{index}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_a5f8127d32e2aa54777ca03bf09e8d7b5}{}\label{classavdecc__lib_1_1descriptor__base__imp_a5f8127d32e2aa54777ca03bf09e8d7b5}
\begin{DoxyReturn}{반환값}
The indicated field in the descriptor. 
\end{DoxyReturn}


\hyperlink{classavdecc__lib_1_1descriptor__base_aa3716832eed0b6f6dcfba358c5d2c601}{descriptor\+\_\+base}를 구현.



descriptor\+\_\+base\+\_\+imp.\+h 파일의 73 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
74     \{
75         \textcolor{keywordflow}{if} (index < \hyperlink{classavdecc__lib_1_1descriptor__base__imp_adce67136eb9c66da9c189b730077b9cd}{m\_fields}.size())
76             \textcolor{keywordflow}{return} \hyperlink{classavdecc__lib_1_1descriptor__base__imp_adce67136eb9c66da9c189b730077b9cd}{m\_fields}.at(index);
77         \textcolor{keywordflow}{else}
78             \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};
79     \};
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=550pt]{classavdecc__lib_1_1descriptor__base__imp_a5f8127d32e2aa54777ca03bf09e8d7b5_cgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!field\+\_\+count@{field\+\_\+count}}
\index{field\+\_\+count@{field\+\_\+count}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{field\+\_\+count() const =0}{field_count() const =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI size\+\_\+t S\+T\+D\+C\+A\+LL field\+\_\+count (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base_ab1edf4996377ed957088a7b3b16aca7d}{}\label{classavdecc__lib_1_1descriptor__base_ab1edf4996377ed957088a7b3b16aca7d}
\begin{DoxyReturn}{반환값}
The number of fields in the descriptor. 
\end{DoxyReturn}


\hyperlink{classavdecc__lib_1_1descriptor__base__imp_a9b98d4f427a6c527e9080c938cfa9334}{descriptor\+\_\+base\+\_\+imp}에서 구현되었습니다.



이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base_ab1edf4996377ed957088a7b3b16aca7d_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!field\+\_\+count@{field\+\_\+count}}
\index{field\+\_\+count@{field\+\_\+count}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{field\+\_\+count() const }{field_count() const }}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t S\+T\+D\+C\+A\+LL field\+\_\+count (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_a9b98d4f427a6c527e9080c938cfa9334}{}\label{classavdecc__lib_1_1descriptor__base__imp_a9b98d4f427a6c527e9080c938cfa9334}
\begin{DoxyReturn}{반환값}
The number of fields in the descriptor. 
\end{DoxyReturn}


\hyperlink{classavdecc__lib_1_1descriptor__base_ab1edf4996377ed957088a7b3b16aca7d}{descriptor\+\_\+base}를 구현.



descriptor\+\_\+base\+\_\+imp.\+h 파일의 68 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
69     \{
70         \textcolor{keywordflow}{return} \hyperlink{classavdecc__lib_1_1descriptor__base__imp_adce67136eb9c66da9c189b730077b9cd}{m\_fields}.size();
71     \};
\end{DoxyCode}
\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!get\+\_\+descriptor\+\_\+response@{get\+\_\+descriptor\+\_\+response}}
\index{get\+\_\+descriptor\+\_\+response@{get\+\_\+descriptor\+\_\+response}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{get\+\_\+descriptor\+\_\+response()=0}{get_descriptor_response()=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI {\bf descriptor\+\_\+response\+\_\+base}$\ast$ S\+T\+D\+C\+A\+LL get\+\_\+descriptor\+\_\+response (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base_ac64e6a5ee8781eeb9c781953e845b1be}{}\label{classavdecc__lib_1_1descriptor__base_ac64e6a5ee8781eeb9c781953e845b1be}
\begin{DoxyReturn}{반환값}
the descriptor base response class. 
\end{DoxyReturn}


\hyperlink{classavdecc__lib_1_1descriptor__base__imp_a8c64c9df60afbc144cf24eab5a42c009}{descriptor\+\_\+base\+\_\+imp}에서 구현되었습니다.



이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base_ac64e6a5ee8781eeb9c781953e845b1be_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!get\+\_\+descriptor\+\_\+response@{get\+\_\+descriptor\+\_\+response}}
\index{get\+\_\+descriptor\+\_\+response@{get\+\_\+descriptor\+\_\+response}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{get\+\_\+descriptor\+\_\+response()}{get_descriptor_response()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf descriptor\+\_\+response\+\_\+base} $\ast$S\+T\+D\+C\+A\+LL get\+\_\+descriptor\+\_\+response (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_a8c64c9df60afbc144cf24eab5a42c009}{}\label{classavdecc__lib_1_1descriptor__base__imp_a8c64c9df60afbc144cf24eab5a42c009}
\begin{DoxyReturn}{반환값}
the descriptor base response class. 
\end{DoxyReturn}


\hyperlink{classavdecc__lib_1_1descriptor__base_ac64e6a5ee8781eeb9c781953e845b1be}{descriptor\+\_\+base}를 구현.



descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 63 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
64 \{
65     std::lock\_guard<std::mutex> guard(\hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\_end\_station\_imp\_ref}->
      \hyperlink{classavdecc__lib_1_1end__station__imp_a2207f93fef130266b292686bf96ef8d3}{locker}); \textcolor{comment}{//mutex lock end station}
66     \textcolor{keywordflow}{return} \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a8b104da8319cda946944548ebb9552f4}{resp\_base} = \textcolor{keyword}{new} descriptor\_response\_base\_imp(\hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2642e3a7c10d38553e7ff4a55e875346}{resp\_ref}->
      \hyperlink{classavdecc__lib_1_1response__frame_a87db6e7ad7e047437cf9c9eaab873626}{get\_desc\_buffer}(), \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2642e3a7c10d38553e7ff4a55e875346}{resp\_ref}->\hyperlink{classavdecc__lib_1_1response__frame_a5302ae13c549f066040ce0e7c7d11ae6}{get\_desc\_size}(),
67                                                         \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2642e3a7c10d38553e7ff4a55e875346}{resp\_ref}->
      \hyperlink{classavdecc__lib_1_1response__frame_a6e6f6cc3d681d41c6de6139ca9cb79d9}{get\_desc\_pos}());
68 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_a8c64c9df60afbc144cf24eab5a42c009_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=274pt]{classavdecc__lib_1_1descriptor__base__imp_a8c64c9df60afbc144cf24eab5a42c009_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!get\+\_\+name\+\_\+response@{get\+\_\+name\+\_\+response}}
\index{get\+\_\+name\+\_\+response@{get\+\_\+name\+\_\+response}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{get\+\_\+name\+\_\+response()=0}{get_name_response()=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI {\bf descriptor\+\_\+base\+\_\+get\+\_\+name\+\_\+response}$\ast$ S\+T\+D\+C\+A\+LL get\+\_\+name\+\_\+response (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base_aba4bf8a81f90f5bf00d5c8b5a7330145}{}\label{classavdecc__lib_1_1descriptor__base_aba4bf8a81f90f5bf00d5c8b5a7330145}
\begin{DoxyReturn}{반환값}
the G\+E\+T\+\_\+\+N\+A\+ME response class. 
\end{DoxyReturn}


\hyperlink{classavdecc__lib_1_1descriptor__base__imp_abf130a286ee3ca9d1f41a7e2abbd0d33}{descriptor\+\_\+base\+\_\+imp}에서 구현되었습니다.



이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base_aba4bf8a81f90f5bf00d5c8b5a7330145_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!get\+\_\+name\+\_\+response@{get\+\_\+name\+\_\+response}}
\index{get\+\_\+name\+\_\+response@{get\+\_\+name\+\_\+response}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{get\+\_\+name\+\_\+response()}{get_name_response()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf descriptor\+\_\+base\+\_\+get\+\_\+name\+\_\+response} $\ast$S\+T\+D\+C\+A\+LL get\+\_\+name\+\_\+response (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_abf130a286ee3ca9d1f41a7e2abbd0d33}{}\label{classavdecc__lib_1_1descriptor__base__imp_abf130a286ee3ca9d1f41a7e2abbd0d33}
\begin{DoxyReturn}{반환값}
the G\+E\+T\+\_\+\+N\+A\+ME response class. 
\end{DoxyReturn}


\hyperlink{classavdecc__lib_1_1descriptor__base_aba4bf8a81f90f5bf00d5c8b5a7330145}{descriptor\+\_\+base}를 구현.



descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 70 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
71 \{
72     std::lock\_guard<std::mutex> guard(\hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\_end\_station\_imp\_ref}->
      \hyperlink{classavdecc__lib_1_1end__station__imp_a2207f93fef130266b292686bf96ef8d3}{locker}); \textcolor{comment}{//mutex lock end station}
73     \textcolor{keywordflow}{return} \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a7d3a410eb242dc2b7abe9862a1593458}{get\_name\_resp} = \textcolor{keyword}{new} descriptor\_base\_get\_name\_response\_imp(
      \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2642e3a7c10d38553e7ff4a55e875346}{resp\_ref}->\hyperlink{classavdecc__lib_1_1response__frame_ad4680d622c198b5256c03b2eb2638c22}{get\_buffer}(), \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2642e3a7c10d38553e7ff4a55e875346}{resp\_ref}->\hyperlink{classavdecc__lib_1_1response__frame_adf55ed6a1edf8e1aa4f3f5f97936ad1e}{get\_size}(),
74                                                                      \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2642e3a7c10d38553e7ff4a55e875346}{resp\_ref}->
      \hyperlink{classavdecc__lib_1_1response__frame_a4038092b7b420000faefc768241adb42}{get\_pos}());
75 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=329pt]{classavdecc__lib_1_1descriptor__base__imp_abf130a286ee3ca9d1f41a7e2abbd0d33_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=255pt]{classavdecc__lib_1_1descriptor__base__imp_abf130a286ee3ca9d1f41a7e2abbd0d33_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!get\+\_\+number\+\_\+of\+\_\+pending\+\_\+maps@{get\+\_\+number\+\_\+of\+\_\+pending\+\_\+maps}}
\index{get\+\_\+number\+\_\+of\+\_\+pending\+\_\+maps@{get\+\_\+number\+\_\+of\+\_\+pending\+\_\+maps}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{get\+\_\+number\+\_\+of\+\_\+pending\+\_\+maps()}{get_number_of_pending_maps()}}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t get\+\_\+number\+\_\+of\+\_\+pending\+\_\+maps (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classavdecc__lib_1_1stream__port__output__descriptor__imp_a0cce5060371c58d067bbbdb7ebb2f883}{}\label{classavdecc__lib_1_1stream__port__output__descriptor__imp_a0cce5060371c58d067bbbdb7ebb2f883}
\begin{DoxyReturn}{반환값}
the number of pending audio mappings. 
\end{DoxyReturn}


\hyperlink{classavdecc__lib_1_1stream__port__output__descriptor_ab97aa51efdb274b6226d04c41f2d974e}{stream\+\_\+port\+\_\+output\+\_\+descriptor}를 구현.



stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp.\+cpp 파일의 66 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
67 \{
68     \textcolor{keywordflow}{return} \hyperlink{classavdecc__lib_1_1stream__port__output__descriptor__imp_ae0c1781344cc1ecdf12d9624ae930ccd}{pending\_maps}.size();
69 \}
\end{DoxyCode}
\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!get\+\_\+pending\+\_\+maps@{get\+\_\+pending\+\_\+maps}}
\index{get\+\_\+pending\+\_\+maps@{get\+\_\+pending\+\_\+maps}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{get\+\_\+pending\+\_\+maps(size\+\_\+t index, struct audio\+\_\+map\+\_\+mapping \&map)}{get_pending_maps(size_t index, struct audio_map_mapping &map)}}]{\setlength{\rightskip}{0pt plus 5cm}int get\+\_\+pending\+\_\+maps (
\begin{DoxyParamCaption}
\item[{size\+\_\+t}]{index, }
\item[{struct {\bf audio\+\_\+map\+\_\+mapping} \&}]{map}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classavdecc__lib_1_1stream__port__output__descriptor__imp_a785e11f2e5498626800112562d8a3cc5}{}\label{classavdecc__lib_1_1stream__port__output__descriptor__imp_a785e11f2e5498626800112562d8a3cc5}
Get pending audio mappings.


\begin{DoxyParams}{매개변수}
{\em index} & The index of the queued audio mapping. \\
\hline
\end{DoxyParams}


\hyperlink{classavdecc__lib_1_1stream__port__output__descriptor_aaa56e01b09f3ff3f29037216607e556e}{stream\+\_\+port\+\_\+output\+\_\+descriptor}를 구현.



stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp.\+cpp 파일의 71 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
72 \{
73     \textcolor{keywordflow}{if} (index >= \hyperlink{classavdecc__lib_1_1stream__port__output__descriptor__imp_ae0c1781344cc1ecdf12d9624ae930ccd}{pending\_maps}.size())
74         \textcolor{keywordflow}{return} -1;
75 
76     map = \hyperlink{classavdecc__lib_1_1stream__port__output__descriptor__imp_ae0c1781344cc1ecdf12d9624ae930ccd}{pending\_maps}.at(index);
77     \textcolor{keywordflow}{return} 0;
78 \}
\end{DoxyCode}
\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!get\+\_\+stream\+\_\+port\+\_\+output\+\_\+audio\+\_\+map\+\_\+response@{get\+\_\+stream\+\_\+port\+\_\+output\+\_\+audio\+\_\+map\+\_\+response}}
\index{get\+\_\+stream\+\_\+port\+\_\+output\+\_\+audio\+\_\+map\+\_\+response@{get\+\_\+stream\+\_\+port\+\_\+output\+\_\+audio\+\_\+map\+\_\+response}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{get\+\_\+stream\+\_\+port\+\_\+output\+\_\+audio\+\_\+map\+\_\+response()}{get_stream_port_output_audio_map_response()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf stream\+\_\+port\+\_\+output\+\_\+get\+\_\+audio\+\_\+map\+\_\+response} $\ast$S\+T\+D\+C\+A\+LL get\+\_\+stream\+\_\+port\+\_\+output\+\_\+audio\+\_\+map\+\_\+response (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classavdecc__lib_1_1stream__port__output__descriptor__imp_a33e90ae5702c39b7a852cc347006ddb4}{}\label{classavdecc__lib_1_1stream__port__output__descriptor__imp_a33e90ae5702c39b7a852cc347006ddb4}
\begin{DoxyReturn}{반환값}
the audio\+\_\+map get\+\_\+audio\+\_\+map response class. 
\end{DoxyReturn}


\hyperlink{classavdecc__lib_1_1stream__port__output__descriptor_a4c10a3bd18d5f4e7220778ed34fe2a98}{stream\+\_\+port\+\_\+output\+\_\+descriptor}를 구현.



stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp.\+cpp 파일의 52 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
53 \{
54     std::lock\_guard<std::mutex> guard(\hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\_end\_station\_imp\_ref}->
      \hyperlink{classavdecc__lib_1_1end__station__imp_a2207f93fef130266b292686bf96ef8d3}{locker}); \textcolor{comment}{//mutex lock end station}
55     \textcolor{keywordflow}{return} \hyperlink{classavdecc__lib_1_1stream__port__output__descriptor__imp_a662a30a6f5184ddb2be3bd056cd0fecb}{audio\_map\_resp} = \textcolor{keyword}{new} stream\_port\_output\_get\_audio\_map\_response\_imp(
      \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2642e3a7c10d38553e7ff4a55e875346}{resp\_ref}->\hyperlink{classavdecc__lib_1_1response__frame_ad4680d622c198b5256c03b2eb2638c22}{get\_buffer}(),
56                                                                               
      \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2642e3a7c10d38553e7ff4a55e875346}{resp\_ref}->\hyperlink{classavdecc__lib_1_1response__frame_adf55ed6a1edf8e1aa4f3f5f97936ad1e}{get\_size}(), \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2642e3a7c10d38553e7ff4a55e875346}{resp\_ref}->\hyperlink{classavdecc__lib_1_1response__frame_a4038092b7b420000faefc768241adb42}{get\_pos}());
57 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=344pt]{classavdecc__lib_1_1stream__port__output__descriptor__imp_a33e90ae5702c39b7a852cc347006ddb4_cgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!get\+\_\+stream\+\_\+port\+\_\+output\+\_\+response@{get\+\_\+stream\+\_\+port\+\_\+output\+\_\+response}}
\index{get\+\_\+stream\+\_\+port\+\_\+output\+\_\+response@{get\+\_\+stream\+\_\+port\+\_\+output\+\_\+response}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{get\+\_\+stream\+\_\+port\+\_\+output\+\_\+response()}{get_stream_port_output_response()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+response} $\ast$S\+T\+D\+C\+A\+LL get\+\_\+stream\+\_\+port\+\_\+output\+\_\+response (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classavdecc__lib_1_1stream__port__output__descriptor__imp_ab6e468656996173ebca7287e32c06b97}{}\label{classavdecc__lib_1_1stream__port__output__descriptor__imp_ab6e468656996173ebca7287e32c06b97}
\begin{DoxyReturn}{반환값}
the stream port output descriptor response class. 
\end{DoxyReturn}


\hyperlink{classavdecc__lib_1_1stream__port__output__descriptor_ad55a65e8648f66713ad5c9a7b9fa7181}{stream\+\_\+port\+\_\+output\+\_\+descriptor}를 구현.



stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp.\+cpp 파일의 45 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
46 \{
47     std::lock\_guard<std::mutex> guard(\hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\_end\_station\_imp\_ref}->
      \hyperlink{classavdecc__lib_1_1end__station__imp_a2207f93fef130266b292686bf96ef8d3}{locker}); \textcolor{comment}{//mutex lock end station}
48     \textcolor{keywordflow}{return} \hyperlink{classavdecc__lib_1_1stream__port__output__descriptor__imp_a241ec2f535a1c6918e5a63c40f6a974b}{resp} = \textcolor{keyword}{new} stream\_port\_output\_descriptor\_response\_imp(\hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2642e3a7c10d38553e7ff4a55e875346}{resp\_ref}->
      \hyperlink{classavdecc__lib_1_1response__frame_a87db6e7ad7e047437cf9c9eaab873626}{get\_desc\_buffer}(),
49                                                                  \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2642e3a7c10d38553e7ff4a55e875346}{resp\_ref}->
      \hyperlink{classavdecc__lib_1_1response__frame_a5302ae13c549f066040ce0e7c7d11ae6}{get\_desc\_size}(), \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2642e3a7c10d38553e7ff4a55e875346}{resp\_ref}->\hyperlink{classavdecc__lib_1_1response__frame_a6e6f6cc3d681d41c6de6139ca9cb79d9}{get\_desc\_pos}());
50 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1stream__port__output__descriptor__imp_ab6e468656996173ebca7287e32c06b97_cgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!localized\+\_\+description@{localized\+\_\+description}}
\index{localized\+\_\+description@{localized\+\_\+description}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{localized\+\_\+description()}{localized_description()}}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t S\+T\+D\+C\+A\+LL localized\+\_\+description (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_aa94307532fbb37e2f986fee8fec79373}{}\label{classavdecc__lib_1_1descriptor__base__imp_aa94307532fbb37e2f986fee8fec79373}
\begin{DoxyReturn}{반환값}
The localized string reference pointing to the localized descriptor name. 
\end{DoxyReturn}


\hyperlink{classavdecc__lib_1_1descriptor__base_a1fb9de45567df344090a1407aa6b775f}{descriptor\+\_\+base}를 구현.



\hyperlink{classavdecc__lib_1_1configuration__descriptor__imp_aa94307532fbb37e2f986fee8fec79373}{configuration\+\_\+descriptor\+\_\+imp}에서 재구현되었습니다.



descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 109 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
110 \{
111     \textcolor{keywordflow}{return} 0xffff;
112 \}
\end{DoxyCode}
\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!localized\+\_\+description@{localized\+\_\+description}}
\index{localized\+\_\+description@{localized\+\_\+description}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{localized\+\_\+description()=0}{localized_description()=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI uint16\+\_\+t S\+T\+D\+C\+A\+LL localized\+\_\+description (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base_a1fb9de45567df344090a1407aa6b775f}{}\label{classavdecc__lib_1_1descriptor__base_a1fb9de45567df344090a1407aa6b775f}
\begin{DoxyReturn}{반환값}
The localized string reference pointing to the localized descriptor name. 
\end{DoxyReturn}


\hyperlink{classavdecc__lib_1_1configuration__descriptor__imp_aa94307532fbb37e2f986fee8fec79373}{configuration\+\_\+descriptor\+\_\+imp}, \hyperlink{classavdecc__lib_1_1descriptor__base__imp_aa94307532fbb37e2f986fee8fec79373}{descriptor\+\_\+base\+\_\+imp}에서 구현되었습니다.



이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base_a1fb9de45567df344090a1407aa6b775f_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!lock\+\_\+entity\+\_\+flags@{lock\+\_\+entity\+\_\+flags}}
\index{lock\+\_\+entity\+\_\+flags@{lock\+\_\+entity\+\_\+flags}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{lock\+\_\+entity\+\_\+flags()=0}{lock_entity_flags()=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI {\bf uint32\+\_\+t} S\+T\+D\+C\+A\+LL lock\+\_\+entity\+\_\+flags (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base_a757e66272bba4c52cefa914df8c60bb5}{}\label{classavdecc__lib_1_1descriptor__base_a757e66272bba4c52cefa914df8c60bb5}
\begin{DoxyReturn}{반환값}
The flags after sending a L\+O\+C\+K\+\_\+\+E\+N\+T\+I\+TY command and receiving a response back for the command. 
\end{DoxyReturn}


\hyperlink{classavdecc__lib_1_1descriptor__base__imp_afe2564a2a32f83deced28efa17f332e2}{descriptor\+\_\+base\+\_\+imp}, \hyperlink{classavdecc__lib_1_1entity__descriptor__imp_afe2564a2a32f83deced28efa17f332e2}{entity\+\_\+descriptor\+\_\+imp}에서 구현되었습니다.



이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=298pt]{classavdecc__lib_1_1descriptor__base_a757e66272bba4c52cefa914df8c60bb5_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!lock\+\_\+entity\+\_\+flags@{lock\+\_\+entity\+\_\+flags}}
\index{lock\+\_\+entity\+\_\+flags@{lock\+\_\+entity\+\_\+flags}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{lock\+\_\+entity\+\_\+flags()}{lock_entity_flags()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\+\_\+t} S\+T\+D\+C\+A\+LL lock\+\_\+entity\+\_\+flags (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_afe2564a2a32f83deced28efa17f332e2}{}\label{classavdecc__lib_1_1descriptor__base__imp_afe2564a2a32f83deced28efa17f332e2}
Get the flags after sending a L\+O\+C\+K\+\_\+\+E\+N\+T\+I\+TY command and receiving a response back for the command. 

\hyperlink{classavdecc__lib_1_1descriptor__base_a757e66272bba4c52cefa914df8c60bb5}{descriptor\+\_\+base}를 구현.



\hyperlink{classavdecc__lib_1_1entity__descriptor__imp_afe2564a2a32f83deced28efa17f332e2}{entity\+\_\+descriptor\+\_\+imp}에서 재구현되었습니다.



descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 124 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
125 \{
126     \textcolor{keywordflow}{return} 0;
127 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=241pt]{classavdecc__lib_1_1descriptor__base__imp_afe2564a2a32f83deced28efa17f332e2_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!lock\+\_\+entity\+\_\+locked\+\_\+entity\+\_\+id@{lock\+\_\+entity\+\_\+locked\+\_\+entity\+\_\+id}}
\index{lock\+\_\+entity\+\_\+locked\+\_\+entity\+\_\+id@{lock\+\_\+entity\+\_\+locked\+\_\+entity\+\_\+id}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{lock\+\_\+entity\+\_\+locked\+\_\+entity\+\_\+id()=0}{lock_entity_locked_entity_id()=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI {\bf uint64\+\_\+t} S\+T\+D\+C\+A\+LL lock\+\_\+entity\+\_\+locked\+\_\+entity\+\_\+id (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base_a052b47529d0e60ca87894159fcb65e14}{}\label{classavdecc__lib_1_1descriptor__base_a052b47529d0e60ca87894159fcb65e14}
\begin{DoxyReturn}{반환값}
The locked entity id after sending a L\+O\+C\+K\+\_\+\+E\+N\+T\+I\+TY command and receiving a response back for the command. 
\end{DoxyReturn}


\hyperlink{classavdecc__lib_1_1descriptor__base__imp_aeb8f096d55f82522516cbf00a616246a}{descriptor\+\_\+base\+\_\+imp}, \hyperlink{classavdecc__lib_1_1entity__descriptor__imp_aeb8f096d55f82522516cbf00a616246a}{entity\+\_\+descriptor\+\_\+imp}에서 구현되었습니다.



이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=306pt]{classavdecc__lib_1_1descriptor__base_a052b47529d0e60ca87894159fcb65e14_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!lock\+\_\+entity\+\_\+locked\+\_\+entity\+\_\+id@{lock\+\_\+entity\+\_\+locked\+\_\+entity\+\_\+id}}
\index{lock\+\_\+entity\+\_\+locked\+\_\+entity\+\_\+id@{lock\+\_\+entity\+\_\+locked\+\_\+entity\+\_\+id}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{lock\+\_\+entity\+\_\+locked\+\_\+entity\+\_\+id()}{lock_entity_locked_entity_id()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint64\+\_\+t} S\+T\+D\+C\+A\+LL lock\+\_\+entity\+\_\+locked\+\_\+entity\+\_\+id (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_aeb8f096d55f82522516cbf00a616246a}{}\label{classavdecc__lib_1_1descriptor__base__imp_aeb8f096d55f82522516cbf00a616246a}
Get the locked entity id after sending a L\+O\+C\+K\+\_\+\+E\+N\+T\+I\+TY command and receiving a response back for the command. 

\hyperlink{classavdecc__lib_1_1descriptor__base_a052b47529d0e60ca87894159fcb65e14}{descriptor\+\_\+base}를 구현.



\hyperlink{classavdecc__lib_1_1entity__descriptor__imp_aeb8f096d55f82522516cbf00a616246a}{entity\+\_\+descriptor\+\_\+imp}에서 재구현되었습니다.



descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 129 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
130 \{
131     \textcolor{keywordflow}{return} 0;
132 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=249pt]{classavdecc__lib_1_1descriptor__base__imp_aeb8f096d55f82522516cbf00a616246a_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!proc\+\_\+acquire\+\_\+entity\+\_\+resp@{proc\+\_\+acquire\+\_\+entity\+\_\+resp}}
\index{proc\+\_\+acquire\+\_\+entity\+\_\+resp@{proc\+\_\+acquire\+\_\+entity\+\_\+resp}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{proc\+\_\+acquire\+\_\+entity\+\_\+resp(void $\ast$\&notification\+\_\+id, const uint8\+\_\+t $\ast$frame, size\+\_\+t frame\+\_\+len, int \&status)}{proc_acquire_entity_resp(void *&notification_id, const uint8_t *frame, size_t frame_len, int &status)}}]{\setlength{\rightskip}{0pt plus 5cm}int proc\+\_\+acquire\+\_\+entity\+\_\+resp (
\begin{DoxyParamCaption}
\item[{void $\ast$\&}]{notification\+\_\+id, }
\item[{const {\bf uint8\+\_\+t} $\ast$}]{frame, }
\item[{size\+\_\+t}]{frame\+\_\+len, }
\item[{int \&}]{status}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_a934de13d0b017574d514ce276180a004}{}\label{classavdecc__lib_1_1descriptor__base__imp_a934de13d0b017574d514ce276180a004}


\hyperlink{classavdecc__lib_1_1entity__descriptor__imp_a934de13d0b017574d514ce276180a004}{entity\+\_\+descriptor\+\_\+imp}에서 재구현되었습니다.



descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 143 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
144 \{
145     (void)notification\_id; \textcolor{comment}{//unused}
146     (void)\hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame};
147     (void)frame\_len;
148     (void)status;
149 
150     \hyperlink{namespaceavdecc__lib_acbe3e2a96ae6524943ca532c87a28529}{log\_imp\_ref}->\hyperlink{classavdecc__lib_1_1log_a68139a6297697e4ccebf36ccfd02e44a}{post\_log\_msg}(\hyperlink{namespaceavdecc__lib_a501055c431e6872ef46f252ad13f85cdaf2c4481208273451a6f5c7bb9770ec8a}{LOGGING\_LEVEL\_ERROR}, \textcolor{stringliteral}{"Need to
       override proc\_acquire\_entity\_resp.\(\backslash\)n"});
151     \textcolor{keywordflow}{return} 0;
152 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_a934de13d0b017574d514ce276180a004_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_a934de13d0b017574d514ce276180a004_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!proc\+\_\+add\+\_\+audio\+\_\+mappings\+\_\+resp@{proc\+\_\+add\+\_\+audio\+\_\+mappings\+\_\+resp}}
\index{proc\+\_\+add\+\_\+audio\+\_\+mappings\+\_\+resp@{proc\+\_\+add\+\_\+audio\+\_\+mappings\+\_\+resp}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{proc\+\_\+add\+\_\+audio\+\_\+mappings\+\_\+resp(void $\ast$\&notification\+\_\+id, const uint8\+\_\+t $\ast$frame, size\+\_\+t frame\+\_\+len, int \&status)}{proc_add_audio_mappings_resp(void *&notification_id, const uint8_t *frame, size_t frame_len, int &status)}}]{\setlength{\rightskip}{0pt plus 5cm}int proc\+\_\+add\+\_\+audio\+\_\+mappings\+\_\+resp (
\begin{DoxyParamCaption}
\item[{void $\ast$\&}]{notification\+\_\+id, }
\item[{const {\bf uint8\+\_\+t} $\ast$}]{frame, }
\item[{size\+\_\+t}]{frame\+\_\+len, }
\item[{int \&}]{status}
\end{DoxyParamCaption}
)}\hypertarget{classavdecc__lib_1_1stream__port__output__descriptor__imp_a70814551b88eadc6577730d6bc680723}{}\label{classavdecc__lib_1_1stream__port__output__descriptor__imp_a70814551b88eadc6577730d6bc680723}


stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp.\+cpp 파일의 252 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
253 \{
254     \textcolor{keyword}{struct }\hyperlink{structjdksavdecc__frame}{jdksavdecc\_frame} cmd\_frame;
255     \textcolor{keyword}{struct }\hyperlink{structjdksavdecc__aem__command__add__audio__mappings__response}{jdksavdecc\_aem\_command\_add\_audio\_mappings\_response}
       aem\_cmd\_add\_audio\_mappings\_resp;
256     ssize\_t aem\_cmd\_add\_audio\_mappings\_resp\_returned;
257     \hyperlink{parse_8c_a6eb1e68cc391dd753bc8ce896dbb8315}{uint32\_t} msg\_type;
258     \textcolor{keywordtype}{bool} u\_field;
259 
260     memcpy(cmd\_frame.payload, \hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, frame\_len);
261     memset(&aem\_cmd\_add\_audio\_mappings\_resp, 0, \textcolor{keyword}{sizeof}(
      \hyperlink{structjdksavdecc__aem__command__add__audio__mappings__response}{jdksavdecc\_aem\_command\_add\_audio\_mappings\_response}));
262 
263     aem\_cmd\_add\_audio\_mappings\_resp\_returned = 
      \hyperlink{group__command__add__audio__mappings__response_ga865d122ac12aa8ff911c20322b5ff13f}{jdksavdecc\_aem\_command\_add\_audio\_mappings\_response\_read}
      (&aem\_cmd\_add\_audio\_mappings\_resp,
264                                                                                                        
      \hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame},
265                                                                                                        
      \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE},
266                                                                                                        
      frame\_len);
267 
268     \textcolor{keywordflow}{if} (aem\_cmd\_add\_audio\_mappings\_resp\_returned < 0)
269     \{
270         \hyperlink{namespaceavdecc__lib_acbe3e2a96ae6524943ca532c87a28529}{log\_imp\_ref}->\hyperlink{classavdecc__lib_1_1log_a68139a6297697e4ccebf36ccfd02e44a}{post\_log\_msg}(\hyperlink{namespaceavdecc__lib_a501055c431e6872ef46f252ad13f85cdaf2c4481208273451a6f5c7bb9770ec8a}{LOGGING\_LEVEL\_ERROR}, \textcolor{stringliteral}{"
      aem\_cmd\_add\_audio\_mappings\_resp\_read error\(\backslash\)n"});
271         assert(aem\_cmd\_add\_audio\_mappings\_resp\_returned >= 0);
272         \textcolor{keywordflow}{return} -1;
273     \}
274 
275     msg\_type = aem\_cmd\_add\_audio\_mappings\_resp.aem\_header.aecpdu\_header.header.message\_type;
276     status = aem\_cmd\_add\_audio\_mappings\_resp.aem\_header.aecpdu\_header.header.status;
277     u\_field = aem\_cmd\_add\_audio\_mappings\_resp.aem\_header.command\_type >> 15 & 0x01; \textcolor{comment}{// u\_field = the msb of
       the uint16\_t command\_type}
278 
279     \hyperlink{namespaceavdecc__lib_a0b1b5aea3c0490f77cbfd9178af5be22}{aecp\_controller\_state\_machine\_ref}->
      \hyperlink{classavdecc__lib_1_1aecp__controller__state__machine_a997abd9786c330a5505e903e6443208e}{update\_inflight\_for\_rcvd\_resp}(notification\_id, msg\_type, u\_field, &cmd\_frame);
280 
281     \textcolor{keywordflow}{return} 0;
282 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1stream__port__output__descriptor__imp_a70814551b88eadc6577730d6bc680723_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1stream__port__output__descriptor__imp_a70814551b88eadc6577730d6bc680723_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!proc\+\_\+get\+\_\+audio\+\_\+map\+\_\+resp@{proc\+\_\+get\+\_\+audio\+\_\+map\+\_\+resp}}
\index{proc\+\_\+get\+\_\+audio\+\_\+map\+\_\+resp@{proc\+\_\+get\+\_\+audio\+\_\+map\+\_\+resp}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{proc\+\_\+get\+\_\+audio\+\_\+map\+\_\+resp(void $\ast$\&notification\+\_\+id, const uint8\+\_\+t $\ast$frame, size\+\_\+t frame\+\_\+len, int \&status)}{proc_get_audio_map_resp(void *&notification_id, const uint8_t *frame, size_t frame_len, int &status)}}]{\setlength{\rightskip}{0pt plus 5cm}int proc\+\_\+get\+\_\+audio\+\_\+map\+\_\+resp (
\begin{DoxyParamCaption}
\item[{void $\ast$\&}]{notification\+\_\+id, }
\item[{const {\bf uint8\+\_\+t} $\ast$}]{frame, }
\item[{size\+\_\+t}]{frame\+\_\+len, }
\item[{int \&}]{status}
\end{DoxyParamCaption}
)}\hypertarget{classavdecc__lib_1_1stream__port__output__descriptor__imp_aadd7ab4cda0474cfe2444de48e5823fd}{}\label{classavdecc__lib_1_1stream__port__output__descriptor__imp_aadd7ab4cda0474cfe2444de48e5823fd}


stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp.\+cpp 파일의 134 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
135 \{
136     \textcolor{keyword}{struct }\hyperlink{structjdksavdecc__frame}{jdksavdecc\_frame} cmd\_frame;
137     \textcolor{keyword}{struct }\hyperlink{structjdksavdecc__aem__command__get__audio__map__response}{jdksavdecc\_aem\_command\_get\_audio\_map\_response} 
      aem\_cmd\_get\_audio\_map\_resp;
138     ssize\_t aem\_cmd\_get\_audio\_map\_resp\_returned;
139     \hyperlink{parse_8c_a6eb1e68cc391dd753bc8ce896dbb8315}{uint32\_t} msg\_type;
140     \textcolor{keywordtype}{bool} u\_field;
141 
142     memcpy(cmd\_frame.payload, \hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, frame\_len);
143     memset(&aem\_cmd\_get\_audio\_map\_resp, 0, \textcolor{keyword}{sizeof}(
      \hyperlink{structjdksavdecc__aem__command__get__audio__map__response}{jdksavdecc\_aem\_command\_get\_audio\_map\_response}));
144 
145     aem\_cmd\_get\_audio\_map\_resp\_returned = 
      \hyperlink{group__command__get__audio__map__response_gaa5c9113e9338a304ff217f3ea6cd92d2}{jdksavdecc\_aem\_command\_get\_audio\_map\_response\_read}(&
      aem\_cmd\_get\_audio\_map\_resp,
146                                                                                              
      \hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame},
147                                                                                              
      \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE},
148                                                                                              frame\_len);
149 
150     \textcolor{keywordflow}{if} (aem\_cmd\_get\_audio\_map\_resp\_returned < 0)
151     \{
152         \hyperlink{namespaceavdecc__lib_acbe3e2a96ae6524943ca532c87a28529}{log\_imp\_ref}->\hyperlink{classavdecc__lib_1_1log_a68139a6297697e4ccebf36ccfd02e44a}{post\_log\_msg}(\hyperlink{namespaceavdecc__lib_a501055c431e6872ef46f252ad13f85cdaf2c4481208273451a6f5c7bb9770ec8a}{LOGGING\_LEVEL\_ERROR}, \textcolor{stringliteral}{"
      aem\_cmd\_get\_audio\_map\_resp\_read error\(\backslash\)n"});
153         assert(aem\_cmd\_get\_audio\_map\_resp\_returned >= 0);
154         \textcolor{keywordflow}{return} -1;
155     \}
156 
157     \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a482fe95208e9e14885e28e73e7be2c49}{replace\_frame}(\hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE}, frame\_len);
158 
159     msg\_type = aem\_cmd\_get\_audio\_map\_resp.aem\_header.aecpdu\_header.header.message\_type;
160     status = aem\_cmd\_get\_audio\_map\_resp.aem\_header.aecpdu\_header.header.status;
161     u\_field = aem\_cmd\_get\_audio\_map\_resp.aem\_header.command\_type >> 15 & 0x01; \textcolor{comment}{// u\_field = the msb of the
       uint16\_t command\_type}
162 
163     \hyperlink{namespaceavdecc__lib_a0b1b5aea3c0490f77cbfd9178af5be22}{aecp\_controller\_state\_machine\_ref}->
      \hyperlink{classavdecc__lib_1_1aecp__controller__state__machine_a997abd9786c330a5505e903e6443208e}{update\_inflight\_for\_rcvd\_resp}(notification\_id, msg\_type, u\_field, &cmd\_frame);
164 
165     \textcolor{keywordflow}{return} 0;
166 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1stream__port__output__descriptor__imp_aadd7ab4cda0474cfe2444de48e5823fd_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1stream__port__output__descriptor__imp_aadd7ab4cda0474cfe2444de48e5823fd_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!proc\+\_\+get\+\_\+name\+\_\+resp@{proc\+\_\+get\+\_\+name\+\_\+resp}}
\index{proc\+\_\+get\+\_\+name\+\_\+resp@{proc\+\_\+get\+\_\+name\+\_\+resp}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{proc\+\_\+get\+\_\+name\+\_\+resp(void $\ast$\&notification\+\_\+id, const uint8\+\_\+t $\ast$frame, size\+\_\+t frame\+\_\+len, int \&status)}{proc_get_name_resp(void *&notification_id, const uint8_t *frame, size_t frame_len, int &status)}}]{\setlength{\rightskip}{0pt plus 5cm}int proc\+\_\+get\+\_\+name\+\_\+resp (
\begin{DoxyParamCaption}
\item[{void $\ast$\&}]{notification\+\_\+id, }
\item[{const {\bf uint8\+\_\+t} $\ast$}]{frame, }
\item[{size\+\_\+t}]{frame\+\_\+len, }
\item[{int \&}]{status}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_ac4e290a88039a8e4915f7b9f8738881f}{}\label{classavdecc__lib_1_1descriptor__base__imp_ac4e290a88039a8e4915f7b9f8738881f}


descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 623 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
624 \{
625     \textcolor{keyword}{struct }\hyperlink{structjdksavdecc__aem__command__get__name__response}{jdksavdecc\_aem\_command\_get\_name\_response} 
      aem\_cmd\_get\_name\_resp;
626     memset(&aem\_cmd\_get\_name\_resp, 0, \textcolor{keyword}{sizeof}(
      \hyperlink{structjdksavdecc__aem__command__get__name__response}{jdksavdecc\_aem\_command\_get\_name\_response}));
627     \textcolor{keywordflow}{return} \hyperlink{classavdecc__lib_1_1descriptor__base__imp_acc8b1c1591bd54bc9a2d21d4f0db2e86}{default\_proc\_get\_name\_resp}(aem\_cmd\_get\_name\_resp, notification\_id, 
      \hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, frame\_len, status);
628 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_ac4e290a88039a8e4915f7b9f8738881f_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_ac4e290a88039a8e4915f7b9f8738881f_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!proc\+\_\+lock\+\_\+entity\+\_\+resp@{proc\+\_\+lock\+\_\+entity\+\_\+resp}}
\index{proc\+\_\+lock\+\_\+entity\+\_\+resp@{proc\+\_\+lock\+\_\+entity\+\_\+resp}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{proc\+\_\+lock\+\_\+entity\+\_\+resp(void $\ast$\&notification\+\_\+id, const uint8\+\_\+t $\ast$frame, size\+\_\+t frame\+\_\+len, int \&status)}{proc_lock_entity_resp(void *&notification_id, const uint8_t *frame, size_t frame_len, int &status)}}]{\setlength{\rightskip}{0pt plus 5cm}int proc\+\_\+lock\+\_\+entity\+\_\+resp (
\begin{DoxyParamCaption}
\item[{void $\ast$\&}]{notification\+\_\+id, }
\item[{const {\bf uint8\+\_\+t} $\ast$}]{frame, }
\item[{size\+\_\+t}]{frame\+\_\+len, }
\item[{int \&}]{status}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_a6cd2b73ea95b18f07dbdc251140679b0}{}\label{classavdecc__lib_1_1descriptor__base__imp_a6cd2b73ea95b18f07dbdc251140679b0}


\hyperlink{classavdecc__lib_1_1entity__descriptor__imp_a6cd2b73ea95b18f07dbdc251140679b0}{entity\+\_\+descriptor\+\_\+imp}에서 재구현되었습니다.



descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 240 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
241 \{
242     (void)notification\_id; \textcolor{comment}{//unused}
243     (void)\hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame};
244     (void)frame\_len;
245     (void)status;
246 
247     \hyperlink{namespaceavdecc__lib_acbe3e2a96ae6524943ca532c87a28529}{log\_imp\_ref}->\hyperlink{classavdecc__lib_1_1log_a68139a6297697e4ccebf36ccfd02e44a}{post\_log\_msg}(\hyperlink{namespaceavdecc__lib_a501055c431e6872ef46f252ad13f85cdaf2c4481208273451a6f5c7bb9770ec8a}{LOGGING\_LEVEL\_ERROR}, \textcolor{stringliteral}{"Need to
       override proc\_lock\_entity\_resp.\(\backslash\)n"});
248 
249     \textcolor{keywordflow}{return} 0;
250 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_a6cd2b73ea95b18f07dbdc251140679b0_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_a6cd2b73ea95b18f07dbdc251140679b0_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!proc\+\_\+reboot\+\_\+resp@{proc\+\_\+reboot\+\_\+resp}}
\index{proc\+\_\+reboot\+\_\+resp@{proc\+\_\+reboot\+\_\+resp}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{proc\+\_\+reboot\+\_\+resp(void $\ast$\&notification\+\_\+id, const uint8\+\_\+t $\ast$frame, size\+\_\+t frame\+\_\+len, int \&status)}{proc_reboot_resp(void *&notification_id, const uint8_t *frame, size_t frame_len, int &status)}}]{\setlength{\rightskip}{0pt plus 5cm}int proc\+\_\+reboot\+\_\+resp (
\begin{DoxyParamCaption}
\item[{void $\ast$\&}]{notification\+\_\+id, }
\item[{const {\bf uint8\+\_\+t} $\ast$}]{frame, }
\item[{size\+\_\+t}]{frame\+\_\+len, }
\item[{int \&}]{status}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_a8b3de398748e8299daf7296964f73c22}{}\label{classavdecc__lib_1_1descriptor__base__imp_a8b3de398748e8299daf7296964f73c22}


\hyperlink{classavdecc__lib_1_1entity__descriptor__imp_a8b3de398748e8299daf7296964f73c22}{entity\+\_\+descriptor\+\_\+imp}에서 재구현되었습니다.



descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 337 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
338 \{
339     (void)notification\_id; \textcolor{comment}{//unused}
340     (void)\hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame};
341     (void)frame\_len;
342     (void)status;
343 
344     \hyperlink{namespaceavdecc__lib_acbe3e2a96ae6524943ca532c87a28529}{log\_imp\_ref}->\hyperlink{classavdecc__lib_1_1log_a68139a6297697e4ccebf36ccfd02e44a}{post\_log\_msg}(\hyperlink{namespaceavdecc__lib_a501055c431e6872ef46f252ad13f85cdaf2c4481208273451a6f5c7bb9770ec8a}{LOGGING\_LEVEL\_ERROR}, \textcolor{stringliteral}{"Need to
       override proc\_reboot\_resp.\(\backslash\)n"});
345 
346     \textcolor{keywordflow}{return} 0;
347 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_a8b3de398748e8299daf7296964f73c22_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=243pt]{classavdecc__lib_1_1descriptor__base__imp_a8b3de398748e8299daf7296964f73c22_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!proc\+\_\+remove\+\_\+audio\+\_\+mappings\+\_\+resp@{proc\+\_\+remove\+\_\+audio\+\_\+mappings\+\_\+resp}}
\index{proc\+\_\+remove\+\_\+audio\+\_\+mappings\+\_\+resp@{proc\+\_\+remove\+\_\+audio\+\_\+mappings\+\_\+resp}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{proc\+\_\+remove\+\_\+audio\+\_\+mappings\+\_\+resp(void $\ast$\&notification\+\_\+id, const uint8\+\_\+t $\ast$frame, size\+\_\+t frame\+\_\+len, int \&status)}{proc_remove_audio_mappings_resp(void *&notification_id, const uint8_t *frame, size_t frame_len, int &status)}}]{\setlength{\rightskip}{0pt plus 5cm}int proc\+\_\+remove\+\_\+audio\+\_\+mappings\+\_\+resp (
\begin{DoxyParamCaption}
\item[{void $\ast$\&}]{notification\+\_\+id, }
\item[{const {\bf uint8\+\_\+t} $\ast$}]{frame, }
\item[{size\+\_\+t}]{frame\+\_\+len, }
\item[{int \&}]{status}
\end{DoxyParamCaption}
)}\hypertarget{classavdecc__lib_1_1stream__port__output__descriptor__imp_acb59e12bd075d86e8d9af20713a6e1fb}{}\label{classavdecc__lib_1_1stream__port__output__descriptor__imp_acb59e12bd075d86e8d9af20713a6e1fb}


stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp.\+cpp 파일의 368 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
369 \{
370     \textcolor{keyword}{struct }\hyperlink{structjdksavdecc__frame}{jdksavdecc\_frame} cmd\_frame;
371     \textcolor{keyword}{struct }\hyperlink{structjdksavdecc__aem__command__remove__audio__mappings__response}{jdksavdecc\_aem\_command\_remove\_audio\_mappings\_response}
       aem\_cmd\_remove\_audio\_mappings\_resp;
372     ssize\_t aem\_cmd\_remove\_audio\_mappings\_resp\_returned;
373     \hyperlink{parse_8c_a6eb1e68cc391dd753bc8ce896dbb8315}{uint32\_t} msg\_type;
374     \textcolor{keywordtype}{bool} u\_field;
375 
376     memcpy(cmd\_frame.payload, \hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, frame\_len);
377     memset(&aem\_cmd\_remove\_audio\_mappings\_resp, 0, \textcolor{keyword}{sizeof}(
      \hyperlink{structjdksavdecc__aem__command__remove__audio__mappings__response}{jdksavdecc\_aem\_command\_remove\_audio\_mappings\_response})
      );
378 
379     aem\_cmd\_remove\_audio\_mappings\_resp\_returned = 
      \hyperlink{group__command__remove__audio__mappings__response_ga5455bc63492c65ab461084dbfe25ecde}{jdksavdecc\_aem\_command\_remove\_audio\_mappings\_response\_read}
      (&aem\_cmd\_remove\_audio\_mappings\_resp,
380                                                                                                            
        \hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame},
381                                                                                                            
        \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE},
382                                                                                                            
        frame\_len);
383 
384     \textcolor{keywordflow}{if} (aem\_cmd\_remove\_audio\_mappings\_resp\_returned < 0)
385     \{
386         \hyperlink{namespaceavdecc__lib_acbe3e2a96ae6524943ca532c87a28529}{log\_imp\_ref}->\hyperlink{classavdecc__lib_1_1log_a68139a6297697e4ccebf36ccfd02e44a}{post\_log\_msg}(\hyperlink{namespaceavdecc__lib_a501055c431e6872ef46f252ad13f85cdaf2c4481208273451a6f5c7bb9770ec8a}{LOGGING\_LEVEL\_ERROR}, \textcolor{stringliteral}{"
      aem\_cmd\_remove\_audio\_mappings\_resp\_read error\(\backslash\)n"});
387         assert(aem\_cmd\_remove\_audio\_mappings\_resp\_returned >= 0);
388         \textcolor{keywordflow}{return} -1;
389     \}
390 
391     msg\_type = aem\_cmd\_remove\_audio\_mappings\_resp.aem\_header.aecpdu\_header.header.message\_type;
392     status = aem\_cmd\_remove\_audio\_mappings\_resp.aem\_header.aecpdu\_header.header.status;
393     u\_field = aem\_cmd\_remove\_audio\_mappings\_resp.aem\_header.command\_type >> 15 & 0x01; \textcolor{comment}{// u\_field = the msb
       of the uint16\_t command\_type}
394 
395     \hyperlink{namespaceavdecc__lib_a0b1b5aea3c0490f77cbfd9178af5be22}{aecp\_controller\_state\_machine\_ref}->
      \hyperlink{classavdecc__lib_1_1aecp__controller__state__machine_a997abd9786c330a5505e903e6443208e}{update\_inflight\_for\_rcvd\_resp}(notification\_id, msg\_type, u\_field, &cmd\_frame);
396 
397     \textcolor{keywordflow}{return} 0;
398 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1stream__port__output__descriptor__imp_acb59e12bd075d86e8d9af20713a6e1fb_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1stream__port__output__descriptor__imp_acb59e12bd075d86e8d9af20713a6e1fb_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!proc\+\_\+set\+\_\+name\+\_\+resp@{proc\+\_\+set\+\_\+name\+\_\+resp}}
\index{proc\+\_\+set\+\_\+name\+\_\+resp@{proc\+\_\+set\+\_\+name\+\_\+resp}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{proc\+\_\+set\+\_\+name\+\_\+resp(void $\ast$\&notification\+\_\+id, const uint8\+\_\+t $\ast$frame, size\+\_\+t frame\+\_\+len, int \&status)}{proc_set_name_resp(void *&notification_id, const uint8_t *frame, size_t frame_len, int &status)}}]{\setlength{\rightskip}{0pt plus 5cm}int proc\+\_\+set\+\_\+name\+\_\+resp (
\begin{DoxyParamCaption}
\item[{void $\ast$\&}]{notification\+\_\+id, }
\item[{const {\bf uint8\+\_\+t} $\ast$}]{frame, }
\item[{size\+\_\+t}]{frame\+\_\+len, }
\item[{int \&}]{status}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_a182c43d9f31980bb74f05956b1323624}{}\label{classavdecc__lib_1_1descriptor__base__imp_a182c43d9f31980bb74f05956b1323624}


descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 426 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
427 \{
428     \textcolor{keyword}{struct }\hyperlink{structjdksavdecc__aem__command__set__name__response}{jdksavdecc\_aem\_command\_set\_name\_response} 
      aem\_cmd\_set\_name\_resp;
429     \textcolor{keywordflow}{return} \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2f52c3b9a7ad6f490bed0c96a9136bc3}{default\_proc\_set\_name\_resp}(aem\_cmd\_set\_name\_resp, notification\_id, 
      \hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, frame\_len, status);
430 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_a182c43d9f31980bb74f05956b1323624_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_a182c43d9f31980bb74f05956b1323624_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!replace\+\_\+desc\+\_\+frame@{replace\+\_\+desc\+\_\+frame}}
\index{replace\+\_\+desc\+\_\+frame@{replace\+\_\+desc\+\_\+frame}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{replace\+\_\+desc\+\_\+frame(const uint8\+\_\+t $\ast$frame, ssize\+\_\+t pos, size\+\_\+t size)}{replace_desc_frame(const uint8_t *frame, ssize_t pos, size_t size)}}]{\setlength{\rightskip}{0pt plus 5cm}void S\+T\+D\+C\+A\+LL replace\+\_\+desc\+\_\+frame (
\begin{DoxyParamCaption}
\item[{const {\bf uint8\+\_\+t} $\ast$}]{frame, }
\item[{ssize\+\_\+t}]{pos, }
\item[{size\+\_\+t}]{size}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_a8dbf7d4faedf36ec789d33f228e22039}{}\label{classavdecc__lib_1_1descriptor__base__imp_a8dbf7d4faedf36ec789d33f228e22039}
Replace the frame for descriptors. 

descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 93 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
94 \{
95     std::lock\_guard<std::mutex> guard(\hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\_end\_station\_imp\_ref}->
      \hyperlink{classavdecc__lib_1_1end__station__imp_a2207f93fef130266b292686bf96ef8d3}{locker}); \textcolor{comment}{//mutex lock the end station}
96     \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2642e3a7c10d38553e7ff4a55e875346}{resp\_ref}->\hyperlink{classavdecc__lib_1_1response__frame_a438c7ec184b6d10ffcd8bc97a4cfa773}{replace\_desc\_frame}(\hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, pos, \hyperlink{gst__avb__playbin_8c_a439227feff9d7f55384e8780cfc2eb82}{size});
97 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_a8dbf7d4faedf36ec789d33f228e22039_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=550pt]{classavdecc__lib_1_1descriptor__base__imp_a8dbf7d4faedf36ec789d33f228e22039_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!replace\+\_\+frame@{replace\+\_\+frame}}
\index{replace\+\_\+frame@{replace\+\_\+frame}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{replace\+\_\+frame(const uint8\+\_\+t $\ast$frame, ssize\+\_\+t pos, size\+\_\+t size)}{replace_frame(const uint8_t *frame, ssize_t pos, size_t size)}}]{\setlength{\rightskip}{0pt plus 5cm}void S\+T\+D\+C\+A\+LL replace\+\_\+frame (
\begin{DoxyParamCaption}
\item[{const {\bf uint8\+\_\+t} $\ast$}]{frame, }
\item[{ssize\+\_\+t}]{pos, }
\item[{size\+\_\+t}]{size}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_a482fe95208e9e14885e28e73e7be2c49}{}\label{classavdecc__lib_1_1descriptor__base__imp_a482fe95208e9e14885e28e73e7be2c49}
Replace the frame for counters/commands. 

descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 87 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
88 \{
89     std::lock\_guard<std::mutex> guard(\hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\_end\_station\_imp\_ref}->
      \hyperlink{classavdecc__lib_1_1end__station__imp_a2207f93fef130266b292686bf96ef8d3}{locker}); \textcolor{comment}{//mutex lock the end station}
90     \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2642e3a7c10d38553e7ff4a55e875346}{resp\_ref}->\hyperlink{classavdecc__lib_1_1response__frame_adaac07821dba7c4ae2c35642d67a9a37}{replace\_frame}(\hyperlink{gst__avb__playbin_8c_ac8e710e0b5e994c0545d75d69868c6f0}{frame}, pos, \hyperlink{gst__avb__playbin_8c_a439227feff9d7f55384e8780cfc2eb82}{size});
91 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_a482fe95208e9e14885e28e73e7be2c49_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_a482fe95208e9e14885e28e73e7be2c49_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!send\+\_\+acquire\+\_\+entity\+\_\+cmd@{send\+\_\+acquire\+\_\+entity\+\_\+cmd}}
\index{send\+\_\+acquire\+\_\+entity\+\_\+cmd@{send\+\_\+acquire\+\_\+entity\+\_\+cmd}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{send\+\_\+acquire\+\_\+entity\+\_\+cmd(void $\ast$notification\+\_\+id, uint32\+\_\+t acquire\+\_\+entity\+\_\+flag)=0}{send_acquire_entity_cmd(void *notification_id, uint32_t acquire_entity_flag)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI int S\+T\+D\+C\+A\+LL send\+\_\+acquire\+\_\+entity\+\_\+cmd (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{notification\+\_\+id, }
\item[{{\bf uint32\+\_\+t}}]{acquire\+\_\+entity\+\_\+flag}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base_adfd0cf2a51bff7d762b0efc743480c48}{}\label{classavdecc__lib_1_1descriptor__base_adfd0cf2a51bff7d762b0efc743480c48}
Send a A\+C\+Q\+U\+R\+E\+\_\+\+E\+N\+T\+I\+TY command to obtain exclusive access to an entire Entity or a sub-\/tree of objects.


\begin{DoxyParams}{매개변수}
{\em notification\+\_\+id} & A void pointer to the unique identifier associated with the command. \\
\hline
{\em acquire\+\_\+entity\+\_\+flag} & The flag to be set for the command. Valid flags are 0, 1 (P\+E\+R\+S\+I\+S\+T\+E\+NT), and 0x80000000 (R\+E\+L\+E\+A\+SE).\\
\hline
\end{DoxyParams}
The flags and owner id can be retrieved by calling the following function after successfully receiving a response back for the A\+C\+Q\+U\+R\+E\+\_\+\+E\+N\+T\+I\+TY command sent.

\begin{DoxySeeAlso}{참고}
\hyperlink{classavdecc__lib_1_1descriptor__base_a42f2a796375edd05c8d29856c018042d}{acquire\+\_\+entity\+\_\+flags()}, \hyperlink{classavdecc__lib_1_1descriptor__base_a6480d803970d505ce7a9b429a6eb71bd}{acquire\+\_\+entity\+\_\+owner\+\_\+entity\+\_\+id()} 
\end{DoxySeeAlso}


\hyperlink{classavdecc__lib_1_1descriptor__base__imp_aea9e3053b75477816c15487d3e9a6f70}{descriptor\+\_\+base\+\_\+imp}, \hyperlink{classavdecc__lib_1_1entity__descriptor__imp_aea9e3053b75477816c15487d3e9a6f70}{entity\+\_\+descriptor\+\_\+imp}에서 구현되었습니다.



이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base_adfd0cf2a51bff7d762b0efc743480c48_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!send\+\_\+acquire\+\_\+entity\+\_\+cmd@{send\+\_\+acquire\+\_\+entity\+\_\+cmd}}
\index{send\+\_\+acquire\+\_\+entity\+\_\+cmd@{send\+\_\+acquire\+\_\+entity\+\_\+cmd}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{send\+\_\+acquire\+\_\+entity\+\_\+cmd(void $\ast$notification\+\_\+id, uint32\+\_\+t acquire\+\_\+entity\+\_\+flag)}{send_acquire_entity_cmd(void *notification_id, uint32_t acquire_entity_flag)}}]{\setlength{\rightskip}{0pt plus 5cm}int S\+T\+D\+C\+A\+LL send\+\_\+acquire\+\_\+entity\+\_\+cmd (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{notification\+\_\+id, }
\item[{{\bf uint32\+\_\+t}}]{acquire\+\_\+entity\+\_\+flag}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_aea9e3053b75477816c15487d3e9a6f70}{}\label{classavdecc__lib_1_1descriptor__base__imp_aea9e3053b75477816c15487d3e9a6f70}
Send a A\+C\+Q\+U\+R\+E\+\_\+\+E\+N\+T\+I\+TY command to obtain exclusive access to an entire Entity or a sub-\/tree of objects.


\begin{DoxyParams}{매개변수}
{\em notification\+\_\+id} & A void pointer to the unique identifier associated with the command. \\
\hline
{\em acquire\+\_\+entity\+\_\+flag} & The flag to be set for the command. Valid flags are 0, 1 (P\+E\+R\+S\+I\+S\+T\+E\+NT), and 0x80000000 (R\+E\+L\+E\+A\+SE).\\
\hline
\end{DoxyParams}
The flags and owner id can be retrieved by calling the following function after successfully receiving a response back for the A\+C\+Q\+U\+R\+E\+\_\+\+E\+N\+T\+I\+TY command sent.

\begin{DoxySeeAlso}{참고}
\hyperlink{classavdecc__lib_1_1descriptor__base__imp_a2d270d205bcea948cf61311a1f8336c6}{acquire\+\_\+entity\+\_\+flags()}, \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a507b250a984bb5611d2699cd26d60a51}{acquire\+\_\+entity\+\_\+owner\+\_\+entity\+\_\+id()} 
\end{DoxySeeAlso}


\hyperlink{classavdecc__lib_1_1descriptor__base_adfd0cf2a51bff7d762b0efc743480c48}{descriptor\+\_\+base}를 구현.



\hyperlink{classavdecc__lib_1_1entity__descriptor__imp_aea9e3053b75477816c15487d3e9a6f70}{entity\+\_\+descriptor\+\_\+imp}에서 재구현되었습니다.



descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 134 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
135 \{
136     (void)notification\_id; \textcolor{comment}{//unused}
137     (void)acquire\_entity\_flag;
138 
139     \hyperlink{namespaceavdecc__lib_acbe3e2a96ae6524943ca532c87a28529}{log\_imp\_ref}->\hyperlink{classavdecc__lib_1_1log_a68139a6297697e4ccebf36ccfd02e44a}{post\_log\_msg}(\hyperlink{namespaceavdecc__lib_a501055c431e6872ef46f252ad13f85cdaf2c4481208273451a6f5c7bb9770ec8a}{LOGGING\_LEVEL\_ERROR}, \textcolor{stringliteral}{"Need to
       override send\_acquire\_entity\_cmd.\(\backslash\)n"});
140     \textcolor{keywordflow}{return} 0;
141 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_aea9e3053b75477816c15487d3e9a6f70_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=279pt]{classavdecc__lib_1_1descriptor__base__imp_aea9e3053b75477816c15487d3e9a6f70_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!send\+\_\+add\+\_\+audio\+\_\+mappings\+\_\+cmd@{send\+\_\+add\+\_\+audio\+\_\+mappings\+\_\+cmd}}
\index{send\+\_\+add\+\_\+audio\+\_\+mappings\+\_\+cmd@{send\+\_\+add\+\_\+audio\+\_\+mappings\+\_\+cmd}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{send\+\_\+add\+\_\+audio\+\_\+mappings\+\_\+cmd(void $\ast$notification\+\_\+id)}{send_add_audio_mappings_cmd(void *notification_id)}}]{\setlength{\rightskip}{0pt plus 5cm}int S\+T\+D\+C\+A\+LL send\+\_\+add\+\_\+audio\+\_\+mappings\+\_\+cmd (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{notification\+\_\+id}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classavdecc__lib_1_1stream__port__output__descriptor__imp_a607418ce38a1e4cbb44bd670eb0f398b}{}\label{classavdecc__lib_1_1stream__port__output__descriptor__imp_a607418ce38a1e4cbb44bd670eb0f398b}
Send an A\+D\+D\+\_\+\+A\+U\+D\+I\+O\+\_\+\+M\+A\+P\+P\+I\+N\+GS command to add mapping entries to the dynamic mappings between the Audio Clusters and the input or output Streams. This command sends up to the maximum number of mappings specified by 1722.\+1. If more mappings are pending, this command should be called multiple times.

The mappings to be added are stored in a local queue. \begin{DoxySeeAlso}{참고}
\hyperlink{classavdecc__lib_1_1stream__port__output__descriptor__imp_a8ca55047d151e78b3804fcdbf04282e8}{store\+\_\+pending\+\_\+map()}.
\end{DoxySeeAlso}

\begin{DoxyParams}{매개변수}
{\em notification\+\_\+id} & A void pointer to the unique identifier associated with the command.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{반환값}
0 if there are no pending mappings after sending the command. ~\newline
 1 if there are more pending mappings after sending the command. 
\end{DoxyReturn}


\hyperlink{classavdecc__lib_1_1stream__port__output__descriptor_a5d94b5190eaba5a650afd90d6e483d72}{stream\+\_\+port\+\_\+output\+\_\+descriptor}를 구현.



stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp.\+cpp 파일의 168 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
169 \{
170     \textcolor{keywordtype}{int} i = 0;
171     \textcolor{keyword}{struct }\hyperlink{structjdksavdecc__frame}{jdksavdecc\_frame} cmd\_frame;
172     \textcolor{keyword}{struct }\hyperlink{structjdksavdecc__aem__command__add__audio__mappings}{jdksavdecc\_aem\_command\_add\_audio\_mappings} 
      aem\_cmd\_add\_audio\_mappings;
173     ssize\_t aem\_cmd\_add\_audio\_mappings\_returned;
174     memset(&aem\_cmd\_add\_audio\_mappings, 0, \textcolor{keyword}{sizeof}(aem\_cmd\_add\_audio\_mappings));
175 
176     \textcolor{comment}{/******************************************** AECP Common Data ****************************************
      *****/}
177     aem\_cmd\_add\_audio\_mappings.aem\_header.aecpdu\_header.controller\_entity\_id = 
      \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\_end\_station\_imp\_ref}->\hyperlink{classavdecc__lib_1_1end__station__imp_a471a74540ce6182fad0c17dfd010107e}{get\_adp}()->
      \hyperlink{classavdecc__lib_1_1adp_a0c0959a46658c0a22e9530334b2912da}{get\_controller\_entity\_id}();
178     \textcolor{comment}{// Fill aem\_cmd\_get\_sampling\_rate.sequence\_id in AEM Controller State Machine}
179     aem\_cmd\_add\_audio\_mappings.aem\_header.command\_type = 
      \hyperlink{group__command_gac872db287b8e91225b52129c617e1da0}{JDKSAVDECC\_AEM\_COMMAND\_ADD\_AUDIO\_MAPPINGS};
180 
181     \textcolor{comment}{/****************** AECP Message Specific Data *****************/}
182     aem\_cmd\_add\_audio\_mappings.descriptor\_type = \hyperlink{classavdecc__lib_1_1descriptor__base__imp_aefc543029ab093823c3f5b9d84f0ccc4}{descriptor\_type}();
183     aem\_cmd\_add\_audio\_mappings.descriptor\_index = \hyperlink{classavdecc__lib_1_1descriptor__base__imp_ac23c0a35276c07cfce8c8660700c2135}{descriptor\_index}();
184     \textcolor{keywordflow}{if} (\hyperlink{classavdecc__lib_1_1stream__port__output__descriptor__imp_ae0c1781344cc1ecdf12d9624ae930ccd}{pending\_maps}.size() > \hyperlink{namespaceavdecc__lib_a97844c4fa619487e53c2854a07fd34d7aeea9bc815c3177c9b296244acb544cc9}{AEM\_MAX\_MAPS})
185     \{
186         aem\_cmd\_add\_audio\_mappings.number\_of\_mappings = \hyperlink{namespaceavdecc__lib_a97844c4fa619487e53c2854a07fd34d7aeea9bc815c3177c9b296244acb544cc9}{AEM\_MAX\_MAPS};
187     \}
188     \textcolor{keywordflow}{else}
189     \{
190         aem\_cmd\_add\_audio\_mappings.number\_of\_mappings = (uint16\_t)\hyperlink{classavdecc__lib_1_1stream__port__output__descriptor__imp_ae0c1781344cc1ecdf12d9624ae930ccd}{pending\_maps}.size();
191     \}
192 
193     \textcolor{comment}{/******************************* Fill frame payload with AECP data and send the frame *****************
      *********/}
194     \hyperlink{namespaceavdecc__lib_a0b1b5aea3c0490f77cbfd9178af5be22}{aecp\_controller\_state\_machine\_ref}->
      \hyperlink{classavdecc__lib_1_1aecp__controller__state__machine_a86ff947c5e6b799cfb877d3767bfa1f9}{ether\_frame\_init}(\hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\_end\_station\_imp\_ref}->
      \hyperlink{classavdecc__lib_1_1end__station__imp_a08e1bd1861b3b8f447ea374a65ac11f9}{mac}(), &cmd\_frame,
195                                                         \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE} + 
      \hyperlink{group__command__add__audio__mappings_ga861cb37521da0ee33e15de79c08c65e8}{JDKSAVDECC\_AEM\_COMMAND\_ADD\_AUDIO\_MAPPINGS\_COMMAND\_LEN} 
      +
196                                                             (uint16\_t)
      \hyperlink{classavdecc__lib_1_1stream__port__output__descriptor__imp_ae0c1781344cc1ecdf12d9624ae930ccd}{pending\_maps}.size() * \hyperlink{group__audio__mapping_ga0dd006bf2320b99909db301f043f0cae}{JDKSAVDECC\_AUDIO\_MAPPING\_LEN});
197     aem\_cmd\_add\_audio\_mappings\_returned = 
      \hyperlink{group__command__add__audio__mappings_ga406afad9c22c864d81b8737f39eaf2cc}{jdksavdecc\_aem\_command\_add\_audio\_mappings\_write}(&
      aem\_cmd\_add\_audio\_mappings,
198                                                                                           cmd\_frame.payload
      ,
199                                                                                           
      \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE},
200                                                                                           \textcolor{keyword}{sizeof}(cmd\_frame.
      payload));
201     \textcolor{keywordflow}{if} (aem\_cmd\_add\_audio\_mappings\_returned < 0)
202     \{
203         \hyperlink{namespaceavdecc__lib_acbe3e2a96ae6524943ca532c87a28529}{log\_imp\_ref}->\hyperlink{classavdecc__lib_1_1log_a68139a6297697e4ccebf36ccfd02e44a}{post\_log\_msg}(\hyperlink{namespaceavdecc__lib_a501055c431e6872ef46f252ad13f85cdaf2c4481208273451a6f5c7bb9770ec8a}{LOGGING\_LEVEL\_ERROR}, \textcolor{stringliteral}{"
      aem\_cmd\_add\_audio\_mappings\_write error\(\backslash\)n"});
204         assert(aem\_cmd\_add\_audio\_mappings\_returned >= 0);
205         \textcolor{keywordflow}{return} -1;
206     \}
207 
208     \textcolor{keywordtype}{size\_t} num\_pending\_maps = \hyperlink{classavdecc__lib_1_1stream__port__output__descriptor__imp_ae0c1781344cc1ecdf12d9624ae930ccd}{pending\_maps}.size();
209     std::vector<struct audio\_map\_mapping>::iterator it = \hyperlink{classavdecc__lib_1_1stream__port__output__descriptor__imp_ae0c1781344cc1ecdf12d9624ae930ccd}{pending\_maps}.begin();
210     \textcolor{keywordflow}{while} (it != \hyperlink{classavdecc__lib_1_1stream__port__output__descriptor__imp_ae0c1781344cc1ecdf12d9624ae930ccd}{pending\_maps}.end())
211     \{
212         \textcolor{keywordflow}{if} (i >= \hyperlink{namespaceavdecc__lib_a97844c4fa619487e53c2854a07fd34d7aeea9bc815c3177c9b296244acb544cc9}{AEM\_MAX\_MAPS})
213             \textcolor{keywordflow}{break};
214 
215         \textcolor{keyword}{struct }\hyperlink{structavdecc__lib_1_1audio__map__mapping}{avdecc\_lib::audio\_map\_mapping} map = *it;
216 
217         \hyperlink{group__endian_ga14b9eeadc05f94334096c127c955a60b}{jdksavdecc\_uint16\_set}(map.\hyperlink{structavdecc__lib_1_1audio__map__mapping_acad3919f1d34fc0ae26a5508175defb1}{stream\_index}, cmd\_frame.payload, 
      \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE} +
218                                                                        
      \hyperlink{group__command__add__audio__mappings_gae6e0d2f9951c1e0f947cde329e626569}{JDKSAVDECC\_AEM\_COMMAND\_ADD\_AUDIO\_MAPPINGS\_COMMAND\_OFFSET\_MAPPINGS}
       + \hyperlink{group__audio__mapping_ga0dd006bf2320b99909db301f043f0cae}{JDKSAVDECC\_AUDIO\_MAPPING\_LEN} * i +
219                                                                        
      \hyperlink{group__audio__mapping_gaff17abcbae620dedc2c0f683b6148b8f}{JDKSAVDECC\_AUDIO\_MAPPING\_OFFSET\_MAPPING\_STREAM\_INDEX});
220         \hyperlink{group__endian_ga14b9eeadc05f94334096c127c955a60b}{jdksavdecc\_uint16\_set}(map.\hyperlink{structavdecc__lib_1_1audio__map__mapping_a99de82258f8163098a8ff558abf07af7}{stream\_channel}, cmd\_frame.payload, 
      \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE} +
221                                                                          
      \hyperlink{group__command__add__audio__mappings_gae6e0d2f9951c1e0f947cde329e626569}{JDKSAVDECC\_AEM\_COMMAND\_ADD\_AUDIO\_MAPPINGS\_COMMAND\_OFFSET\_MAPPINGS}
       +
222                                                                          (
      \hyperlink{group__audio__mapping_ga0dd006bf2320b99909db301f043f0cae}{JDKSAVDECC\_AUDIO\_MAPPING\_LEN} * i + 
      \hyperlink{group__audio__mapping_ga2b4b83a34d5baf5fd8eeaffc6eebbb30}{JDKSAVDECC\_AUDIO\_MAPPING\_OFFSET\_MAPPING\_STREAM\_CHANNEL}
      ));
223         \hyperlink{group__endian_ga14b9eeadc05f94334096c127c955a60b}{jdksavdecc\_uint16\_set}(map.\hyperlink{structavdecc__lib_1_1audio__map__mapping_ad255a47e83b1a3056865a81c5f3a2545}{cluster\_offset}, cmd\_frame.payload, 
      \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE} +
224                                                                          
      \hyperlink{group__command__add__audio__mappings_gae6e0d2f9951c1e0f947cde329e626569}{JDKSAVDECC\_AEM\_COMMAND\_ADD\_AUDIO\_MAPPINGS\_COMMAND\_OFFSET\_MAPPINGS}
       +
225                                                                          (
      \hyperlink{group__audio__mapping_ga0dd006bf2320b99909db301f043f0cae}{JDKSAVDECC\_AUDIO\_MAPPING\_LEN} * i + 
      \hyperlink{group__audio__mapping_ga174ac05daccbcd25f401eac241ad6667}{JDKSAVDECC\_AUDIO\_MAPPING\_OFFSET\_MAPPING\_CLUSTER\_OFFSET}
      ));
226         \hyperlink{group__endian_ga14b9eeadc05f94334096c127c955a60b}{jdksavdecc\_uint16\_set}(map.\hyperlink{structavdecc__lib_1_1audio__map__mapping_ad7ad28dde5b77668bff26372dab9ea76}{cluster\_channel}, cmd\_frame.payload, 
      \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE} +
227                                                                           
      \hyperlink{group__command__add__audio__mappings_gae6e0d2f9951c1e0f947cde329e626569}{JDKSAVDECC\_AEM\_COMMAND\_ADD\_AUDIO\_MAPPINGS\_COMMAND\_OFFSET\_MAPPINGS}
       +
228                                                                           (
      \hyperlink{group__audio__mapping_ga0dd006bf2320b99909db301f043f0cae}{JDKSAVDECC\_AUDIO\_MAPPING\_LEN} * i + 
      \hyperlink{group__audio__mapping_ga625a930d4963bce1d448347efdd150ce}{JDKSAVDECC\_AUDIO\_MAPPING\_OFFSET\_MAPPING\_CLUSTER\_CHANNEL}
      ));
229 
230         \hyperlink{classavdecc__lib_1_1stream__port__output__descriptor__imp_ae0c1781344cc1ecdf12d9624ae930ccd}{pending\_maps}.erase(it);
231         it = \hyperlink{classavdecc__lib_1_1stream__port__output__descriptor__imp_ae0c1781344cc1ecdf12d9624ae930ccd}{pending\_maps}.begin();
232         i++;
233     \}
234 
235     \hyperlink{namespaceavdecc__lib_a0b1b5aea3c0490f77cbfd9178af5be22}{aecp\_controller\_state\_machine\_ref}->
      \hyperlink{classavdecc__lib_1_1aecp__controller__state__machine_aafc737d7ed17a62fed9df6528f18d3ec}{common\_hdr\_init}(\hyperlink{group__aecp__message__type_ga4625ce189cc209f42deb0629f48faf69}{JDKSAVDECC\_AECP\_MESSAGE\_TYPE\_AEM\_COMMAND}
      ,
236                                                        &cmd\_frame,
237                                                        \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\_end\_station\_imp\_ref}->
      \hyperlink{classavdecc__lib_1_1end__station__imp_a363b6c9664a0d701def9b17863e20ad3}{entity\_id}(),
238                                                        
      \hyperlink{group__command__add__audio__mappings_ga861cb37521da0ee33e15de79c08c65e8}{JDKSAVDECC\_AEM\_COMMAND\_ADD\_AUDIO\_MAPPINGS\_COMMAND\_LEN} 
      -
239                                                            
      \hyperlink{group__jdksavdecc__avtp__common__control__header_gaae84052886fb1bb42f3bc5f85b741dff}{JDKSAVDECC\_COMMON\_CONTROL\_HEADER\_LEN});
240     \hyperlink{namespaceavdecc__lib_a6dd511685627c0865a3442b539a4e8e9}{system\_queue\_tx}(notification\_id, \hyperlink{namespaceavdecc__lib_aabcadff06aa62be0ce47bc0646823604aba48b8a017e06fb240b650cdea965178}{CMD\_WITH\_NOTIFICATION}, cmd\_frame.
      payload, cmd\_frame.length);
241 
242     \textcolor{keywordflow}{if} (num\_pending\_maps > \hyperlink{namespaceavdecc__lib_a97844c4fa619487e53c2854a07fd34d7aeea9bc815c3177c9b296244acb544cc9}{AEM\_MAX\_MAPS})
243     \{
244         \textcolor{keywordflow}{return} 1;
245     \}
246     \textcolor{keywordflow}{else}
247     \{
248         \textcolor{keywordflow}{return} 0;
249     \}
250 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1stream__port__output__descriptor__imp_a607418ce38a1e4cbb44bd670eb0f398b_cgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!send\+\_\+get\+\_\+audio\+\_\+map\+\_\+cmd@{send\+\_\+get\+\_\+audio\+\_\+map\+\_\+cmd}}
\index{send\+\_\+get\+\_\+audio\+\_\+map\+\_\+cmd@{send\+\_\+get\+\_\+audio\+\_\+map\+\_\+cmd}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{send\+\_\+get\+\_\+audio\+\_\+map\+\_\+cmd(void $\ast$notification\+\_\+id, uint16\+\_\+t mapping\+\_\+index)}{send_get_audio_map_cmd(void *notification_id, uint16_t mapping_index)}}]{\setlength{\rightskip}{0pt plus 5cm}int S\+T\+D\+C\+A\+LL send\+\_\+get\+\_\+audio\+\_\+map\+\_\+cmd (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{notification\+\_\+id, }
\item[{uint16\+\_\+t}]{mapping\+\_\+index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classavdecc__lib_1_1stream__port__output__descriptor__imp_a23b5816691c09ead5cc4a90a72222c9f}{}\label{classavdecc__lib_1_1stream__port__output__descriptor__imp_a23b5816691c09ead5cc4a90a72222c9f}
Send a G\+E\+T\+\_\+\+A\+U\+D\+I\+O\+\_\+\+M\+AP command to fetch the dynamic mapping between the Audio Clusters and the input or output streams.


\begin{DoxyParams}{매개변수}
{\em notification\+\_\+id} & A void pointer to the unique identifier associated with the command. \\
\hline
\end{DoxyParams}


\hyperlink{classavdecc__lib_1_1stream__port__output__descriptor_a685ec3b997e066fc3530a3cd213f581b}{stream\+\_\+port\+\_\+output\+\_\+descriptor}를 구현.



stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp.\+cpp 파일의 93 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
94 \{
95     \textcolor{keyword}{struct }\hyperlink{structjdksavdecc__frame}{jdksavdecc\_frame} cmd\_frame;
96     \textcolor{keyword}{struct }\hyperlink{structjdksavdecc__aem__command__get__audio__map}{jdksavdecc\_aem\_command\_get\_audio\_map} aem\_cmd\_get\_audio\_map;
97     ssize\_t aem\_cmd\_get\_audio\_map\_returned;
98     memset(&aem\_cmd\_get\_audio\_map, 0, \textcolor{keyword}{sizeof}(aem\_cmd\_get\_audio\_map));
99 
100     \textcolor{comment}{/******************************************** AECP Common Data ****************************************
      *****/}
101     aem\_cmd\_get\_audio\_map.aem\_header.aecpdu\_header.controller\_entity\_id = 
      \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\_end\_station\_imp\_ref}->\hyperlink{classavdecc__lib_1_1end__station__imp_a471a74540ce6182fad0c17dfd010107e}{get\_adp}()->
      \hyperlink{classavdecc__lib_1_1adp_a0c0959a46658c0a22e9530334b2912da}{get\_controller\_entity\_id}();
102     \textcolor{comment}{// Fill aem\_cmd\_get\_sampling\_rate.sequence\_id in AEM Controller State Machine}
103     aem\_cmd\_get\_audio\_map.aem\_header.command\_type = 
      \hyperlink{group__command_ga5d806d56b7dfd0104e5e127c910dbb65}{JDKSAVDECC\_AEM\_COMMAND\_GET\_AUDIO\_MAP};
104 
105     \textcolor{comment}{/****************** AECP Message Specific Data *****************/}
106     aem\_cmd\_get\_audio\_map.descriptor\_type = \hyperlink{classavdecc__lib_1_1descriptor__base__imp_aefc543029ab093823c3f5b9d84f0ccc4}{descriptor\_type}();
107     aem\_cmd\_get\_audio\_map.descriptor\_index = \hyperlink{classavdecc__lib_1_1descriptor__base__imp_ac23c0a35276c07cfce8c8660700c2135}{descriptor\_index}();
108     aem\_cmd\_get\_audio\_map.map\_index = mapping\_index;
109 
110     \textcolor{comment}{/******************************* Fill frame payload with AECP data and send the frame *****************
      *********/}
111     \hyperlink{namespaceavdecc__lib_a0b1b5aea3c0490f77cbfd9178af5be22}{aecp\_controller\_state\_machine\_ref}->
      \hyperlink{classavdecc__lib_1_1aecp__controller__state__machine_a86ff947c5e6b799cfb877d3767bfa1f9}{ether\_frame\_init}(\hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\_end\_station\_imp\_ref}->
      \hyperlink{classavdecc__lib_1_1end__station__imp_a08e1bd1861b3b8f447ea374a65ac11f9}{mac}(), &cmd\_frame,
112                                                         \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE} + 
      \hyperlink{group__command__get__audio__map_ga7b45da8d0aff8a96f43af7c25003dfcc}{JDKSAVDECC\_AEM\_COMMAND\_GET\_AUDIO\_MAP\_COMMAND\_LEN});
113     aem\_cmd\_get\_audio\_map\_returned = \hyperlink{group__command__get__audio__map_gab104d4a38d80dcee98d130f0c1f7a9b8}{jdksavdecc\_aem\_command\_get\_audio\_map\_write}
      (&aem\_cmd\_get\_audio\_map,
114                                                                                 cmd\_frame.payload,
115                                                                                 
      \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE},
116                                                                                 \textcolor{keyword}{sizeof}(cmd\_frame.payload));
117     \textcolor{keywordflow}{if} (aem\_cmd\_get\_audio\_map\_returned < 0)
118     \{
119         \hyperlink{namespaceavdecc__lib_acbe3e2a96ae6524943ca532c87a28529}{log\_imp\_ref}->\hyperlink{classavdecc__lib_1_1log_a68139a6297697e4ccebf36ccfd02e44a}{post\_log\_msg}(\hyperlink{namespaceavdecc__lib_a501055c431e6872ef46f252ad13f85cdaf2c4481208273451a6f5c7bb9770ec8a}{LOGGING\_LEVEL\_ERROR}, \textcolor{stringliteral}{"
      aem\_cmd\_get\_audio\_map\_write error\(\backslash\)n"});
120         assert(aem\_cmd\_get\_audio\_map\_returned >= 0);
121         \textcolor{keywordflow}{return} -1;
122     \}
123 
124     \hyperlink{namespaceavdecc__lib_a0b1b5aea3c0490f77cbfd9178af5be22}{aecp\_controller\_state\_machine\_ref}->
      \hyperlink{classavdecc__lib_1_1aecp__controller__state__machine_aafc737d7ed17a62fed9df6528f18d3ec}{common\_hdr\_init}(\hyperlink{group__aecp__message__type_ga4625ce189cc209f42deb0629f48faf69}{JDKSAVDECC\_AECP\_MESSAGE\_TYPE\_AEM\_COMMAND}
      ,
125                                                        &cmd\_frame,
126                                                        \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\_end\_station\_imp\_ref}->
      \hyperlink{classavdecc__lib_1_1end__station__imp_a363b6c9664a0d701def9b17863e20ad3}{entity\_id}(),
127                                                        
      \hyperlink{group__command__get__audio__map_ga7b45da8d0aff8a96f43af7c25003dfcc}{JDKSAVDECC\_AEM\_COMMAND\_GET\_AUDIO\_MAP\_COMMAND\_LEN} -
128                                                            
      \hyperlink{group__jdksavdecc__avtp__common__control__header_gaae84052886fb1bb42f3bc5f85b741dff}{JDKSAVDECC\_COMMON\_CONTROL\_HEADER\_LEN});
129     \hyperlink{namespaceavdecc__lib_a6dd511685627c0865a3442b539a4e8e9}{system\_queue\_tx}(notification\_id, \hyperlink{namespaceavdecc__lib_aabcadff06aa62be0ce47bc0646823604aba48b8a017e06fb240b650cdea965178}{CMD\_WITH\_NOTIFICATION}, cmd\_frame.
      payload, cmd\_frame.length);
130 
131     \textcolor{keywordflow}{return} 0;
132 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1stream__port__output__descriptor__imp_a23b5816691c09ead5cc4a90a72222c9f_cgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!send\+\_\+get\+\_\+name\+\_\+cmd@{send\+\_\+get\+\_\+name\+\_\+cmd}}
\index{send\+\_\+get\+\_\+name\+\_\+cmd@{send\+\_\+get\+\_\+name\+\_\+cmd}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{send\+\_\+get\+\_\+name\+\_\+cmd(void $\ast$notification\+\_\+id, uint16\+\_\+t name\+\_\+index, uint16\+\_\+t config\+\_\+index)=0}{send_get_name_cmd(void *notification_id, uint16_t name_index, uint16_t config_index)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI int S\+T\+D\+C\+A\+LL send\+\_\+get\+\_\+name\+\_\+cmd (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{notification\+\_\+id, }
\item[{uint16\+\_\+t}]{name\+\_\+index, }
\item[{uint16\+\_\+t}]{config\+\_\+index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base_a27ba9959456de53a8de18eead74806f7}{}\label{classavdecc__lib_1_1descriptor__base_a27ba9959456de53a8de18eead74806f7}
Send a G\+E\+T\+\_\+\+N\+A\+ME command to get the value of a name field within a descriptor. For descriptors with multiple names, this sets only one specified name.


\begin{DoxyParams}{매개변수}
{\em notification\+\_\+id} & A void pointer to the unique identifier associated with the command. \\
\hline
{\em name\+\_\+index} & The index of the name within the descriptor, with the first name being index 0 and so on. \\
\hline
{\em config\+\_\+index} & The descriptor index of the configuration, which contains the descriptor whose name is being set. If the descriptor type field is either E\+N\+T\+I\+TY or C\+O\+N\+F\+I\+G\+U\+R\+A\+T\+I\+ON, then this field is set to 0. \\
\hline
\end{DoxyParams}


\hyperlink{classavdecc__lib_1_1descriptor__base__imp_a4e8ce103baabbd5fc07deabfb95f791a}{descriptor\+\_\+base\+\_\+imp}에서 구현되었습니다.



이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base_a27ba9959456de53a8de18eead74806f7_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!send\+\_\+get\+\_\+name\+\_\+cmd@{send\+\_\+get\+\_\+name\+\_\+cmd}}
\index{send\+\_\+get\+\_\+name\+\_\+cmd@{send\+\_\+get\+\_\+name\+\_\+cmd}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{send\+\_\+get\+\_\+name\+\_\+cmd(void $\ast$notification\+\_\+id, uint16\+\_\+t name\+\_\+index, uint16\+\_\+t config\+\_\+index)}{send_get_name_cmd(void *notification_id, uint16_t name_index, uint16_t config_index)}}]{\setlength{\rightskip}{0pt plus 5cm}int S\+T\+D\+C\+A\+LL send\+\_\+get\+\_\+name\+\_\+cmd (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{notification\+\_\+id, }
\item[{uint16\+\_\+t}]{name\+\_\+index, }
\item[{uint16\+\_\+t}]{config\+\_\+index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_a4e8ce103baabbd5fc07deabfb95f791a}{}\label{classavdecc__lib_1_1descriptor__base__imp_a4e8ce103baabbd5fc07deabfb95f791a}
Send a G\+E\+T\+\_\+\+N\+A\+ME command to get the value of a name field within a descriptor. For descriptors with multiple names, this sets only one specified name.


\begin{DoxyParams}{매개변수}
{\em notification\+\_\+id} & A void pointer to the unique identifier associated with the command. \\
\hline
{\em name\+\_\+index} & The index of the name within the descriptor, with the first name being index 0 and so on. \\
\hline
{\em config\+\_\+index} & The descriptor index of the configuration, which contains the descriptor whose name is being set. If the descriptor type field is either E\+N\+T\+I\+TY or C\+O\+N\+F\+I\+G\+U\+R\+A\+T\+I\+ON, then this field is set to 0. \\
\hline
\end{DoxyParams}


\hyperlink{classavdecc__lib_1_1descriptor__base_a27ba9959456de53a8de18eead74806f7}{descriptor\+\_\+base}를 구현.



descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 618 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
619 \{
620     \textcolor{keywordflow}{return} \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a92f2c88d261418872a496a8145800751}{default\_send\_get\_name\_cmd}(\textcolor{keyword}{this}, notification\_id, name\_index, 
      config\_index);
621 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_a4e8ce103baabbd5fc07deabfb95f791a_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=261pt]{classavdecc__lib_1_1descriptor__base__imp_a4e8ce103baabbd5fc07deabfb95f791a_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!send\+\_\+lock\+\_\+entity\+\_\+cmd@{send\+\_\+lock\+\_\+entity\+\_\+cmd}}
\index{send\+\_\+lock\+\_\+entity\+\_\+cmd@{send\+\_\+lock\+\_\+entity\+\_\+cmd}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{send\+\_\+lock\+\_\+entity\+\_\+cmd(void $\ast$notification\+\_\+id, uint32\+\_\+t lock\+\_\+entity\+\_\+flag)=0}{send_lock_entity_cmd(void *notification_id, uint32_t lock_entity_flag)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI int S\+T\+D\+C\+A\+LL send\+\_\+lock\+\_\+entity\+\_\+cmd (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{notification\+\_\+id, }
\item[{{\bf uint32\+\_\+t}}]{lock\+\_\+entity\+\_\+flag}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base_a1ac1f5c700f4eebd37b7c45498b36bbc}{}\label{classavdecc__lib_1_1descriptor__base_a1ac1f5c700f4eebd37b7c45498b36bbc}
Send a L\+O\+C\+K\+\_\+\+E\+N\+T\+I\+TY command to provide short term exclusive access to the A\+V\+D\+E\+CC Entity to perform atomic operations.


\begin{DoxyParams}{매개변수}
{\em notification\+\_\+id} & A void pointer to the unique identifier associated with the command. \\
\hline
{\em lock\+\_\+entity\+\_\+flag} & The flag to be set for the command. Valid flags are 0 and 1 (U\+N\+L\+O\+CK).\\
\hline
\end{DoxyParams}
The flags and locked entity id can be retrieved by calling the following function after successfully receiving a response back for the L\+O\+C\+K\+\_\+\+E\+N\+T\+I\+TY command sent.

\begin{DoxySeeAlso}{참고}
\hyperlink{classavdecc__lib_1_1descriptor__base_a757e66272bba4c52cefa914df8c60bb5}{lock\+\_\+entity\+\_\+flags()}, \hyperlink{classavdecc__lib_1_1descriptor__base_a052b47529d0e60ca87894159fcb65e14}{lock\+\_\+entity\+\_\+locked\+\_\+entity\+\_\+id()} 
\end{DoxySeeAlso}


\hyperlink{classavdecc__lib_1_1descriptor__base__imp_a26fd66d8c409502eaa4dba47742ca7fa}{descriptor\+\_\+base\+\_\+imp}, \hyperlink{classavdecc__lib_1_1entity__descriptor__imp_a26fd66d8c409502eaa4dba47742ca7fa}{entity\+\_\+descriptor\+\_\+imp}에서 구현되었습니다.



이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base_a1ac1f5c700f4eebd37b7c45498b36bbc_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!send\+\_\+lock\+\_\+entity\+\_\+cmd@{send\+\_\+lock\+\_\+entity\+\_\+cmd}}
\index{send\+\_\+lock\+\_\+entity\+\_\+cmd@{send\+\_\+lock\+\_\+entity\+\_\+cmd}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{send\+\_\+lock\+\_\+entity\+\_\+cmd(void $\ast$notification\+\_\+id, uint32\+\_\+t lock\+\_\+entity\+\_\+flag)}{send_lock_entity_cmd(void *notification_id, uint32_t lock_entity_flag)}}]{\setlength{\rightskip}{0pt plus 5cm}int S\+T\+D\+C\+A\+LL send\+\_\+lock\+\_\+entity\+\_\+cmd (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{notification\+\_\+id, }
\item[{{\bf uint32\+\_\+t}}]{lock\+\_\+entity\+\_\+flag}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_a26fd66d8c409502eaa4dba47742ca7fa}{}\label{classavdecc__lib_1_1descriptor__base__imp_a26fd66d8c409502eaa4dba47742ca7fa}
Send a L\+O\+C\+K\+\_\+\+E\+N\+T\+I\+TY command to provide short term exclusive access to the A\+V\+D\+E\+CC Entity to perform atomic operations.


\begin{DoxyParams}{매개변수}
{\em notification\+\_\+id} & A void pointer to the unique identifier associated with the command. \\
\hline
{\em lock\+\_\+entity\+\_\+flag} & The flag to be set for the command. Valid flags are 0 and 1 (U\+N\+L\+O\+CK).\\
\hline
\end{DoxyParams}
The flags and locked entity id can be retrieved by calling the following function after successfully receiving a response back for the L\+O\+C\+K\+\_\+\+E\+N\+T\+I\+TY command sent.

\begin{DoxySeeAlso}{참고}
\hyperlink{classavdecc__lib_1_1descriptor__base__imp_afe2564a2a32f83deced28efa17f332e2}{lock\+\_\+entity\+\_\+flags()}, \hyperlink{classavdecc__lib_1_1descriptor__base__imp_aeb8f096d55f82522516cbf00a616246a}{lock\+\_\+entity\+\_\+locked\+\_\+entity\+\_\+id()} 
\end{DoxySeeAlso}


\hyperlink{classavdecc__lib_1_1descriptor__base_a1ac1f5c700f4eebd37b7c45498b36bbc}{descriptor\+\_\+base}를 구현.



\hyperlink{classavdecc__lib_1_1entity__descriptor__imp_a26fd66d8c409502eaa4dba47742ca7fa}{entity\+\_\+descriptor\+\_\+imp}에서 재구현되었습니다.



descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 230 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
231 \{
232     (void)notification\_id; \textcolor{comment}{//unused}
233     (void)lock\_entity\_flag;
234 
235     \hyperlink{namespaceavdecc__lib_acbe3e2a96ae6524943ca532c87a28529}{log\_imp\_ref}->\hyperlink{classavdecc__lib_1_1log_a68139a6297697e4ccebf36ccfd02e44a}{post\_log\_msg}(\hyperlink{namespaceavdecc__lib_a501055c431e6872ef46f252ad13f85cdaf2c4481208273451a6f5c7bb9770ec8a}{LOGGING\_LEVEL\_ERROR}, \textcolor{stringliteral}{"Need to
       override send\_lock\_entity\_cmd.\(\backslash\)n"});
236 
237     \textcolor{keywordflow}{return} 0;
238 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_a26fd66d8c409502eaa4dba47742ca7fa_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=265pt]{classavdecc__lib_1_1descriptor__base__imp_a26fd66d8c409502eaa4dba47742ca7fa_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!send\+\_\+reboot\+\_\+cmd@{send\+\_\+reboot\+\_\+cmd}}
\index{send\+\_\+reboot\+\_\+cmd@{send\+\_\+reboot\+\_\+cmd}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{send\+\_\+reboot\+\_\+cmd(void $\ast$notification\+\_\+id)=0}{send_reboot_cmd(void *notification_id)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI int S\+T\+D\+C\+A\+LL send\+\_\+reboot\+\_\+cmd (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{notification\+\_\+id}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base_a1618412a9b3d57a12044030b31cfd5a3}{}\label{classavdecc__lib_1_1descriptor__base_a1618412a9b3d57a12044030b31cfd5a3}
Send a R\+E\+B\+O\+OT command to the A\+V\+D\+E\+CC Entity


\begin{DoxyParams}{매개변수}
{\em notification\+\_\+id} & A void pointer to the unique identifier associated with the command. \\
\hline
{\em lock\+\_\+entity\+\_\+flag} & The flag to be set for the command. Valid flags are 0 and 1 (U\+N\+L\+O\+CK). \\
\hline
\end{DoxyParams}


\hyperlink{classavdecc__lib_1_1descriptor__base__imp_a7579db44e8e86da0f8f94aa4680df795}{descriptor\+\_\+base\+\_\+imp}, \hyperlink{classavdecc__lib_1_1entity__descriptor__imp_a7579db44e8e86da0f8f94aa4680df795}{entity\+\_\+descriptor\+\_\+imp}에서 구현되었습니다.



이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base_a1618412a9b3d57a12044030b31cfd5a3_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!send\+\_\+reboot\+\_\+cmd@{send\+\_\+reboot\+\_\+cmd}}
\index{send\+\_\+reboot\+\_\+cmd@{send\+\_\+reboot\+\_\+cmd}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{send\+\_\+reboot\+\_\+cmd(void $\ast$notification\+\_\+id)}{send_reboot_cmd(void *notification_id)}}]{\setlength{\rightskip}{0pt plus 5cm}int S\+T\+D\+C\+A\+LL send\+\_\+reboot\+\_\+cmd (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{notification\+\_\+id}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_a7579db44e8e86da0f8f94aa4680df795}{}\label{classavdecc__lib_1_1descriptor__base__imp_a7579db44e8e86da0f8f94aa4680df795}
Send a R\+E\+B\+O\+OT command to the A\+V\+D\+E\+CC Entity


\begin{DoxyParams}{매개변수}
{\em notification\+\_\+id} & A void pointer to the unique identifier associated with the command. \\
\hline
{\em lock\+\_\+entity\+\_\+flag} & The flag to be set for the command. Valid flags are 0 and 1 (U\+N\+L\+O\+CK). \\
\hline
\end{DoxyParams}


\hyperlink{classavdecc__lib_1_1descriptor__base_a1618412a9b3d57a12044030b31cfd5a3}{descriptor\+\_\+base}를 구현.



\hyperlink{classavdecc__lib_1_1entity__descriptor__imp_a7579db44e8e86da0f8f94aa4680df795}{entity\+\_\+descriptor\+\_\+imp}에서 재구현되었습니다.



descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 328 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
329 \{
330     (void)notification\_id; \textcolor{comment}{//unused}
331 
332     \hyperlink{namespaceavdecc__lib_acbe3e2a96ae6524943ca532c87a28529}{log\_imp\_ref}->\hyperlink{classavdecc__lib_1_1log_a68139a6297697e4ccebf36ccfd02e44a}{post\_log\_msg}(\hyperlink{namespaceavdecc__lib_a501055c431e6872ef46f252ad13f85cdaf2c4481208273451a6f5c7bb9770ec8a}{LOGGING\_LEVEL\_ERROR}, \textcolor{stringliteral}{"Need to
       override send\_reboot\_cmd.\(\backslash\)n"});
333 
334     \textcolor{keywordflow}{return} 0;
335 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_a7579db44e8e86da0f8f94aa4680df795_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=245pt]{classavdecc__lib_1_1descriptor__base__imp_a7579db44e8e86da0f8f94aa4680df795_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!send\+\_\+remove\+\_\+audio\+\_\+mappings\+\_\+cmd@{send\+\_\+remove\+\_\+audio\+\_\+mappings\+\_\+cmd}}
\index{send\+\_\+remove\+\_\+audio\+\_\+mappings\+\_\+cmd@{send\+\_\+remove\+\_\+audio\+\_\+mappings\+\_\+cmd}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{send\+\_\+remove\+\_\+audio\+\_\+mappings\+\_\+cmd(void $\ast$notification\+\_\+id)}{send_remove_audio_mappings_cmd(void *notification_id)}}]{\setlength{\rightskip}{0pt plus 5cm}int S\+T\+D\+C\+A\+LL send\+\_\+remove\+\_\+audio\+\_\+mappings\+\_\+cmd (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{notification\+\_\+id}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classavdecc__lib_1_1stream__port__output__descriptor__imp_af6ad50a43367920f62229d2a1f942856}{}\label{classavdecc__lib_1_1stream__port__output__descriptor__imp_af6ad50a43367920f62229d2a1f942856}
Send a R\+E\+M\+O\+V\+E\+\_\+\+A\+U\+D\+I\+O\+\_\+\+M\+A\+P\+P\+I\+N\+GS command to remove mapping entries from the dynamic mappings between the Audio Clusters and the input or output Streams. This command sends up to the maximum number of mappings specified by 1722.\+1. If more mappings are pending, this command should be called multiple times.

The mappings to be removed are stored in a local queue. \begin{DoxySeeAlso}{참고}
\hyperlink{classavdecc__lib_1_1stream__port__output__descriptor__imp_a8ca55047d151e78b3804fcdbf04282e8}{store\+\_\+pending\+\_\+map()}.
\end{DoxySeeAlso}

\begin{DoxyParams}{매개변수}
{\em notification\+\_\+id} & A void pointer to the unique identifier associated with the command.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{반환값}
0 if there are no pending mappings after sending the command. ~\newline
 1 if there are more pending mappings after sending the command. 
\end{DoxyReturn}


\hyperlink{classavdecc__lib_1_1stream__port__output__descriptor_ae22529f0333bc3efc10d16ecb3700cd5}{stream\+\_\+port\+\_\+output\+\_\+descriptor}를 구현.



stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp.\+cpp 파일의 284 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
285 \{
286     \textcolor{keywordtype}{int} i = 0;
287     \textcolor{keyword}{struct }\hyperlink{structjdksavdecc__frame}{jdksavdecc\_frame} cmd\_frame;
288     \textcolor{keyword}{struct }\hyperlink{structjdksavdecc__aem__command__remove__audio__mappings}{jdksavdecc\_aem\_command\_remove\_audio\_mappings} 
      aem\_cmd\_remove\_audio\_mappings;
289     ssize\_t aem\_cmd\_remove\_audio\_mappings\_returned;
290     memset(&aem\_cmd\_remove\_audio\_mappings, 0, \textcolor{keyword}{sizeof}(aem\_cmd\_remove\_audio\_mappings));
291 
292     \textcolor{comment}{/******************************************** AECP Common Data ****************************************
      *****/}
293     aem\_cmd\_remove\_audio\_mappings.aem\_header.aecpdu\_header.controller\_entity\_id = 
      \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\_end\_station\_imp\_ref}->\hyperlink{classavdecc__lib_1_1end__station__imp_a471a74540ce6182fad0c17dfd010107e}{get\_adp}()->
      \hyperlink{classavdecc__lib_1_1adp_a0c0959a46658c0a22e9530334b2912da}{get\_controller\_entity\_id}();
294     \textcolor{comment}{// Fill aem\_cmd\_get\_sampling\_rate.sequence\_id in AEM Controller State Machine}
295     aem\_cmd\_remove\_audio\_mappings.aem\_header.command\_type = 
      \hyperlink{group__command_gae6ee643ac7127012a5a4cc44813f52c7}{JDKSAVDECC\_AEM\_COMMAND\_REMOVE\_AUDIO\_MAPPINGS};
296 
297     \textcolor{comment}{/****************** AECP Message Specific Data *****************/}
298     aem\_cmd\_remove\_audio\_mappings.descriptor\_type = \hyperlink{classavdecc__lib_1_1descriptor__base__imp_aefc543029ab093823c3f5b9d84f0ccc4}{descriptor\_type}();
299     aem\_cmd\_remove\_audio\_mappings.descriptor\_index = \hyperlink{classavdecc__lib_1_1descriptor__base__imp_ac23c0a35276c07cfce8c8660700c2135}{descriptor\_index}();
300     \textcolor{keywordflow}{if} (\hyperlink{classavdecc__lib_1_1stream__port__output__descriptor__imp_ae0c1781344cc1ecdf12d9624ae930ccd}{pending\_maps}.size() > \hyperlink{namespaceavdecc__lib_a97844c4fa619487e53c2854a07fd34d7aeea9bc815c3177c9b296244acb544cc9}{AEM\_MAX\_MAPS})
301     \{
302         aem\_cmd\_remove\_audio\_mappings.number\_of\_mappings = \hyperlink{namespaceavdecc__lib_a97844c4fa619487e53c2854a07fd34d7aeea9bc815c3177c9b296244acb544cc9}{AEM\_MAX\_MAPS};
303     \}
304     \textcolor{keywordflow}{else}
305     \{
306         aem\_cmd\_remove\_audio\_mappings.number\_of\_mappings = (uint16\_t)
      \hyperlink{classavdecc__lib_1_1stream__port__output__descriptor__imp_ae0c1781344cc1ecdf12d9624ae930ccd}{pending\_maps}.size();
307     \}
308 
309     \textcolor{comment}{/******************************* Fill frame payload with AECP data and send the frame *****************
      *********/}
310     \hyperlink{namespaceavdecc__lib_a0b1b5aea3c0490f77cbfd9178af5be22}{aecp\_controller\_state\_machine\_ref}->
      \hyperlink{classavdecc__lib_1_1aecp__controller__state__machine_a86ff947c5e6b799cfb877d3767bfa1f9}{ether\_frame\_init}(\hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\_end\_station\_imp\_ref}->
      \hyperlink{classavdecc__lib_1_1end__station__imp_a08e1bd1861b3b8f447ea374a65ac11f9}{mac}(), &cmd\_frame,
311                                                         \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE} + 
      \hyperlink{group__command__remove__audio__mappings_ga2f5c2a11750df03fd2b890c2a1f6303c}{JDKSAVDECC\_AEM\_COMMAND\_REMOVE\_AUDIO\_MAPPINGS\_COMMAND\_LEN}
       +
312                                                             (uint16\_t)
      \hyperlink{classavdecc__lib_1_1stream__port__output__descriptor__imp_ae0c1781344cc1ecdf12d9624ae930ccd}{pending\_maps}.size() * \hyperlink{group__audio__mapping_ga0dd006bf2320b99909db301f043f0cae}{JDKSAVDECC\_AUDIO\_MAPPING\_LEN});
313     aem\_cmd\_remove\_audio\_mappings\_returned = 
      \hyperlink{group__command__remove__audio__mappings_gaa81cbfd23881b3c418e187bb590155a0}{jdksavdecc\_aem\_command\_remove\_audio\_mappings\_write}(&
      aem\_cmd\_remove\_audio\_mappings,
314                                                                                                 cmd\_frame.
      payload,
315                                                                                                 
      \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE},
316                                                                                                 \textcolor{keyword}{sizeof}(
      cmd\_frame.payload));
317     \textcolor{keywordflow}{if} (aem\_cmd\_remove\_audio\_mappings\_returned < 0)
318     \{
319         \hyperlink{namespaceavdecc__lib_acbe3e2a96ae6524943ca532c87a28529}{log\_imp\_ref}->\hyperlink{classavdecc__lib_1_1log_a68139a6297697e4ccebf36ccfd02e44a}{post\_log\_msg}(\hyperlink{namespaceavdecc__lib_a501055c431e6872ef46f252ad13f85cdaf2c4481208273451a6f5c7bb9770ec8a}{LOGGING\_LEVEL\_ERROR}, \textcolor{stringliteral}{"
      aem\_cmd\_remove\_audio\_mappings\_write error\(\backslash\)n"});
320         assert(aem\_cmd\_remove\_audio\_mappings\_returned >= 0);
321         \textcolor{keywordflow}{return} -1;
322     \}
323 
324     \textcolor{keywordtype}{size\_t} num\_pending\_maps = \hyperlink{classavdecc__lib_1_1stream__port__output__descriptor__imp_ae0c1781344cc1ecdf12d9624ae930ccd}{pending\_maps}.size();
325     std::vector<struct audio\_map\_mapping>::iterator it = \hyperlink{classavdecc__lib_1_1stream__port__output__descriptor__imp_ae0c1781344cc1ecdf12d9624ae930ccd}{pending\_maps}.begin();
326     \textcolor{keywordflow}{while} (it != \hyperlink{classavdecc__lib_1_1stream__port__output__descriptor__imp_ae0c1781344cc1ecdf12d9624ae930ccd}{pending\_maps}.end())
327     \{
328         \textcolor{keywordflow}{if} (i >= \hyperlink{namespaceavdecc__lib_a97844c4fa619487e53c2854a07fd34d7aeea9bc815c3177c9b296244acb544cc9}{AEM\_MAX\_MAPS})
329             \textcolor{keywordflow}{break};
330 
331         \textcolor{keyword}{struct }\hyperlink{structavdecc__lib_1_1audio__map__mapping}{avdecc\_lib::audio\_map\_mapping} map = *it;
332 
333         \hyperlink{group__endian_ga14b9eeadc05f94334096c127c955a60b}{jdksavdecc\_uint16\_set}(map.\hyperlink{structavdecc__lib_1_1audio__map__mapping_acad3919f1d34fc0ae26a5508175defb1}{stream\_index}, cmd\_frame.payload, 
      \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE} +
334                                                                        
      \hyperlink{group__command__remove__audio__mappings_gade5c697bfe282579c5ddd334e762f6b6}{JDKSAVDECC\_AEM\_COMMAND\_REMOVE\_AUDIO\_MAPPINGS\_COMMAND\_OFFSET\_MAPPINGS}
       + \hyperlink{group__audio__mapping_ga0dd006bf2320b99909db301f043f0cae}{JDKSAVDECC\_AUDIO\_MAPPING\_LEN} * i +
335                                                                        
      \hyperlink{group__audio__mapping_gaff17abcbae620dedc2c0f683b6148b8f}{JDKSAVDECC\_AUDIO\_MAPPING\_OFFSET\_MAPPING\_STREAM\_INDEX});
336         \hyperlink{group__endian_ga14b9eeadc05f94334096c127c955a60b}{jdksavdecc\_uint16\_set}(map.\hyperlink{structavdecc__lib_1_1audio__map__mapping_a99de82258f8163098a8ff558abf07af7}{stream\_channel}, cmd\_frame.payload, 
      \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE} +
337                                                                          
      \hyperlink{group__command__remove__audio__mappings_gade5c697bfe282579c5ddd334e762f6b6}{JDKSAVDECC\_AEM\_COMMAND\_REMOVE\_AUDIO\_MAPPINGS\_COMMAND\_OFFSET\_MAPPINGS}
       +
338                                                                          (
      \hyperlink{group__audio__mapping_ga0dd006bf2320b99909db301f043f0cae}{JDKSAVDECC\_AUDIO\_MAPPING\_LEN} * i + 
      \hyperlink{group__audio__mapping_ga2b4b83a34d5baf5fd8eeaffc6eebbb30}{JDKSAVDECC\_AUDIO\_MAPPING\_OFFSET\_MAPPING\_STREAM\_CHANNEL}
      ));
339         \hyperlink{group__endian_ga14b9eeadc05f94334096c127c955a60b}{jdksavdecc\_uint16\_set}(map.\hyperlink{structavdecc__lib_1_1audio__map__mapping_ad255a47e83b1a3056865a81c5f3a2545}{cluster\_offset}, cmd\_frame.payload, 
      \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE} +
340                                                                          
      \hyperlink{group__command__remove__audio__mappings_gade5c697bfe282579c5ddd334e762f6b6}{JDKSAVDECC\_AEM\_COMMAND\_REMOVE\_AUDIO\_MAPPINGS\_COMMAND\_OFFSET\_MAPPINGS}
       +
341                                                                          (
      \hyperlink{group__audio__mapping_ga0dd006bf2320b99909db301f043f0cae}{JDKSAVDECC\_AUDIO\_MAPPING\_LEN} * i + 
      \hyperlink{group__audio__mapping_ga174ac05daccbcd25f401eac241ad6667}{JDKSAVDECC\_AUDIO\_MAPPING\_OFFSET\_MAPPING\_CLUSTER\_OFFSET}
      ));
342         \hyperlink{group__endian_ga14b9eeadc05f94334096c127c955a60b}{jdksavdecc\_uint16\_set}(map.\hyperlink{structavdecc__lib_1_1audio__map__mapping_ad7ad28dde5b77668bff26372dab9ea76}{cluster\_channel}, cmd\_frame.payload, 
      \hyperlink{namespaceavdecc__lib_a6c827b1a0d973e18119c5e3da518e65ca9512ad9b34302ba7048d88197e0a2dc0}{ETHER\_HDR\_SIZE} +
343                                                                           
      \hyperlink{group__command__remove__audio__mappings_gade5c697bfe282579c5ddd334e762f6b6}{JDKSAVDECC\_AEM\_COMMAND\_REMOVE\_AUDIO\_MAPPINGS\_COMMAND\_OFFSET\_MAPPINGS}
       +
344                                                                           (
      \hyperlink{group__audio__mapping_ga0dd006bf2320b99909db301f043f0cae}{JDKSAVDECC\_AUDIO\_MAPPING\_LEN} * i + 
      \hyperlink{group__audio__mapping_ga625a930d4963bce1d448347efdd150ce}{JDKSAVDECC\_AUDIO\_MAPPING\_OFFSET\_MAPPING\_CLUSTER\_CHANNEL}
      ));
345 
346         \hyperlink{classavdecc__lib_1_1stream__port__output__descriptor__imp_ae0c1781344cc1ecdf12d9624ae930ccd}{pending\_maps}.erase(it);
347         it = \hyperlink{classavdecc__lib_1_1stream__port__output__descriptor__imp_ae0c1781344cc1ecdf12d9624ae930ccd}{pending\_maps}.begin();
348         i++;
349     \}
350 
351     \hyperlink{namespaceavdecc__lib_a0b1b5aea3c0490f77cbfd9178af5be22}{aecp\_controller\_state\_machine\_ref}->
      \hyperlink{classavdecc__lib_1_1aecp__controller__state__machine_aafc737d7ed17a62fed9df6528f18d3ec}{common\_hdr\_init}(\hyperlink{group__aecp__message__type_ga4625ce189cc209f42deb0629f48faf69}{JDKSAVDECC\_AECP\_MESSAGE\_TYPE\_AEM\_COMMAND}
      ,
352                                                        &cmd\_frame,
353                                                        \hyperlink{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{base\_end\_station\_imp\_ref}->
      \hyperlink{classavdecc__lib_1_1end__station__imp_a363b6c9664a0d701def9b17863e20ad3}{entity\_id}(),
354                                                        
      \hyperlink{group__command__remove__audio__mappings_ga2f5c2a11750df03fd2b890c2a1f6303c}{JDKSAVDECC\_AEM\_COMMAND\_REMOVE\_AUDIO\_MAPPINGS\_COMMAND\_LEN}
       -
355                                                            
      \hyperlink{group__jdksavdecc__avtp__common__control__header_gaae84052886fb1bb42f3bc5f85b741dff}{JDKSAVDECC\_COMMON\_CONTROL\_HEADER\_LEN});
356     \hyperlink{namespaceavdecc__lib_a6dd511685627c0865a3442b539a4e8e9}{system\_queue\_tx}(notification\_id, \hyperlink{namespaceavdecc__lib_aabcadff06aa62be0ce47bc0646823604aba48b8a017e06fb240b650cdea965178}{CMD\_WITH\_NOTIFICATION}, cmd\_frame.
      payload, cmd\_frame.length);
357 
358     \textcolor{keywordflow}{if} (num\_pending\_maps > \hyperlink{namespaceavdecc__lib_a97844c4fa619487e53c2854a07fd34d7aeea9bc815c3177c9b296244acb544cc9}{AEM\_MAX\_MAPS})
359     \{
360         \textcolor{keywordflow}{return} 1;
361     \}
362     \textcolor{keywordflow}{else}
363     \{
364         \textcolor{keywordflow}{return} 0;
365     \}
366 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1stream__port__output__descriptor__imp_af6ad50a43367920f62229d2a1f942856_cgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!send\+\_\+set\+\_\+name\+\_\+cmd@{send\+\_\+set\+\_\+name\+\_\+cmd}}
\index{send\+\_\+set\+\_\+name\+\_\+cmd@{send\+\_\+set\+\_\+name\+\_\+cmd}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{send\+\_\+set\+\_\+name\+\_\+cmd(void $\ast$notification\+\_\+id, uint16\+\_\+t name\+\_\+index, uint16\+\_\+t config\+\_\+index, const struct avdecc\+\_\+lib\+\_\+name\+\_\+string64 $\ast$new\+\_\+name)=0}{send_set_name_cmd(void *notification_id, uint16_t name_index, uint16_t config_index, const struct avdecc_lib_name_string64 *new_name)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual A\+V\+D\+E\+C\+C\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+L\+I\+B32\+\_\+\+A\+PI int S\+T\+D\+C\+A\+LL send\+\_\+set\+\_\+name\+\_\+cmd (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{notification\+\_\+id, }
\item[{uint16\+\_\+t}]{name\+\_\+index, }
\item[{uint16\+\_\+t}]{config\+\_\+index, }
\item[{const struct {\bf avdecc\+\_\+lib\+\_\+name\+\_\+string64} $\ast$}]{new\+\_\+name}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base_a6a8c227d7a202f251c689107df7ede0b}{}\label{classavdecc__lib_1_1descriptor__base_a6a8c227d7a202f251c689107df7ede0b}
Send a S\+E\+T\+\_\+\+N\+A\+ME command to change the value of a name field within a descriptor. For descriptors with multiple names, this sets only one specified name per command.


\begin{DoxyParams}{매개변수}
{\em notification\+\_\+id} & A void pointer to the unique identifier associated with the command. \\
\hline
{\em name\+\_\+index} & The index of the name within the descriptor, with the first name being index 0 and so on. \\
\hline
{\em config\+\_\+index} & The descriptor index of the configuration, which contains the descriptor whose name is being set. If the descriptor type field is either E\+N\+T\+I\+TY or C\+O\+N\+F\+I\+G\+U\+R\+A\+T\+I\+ON, then this field is set to 0. \\
\hline
{\em new\+\_\+name} & The new name to be set. The name does not contain a trailing N\+U\+LL, but if the name is less than 64 bytes in length, then it is zero padded. \\
\hline
\end{DoxyParams}


\hyperlink{classavdecc__lib_1_1descriptor__base__imp_af0bb05af3bf67f2ab0eb522096011592}{descriptor\+\_\+base\+\_\+imp}에서 구현되었습니다.



이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base_a6a8c227d7a202f251c689107df7ede0b_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!send\+\_\+set\+\_\+name\+\_\+cmd@{send\+\_\+set\+\_\+name\+\_\+cmd}}
\index{send\+\_\+set\+\_\+name\+\_\+cmd@{send\+\_\+set\+\_\+name\+\_\+cmd}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{send\+\_\+set\+\_\+name\+\_\+cmd(void $\ast$notification\+\_\+id, uint16\+\_\+t name\+\_\+index, uint16\+\_\+t config\+\_\+index, const struct avdecc\+\_\+lib\+\_\+name\+\_\+string64 $\ast$new\+\_\+name)}{send_set_name_cmd(void *notification_id, uint16_t name_index, uint16_t config_index, const struct avdecc_lib_name_string64 *new_name)}}]{\setlength{\rightskip}{0pt plus 5cm}int S\+T\+D\+C\+A\+LL send\+\_\+set\+\_\+name\+\_\+cmd (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{notification\+\_\+id, }
\item[{uint16\+\_\+t}]{name\+\_\+index, }
\item[{uint16\+\_\+t}]{config\+\_\+index, }
\item[{const struct {\bf avdecc\+\_\+lib\+\_\+name\+\_\+string64} $\ast$}]{new\+\_\+name}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_af0bb05af3bf67f2ab0eb522096011592}{}\label{classavdecc__lib_1_1descriptor__base__imp_af0bb05af3bf67f2ab0eb522096011592}
Send a S\+E\+T\+\_\+\+N\+A\+ME command to change the value of a name field within a descriptor. For descriptors with multiple names, this sets only one specified name per command.


\begin{DoxyParams}{매개변수}
{\em notification\+\_\+id} & A void pointer to the unique identifier associated with the command. \\
\hline
{\em name\+\_\+index} & The index of the name within the descriptor, with the first name being index 0 and so on. \\
\hline
{\em config\+\_\+index} & The descriptor index of the configuration, which contains the descriptor whose name is being set. If the descriptor type field is either E\+N\+T\+I\+TY or C\+O\+N\+F\+I\+G\+U\+R\+A\+T\+I\+ON, then this field is set to 0. \\
\hline
{\em new\+\_\+name} & The new name to be set. The name does not contain a trailing N\+U\+LL, but if the name is less than 64 bytes in length, then it is zero padded. \\
\hline
\end{DoxyParams}


\hyperlink{classavdecc__lib_1_1descriptor__base_a6a8c227d7a202f251c689107df7ede0b}{descriptor\+\_\+base}를 구현.



descriptor\+\_\+base\+\_\+imp.\+cpp 파일의 421 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
422 \{
423     \textcolor{keywordflow}{return} \hyperlink{classavdecc__lib_1_1descriptor__base__imp_aed899a0eaaaa06a02569135f844ffce8}{default\_send\_set\_name\_cmd}(\textcolor{keyword}{this}, notification\_id, name\_index, 
      config\_index, name);
424 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classavdecc__lib_1_1descriptor__base__imp_af0bb05af3bf67f2ab0eb522096011592_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=261pt]{classavdecc__lib_1_1descriptor__base__imp_af0bb05af3bf67f2ab0eb522096011592_icgraph}
\end{center}
\end{figure}


\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!store\+\_\+pending\+\_\+map@{store\+\_\+pending\+\_\+map}}
\index{store\+\_\+pending\+\_\+map@{store\+\_\+pending\+\_\+map}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{store\+\_\+pending\+\_\+map(struct audio\+\_\+map\+\_\+mapping \&map)}{store_pending_map(struct audio_map_mapping &map)}}]{\setlength{\rightskip}{0pt plus 5cm}int store\+\_\+pending\+\_\+map (
\begin{DoxyParamCaption}
\item[{struct {\bf audio\+\_\+map\+\_\+mapping} \&}]{map}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classavdecc__lib_1_1stream__port__output__descriptor__imp_a8ca55047d151e78b3804fcdbf04282e8}{}\label{classavdecc__lib_1_1stream__port__output__descriptor__imp_a8ca55047d151e78b3804fcdbf04282e8}

\begin{DoxyParams}{매개변수}
{\em map} & The added audio\+\_\+map pending for adding/removal. \\
\hline
\end{DoxyParams}


\hyperlink{classavdecc__lib_1_1stream__port__output__descriptor_ac1774e84412c74378819f20d257a7653}{stream\+\_\+port\+\_\+output\+\_\+descriptor}를 구현.



stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp.\+cpp 파일의 59 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
60 \{
61     \hyperlink{classavdecc__lib_1_1stream__port__output__descriptor__imp_ae0c1781344cc1ecdf12d9624ae930ccd}{pending\_maps}.push\_back(map);
62 
63     \textcolor{keywordflow}{return} 0;
64 \}
\end{DoxyCode}


\subsection{필드 문서화}
\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!audio\+\_\+map\+\_\+resp@{audio\+\_\+map\+\_\+resp}}
\index{audio\+\_\+map\+\_\+resp@{audio\+\_\+map\+\_\+resp}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{audio\+\_\+map\+\_\+resp}{audio_map_resp}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf stream\+\_\+port\+\_\+output\+\_\+get\+\_\+audio\+\_\+map\+\_\+response\+\_\+imp}$\ast$ audio\+\_\+map\+\_\+resp}\hypertarget{classavdecc__lib_1_1stream__port__output__descriptor__imp_a662a30a6f5184ddb2be3bd056cd0fecb}{}\label{classavdecc__lib_1_1stream__port__output__descriptor__imp_a662a30a6f5184ddb2be3bd056cd0fecb}


stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp.\+h 파일의 49 번째 라인에서 정의되었습니다.

\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!base\+\_\+end\+\_\+station\+\_\+imp\+\_\+ref@{base\+\_\+end\+\_\+station\+\_\+imp\+\_\+ref}}
\index{base\+\_\+end\+\_\+station\+\_\+imp\+\_\+ref@{base\+\_\+end\+\_\+station\+\_\+imp\+\_\+ref}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{base\+\_\+end\+\_\+station\+\_\+imp\+\_\+ref}{base_end_station_imp_ref}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf end\+\_\+station\+\_\+imp}$\ast$ base\+\_\+end\+\_\+station\+\_\+imp\+\_\+ref\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}{}\label{classavdecc__lib_1_1descriptor__base__imp_a550c969411f5f3b69f55cc139763d224}


descriptor\+\_\+base\+\_\+imp.\+h 파일의 54 번째 라인에서 정의되었습니다.

\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!desc\+\_\+index@{desc\+\_\+index}}
\index{desc\+\_\+index@{desc\+\_\+index}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{desc\+\_\+index}{desc_index}}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t desc\+\_\+index\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_a2bbd0d8f32f687ca36aaa543c06f764c}{}\label{classavdecc__lib_1_1descriptor__base__imp_a2bbd0d8f32f687ca36aaa543c06f764c}


descriptor\+\_\+base\+\_\+imp.\+h 파일의 58 번째 라인에서 정의되었습니다.

\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!desc\+\_\+type@{desc\+\_\+type}}
\index{desc\+\_\+type@{desc\+\_\+type}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{desc\+\_\+type}{desc_type}}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t desc\+\_\+type\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_a9dada313309522d04f1e52fe887442b4}{}\label{classavdecc__lib_1_1descriptor__base__imp_a9dada313309522d04f1e52fe887442b4}


descriptor\+\_\+base\+\_\+imp.\+h 파일의 57 번째 라인에서 정의되었습니다.

\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!get\+\_\+name\+\_\+resp@{get\+\_\+name\+\_\+resp}}
\index{get\+\_\+name\+\_\+resp@{get\+\_\+name\+\_\+resp}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{get\+\_\+name\+\_\+resp}{get_name_resp}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf descriptor\+\_\+base\+\_\+get\+\_\+name\+\_\+response\+\_\+imp}$\ast$ get\+\_\+name\+\_\+resp\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_a7d3a410eb242dc2b7abe9862a1593458}{}\label{classavdecc__lib_1_1descriptor__base__imp_a7d3a410eb242dc2b7abe9862a1593458}


descriptor\+\_\+base\+\_\+imp.\+h 파일의 53 번째 라인에서 정의되었습니다.

\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!m\+\_\+fields@{m\+\_\+fields}}
\index{m\+\_\+fields@{m\+\_\+fields}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{m\+\_\+fields}{m_fields}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::vector$<${\bf descriptor\+\_\+field\+\_\+imp} $\ast$$>$ m\+\_\+fields\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_adce67136eb9c66da9c189b730077b9cd}{}\label{classavdecc__lib_1_1descriptor__base__imp_adce67136eb9c66da9c189b730077b9cd}


descriptor\+\_\+base\+\_\+imp.\+h 파일의 55 번째 라인에서 정의되었습니다.

\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!pending\+\_\+maps@{pending\+\_\+maps}}
\index{pending\+\_\+maps@{pending\+\_\+maps}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{pending\+\_\+maps}{pending_maps}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::vector$<$struct {\bf audio\+\_\+map\+\_\+mapping}$>$ pending\+\_\+maps\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classavdecc__lib_1_1stream__port__output__descriptor__imp_ae0c1781344cc1ecdf12d9624ae930ccd}{}\label{classavdecc__lib_1_1stream__port__output__descriptor__imp_ae0c1781344cc1ecdf12d9624ae930ccd}


stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp.\+h 파일의 43 번째 라인에서 정의되었습니다.

\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!resp@{resp}}
\index{resp@{resp}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{resp}{resp}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+response\+\_\+imp}$\ast$ resp}\hypertarget{classavdecc__lib_1_1stream__port__output__descriptor__imp_a241ec2f535a1c6918e5a63c40f6a974b}{}\label{classavdecc__lib_1_1stream__port__output__descriptor__imp_a241ec2f535a1c6918e5a63c40f6a974b}


stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp.\+h 파일의 48 번째 라인에서 정의되었습니다.

\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!resp\+\_\+base@{resp\+\_\+base}}
\index{resp\+\_\+base@{resp\+\_\+base}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{resp\+\_\+base}{resp_base}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf descriptor\+\_\+response\+\_\+base\+\_\+imp}$\ast$ resp\+\_\+base\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_a8b104da8319cda946944548ebb9552f4}{}\label{classavdecc__lib_1_1descriptor__base__imp_a8b104da8319cda946944548ebb9552f4}


descriptor\+\_\+base\+\_\+imp.\+h 파일의 52 번째 라인에서 정의되었습니다.

\index{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}!resp\+\_\+ref@{resp\+\_\+ref}}
\index{resp\+\_\+ref@{resp\+\_\+ref}!avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp@{avdecc\+\_\+lib\+::stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp}}
\subsubsection[{\texorpdfstring{resp\+\_\+ref}{resp_ref}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf response\+\_\+frame}$\ast$ resp\+\_\+ref\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [inherited]}}\hypertarget{classavdecc__lib_1_1descriptor__base__imp_a2642e3a7c10d38553e7ff4a55e875346}{}\label{classavdecc__lib_1_1descriptor__base__imp_a2642e3a7c10d38553e7ff4a55e875346}


descriptor\+\_\+base\+\_\+imp.\+h 파일의 56 번째 라인에서 정의되었습니다.



이 클래스에 대한 문서화 페이지는 다음의 파일들로부터 생성되었습니다.\+:\begin{DoxyCompactItemize}
\item 
avdecc-\/lib/controller/lib/src/\hyperlink{stream__port__output__descriptor__imp_8h}{stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp.\+h}\item 
avdecc-\/lib/controller/lib/src/\hyperlink{stream__port__output__descriptor__imp_8cpp}{stream\+\_\+port\+\_\+output\+\_\+descriptor\+\_\+imp.\+cpp}\end{DoxyCompactItemize}
