\hypertarget{class_dummy_memory_leak_detector}{}\section{Dummy\+Memory\+Leak\+Detector 클래스 참조}
\label{class_dummy_memory_leak_detector}\index{Dummy\+Memory\+Leak\+Detector@{Dummy\+Memory\+Leak\+Detector}}


Dummy\+Memory\+Leak\+Detector에 대한 상속 다이어그램 \+: 
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=550pt]{class_dummy_memory_leak_detector__inherit__graph}
\end{center}
\end{figure}


Dummy\+Memory\+Leak\+Detector에 대한 협력 다이어그램\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=550pt]{class_dummy_memory_leak_detector__coll__graph}
\end{center}
\end{figure}
\subsection*{Public 타입}
\begin{DoxyCompactItemize}
\item 
enum \{ \hyperlink{class_memory_leak_detector_a81929fb3d21206b62f55bcb744f71d5da5220cc4ba0bebf171c9984d05561bcc2}{memory\+\_\+corruption\+\_\+buffer\+\_\+size} = 3
 \}
\end{DoxyCompactItemize}
\subsection*{Public 멤버 함수}
\begin{DoxyCompactItemize}
\item 
\hyperlink{class_dummy_memory_leak_detector_a6cf556e6cc5e22c9d1ac0dfd96b1eab9}{Dummy\+Memory\+Leak\+Detector} (\hyperlink{class_memory_leak_failure}{Memory\+Leak\+Failure} $\ast$reporter)
\item 
virtual \hyperlink{class_dummy_memory_leak_detector_aa69633ef4e03585da2bea27233f39338}{$\sim$\+Dummy\+Memory\+Leak\+Detector} ()
\item 
void \hyperlink{class_memory_leak_detector_a486f22824bd83c5308a0d70ffac6f758}{enable} ()
\item 
void \hyperlink{class_memory_leak_detector_a8cfbbe53c1cf6e3054736daea3044c0f}{disable} ()
\item 
void \hyperlink{class_memory_leak_detector_a87bbe373712386442509ec83e9444021}{disable\+Allocation\+Type\+Checking} ()
\item 
void \hyperlink{class_memory_leak_detector_a4ef0d2380dbe5ecfa77d2d477d9047e9}{enable\+Allocation\+Type\+Checking} ()
\item 
void \hyperlink{class_memory_leak_detector_ae912c5ee9034b76f13f1c9dbab55e512}{start\+Checking} ()
\item 
void \hyperlink{class_memory_leak_detector_a9e85551d474d895ba8852b8e56481c7c}{stop\+Checking} ()
\item 
const char $\ast$ \hyperlink{class_memory_leak_detector_acc70330c27080c4b09b96342929dc9ca}{report} (\hyperlink{_memory_leak_detector_8h_ab248e6cc6c6699b88b002286d8a3ed76}{Mem\+Leak\+Period} period)
\item 
void \hyperlink{class_memory_leak_detector_a6db202697cf20e8d84748b129c403545}{mark\+Checking\+Period\+Leaks\+As\+Non\+Checking\+Period} ()
\item 
int \hyperlink{class_memory_leak_detector_a7b0c5d9c4d678d6e0081802416660803}{total\+Memory\+Leaks} (\hyperlink{_memory_leak_detector_8h_ab248e6cc6c6699b88b002286d8a3ed76}{Mem\+Leak\+Period} period)
\item 
void \hyperlink{class_memory_leak_detector_a6c18f981e1c2139528a10aa573ffeaa9}{clear\+All\+Accounting} (\hyperlink{_memory_leak_detector_8h_ab248e6cc6c6699b88b002286d8a3ed76}{Mem\+Leak\+Period} period)
\item 
char $\ast$ \hyperlink{class_memory_leak_detector_a15c9b9fb87d6e63d8972f03e25fb3cf5}{alloc\+Memory} (\hyperlink{class_test_memory_allocator}{Test\+Memory\+Allocator} $\ast$\hyperlink{_memory_leak_warning_test_8cpp_a83fc2e9b9142613f7df2bcc3ff8292bc}{allocator}, size\+\_\+t \hyperlink{gst__avb__playbin_8c_a439227feff9d7f55384e8780cfc2eb82}{size}, \hyperlink{avb__gptp_8h_af6a258d8f3ee5206d682d799316314b1}{bool} allocat\+Nodes\+Seperately=\hyperlink{avb__gptp_8h_af6a258d8f3ee5206d682d799316314b1ae9de385ef6fe9bf3360d1038396b884c}{false})
\item 
char $\ast$ \hyperlink{class_memory_leak_detector_ace7838f234f5dea076a6ab2528a66164}{alloc\+Memory} (\hyperlink{class_test_memory_allocator}{Test\+Memory\+Allocator} $\ast$\hyperlink{_memory_leak_warning_test_8cpp_a83fc2e9b9142613f7df2bcc3ff8292bc}{allocator}, size\+\_\+t \hyperlink{gst__avb__playbin_8c_a439227feff9d7f55384e8780cfc2eb82}{size}, const char $\ast$file, int line, \hyperlink{avb__gptp_8h_af6a258d8f3ee5206d682d799316314b1}{bool} allocat\+Nodes\+Seperately=\hyperlink{avb__gptp_8h_af6a258d8f3ee5206d682d799316314b1ae9de385ef6fe9bf3360d1038396b884c}{false})
\item 
void \hyperlink{class_memory_leak_detector_a1526d6f241a7f41eaeae20fd2c712873}{dealloc\+Memory} (\hyperlink{class_test_memory_allocator}{Test\+Memory\+Allocator} $\ast$\hyperlink{_memory_leak_warning_test_8cpp_a83fc2e9b9142613f7df2bcc3ff8292bc}{allocator}, void $\ast$memory, \hyperlink{avb__gptp_8h_af6a258d8f3ee5206d682d799316314b1}{bool} allocat\+Nodes\+Seperately=\hyperlink{avb__gptp_8h_af6a258d8f3ee5206d682d799316314b1ae9de385ef6fe9bf3360d1038396b884c}{false})
\item 
void \hyperlink{class_memory_leak_detector_a235bec7842c694f869f6edbf131a6c55}{dealloc\+Memory} (\hyperlink{class_test_memory_allocator}{Test\+Memory\+Allocator} $\ast$\hyperlink{_memory_leak_warning_test_8cpp_a83fc2e9b9142613f7df2bcc3ff8292bc}{allocator}, void $\ast$memory, const char $\ast$file, int line, \hyperlink{avb__gptp_8h_af6a258d8f3ee5206d682d799316314b1}{bool} allocat\+Nodes\+Seperately=\hyperlink{avb__gptp_8h_af6a258d8f3ee5206d682d799316314b1ae9de385ef6fe9bf3360d1038396b884c}{false})
\item 
char $\ast$ \hyperlink{class_memory_leak_detector_a6aded764a2297f52a104b75eae2d4b5c}{realloc\+Memory} (\hyperlink{class_test_memory_allocator}{Test\+Memory\+Allocator} $\ast$\hyperlink{_memory_leak_warning_test_8cpp_a83fc2e9b9142613f7df2bcc3ff8292bc}{allocator}, char $\ast$memory, size\+\_\+t \hyperlink{gst__avb__playbin_8c_a439227feff9d7f55384e8780cfc2eb82}{size}, const char $\ast$file, int line, \hyperlink{avb__gptp_8h_af6a258d8f3ee5206d682d799316314b1}{bool} allocat\+Nodes\+Seperately=\hyperlink{avb__gptp_8h_af6a258d8f3ee5206d682d799316314b1ae9de385ef6fe9bf3360d1038396b884c}{false})
\item 
void \hyperlink{class_memory_leak_detector_a1b924f98e6bf1203714985e0b0c3de5d}{invalidate\+Memory} (char $\ast$memory)
\item 
void \hyperlink{class_memory_leak_detector_ac17764ba8c2ced15cbbbca1731f6b21e}{remove\+Memory\+Leak\+Information\+Without\+Checking\+Or\+Deallocating\+The\+Memory\+But\+Deallocating\+The\+Account\+Information} (\hyperlink{class_test_memory_allocator}{Test\+Memory\+Allocator} $\ast$\hyperlink{_memory_leak_warning_test_8cpp_a83fc2e9b9142613f7df2bcc3ff8292bc}{allocator}, void $\ast$memory, \hyperlink{avb__gptp_8h_af6a258d8f3ee5206d682d799316314b1}{bool} allocat\+Nodes\+Seperately)
\item 
unsigned \hyperlink{class_memory_leak_detector_a774a54e55a1203f145f722609ae18317}{get\+Current\+Allocation\+Number} ()
\item 
\hyperlink{class_simple_mutex}{Simple\+Mutex} $\ast$ \hyperlink{class_memory_leak_detector_a19d27cb7dd06173cc88f58543bfe3020}{get\+Mutex} (void)
\end{DoxyCompactItemize}


\subsection{상세한 설명}


Memory\+Leak\+Warning\+Test.\+cpp 파일의 155 번째 라인에서 정의되었습니다.



\subsection{멤버 열거형 문서화}
\subsubsection[{\texorpdfstring{anonymous enum}{anonymous enum}}]{\setlength{\rightskip}{0pt plus 5cm}anonymous enum\hspace{0.3cm}{\ttfamily [inherited]}}\hypertarget{class_memory_leak_detector_a81929fb3d21206b62f55bcb744f71d5d}{}\label{class_memory_leak_detector_a81929fb3d21206b62f55bcb744f71d5d}
\begin{Desc}
\item[열거형 멤버]\par
\begin{description}
\index{memory\+\_\+corruption\+\_\+buffer\+\_\+size@{memory\+\_\+corruption\+\_\+buffer\+\_\+size}!Dummy\+Memory\+Leak\+Detector@{Dummy\+Memory\+Leak\+Detector}}\index{Dummy\+Memory\+Leak\+Detector@{Dummy\+Memory\+Leak\+Detector}!memory\+\_\+corruption\+\_\+buffer\+\_\+size@{memory\+\_\+corruption\+\_\+buffer\+\_\+size}}\item[{\em 
memory\+\_\+corruption\+\_\+buffer\+\_\+size\hypertarget{class_memory_leak_detector_a81929fb3d21206b62f55bcb744f71d5da5220cc4ba0bebf171c9984d05561bcc2}{}\label{class_memory_leak_detector_a81929fb3d21206b62f55bcb744f71d5da5220cc4ba0bebf171c9984d05561bcc2}
}]\end{description}
\end{Desc}


Memory\+Leak\+Detector.\+h 파일의 217 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
218     \{
219         \hyperlink{class_memory_leak_detector_a81929fb3d21206b62f55bcb744f71d5da5220cc4ba0bebf171c9984d05561bcc2}{memory\_corruption\_buffer\_size} = 3
220     \};
\end{DoxyCode}


\subsection{생성자 \& 소멸자 문서화}
\index{Dummy\+Memory\+Leak\+Detector@{Dummy\+Memory\+Leak\+Detector}!Dummy\+Memory\+Leak\+Detector@{Dummy\+Memory\+Leak\+Detector}}
\index{Dummy\+Memory\+Leak\+Detector@{Dummy\+Memory\+Leak\+Detector}!Dummy\+Memory\+Leak\+Detector@{Dummy\+Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{Dummy\+Memory\+Leak\+Detector(\+Memory\+Leak\+Failure $\ast$reporter)}{DummyMemoryLeakDetector(MemoryLeakFailure *reporter)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Dummy\+Memory\+Leak\+Detector} (
\begin{DoxyParamCaption}
\item[{{\bf Memory\+Leak\+Failure} $\ast$}]{reporter}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{class_dummy_memory_leak_detector_a6cf556e6cc5e22c9d1ac0dfd96b1eab9}{}\label{class_dummy_memory_leak_detector_a6cf556e6cc5e22c9d1ac0dfd96b1eab9}


Memory\+Leak\+Warning\+Test.\+cpp 파일의 158 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
158 : \hyperlink{class_memory_leak_detector_adce0cc8ded968fc3af6035ed9aebe949}{MemoryLeakDetector}(reporter) \{\}
\end{DoxyCode}
\index{Dummy\+Memory\+Leak\+Detector@{Dummy\+Memory\+Leak\+Detector}!````~Dummy\+Memory\+Leak\+Detector@{$\sim$\+Dummy\+Memory\+Leak\+Detector}}
\index{````~Dummy\+Memory\+Leak\+Detector@{$\sim$\+Dummy\+Memory\+Leak\+Detector}!Dummy\+Memory\+Leak\+Detector@{Dummy\+Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{$\sim$\+Dummy\+Memory\+Leak\+Detector()}{~DummyMemoryLeakDetector()}}]{\setlength{\rightskip}{0pt plus 5cm}virtual $\sim${\bf Dummy\+Memory\+Leak\+Detector} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{class_dummy_memory_leak_detector_aa69633ef4e03585da2bea27233f39338}{}\label{class_dummy_memory_leak_detector_aa69633ef4e03585da2bea27233f39338}


Memory\+Leak\+Warning\+Test.\+cpp 파일의 159 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
160     \{
161         \hyperlink{_memory_leak_warning_test_8cpp_a17ec45aae5d9c6758eb79ab66c5d3ccf}{memoryLeakDetectorWasDeleted} = \textcolor{keyword}{true};
162     \}
\end{DoxyCode}


\subsection{멤버 함수 문서화}
\index{Dummy\+Memory\+Leak\+Detector@{Dummy\+Memory\+Leak\+Detector}!alloc\+Memory@{alloc\+Memory}}
\index{alloc\+Memory@{alloc\+Memory}!Dummy\+Memory\+Leak\+Detector@{Dummy\+Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{alloc\+Memory(\+Test\+Memory\+Allocator $\ast$allocator, size\+\_\+t size, bool allocat\+Nodes\+Seperately=false)}{allocMemory(TestMemoryAllocator *allocator, size_t size, bool allocatNodesSeperately=false)}}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$ alloc\+Memory (
\begin{DoxyParamCaption}
\item[{{\bf Test\+Memory\+Allocator} $\ast$}]{allocator, }
\item[{size\+\_\+t}]{size, }
\item[{{\bf bool}}]{allocat\+Nodes\+Seperately = {\ttfamily {\bf false}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inherited]}}\hypertarget{class_memory_leak_detector_a15c9b9fb87d6e63d8972f03e25fb3cf5}{}\label{class_memory_leak_detector_a15c9b9fb87d6e63d8972f03e25fb3cf5}


Memory\+Leak\+Detector.\+cpp 파일의 550 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
551 \{
552     \textcolor{keywordflow}{return} \hyperlink{class_memory_leak_detector_a15c9b9fb87d6e63d8972f03e25fb3cf5}{allocMemory}(allocator, \hyperlink{gst__avb__playbin_8c_a439227feff9d7f55384e8780cfc2eb82}{size}, \hyperlink{_memory_leak_detector_8cpp_ac1ae4add974b9cfc6b5aaf8a578f01ab}{UNKNOWN}, 0, allocatNodesSeperately);
553 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_memory_leak_detector_a15c9b9fb87d6e63d8972f03e25fb3cf5_icgraph}
\end{center}
\end{figure}


\index{Dummy\+Memory\+Leak\+Detector@{Dummy\+Memory\+Leak\+Detector}!alloc\+Memory@{alloc\+Memory}}
\index{alloc\+Memory@{alloc\+Memory}!Dummy\+Memory\+Leak\+Detector@{Dummy\+Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{alloc\+Memory(\+Test\+Memory\+Allocator $\ast$allocator, size\+\_\+t size, const char $\ast$file, int line, bool allocat\+Nodes\+Seperately=false)}{allocMemory(TestMemoryAllocator *allocator, size_t size, const char *file, int line, bool allocatNodesSeperately=false)}}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$ alloc\+Memory (
\begin{DoxyParamCaption}
\item[{{\bf Test\+Memory\+Allocator} $\ast$}]{allocator, }
\item[{size\+\_\+t}]{size, }
\item[{const char $\ast$}]{file, }
\item[{int}]{line, }
\item[{{\bf bool}}]{allocat\+Nodes\+Seperately = {\ttfamily {\bf false}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inherited]}}\hypertarget{class_memory_leak_detector_ace7838f234f5dea076a6ab2528a66164}{}\label{class_memory_leak_detector_ace7838f234f5dea076a6ab2528a66164}


Memory\+Leak\+Detector.\+cpp 파일의 573 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
574 \{
575     \textcolor{comment}{/* With malloc, it is harder to guarantee that the allocator free is called.}
576 \textcolor{comment}{     * This is because operator new is overloaded via linker symbols, but malloc just via #defines.}
577 \textcolor{comment}{     * If the same allocation is used and the wrong free is called, it will deallocate the memory leak
       information}
578 \textcolor{comment}{     * without the memory leak detector ever noticing it!}
579 \textcolor{comment}{     * So, for malloc, we'll allocate the memory separately so we can detect this and give a proper error.}
580 \textcolor{comment}{     */}
581 
582     \textcolor{keywordtype}{char}* memory = \hyperlink{class_memory_leak_detector_a9f85c6601d58ad9a888439e5834ae237}{allocateMemoryWithAccountingInformation}(allocator
      , \hyperlink{gst__avb__playbin_8c_a439227feff9d7f55384e8780cfc2eb82}{size}, file, line, allocatNodesSeperately);
583     \textcolor{keywordflow}{if} (memory == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}) \textcolor{keywordflow}{return} \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
584     \hyperlink{struct_memory_leak_detector_node}{MemoryLeakDetectorNode}* node = 
      \hyperlink{class_memory_leak_detector_a7ee2afe61a37ef68a82228bd91643442}{createMemoryLeakAccountingInformation}(allocator, 
      \hyperlink{gst__avb__playbin_8c_a439227feff9d7f55384e8780cfc2eb82}{size}, memory, allocatNodesSeperately);
585 
586     \hyperlink{class_memory_leak_detector_ad65311ebd24859da19c751e2e42e796f}{storeLeakInformation}(node, memory, \hyperlink{gst__avb__playbin_8c_a439227feff9d7f55384e8780cfc2eb82}{size}, allocator, file, line);
587     \textcolor{keywordflow}{return} node->\hyperlink{struct_memory_leak_detector_node_a6cdb5ad30702010eaf86e4e5f26defce}{memory\_};
588 \}
\end{DoxyCode}
\index{Dummy\+Memory\+Leak\+Detector@{Dummy\+Memory\+Leak\+Detector}!clear\+All\+Accounting@{clear\+All\+Accounting}}
\index{clear\+All\+Accounting@{clear\+All\+Accounting}!Dummy\+Memory\+Leak\+Detector@{Dummy\+Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{clear\+All\+Accounting(\+Mem\+Leak\+Period period)}{clearAllAccounting(MemLeakPeriod period)}}]{\setlength{\rightskip}{0pt plus 5cm}void clear\+All\+Accounting (
\begin{DoxyParamCaption}
\item[{{\bf Mem\+Leak\+Period}}]{period}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inherited]}}\hypertarget{class_memory_leak_detector_a6c18f981e1c2139528a10aa573ffeaa9}{}\label{class_memory_leak_detector_a6c18f981e1c2139528a10aa573ffeaa9}


Memory\+Leak\+Detector.\+cpp 파일의 436 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
437 \{
438     \hyperlink{class_memory_leak_detector_abee17cabbc59ef23d6f51027208a100c}{memoryTable\_}.\hyperlink{struct_memory_leak_detector_table_a6c18f981e1c2139528a10aa573ffeaa9}{clearAllAccounting}(period);
439 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=256pt]{class_memory_leak_detector_a6c18f981e1c2139528a10aa573ffeaa9_icgraph}
\end{center}
\end{figure}


\index{Dummy\+Memory\+Leak\+Detector@{Dummy\+Memory\+Leak\+Detector}!dealloc\+Memory@{dealloc\+Memory}}
\index{dealloc\+Memory@{dealloc\+Memory}!Dummy\+Memory\+Leak\+Detector@{Dummy\+Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{dealloc\+Memory(\+Test\+Memory\+Allocator $\ast$allocator, void $\ast$memory, bool allocat\+Nodes\+Seperately=false)}{deallocMemory(TestMemoryAllocator *allocator, void *memory, bool allocatNodesSeperately=false)}}]{\setlength{\rightskip}{0pt plus 5cm}void dealloc\+Memory (
\begin{DoxyParamCaption}
\item[{{\bf Test\+Memory\+Allocator} $\ast$}]{allocator, }
\item[{void $\ast$}]{memory, }
\item[{{\bf bool}}]{allocat\+Nodes\+Seperately = {\ttfamily {\bf false}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inherited]}}\hypertarget{class_memory_leak_detector_a1526d6f241a7f41eaeae20fd2c712873}{}\label{class_memory_leak_detector_a1526d6f241a7f41eaeae20fd2c712873}


Memory\+Leak\+Detector.\+cpp 파일의 611 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
612 \{
613     \hyperlink{class_memory_leak_detector_a1526d6f241a7f41eaeae20fd2c712873}{deallocMemory}(allocator, (\textcolor{keywordtype}{char}*) memory, \hyperlink{_memory_leak_detector_8cpp_ac1ae4add974b9cfc6b5aaf8a578f01ab}{UNKNOWN}, 0, allocatNodesSeperately);
614 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_memory_leak_detector_a1526d6f241a7f41eaeae20fd2c712873_icgraph}
\end{center}
\end{figure}


\index{Dummy\+Memory\+Leak\+Detector@{Dummy\+Memory\+Leak\+Detector}!dealloc\+Memory@{dealloc\+Memory}}
\index{dealloc\+Memory@{dealloc\+Memory}!Dummy\+Memory\+Leak\+Detector@{Dummy\+Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{dealloc\+Memory(\+Test\+Memory\+Allocator $\ast$allocator, void $\ast$memory, const char $\ast$file, int line, bool allocat\+Nodes\+Seperately=false)}{deallocMemory(TestMemoryAllocator *allocator, void *memory, const char *file, int line, bool allocatNodesSeperately=false)}}]{\setlength{\rightskip}{0pt plus 5cm}void dealloc\+Memory (
\begin{DoxyParamCaption}
\item[{{\bf Test\+Memory\+Allocator} $\ast$}]{allocator, }
\item[{void $\ast$}]{memory, }
\item[{const char $\ast$}]{file, }
\item[{int}]{line, }
\item[{{\bf bool}}]{allocat\+Nodes\+Seperately = {\ttfamily {\bf false}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inherited]}}\hypertarget{class_memory_leak_detector_a235bec7842c694f869f6edbf131a6c55}{}\label{class_memory_leak_detector_a235bec7842c694f869f6edbf131a6c55}


Memory\+Leak\+Detector.\+cpp 파일의 596 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
597 \{
598     \textcolor{keywordflow}{if} (memory == 0) \textcolor{keywordflow}{return};
599 
600     \hyperlink{struct_memory_leak_detector_node}{MemoryLeakDetectorNode}* node = \hyperlink{class_memory_leak_detector_abee17cabbc59ef23d6f51027208a100c}{memoryTable\_}.
      \hyperlink{struct_memory_leak_detector_table_aaa0452383ce806d8a7248cb567813f84}{removeNode}((\textcolor{keywordtype}{char}*) memory);
601     \textcolor{keywordflow}{if} (node == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}) \{
602         \hyperlink{class_memory_leak_detector_a7d0b175420d83f9ee397b398ae14ac75}{outputBuffer\_}.\hyperlink{class_memory_leak_output_string_buffer_a0061b779a33beb2d8c87eb915b20309a}{reportDeallocateNonAllocatedMemoryFailure}
      (file, line, allocator, \hyperlink{class_memory_leak_detector_a632df6e6476c93d9c58a104a17e155d9}{reporter\_});
603         \textcolor{keywordflow}{return};
604     \}
605     \textcolor{keywordflow}{if} (!allocator->\hyperlink{class_test_memory_allocator_ae26c82159ce24eb59770352585b402fd}{hasBeenDestroyed}()) \{
606         \hyperlink{class_memory_leak_detector_ae260d75b307f341763273c1e99a11c1d}{checkForCorruption}(node, file, line, allocator, allocatNodesSeperately);
607         allocator->\hyperlink{class_test_memory_allocator_a529ac9813d3b0836ce0b964449942534}{free\_memory}((\textcolor{keywordtype}{char}*) memory, file, line);
608     \}
609 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=309pt]{class_memory_leak_detector_a235bec7842c694f869f6edbf131a6c55_cgraph}
\end{center}
\end{figure}


\index{Dummy\+Memory\+Leak\+Detector@{Dummy\+Memory\+Leak\+Detector}!disable@{disable}}
\index{disable@{disable}!Dummy\+Memory\+Leak\+Detector@{Dummy\+Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{disable()}{disable()}}]{\setlength{\rightskip}{0pt plus 5cm}void disable (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inherited]}}\hypertarget{class_memory_leak_detector_a8cfbbe53c1cf6e3054736daea3044c0f}{}\label{class_memory_leak_detector_a8cfbbe53c1cf6e3054736daea3044c0f}


Memory\+Leak\+Detector.\+cpp 파일의 457 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
458 \{
459     \hyperlink{class_memory_leak_detector_af82b746b32f3ce3919db77a6985bab42}{current\_period\_} = \hyperlink{_memory_leak_detector_8h_ab248e6cc6c6699b88b002286d8a3ed76a486ca2e142f018cbf5f8f6b5561b4c48}{mem\_leak\_period\_disabled};
460 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=205pt]{class_memory_leak_detector_a8cfbbe53c1cf6e3054736daea3044c0f_icgraph}
\end{center}
\end{figure}


\index{Dummy\+Memory\+Leak\+Detector@{Dummy\+Memory\+Leak\+Detector}!disable\+Allocation\+Type\+Checking@{disable\+Allocation\+Type\+Checking}}
\index{disable\+Allocation\+Type\+Checking@{disable\+Allocation\+Type\+Checking}!Dummy\+Memory\+Leak\+Detector@{Dummy\+Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{disable\+Allocation\+Type\+Checking()}{disableAllocationTypeChecking()}}]{\setlength{\rightskip}{0pt plus 5cm}void disable\+Allocation\+Type\+Checking (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inherited]}}\hypertarget{class_memory_leak_detector_a87bbe373712386442509ec83e9444021}{}\label{class_memory_leak_detector_a87bbe373712386442509ec83e9444021}


Memory\+Leak\+Detector.\+cpp 파일의 462 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
463 \{
464     \hyperlink{class_memory_leak_detector_a9355cba4a5dcc00a72553874773d209e}{doAllocationTypeChecking\_} = \textcolor{keyword}{false};
465 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=311pt]{class_memory_leak_detector_a87bbe373712386442509ec83e9444021_icgraph}
\end{center}
\end{figure}


\index{Dummy\+Memory\+Leak\+Detector@{Dummy\+Memory\+Leak\+Detector}!enable@{enable}}
\index{enable@{enable}!Dummy\+Memory\+Leak\+Detector@{Dummy\+Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{enable()}{enable()}}]{\setlength{\rightskip}{0pt plus 5cm}void enable (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inherited]}}\hypertarget{class_memory_leak_detector_a486f22824bd83c5308a0d70ffac6f758}{}\label{class_memory_leak_detector_a486f22824bd83c5308a0d70ffac6f758}


Memory\+Leak\+Detector.\+cpp 파일의 452 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
453 \{
454     \hyperlink{class_memory_leak_detector_af82b746b32f3ce3919db77a6985bab42}{current\_period\_} = \hyperlink{_memory_leak_detector_8h_ab248e6cc6c6699b88b002286d8a3ed76af44afdfdc843b0c299b8b0a9585a0f32}{mem\_leak\_period\_enabled};
455 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=303pt]{class_memory_leak_detector_a486f22824bd83c5308a0d70ffac6f758_icgraph}
\end{center}
\end{figure}


\index{Dummy\+Memory\+Leak\+Detector@{Dummy\+Memory\+Leak\+Detector}!enable\+Allocation\+Type\+Checking@{enable\+Allocation\+Type\+Checking}}
\index{enable\+Allocation\+Type\+Checking@{enable\+Allocation\+Type\+Checking}!Dummy\+Memory\+Leak\+Detector@{Dummy\+Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{enable\+Allocation\+Type\+Checking()}{enableAllocationTypeChecking()}}]{\setlength{\rightskip}{0pt plus 5cm}void enable\+Allocation\+Type\+Checking (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inherited]}}\hypertarget{class_memory_leak_detector_a4ef0d2380dbe5ecfa77d2d477d9047e9}{}\label{class_memory_leak_detector_a4ef0d2380dbe5ecfa77d2d477d9047e9}


Memory\+Leak\+Detector.\+cpp 파일의 467 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
468 \{
469     \hyperlink{class_memory_leak_detector_a9355cba4a5dcc00a72553874773d209e}{doAllocationTypeChecking\_} = \textcolor{keyword}{true};
470 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=309pt]{class_memory_leak_detector_a4ef0d2380dbe5ecfa77d2d477d9047e9_icgraph}
\end{center}
\end{figure}


\index{Dummy\+Memory\+Leak\+Detector@{Dummy\+Memory\+Leak\+Detector}!get\+Current\+Allocation\+Number@{get\+Current\+Allocation\+Number}}
\index{get\+Current\+Allocation\+Number@{get\+Current\+Allocation\+Number}!Dummy\+Memory\+Leak\+Detector@{Dummy\+Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{get\+Current\+Allocation\+Number()}{getCurrentAllocationNumber()}}]{\setlength{\rightskip}{0pt plus 5cm}unsigned get\+Current\+Allocation\+Number (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inherited]}}\hypertarget{class_memory_leak_detector_a774a54e55a1203f145f722609ae18317}{}\label{class_memory_leak_detector_a774a54e55a1203f145f722609ae18317}


Memory\+Leak\+Detector.\+cpp 파일의 472 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
473 \{
474     \textcolor{keywordflow}{return} \hyperlink{class_memory_leak_detector_a848e960c1d67dbe545416e2541663260}{allocationSequenceNumber\_};
475 \}
\end{DoxyCode}
\index{Dummy\+Memory\+Leak\+Detector@{Dummy\+Memory\+Leak\+Detector}!get\+Mutex@{get\+Mutex}}
\index{get\+Mutex@{get\+Mutex}!Dummy\+Memory\+Leak\+Detector@{Dummy\+Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{get\+Mutex(void)}{getMutex(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Simple\+Mutex} $\ast$ get\+Mutex (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inherited]}}\hypertarget{class_memory_leak_detector_a19d27cb7dd06173cc88f58543bfe3020}{}\label{class_memory_leak_detector_a19d27cb7dd06173cc88f58543bfe3020}


Memory\+Leak\+Detector.\+cpp 파일의 477 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
478 \{
479     \textcolor{keywordflow}{return} \hyperlink{class_memory_leak_detector_ab92d2f1606fbc62f3c4d5184d735dd04}{mutex\_};
480 \}
\end{DoxyCode}
\index{Dummy\+Memory\+Leak\+Detector@{Dummy\+Memory\+Leak\+Detector}!invalidate\+Memory@{invalidate\+Memory}}
\index{invalidate\+Memory@{invalidate\+Memory}!Dummy\+Memory\+Leak\+Detector@{Dummy\+Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{invalidate\+Memory(char $\ast$memory)}{invalidateMemory(char *memory)}}]{\setlength{\rightskip}{0pt plus 5cm}void invalidate\+Memory (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{memory}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inherited]}}\hypertarget{class_memory_leak_detector_a1b924f98e6bf1203714985e0b0c3de5d}{}\label{class_memory_leak_detector_a1b924f98e6bf1203714985e0b0c3de5d}


Memory\+Leak\+Detector.\+cpp 파일의 514 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
515 \{
516   \hyperlink{struct_memory_leak_detector_node}{MemoryLeakDetectorNode}* node = \hyperlink{class_memory_leak_detector_abee17cabbc59ef23d6f51027208a100c}{memoryTable\_}.
      \hyperlink{struct_memory_leak_detector_table_aa1655267a6cde38557847aca1e545a77}{retrieveNode}(memory);
517   \textcolor{keywordflow}{if} (node)
518     \hyperlink{_platform_specific_functions__c_8h_af64506f1a244f59ae6d68728a912133d}{PlatformSpecificMemset}(memory, 0xCD, node->\hyperlink{struct_memory_leak_detector_node_a5f31775800bbb46b35b5791def1f3acc}{size\_});
519 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_memory_leak_detector_a1b924f98e6bf1203714985e0b0c3de5d_icgraph}
\end{center}
\end{figure}


\index{Dummy\+Memory\+Leak\+Detector@{Dummy\+Memory\+Leak\+Detector}!mark\+Checking\+Period\+Leaks\+As\+Non\+Checking\+Period@{mark\+Checking\+Period\+Leaks\+As\+Non\+Checking\+Period}}
\index{mark\+Checking\+Period\+Leaks\+As\+Non\+Checking\+Period@{mark\+Checking\+Period\+Leaks\+As\+Non\+Checking\+Period}!Dummy\+Memory\+Leak\+Detector@{Dummy\+Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{mark\+Checking\+Period\+Leaks\+As\+Non\+Checking\+Period()}{markCheckingPeriodLeaksAsNonCheckingPeriod()}}]{\setlength{\rightskip}{0pt plus 5cm}void mark\+Checking\+Period\+Leaks\+As\+Non\+Checking\+Period (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inherited]}}\hypertarget{class_memory_leak_detector_a6db202697cf20e8d84748b129c403545}{}\label{class_memory_leak_detector_a6db202697cf20e8d84748b129c403545}


Memory\+Leak\+Detector.\+cpp 파일의 650 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
651 \{
652     \hyperlink{struct_memory_leak_detector_node}{MemoryLeakDetectorNode}* leak = \hyperlink{class_memory_leak_detector_abee17cabbc59ef23d6f51027208a100c}{memoryTable\_}.
      \hyperlink{struct_memory_leak_detector_table_a1b95cd1a5e8372a8f795f2d3387ae065}{getFirstLeak}(\hyperlink{_memory_leak_detector_8h_ab248e6cc6c6699b88b002286d8a3ed76ad140291a5b8a535af47f9858220f2639}{mem\_leak\_period\_checking});
653     \textcolor{keywordflow}{while} (leak) \{
654         \textcolor{keywordflow}{if} (leak->\hyperlink{struct_memory_leak_detector_node_a4b296dc99cd64623a83ce9027f70e0e7}{period\_} == \hyperlink{_memory_leak_detector_8h_ab248e6cc6c6699b88b002286d8a3ed76ad140291a5b8a535af47f9858220f2639}{mem\_leak\_period\_checking}) leak->
      \hyperlink{struct_memory_leak_detector_node_a4b296dc99cd64623a83ce9027f70e0e7}{period\_} = \hyperlink{_memory_leak_detector_8h_ab248e6cc6c6699b88b002286d8a3ed76af44afdfdc843b0c299b8b0a9585a0f32}{mem\_leak\_period\_enabled};
655         leak = \hyperlink{class_memory_leak_detector_abee17cabbc59ef23d6f51027208a100c}{memoryTable\_}.\hyperlink{struct_memory_leak_detector_table_a4aafc8945d8152ee287b651ffd2ede97}{getNextLeak}(leak, 
      \hyperlink{_memory_leak_detector_8h_ab248e6cc6c6699b88b002286d8a3ed76ad140291a5b8a535af47f9858220f2639}{mem\_leak\_period\_checking});
656     \}
657 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_memory_leak_detector_a6db202697cf20e8d84748b129c403545_icgraph}
\end{center}
\end{figure}


\index{Dummy\+Memory\+Leak\+Detector@{Dummy\+Memory\+Leak\+Detector}!realloc\+Memory@{realloc\+Memory}}
\index{realloc\+Memory@{realloc\+Memory}!Dummy\+Memory\+Leak\+Detector@{Dummy\+Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{realloc\+Memory(\+Test\+Memory\+Allocator $\ast$allocator, char $\ast$memory, size\+\_\+t size, const char $\ast$file, int line, bool allocat\+Nodes\+Seperately=false)}{reallocMemory(TestMemoryAllocator *allocator, char *memory, size_t size, const char *file, int line, bool allocatNodesSeperately=false)}}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$ realloc\+Memory (
\begin{DoxyParamCaption}
\item[{{\bf Test\+Memory\+Allocator} $\ast$}]{allocator, }
\item[{char $\ast$}]{memory, }
\item[{size\+\_\+t}]{size, }
\item[{const char $\ast$}]{file, }
\item[{int}]{line, }
\item[{{\bf bool}}]{allocat\+Nodes\+Seperately = {\ttfamily {\bf false}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inherited]}}\hypertarget{class_memory_leak_detector_a6aded764a2297f52a104b75eae2d4b5c}{}\label{class_memory_leak_detector_a6aded764a2297f52a104b75eae2d4b5c}


Memory\+Leak\+Detector.\+cpp 파일의 616 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
617 \{
618     \textcolor{keywordflow}{if} (memory) \{
619         \hyperlink{struct_memory_leak_detector_node}{MemoryLeakDetectorNode}* node = \hyperlink{class_memory_leak_detector_abee17cabbc59ef23d6f51027208a100c}{memoryTable\_}.
      \hyperlink{struct_memory_leak_detector_table_aaa0452383ce806d8a7248cb567813f84}{removeNode}(memory);
620         \textcolor{keywordflow}{if} (node == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}) \{
621             \hyperlink{class_memory_leak_detector_a7d0b175420d83f9ee397b398ae14ac75}{outputBuffer\_}.\hyperlink{class_memory_leak_output_string_buffer_a0061b779a33beb2d8c87eb915b20309a}{reportDeallocateNonAllocatedMemoryFailure}
      (file, line, allocator, \hyperlink{class_memory_leak_detector_a632df6e6476c93d9c58a104a17e155d9}{reporter\_});
622             \textcolor{keywordflow}{return} \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
623         \}
624         \hyperlink{class_memory_leak_detector_ae260d75b307f341763273c1e99a11c1d}{checkForCorruption}(node, file, line, allocator, allocatNodesSeperately);
625     \}
626     \textcolor{keywordflow}{return} \hyperlink{class_memory_leak_detector_aa670d663e64a85135a23f26c124e5bd7}{reallocateMemoryAndLeakInformation}(allocator, memory, 
      \hyperlink{gst__avb__playbin_8c_a439227feff9d7f55384e8780cfc2eb82}{size}, file, line, allocatNodesSeperately);
627 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=238pt]{class_memory_leak_detector_a6aded764a2297f52a104b75eae2d4b5c_icgraph}
\end{center}
\end{figure}


\index{Dummy\+Memory\+Leak\+Detector@{Dummy\+Memory\+Leak\+Detector}!remove\+Memory\+Leak\+Information\+Without\+Checking\+Or\+Deallocating\+The\+Memory\+But\+Deallocating\+The\+Account\+Information@{remove\+Memory\+Leak\+Information\+Without\+Checking\+Or\+Deallocating\+The\+Memory\+But\+Deallocating\+The\+Account\+Information}}
\index{remove\+Memory\+Leak\+Information\+Without\+Checking\+Or\+Deallocating\+The\+Memory\+But\+Deallocating\+The\+Account\+Information@{remove\+Memory\+Leak\+Information\+Without\+Checking\+Or\+Deallocating\+The\+Memory\+But\+Deallocating\+The\+Account\+Information}!Dummy\+Memory\+Leak\+Detector@{Dummy\+Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{remove\+Memory\+Leak\+Information\+Without\+Checking\+Or\+Deallocating\+The\+Memory\+But\+Deallocating\+The\+Account\+Information(\+Test\+Memory\+Allocator $\ast$allocator, void $\ast$memory, bool allocat\+Nodes\+Seperately)}{removeMemoryLeakInformationWithoutCheckingOrDeallocatingTheMemoryButDeallocatingTheAccountInformation(TestMemoryAllocator *allocator, void *memory, bool allocatNodesSeperately)}}]{\setlength{\rightskip}{0pt plus 5cm}void remove\+Memory\+Leak\+Information\+Without\+Checking\+Or\+Deallocating\+The\+Memory\+But\+Deallocating\+The\+Account\+Information (
\begin{DoxyParamCaption}
\item[{{\bf Test\+Memory\+Allocator} $\ast$}]{allocator, }
\item[{void $\ast$}]{memory, }
\item[{{\bf bool}}]{allocat\+Nodes\+Seperately}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inherited]}}\hypertarget{class_memory_leak_detector_ac17764ba8c2ced15cbbbca1731f6b21e}{}\label{class_memory_leak_detector_ac17764ba8c2ced15cbbbca1731f6b21e}


Memory\+Leak\+Detector.\+cpp 파일의 590 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
591 \{
592     \hyperlink{struct_memory_leak_detector_node}{MemoryLeakDetectorNode}* node = \hyperlink{class_memory_leak_detector_abee17cabbc59ef23d6f51027208a100c}{memoryTable\_}.
      \hyperlink{struct_memory_leak_detector_table_aaa0452383ce806d8a7248cb567813f84}{removeNode}((\textcolor{keywordtype}{char}*) memory);
593     \textcolor{keywordflow}{if} (allocatNodesSeperately) allocator->\hyperlink{class_test_memory_allocator_a10f2958f3b7378256e933896ccc93df0}{freeMemoryLeakNode}( (\textcolor{keywordtype}{char}*) node);
594 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_memory_leak_detector_ac17764ba8c2ced15cbbbca1731f6b21e_cgraph}
\end{center}
\end{figure}


\index{Dummy\+Memory\+Leak\+Detector@{Dummy\+Memory\+Leak\+Detector}!report@{report}}
\index{report@{report}!Dummy\+Memory\+Leak\+Detector@{Dummy\+Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{report(\+Mem\+Leak\+Period period)}{report(MemLeakPeriod period)}}]{\setlength{\rightskip}{0pt plus 5cm}const char $\ast$ report (
\begin{DoxyParamCaption}
\item[{{\bf Mem\+Leak\+Period}}]{period}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inherited]}}\hypertarget{class_memory_leak_detector_acc70330c27080c4b09b96342929dc9ca}{}\label{class_memory_leak_detector_acc70330c27080c4b09b96342929dc9ca}


Memory\+Leak\+Detector.\+cpp 파일의 643 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
644 \{
645     \hyperlink{class_memory_leak_detector_a4a0939ba826695d9def779d703dcb93f}{ConstructMemoryLeakReport}(period);
646 
647     \textcolor{keywordflow}{return} \hyperlink{class_memory_leak_detector_a7d0b175420d83f9ee397b398ae14ac75}{outputBuffer\_}.\hyperlink{class_memory_leak_output_string_buffer_ac4969471df03a7a438bd99bfe61a0d5e}{toString}();
648 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=255pt]{class_memory_leak_detector_acc70330c27080c4b09b96342929dc9ca_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_memory_leak_detector_acc70330c27080c4b09b96342929dc9ca_icgraph}
\end{center}
\end{figure}


\index{Dummy\+Memory\+Leak\+Detector@{Dummy\+Memory\+Leak\+Detector}!start\+Checking@{start\+Checking}}
\index{start\+Checking@{start\+Checking}!Dummy\+Memory\+Leak\+Detector@{Dummy\+Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{start\+Checking()}{startChecking()}}]{\setlength{\rightskip}{0pt plus 5cm}void start\+Checking (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inherited]}}\hypertarget{class_memory_leak_detector_ae912c5ee9034b76f13f1c9dbab55e512}{}\label{class_memory_leak_detector_ae912c5ee9034b76f13f1c9dbab55e512}


Memory\+Leak\+Detector.\+cpp 파일의 441 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
442 \{
443     \hyperlink{class_memory_leak_detector_a7d0b175420d83f9ee397b398ae14ac75}{outputBuffer\_}.\hyperlink{class_memory_leak_output_string_buffer_ac8bb3912a3ce86b15842e79d0b421204}{clear}();
444     \hyperlink{class_memory_leak_detector_af82b746b32f3ce3919db77a6985bab42}{current\_period\_} = \hyperlink{_memory_leak_detector_8h_ab248e6cc6c6699b88b002286d8a3ed76ad140291a5b8a535af47f9858220f2639}{mem\_leak\_period\_checking};
445 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=291pt]{class_memory_leak_detector_ae912c5ee9034b76f13f1c9dbab55e512_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=329pt]{class_memory_leak_detector_ae912c5ee9034b76f13f1c9dbab55e512_icgraph}
\end{center}
\end{figure}


\index{Dummy\+Memory\+Leak\+Detector@{Dummy\+Memory\+Leak\+Detector}!stop\+Checking@{stop\+Checking}}
\index{stop\+Checking@{stop\+Checking}!Dummy\+Memory\+Leak\+Detector@{Dummy\+Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{stop\+Checking()}{stopChecking()}}]{\setlength{\rightskip}{0pt plus 5cm}void stop\+Checking (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inherited]}}\hypertarget{class_memory_leak_detector_a9e85551d474d895ba8852b8e56481c7c}{}\label{class_memory_leak_detector_a9e85551d474d895ba8852b8e56481c7c}


Memory\+Leak\+Detector.\+cpp 파일의 447 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
448 \{
449     \hyperlink{class_memory_leak_detector_af82b746b32f3ce3919db77a6985bab42}{current\_period\_} = \hyperlink{_memory_leak_detector_8h_ab248e6cc6c6699b88b002286d8a3ed76af44afdfdc843b0c299b8b0a9585a0f32}{mem\_leak\_period\_enabled};
450 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=329pt]{class_memory_leak_detector_a9e85551d474d895ba8852b8e56481c7c_icgraph}
\end{center}
\end{figure}


\index{Dummy\+Memory\+Leak\+Detector@{Dummy\+Memory\+Leak\+Detector}!total\+Memory\+Leaks@{total\+Memory\+Leaks}}
\index{total\+Memory\+Leaks@{total\+Memory\+Leaks}!Dummy\+Memory\+Leak\+Detector@{Dummy\+Memory\+Leak\+Detector}}
\subsubsection[{\texorpdfstring{total\+Memory\+Leaks(\+Mem\+Leak\+Period period)}{totalMemoryLeaks(MemLeakPeriod period)}}]{\setlength{\rightskip}{0pt plus 5cm}int total\+Memory\+Leaks (
\begin{DoxyParamCaption}
\item[{{\bf Mem\+Leak\+Period}}]{period}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inherited]}}\hypertarget{class_memory_leak_detector_a7b0c5d9c4d678d6e0081802416660803}{}\label{class_memory_leak_detector_a7b0c5d9c4d678d6e0081802416660803}


Memory\+Leak\+Detector.\+cpp 파일의 659 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
660 \{
661     \textcolor{keywordflow}{return} \hyperlink{class_memory_leak_detector_abee17cabbc59ef23d6f51027208a100c}{memoryTable\_}.\hyperlink{struct_memory_leak_detector_table_ae203c76563a188474a816e4ef8d8aa06}{getTotalLeaks}(period);
662 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_memory_leak_detector_a7b0c5d9c4d678d6e0081802416660803_icgraph}
\end{center}
\end{figure}




이 클래스에 대한 문서화 페이지는 다음의 파일로부터 생성되었습니다.\+:\begin{DoxyCompactItemize}
\item 
thirdparty/cpputest/tests/\+Cpp\+U\+Test/\hyperlink{_memory_leak_warning_test_8cpp}{Memory\+Leak\+Warning\+Test.\+cpp}\end{DoxyCompactItemize}
