\hypertarget{igb_8c}{}\section{lib/igb/igb.c 파일 참조}
\label{igb_8c}\index{lib/igb/igb.\+c@{lib/igb/igb.\+c}}
{\ttfamily \#include $<$unistd.\+h$>$}\\*
{\ttfamily \#include $<$fcntl.\+h$>$}\\*
{\ttfamily \#include $<$stdlib.\+h$>$}\\*
{\ttfamily \#include $<$stdio.\+h$>$}\\*
{\ttfamily \#include $<$string.\+h$>$}\\*
{\ttfamily \#include $<$syslog.\+h$>$}\\*
{\ttfamily \#include $<$signal.\+h$>$}\\*
{\ttfamily \#include $<$errno.\+h$>$}\\*
{\ttfamily \#include $<$time.\+h$>$}\\*
{\ttfamily \#include $<$sys/ioctl.\+h$>$}\\*
{\ttfamily \#include $<$sys/time.\+h$>$}\\*
{\ttfamily \#include $<$sys/resource.\+h$>$}\\*
{\ttfamily \#include $<$sys/mman.\+h$>$}\\*
{\ttfamily \#include $<$sys/user.\+h$>$}\\*
{\ttfamily \#include $<$sys/stat.\+h$>$}\\*
{\ttfamily \#include $<$stdint.\+h$>$}\\*
{\ttfamily \#include $<$semaphore.\+h$>$}\\*
{\ttfamily \#include $<$pthread.\+h$>$}\\*
{\ttfamily \#include \char`\"{}e1000\+\_\+hw.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}e1000\+\_\+82575.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}igb\+\_\+internal.\+h\char`\"{}}\\*
igb.\+c에 대한 include 의존 그래프
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{igb_8c__incl}
\end{center}
\end{figure}
\subsection*{매크로}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{igb_8c_adb750b9f7efbe2a8f60f02dd4a9343d1}{I\+G\+B\+\_\+\+S\+EM}~\char`\"{}/igb\+\_\+sem\char`\"{}
\item 
\#define \hyperlink{igb_8c_acd517c6f195c75b9dd0f3aad65326f3b}{M\+A\+X\+\_\+\+I\+T\+ER}~32
\item 
\#define \hyperlink{igb_8c_aa9d89e374be1585846f0890ab560f8d6}{M\+I\+N\+\_\+\+W\+A\+L\+L\+C\+L\+O\+C\+K\+\_\+\+T\+S\+C\+\_\+\+W\+I\+N\+D\+OW}~80 /$\ast$ cycles $\ast$/
\item 
\#define \hyperlink{igb_8c_a89ab2f32a0f28c0dd70cf0597008808a}{M\+I\+N\+\_\+\+S\+Y\+S\+C\+L\+O\+C\+K\+\_\+\+W\+I\+N\+D\+OW}~72 /$\ast$ ns $\ast$/
\end{DoxyCompactItemize}
\subsection*{함수}
\begin{DoxyCompactItemize}
\item 
static int \hyperlink{igb_8c_aef7aae6f7e25f628d6313de3911827e5}{igb\+\_\+read\+\_\+mac\+\_\+addr} (struct \hyperlink{structe1000__hw}{e1000\+\_\+hw} $\ast$hw)
\item 
static int \hyperlink{igb_8c_ac2793cb8a8e3320094491f518adfdfb1}{igb\+\_\+allocate\+\_\+pci\+\_\+resources} (struct \hyperlink{structadapter}{adapter} $\ast$\hyperlink{structadapter}{adapter})
\item 
static void \hyperlink{igb_8c_a598861e7bb5e9769bde5e4dbb853fda8}{igb\+\_\+free\+\_\+pci\+\_\+resources} (struct \hyperlink{structadapter}{adapter} $\ast$\hyperlink{structadapter}{adapter})
\item 
static void \hyperlink{igb_8c_afa49e6907f7179625e2267faa054d250}{igb\+\_\+reset} (struct \hyperlink{structadapter}{adapter} $\ast$\hyperlink{structadapter}{adapter})
\item 
static int \hyperlink{igb_8c_a3090d15b20de07b55d9b4d22ab65b84d}{igb\+\_\+allocate\+\_\+queues} (struct \hyperlink{structadapter}{adapter} $\ast$\hyperlink{structadapter}{adapter})
\item 
static int \hyperlink{igb_8c_ac7a39260a8612878b8bca07572027f75}{igb\+\_\+allocate\+\_\+rx\+\_\+queues} (struct \hyperlink{structadapter}{adapter} $\ast$\hyperlink{structadapter}{adapter})
\item 
static void \hyperlink{igb_8c_ab90de8e2832d77cf89310e4e86f5bce3}{igb\+\_\+setup\+\_\+transmit\+\_\+structures} (struct \hyperlink{structadapter}{adapter} $\ast$\hyperlink{structadapter}{adapter})
\item 
static void \hyperlink{igb_8c_a1d555819a110fd3491fc4d2f0a69c2ac}{igb\+\_\+setup\+\_\+receive\+\_\+structures} (struct \hyperlink{structadapter}{adapter} $\ast$\hyperlink{structadapter}{adapter})
\item 
static void \hyperlink{igb_8c_a9c5d92d7861904dde94814d52798648f}{igb\+\_\+setup\+\_\+transmit\+\_\+ring} (struct \hyperlink{structtx__ring}{tx\+\_\+ring} $\ast$txr)
\item 
static void \hyperlink{igb_8c_afe8ec56d1a800f2a02b47a1744c43e4f}{igb\+\_\+initialize\+\_\+transmit\+\_\+units} (struct \hyperlink{structadapter}{adapter} $\ast$\hyperlink{structadapter}{adapter})
\item 
static void \hyperlink{igb_8c_a7e188d0bfc699ebde4636a227e012953}{igb\+\_\+initialize\+\_\+receive\+\_\+units} (struct \hyperlink{structadapter}{adapter} $\ast$\hyperlink{structadapter}{adapter})
\item 
static void \hyperlink{igb_8c_a6a40edaa22ec396808c4e534609acd40}{igb\+\_\+free\+\_\+transmit\+\_\+structures} (struct \hyperlink{structadapter}{adapter} $\ast$\hyperlink{structadapter}{adapter})
\item 
static void \hyperlink{igb_8c_a963d0751ad152e084b08017d83e5d701}{igb\+\_\+free\+\_\+receive\+\_\+structures} (struct \hyperlink{structadapter}{adapter} $\ast$\hyperlink{structadapter}{adapter})
\item 
static void \hyperlink{igb_8c_aaa210ea8eb28fd252bc89ffd3491f863}{igb\+\_\+tx\+\_\+ctx\+\_\+setup} (struct \hyperlink{structtx__ring}{tx\+\_\+ring} $\ast$txr, struct \hyperlink{structigb__packet}{igb\+\_\+packet} $\ast$packet)
\item 
static void \hyperlink{igb_8c_a6dd8c22e48f62fd8dedba075039d6747}{igb\+\_\+free\+\_\+receive\+\_\+buffers} (struct \hyperlink{structrx__ring}{rx\+\_\+ring} $\ast$rxr)
\item 
static int \hyperlink{igb_8c_a7fcc5ae922167895160aed1c771d5e62}{igb\+\_\+create\+\_\+lock} (struct \hyperlink{structadapter}{adapter} $\ast$\hyperlink{structadapter}{adapter})
\item 
int \hyperlink{igb_8c_acd158f7434074c560d468d5acd878f06}{igb\+\_\+probe} (\hyperlink{lib_2igb_2igb_8h_ae819c345449e1c44d253068a0a3ab5e5}{device\+\_\+t} $\ast$dev)
\item 
int \hyperlink{igb_8c_a8c1d26054ca159adda99c2ad1f1c54d7}{igb\+\_\+attach} (char $\ast$dev\+\_\+path, \hyperlink{lib_2igb_2igb_8h_ae819c345449e1c44d253068a0a3ab5e5}{device\+\_\+t} $\ast$pdev)
\item 
int \hyperlink{igb_8c_a1165811ba4373e6d86067dca098df2ef}{igb\+\_\+attach\+\_\+tx} (\hyperlink{lib_2igb_2igb_8h_ae819c345449e1c44d253068a0a3ab5e5}{device\+\_\+t} $\ast$pdev)
\item 
int \hyperlink{igb_8c_a357bc6278f681d74b36ac5d26cb2b6c5}{igb\+\_\+attach\+\_\+rx} (\hyperlink{lib_2igb_2igb_8h_ae819c345449e1c44d253068a0a3ab5e5}{device\+\_\+t} $\ast$pdev)
\item 
int \hyperlink{igb_8c_a234eba39e755b10f3ad1652c95072a77}{igb\+\_\+detach} (\hyperlink{lib_2igb_2igb_8h_ae819c345449e1c44d253068a0a3ab5e5}{device\+\_\+t} $\ast$dev)
\item 
int \hyperlink{igb_8c_a19a337cedcfe8b1bd0ad95b02764e0c2}{igb\+\_\+suspend} (\hyperlink{lib_2igb_2igb_8h_ae819c345449e1c44d253068a0a3ab5e5}{device\+\_\+t} $\ast$dev)
\item 
int \hyperlink{igb_8c_a8c75a4c23961007c7acd70607a34537f}{igb\+\_\+resume} (\hyperlink{lib_2igb_2igb_8h_ae819c345449e1c44d253068a0a3ab5e5}{device\+\_\+t} $\ast$dev)
\item 
int \hyperlink{igb_8c_a923b0ffcf94a4a6ac8f36a7bacd6b0f3}{igb\+\_\+init} (\hyperlink{lib_2igb_2igb_8h_ae819c345449e1c44d253068a0a3ab5e5}{device\+\_\+t} $\ast$dev)
\item 
int \hyperlink{igb_8c_a4e2589d22e959c35c0902ef79ed3f059}{igb\+\_\+dma\+\_\+malloc\+\_\+page} (\hyperlink{lib_2igb_2igb_8h_ae819c345449e1c44d253068a0a3ab5e5}{device\+\_\+t} $\ast$dev, struct \hyperlink{structigb__dma__alloc}{igb\+\_\+dma\+\_\+alloc} $\ast$dma)
\item 
void \hyperlink{igb_8c_a850c73e1871342ff79fe6f0a5e6c26f3}{igb\+\_\+dma\+\_\+free\+\_\+page} (\hyperlink{lib_2igb_2igb_8h_ae819c345449e1c44d253068a0a3ab5e5}{device\+\_\+t} $\ast$dev, struct \hyperlink{structigb__dma__alloc}{igb\+\_\+dma\+\_\+alloc} $\ast$dma)
\item 
int \hyperlink{igb_8c_a6c8e23bd2a93ab63646fd498ac8e2127}{igb\+\_\+xmit} (\hyperlink{lib_2igb_2igb_8h_ae819c345449e1c44d253068a0a3ab5e5}{device\+\_\+t} $\ast$dev, unsigned int queue\+\_\+index, struct \hyperlink{structigb__packet}{igb\+\_\+packet} $\ast$packet)
\item 
void \hyperlink{igb_8c_a5864a4d842dc6705be6cb1f684d8c2b8}{igb\+\_\+trigger} (\hyperlink{lib_2igb_2igb_8h_ae819c345449e1c44d253068a0a3ab5e5}{device\+\_\+t} $\ast$dev, u\+\_\+int32\+\_\+t data)
\item 
void \hyperlink{igb_8c_a5ad072e861f3e0a4d595da0629ee71b7}{igb\+\_\+writereg} (\hyperlink{lib_2igb_2igb_8h_ae819c345449e1c44d253068a0a3ab5e5}{device\+\_\+t} $\ast$dev, u\+\_\+int32\+\_\+t reg, u\+\_\+int32\+\_\+t data)
\item 
void \hyperlink{igb_8c_aee4e5308f98a08ff4036b3a9b3ab7784}{igb\+\_\+readreg} (\hyperlink{lib_2igb_2igb_8h_ae819c345449e1c44d253068a0a3ab5e5}{device\+\_\+t} $\ast$dev, u\+\_\+int32\+\_\+t reg, u\+\_\+int32\+\_\+t $\ast$data)
\item 
int \hyperlink{igb_8c_a791fd0757e3ca1833df21ee94c17b855}{igb\+\_\+lock} (\hyperlink{lib_2igb_2igb_8h_ae819c345449e1c44d253068a0a3ab5e5}{device\+\_\+t} $\ast$dev)
\item 
int \hyperlink{igb_8c_a4072fbeaba958ad7c81990de452139da}{igb\+\_\+unlock} (\hyperlink{lib_2igb_2igb_8h_ae819c345449e1c44d253068a0a3ab5e5}{device\+\_\+t} $\ast$dev)
\item 
void \hyperlink{igb_8c_a03eaebcc1732abe4fd77c1f79c8e2fee}{igb\+\_\+clean} (\hyperlink{lib_2igb_2igb_8h_ae819c345449e1c44d253068a0a3ab5e5}{device\+\_\+t} $\ast$dev, struct \hyperlink{structigb__packet}{igb\+\_\+packet} $\ast$$\ast$\hyperlink{gstavbsink_8c_a03cc454be42935d04410937d1053eb60}{cleaned\+\_\+packets})
\item 
static void \hyperlink{igb_8c_aec1cca14ce5797701742e519f394cbbc}{igb\+\_\+free\+\_\+receive\+\_\+ring} (struct \hyperlink{structrx__ring}{rx\+\_\+ring} $\ast$rxr)
\item 
static void \hyperlink{igb_8c_a7782563000c24cdd2e094c5d22172c9d}{igb\+\_\+setup\+\_\+receive\+\_\+ring} (struct \hyperlink{structrx__ring}{rx\+\_\+ring} $\ast$rxr)
\item 
int \hyperlink{igb_8c_ad8f45b19c3bd6aca50b6b6b599e3a3b5}{igb\+\_\+refresh\+\_\+buffers} (\hyperlink{lib_2igb_2igb_8h_ae819c345449e1c44d253068a0a3ab5e5}{device\+\_\+t} $\ast$dev, u\+\_\+int32\+\_\+t idx, struct \hyperlink{structigb__packet}{igb\+\_\+packet} $\ast$$\ast$rxbuf\+\_\+packets, u\+\_\+int32\+\_\+t num\+\_\+bufs)
\item 
int \hyperlink{igb_8c_aa7d218e2a22d2aae6d98318b477526dd}{igb\+\_\+receive} (\hyperlink{lib_2igb_2igb_8h_ae819c345449e1c44d253068a0a3ab5e5}{device\+\_\+t} $\ast$dev, unsigned int queue\+\_\+index, struct \hyperlink{structigb__packet}{igb\+\_\+packet} $\ast$$\ast$received\+\_\+packets, u\+\_\+int32\+\_\+t $\ast$count)
\item 
static void \hyperlink{igb_8c_aa7a036d8ae3af2ea70fb4cbdf1f25fbd}{rdtscpll} (\hyperlink{parse_8c_aec6fcb673ff035718c238c8c9d544c47}{uint64\+\_\+t} $\ast$val)
\item 
static void \hyperlink{igb_8c_aaf70944cc9bd58b4497abeb70c220890}{\+\_\+\+\_\+sync} (void)
\item 
int \hyperlink{igb_8c_aa45f65b8e5ac2a1d1d1a7081c499a690}{igb\+\_\+get\+\_\+wallclock} (\hyperlink{lib_2igb_2igb_8h_ae819c345449e1c44d253068a0a3ab5e5}{device\+\_\+t} $\ast$dev, u\+\_\+int64\+\_\+t $\ast$curtime, u\+\_\+int64\+\_\+t $\ast$rdtsc)
\item 
struct timespec \hyperlink{igb_8c_ab85ff62741520edc013979580b140b56}{timespec\+\_\+subtract} (struct timespec $\ast$a, struct timespec $\ast$b)
\item 
struct timespec \hyperlink{igb_8c_a83c184a21a1b1cceb3a3229e9f165245}{timespec\+\_\+addns} (struct timespec $\ast$a, unsigned long addns)
\item 
static u\+\_\+int32\+\_\+t \hyperlink{igb_8c_a4b64a260ae06308aa59a1cc415b605fd}{T\+S2\+NS} (struct timespec ts)
\item 
int \hyperlink{igb_8c_a2ad1701694c890809c969274ec597931}{igb\+\_\+gettime} (\hyperlink{lib_2igb_2igb_8h_ae819c345449e1c44d253068a0a3ab5e5}{device\+\_\+t} $\ast$dev, clockid\+\_\+t clk\+\_\+id, u\+\_\+int64\+\_\+t $\ast$curtime, struct timespec $\ast$system\+\_\+time)
\item 
int \hyperlink{igb_8c_a8d49a6fa54c79c1b5bd5b6f006eeb8e1}{igb\+\_\+set\+\_\+class\+\_\+bandwidth} (\hyperlink{lib_2igb_2igb_8h_ae819c345449e1c44d253068a0a3ab5e5}{device\+\_\+t} $\ast$dev, u\+\_\+int32\+\_\+t class\+\_\+a, u\+\_\+int32\+\_\+t class\+\_\+b, u\+\_\+int32\+\_\+t tpktsz\+\_\+a, u\+\_\+int32\+\_\+t tpktsz\+\_\+b)
\item 
int \hyperlink{igb_8c_a08432a2e3faf4dc22641a6ee75f309c9}{igb\+\_\+set\+\_\+class\+\_\+bandwidth2} (\hyperlink{lib_2igb_2igb_8h_ae819c345449e1c44d253068a0a3ab5e5}{device\+\_\+t} $\ast$dev, u\+\_\+int32\+\_\+t class\+\_\+a\+\_\+bytes\+\_\+per\+\_\+second, u\+\_\+int32\+\_\+t class\+\_\+b\+\_\+bytes\+\_\+per\+\_\+second)
\item 
int \hyperlink{igb_8c_a257a2d309437e1cf4b696915dda16871}{igb\+\_\+get\+\_\+mac\+\_\+addr} (\hyperlink{lib_2igb_2igb_8h_ae819c345449e1c44d253068a0a3ab5e5}{device\+\_\+t} $\ast$dev, u\+\_\+int8\+\_\+t mac\+\_\+addr\mbox{[}\hyperlink{igb__internal_8h_a78fc3e3fe5c33412e9f47a214f6e0415}{E\+T\+H\+\_\+\+A\+D\+D\+R\+\_\+\+L\+EN}\mbox{]})
\item 
int \hyperlink{igb_8c_a27cde3a06b5513af43c11c40fc5503dc}{igb\+\_\+setup\+\_\+flex\+\_\+filter} (\hyperlink{lib_2igb_2igb_8h_ae819c345449e1c44d253068a0a3ab5e5}{device\+\_\+t} $\ast$dev, unsigned int queue\+\_\+id, unsigned int filter\+\_\+id, unsigned int filter\+\_\+len, u\+\_\+int8\+\_\+t $\ast$filter, u\+\_\+int8\+\_\+t $\ast$mask)
\item 
int \hyperlink{igb_8c_a4f4ed06dde00dd89730d8968ac3e9f46}{igb\+\_\+clear\+\_\+flex\+\_\+filter} (\hyperlink{lib_2igb_2igb_8h_ae819c345449e1c44d253068a0a3ab5e5}{device\+\_\+t} $\ast$dev, unsigned int filter\+\_\+id)
\end{DoxyCompactItemize}
\subsection*{변수}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{igb__internal_8h_a8fa742277ed808c2270d925703767860}{igb\+\_\+vendor\+\_\+info\+\_\+t} \hyperlink{igb_8c_a9519a91bae2a9829950d6c2b88a7cd26}{igb\+\_\+vendor\+\_\+info\+\_\+array} \mbox{[}$\,$\mbox{]}
\end{DoxyCompactItemize}


\subsection{매크로 문서화}
\index{igb.\+c@{igb.\+c}!I\+G\+B\+\_\+\+S\+EM@{I\+G\+B\+\_\+\+S\+EM}}
\index{I\+G\+B\+\_\+\+S\+EM@{I\+G\+B\+\_\+\+S\+EM}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{I\+G\+B\+\_\+\+S\+EM}{IGB_SEM}}]{\setlength{\rightskip}{0pt plus 5cm}\#define I\+G\+B\+\_\+\+S\+EM~\char`\"{}/igb\+\_\+sem\char`\"{}}\hypertarget{igb_8c_adb750b9f7efbe2a8f60f02dd4a9343d1}{}\label{igb_8c_adb750b9f7efbe2a8f60f02dd4a9343d1}


igb.\+c 파일의 130 번째 라인에서 정의되었습니다.

\index{igb.\+c@{igb.\+c}!M\+A\+X\+\_\+\+I\+T\+ER@{M\+A\+X\+\_\+\+I\+T\+ER}}
\index{M\+A\+X\+\_\+\+I\+T\+ER@{M\+A\+X\+\_\+\+I\+T\+ER}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{M\+A\+X\+\_\+\+I\+T\+ER}{MAX_ITER}}]{\setlength{\rightskip}{0pt plus 5cm}\#define M\+A\+X\+\_\+\+I\+T\+ER~32}\hypertarget{igb_8c_acd517c6f195c75b9dd0f3aad65326f3b}{}\label{igb_8c_acd517c6f195c75b9dd0f3aad65326f3b}


igb.\+c 파일의 1839 번째 라인에서 정의되었습니다.

\index{igb.\+c@{igb.\+c}!M\+I\+N\+\_\+\+S\+Y\+S\+C\+L\+O\+C\+K\+\_\+\+W\+I\+N\+D\+OW@{M\+I\+N\+\_\+\+S\+Y\+S\+C\+L\+O\+C\+K\+\_\+\+W\+I\+N\+D\+OW}}
\index{M\+I\+N\+\_\+\+S\+Y\+S\+C\+L\+O\+C\+K\+\_\+\+W\+I\+N\+D\+OW@{M\+I\+N\+\_\+\+S\+Y\+S\+C\+L\+O\+C\+K\+\_\+\+W\+I\+N\+D\+OW}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{M\+I\+N\+\_\+\+S\+Y\+S\+C\+L\+O\+C\+K\+\_\+\+W\+I\+N\+D\+OW}{MIN_SYSCLOCK_WINDOW}}]{\setlength{\rightskip}{0pt plus 5cm}\#define M\+I\+N\+\_\+\+S\+Y\+S\+C\+L\+O\+C\+K\+\_\+\+W\+I\+N\+D\+OW~72 /$\ast$ ns $\ast$/}\hypertarget{igb_8c_a89ab2f32a0f28c0dd70cf0597008808a}{}\label{igb_8c_a89ab2f32a0f28c0dd70cf0597008808a}


igb.\+c 파일의 1841 번째 라인에서 정의되었습니다.

\index{igb.\+c@{igb.\+c}!M\+I\+N\+\_\+\+W\+A\+L\+L\+C\+L\+O\+C\+K\+\_\+\+T\+S\+C\+\_\+\+W\+I\+N\+D\+OW@{M\+I\+N\+\_\+\+W\+A\+L\+L\+C\+L\+O\+C\+K\+\_\+\+T\+S\+C\+\_\+\+W\+I\+N\+D\+OW}}
\index{M\+I\+N\+\_\+\+W\+A\+L\+L\+C\+L\+O\+C\+K\+\_\+\+T\+S\+C\+\_\+\+W\+I\+N\+D\+OW@{M\+I\+N\+\_\+\+W\+A\+L\+L\+C\+L\+O\+C\+K\+\_\+\+T\+S\+C\+\_\+\+W\+I\+N\+D\+OW}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{M\+I\+N\+\_\+\+W\+A\+L\+L\+C\+L\+O\+C\+K\+\_\+\+T\+S\+C\+\_\+\+W\+I\+N\+D\+OW}{MIN_WALLCLOCK_TSC_WINDOW}}]{\setlength{\rightskip}{0pt plus 5cm}\#define M\+I\+N\+\_\+\+W\+A\+L\+L\+C\+L\+O\+C\+K\+\_\+\+T\+S\+C\+\_\+\+W\+I\+N\+D\+OW~80 /$\ast$ cycles $\ast$/}\hypertarget{igb_8c_aa9d89e374be1585846f0890ab560f8d6}{}\label{igb_8c_aa9d89e374be1585846f0890ab560f8d6}


igb.\+c 파일의 1840 번째 라인에서 정의되었습니다.



\subsection{함수 문서화}
\index{igb.\+c@{igb.\+c}!\+\_\+\+\_\+sync@{\+\_\+\+\_\+sync}}
\index{\+\_\+\+\_\+sync@{\+\_\+\+\_\+sync}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{\+\_\+\+\_\+sync(void)}{__sync(void)}}]{\setlength{\rightskip}{0pt plus 5cm}static void \+\_\+\+\_\+sync (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{igb_8c_aaf70944cc9bd58b4497abeb70c220890}{}\label{igb_8c_aaf70944cc9bd58b4497abeb70c220890}


igb.\+c 파일의 1856 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
1857 \{
1858     \_\_asm\_\_ \_\_volatile\_\_(\textcolor{stringliteral}{"mfence;"}
1859                           :
1860                           :
1861                           : \textcolor{stringliteral}{"memory"});
1862 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=231pt]{igb_8c_aaf70944cc9bd58b4497abeb70c220890_icgraph}
\end{center}
\end{figure}


\index{igb.\+c@{igb.\+c}!igb\+\_\+allocate\+\_\+pci\+\_\+resources@{igb\+\_\+allocate\+\_\+pci\+\_\+resources}}
\index{igb\+\_\+allocate\+\_\+pci\+\_\+resources@{igb\+\_\+allocate\+\_\+pci\+\_\+resources}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{igb\+\_\+allocate\+\_\+pci\+\_\+resources(struct adapter $\ast$adapter)}{igb_allocate_pci_resources(struct adapter *adapter)}}]{\setlength{\rightskip}{0pt plus 5cm}static int igb\+\_\+allocate\+\_\+pci\+\_\+resources (
\begin{DoxyParamCaption}
\item[{struct {\bf adapter} $\ast$}]{adapter}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{igb_8c_ac2793cb8a8e3320094491f518adfdfb1}{}\label{igb_8c_ac2793cb8a8e3320094491f518adfdfb1}


igb.\+c 파일의 644 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
645 \{
646     \textcolor{keywordtype}{int} dev = adapter->\hyperlink{structadapter_ae57c5756a3672ea1541cbc6dfd283161}{ldev};
647 
648     adapter->\hyperlink{structadapter_a7d5953861471302be6287c989e0b20ba}{hw}.\hyperlink{structe1000__hw_a54127b9ee5d8173dc068cf8c43a0600f}{hw\_addr} = (\hyperlink{lib_2igb_2e1000__osdep_8h_a8baca7e76da9e0e11ce3a275dd19130c}{u8} *)mmap(\hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}, adapter->\hyperlink{structadapter_a0ca05bc0e64b6eb88e6fb380b688af4e}{csr}.
      \hyperlink{structresource_a83be2978ea6cb76ae7b9be1c9819e0fe}{mmap\_size},
649                      PROT\_READ | PROT\_WRITE, MAP\_SHARED,
650                      dev, 0);
651 
652     \textcolor{keywordflow}{if} (adapter->\hyperlink{structadapter_a7d5953861471302be6287c989e0b20ba}{hw}.\hyperlink{structe1000__hw_a54127b9ee5d8173dc068cf8c43a0600f}{hw\_addr} == MAP\_FAILED)
653         \textcolor{keywordflow}{return} -ENXIO;
654 
655     \textcolor{keywordflow}{return} 0;
656 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{igb_8c_ac2793cb8a8e3320094491f518adfdfb1_icgraph}
\end{center}
\end{figure}


\index{igb.\+c@{igb.\+c}!igb\+\_\+allocate\+\_\+queues@{igb\+\_\+allocate\+\_\+queues}}
\index{igb\+\_\+allocate\+\_\+queues@{igb\+\_\+allocate\+\_\+queues}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{igb\+\_\+allocate\+\_\+queues(struct adapter $\ast$adapter)}{igb_allocate_queues(struct adapter *adapter)}}]{\setlength{\rightskip}{0pt plus 5cm}static int igb\+\_\+allocate\+\_\+queues (
\begin{DoxyParamCaption}
\item[{struct {\bf adapter} $\ast$}]{adapter}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{igb_8c_a3090d15b20de07b55d9b4d22ab65b84d}{}\label{igb_8c_a3090d15b20de07b55d9b4d22ab65b84d}


igb.\+c 파일의 752 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
753 \{
754     \textcolor{keyword}{struct }\hyperlink{structigb__buf__cmd}{igb\_buf\_cmd} ubuf = \{0\};
755     \textcolor{keywordtype}{int} dev = adapter->\hyperlink{structadapter_ae57c5756a3672ea1541cbc6dfd283161}{ldev};
756     \textcolor{keywordtype}{int} i, error = 0;
757 
758     \textcolor{comment}{/* allocate the TX ring struct memory */}
759     adapter->\hyperlink{structadapter_aec689462327aa3bf0e8a73e7cca2ae55}{tx\_rings} = (\textcolor{keyword}{struct }\hyperlink{structtx__ring}{tx\_ring} *) \hyperlink{_memory_leak_detector_malloc_macros_8h_ab8b25cd8f16d4a6552afe4e65c4f082d}{malloc}(\textcolor{keyword}{sizeof}(\textcolor{keyword}{struct} 
      \hyperlink{structtx__ring}{tx\_ring}) *
760                               adapter->\hyperlink{structadapter_a8befb466d4a5a6a432dc1648230e0a65}{num\_queues});
761 
762     \textcolor{keywordflow}{if} (adapter->\hyperlink{structadapter_aec689462327aa3bf0e8a73e7cca2ae55}{tx\_rings} == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}) \{
763         error = -ENOMEM;
764         \textcolor{keywordflow}{goto} tx\_fail;
765     \}
766 
767     memset(adapter->\hyperlink{structadapter_aec689462327aa3bf0e8a73e7cca2ae55}{tx\_rings}, 0, \textcolor{keyword}{sizeof}(\textcolor{keyword}{struct} \hyperlink{structtx__ring}{tx\_ring}) *
768                         adapter->\hyperlink{structadapter_a8befb466d4a5a6a432dc1648230e0a65}{num\_queues});
769 
770     \textcolor{keywordflow}{for} (i = 0; i < adapter->\hyperlink{structadapter_a8befb466d4a5a6a432dc1648230e0a65}{num\_queues}; i++) \{
771         ubuf.\hyperlink{structigb__buf__cmd_a6be361df991687a3b78645e3e8fa853d}{queue} = i;
772         error = ioctl(dev, \hyperlink{kmod_2igb_2igb_8h_a881eb94333ef1db2f03904887f846ce3}{IGB\_IOCTL\_MAPRING}, &ubuf);
773         \textcolor{keywordflow}{if} (error < 0) \{
774             \textcolor{keywordflow}{if}(error == -EINVAL)
775                 \textcolor{keywordflow}{goto} tx\_fail;
776 
777             error = EBUSY;
778             \textcolor{keywordflow}{goto} tx\_desc;
779         \}
780 
781         \textcolor{keywordflow}{if} (ubuf.\hyperlink{structigb__buf__cmd_a49f357a5ff181876b6c641e455b18b20}{physaddr} % 128)
782             printf(\textcolor{stringliteral}{"warning: tx ring addr (0x%lx) is not a 128 byte-aligned\(\backslash\)n"},
783                 ubuf.\hyperlink{structigb__buf__cmd_a49f357a5ff181876b6c641e455b18b20}{physaddr});
784 
785         adapter->\hyperlink{structadapter_aec689462327aa3bf0e8a73e7cca2ae55}{tx\_rings}[i].\hyperlink{structtx__ring_aefdccf596fff8b81ada9dd89b75697a8}{txdma}.\hyperlink{structresource_ac1f7f4ff311d1bc193e88d7cd3230bc6}{paddr} = ubuf.\hyperlink{structigb__buf__cmd_a49f357a5ff181876b6c641e455b18b20}{physaddr};
786         adapter->\hyperlink{structadapter_aec689462327aa3bf0e8a73e7cca2ae55}{tx\_rings}[i].\hyperlink{structtx__ring_aefdccf596fff8b81ada9dd89b75697a8}{txdma}.\hyperlink{structresource_a83be2978ea6cb76ae7b9be1c9819e0fe}{mmap\_size} = ubuf.
      \hyperlink{structigb__buf__cmd_ac76710c49696b7df6ecbef456496ea50}{mmap\_size};
787         adapter->\hyperlink{structadapter_aec689462327aa3bf0e8a73e7cca2ae55}{tx\_rings}[i].\hyperlink{structtx__ring_afcf2ae577a4363723c3403d160dd4d01}{tx\_base} = \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
788         adapter->\hyperlink{structadapter_aec689462327aa3bf0e8a73e7cca2ae55}{tx\_rings}[i].\hyperlink{structtx__ring_afcf2ae577a4363723c3403d160dd4d01}{tx\_base} =
789             (\textcolor{keyword}{struct }\hyperlink{structe1000__tx__desc}{e1000\_tx\_desc} *)mmap(\hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}, ubuf.\hyperlink{structigb__buf__cmd_ac76710c49696b7df6ecbef456496ea50}{mmap\_size},
790                              PROT\_READ | PROT\_WRITE,
791                              MAP\_SHARED, adapter->\hyperlink{structadapter_ae57c5756a3672ea1541cbc6dfd283161}{ldev},
792                              ubuf.\hyperlink{structigb__buf__cmd_a16daee3847fb6e540a1285a3951ff169}{pa});
793 
794         \textcolor{keywordflow}{if} (adapter->\hyperlink{structadapter_aec689462327aa3bf0e8a73e7cca2ae55}{tx\_rings}[i].\hyperlink{structtx__ring_afcf2ae577a4363723c3403d160dd4d01}{tx\_base} == MAP\_FAILED) \{
795             error = -ENOMEM;
796             \textcolor{keywordflow}{goto} tx\_desc;
797         \}
798 
799         adapter->\hyperlink{structadapter_aec689462327aa3bf0e8a73e7cca2ae55}{tx\_rings}[i].\hyperlink{structtx__ring_a807e6014970a3d469e197cd9ec25229c}{adapter} = adapter;
800         adapter->\hyperlink{structadapter_aec689462327aa3bf0e8a73e7cca2ae55}{tx\_rings}[i].\hyperlink{structtx__ring_af754e6af13b532f2bebcaa3828ea795c}{me} = i;
801         \textcolor{comment}{/* XXX Initialize a TX lock ?? */}
802         adapter->\hyperlink{structadapter_ab0bd5866ff13aa7c17436220693a3d2d}{num\_tx\_desc} = ubuf.\hyperlink{structigb__buf__cmd_ac76710c49696b7df6ecbef456496ea50}{mmap\_size} /
803                        \textcolor{keyword}{sizeof}(\textcolor{keyword}{union }\hyperlink{unione1000__adv__tx__desc}{e1000\_adv\_tx\_desc});
804 
805         \textcolor{comment}{/*}
806 \textcolor{comment}{         * num\_tx\_desc must be always a multiple of 8 because the value of}
807 \textcolor{comment}{         * TDLEN must be a multipe of 128 and each descriptor has 16 bytes.}
808 \textcolor{comment}{         */}
809         \textcolor{keywordflow}{if} (adapter->\hyperlink{structadapter_ab0bd5866ff13aa7c17436220693a3d2d}{num\_tx\_desc} % 8)
810             printf(\textcolor{stringliteral}{"warning: num\_tx\_desc(%d) is not a multiple of 8\(\backslash\)n"},
811                 adapter->\hyperlink{structadapter_ab0bd5866ff13aa7c17436220693a3d2d}{num\_tx\_desc});
812 
813         memset((\textcolor{keywordtype}{void} *)adapter->\hyperlink{structadapter_aec689462327aa3bf0e8a73e7cca2ae55}{tx\_rings}[i].\hyperlink{structtx__ring_afcf2ae577a4363723c3403d160dd4d01}{tx\_base}, 0, ubuf.
      \hyperlink{structigb__buf__cmd_ac76710c49696b7df6ecbef456496ea50}{mmap\_size});
814         adapter->\hyperlink{structadapter_aec689462327aa3bf0e8a73e7cca2ae55}{tx\_rings}[i].\hyperlink{structtx__ring_a9b0485752fc6d8befa2f35ebd45710db}{tx\_buffers} =
815             (\textcolor{keyword}{struct }\hyperlink{structigb__tx__buffer}{igb\_tx\_buffer} *)
816                 \hyperlink{_memory_leak_detector_malloc_macros_8h_ab8b25cd8f16d4a6552afe4e65c4f082d}{malloc}(\textcolor{keyword}{sizeof}(\textcolor{keyword}{struct} \hyperlink{structigb__tx__buffer}{igb\_tx\_buffer}) *
817                        adapter->\hyperlink{structadapter_ab0bd5866ff13aa7c17436220693a3d2d}{num\_tx\_desc});
818 
819         \textcolor{keywordflow}{if} (adapter->\hyperlink{structadapter_aec689462327aa3bf0e8a73e7cca2ae55}{tx\_rings}[i].\hyperlink{structtx__ring_a9b0485752fc6d8befa2f35ebd45710db}{tx\_buffers} == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}) \{
820             error = -ENOMEM;
821             \textcolor{keywordflow}{goto} tx\_desc;
822         \}
823 
824         memset(adapter->\hyperlink{structadapter_aec689462327aa3bf0e8a73e7cca2ae55}{tx\_rings}[i].\hyperlink{structtx__ring_a9b0485752fc6d8befa2f35ebd45710db}{tx\_buffers}, 0,
825                \textcolor{keyword}{sizeof}(\textcolor{keyword}{struct} \hyperlink{structigb__tx__buffer}{igb\_tx\_buffer}) * adapter->\hyperlink{structadapter_ab0bd5866ff13aa7c17436220693a3d2d}{num\_tx\_desc});
826     \}
827 
828     \textcolor{keywordflow}{return} 0;
829 
830 tx\_desc:
831     \textcolor{keywordflow}{for} (i = 0; i < adapter->\hyperlink{structadapter_a8befb466d4a5a6a432dc1648230e0a65}{num\_queues}; i++) \{
832         \textcolor{keywordflow}{if} (adapter->\hyperlink{structadapter_aec689462327aa3bf0e8a73e7cca2ae55}{tx\_rings}[i].\hyperlink{structtx__ring_afcf2ae577a4363723c3403d160dd4d01}{tx\_base})
833             munmap(adapter->\hyperlink{structadapter_aec689462327aa3bf0e8a73e7cca2ae55}{tx\_rings}[i].\hyperlink{structtx__ring_afcf2ae577a4363723c3403d160dd4d01}{tx\_base},
834                    adapter->\hyperlink{structadapter_aec689462327aa3bf0e8a73e7cca2ae55}{tx\_rings}[i].\hyperlink{structtx__ring_aefdccf596fff8b81ada9dd89b75697a8}{txdma}.\hyperlink{structresource_a83be2978ea6cb76ae7b9be1c9819e0fe}{mmap\_size});
835         ubuf.\hyperlink{structigb__buf__cmd_a6be361df991687a3b78645e3e8fa853d}{queue} = i;
836         ioctl(dev, \hyperlink{kmod_2igb_2igb_8h_a8a326cbb1aaa2d97a9f0f6aaf674c8b8}{IGB\_IOCTL\_UNMAPRING}, &ubuf);
837     \};
838 tx\_fail:
839     \hyperlink{_memory_leak_detector_malloc_macros_8h_aa7157aa9480bb73f090dca36776419bf}{free}(adapter->\hyperlink{structadapter_aec689462327aa3bf0e8a73e7cca2ae55}{tx\_rings});
840     adapter->\hyperlink{structadapter_aec689462327aa3bf0e8a73e7cca2ae55}{tx\_rings} = \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
841     \textcolor{keywordflow}{return} error;
842 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{igb_8c_a3090d15b20de07b55d9b4d22ab65b84d_icgraph}
\end{center}
\end{figure}


\index{igb.\+c@{igb.\+c}!igb\+\_\+allocate\+\_\+rx\+\_\+queues@{igb\+\_\+allocate\+\_\+rx\+\_\+queues}}
\index{igb\+\_\+allocate\+\_\+rx\+\_\+queues@{igb\+\_\+allocate\+\_\+rx\+\_\+queues}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{igb\+\_\+allocate\+\_\+rx\+\_\+queues(struct adapter $\ast$adapter)}{igb_allocate_rx_queues(struct adapter *adapter)}}]{\setlength{\rightskip}{0pt plus 5cm}static int igb\+\_\+allocate\+\_\+rx\+\_\+queues (
\begin{DoxyParamCaption}
\item[{struct {\bf adapter} $\ast$}]{adapter}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{igb_8c_ac7a39260a8612878b8bca07572027f75}{}\label{igb_8c_ac7a39260a8612878b8bca07572027f75}


igb.\+c 파일의 1329 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
1330 \{
1331     \textcolor{keyword}{struct }\hyperlink{structigb__buf__cmd}{igb\_buf\_cmd} ubuf;
1332     \textcolor{keywordtype}{int} dev = adapter->\hyperlink{structadapter_ae57c5756a3672ea1541cbc6dfd283161}{ldev};
1333     \textcolor{keywordtype}{int} i, error = 0;
1334 
1335     \textcolor{comment}{/* allocate the RX ring struct memory */}
1336     adapter->\hyperlink{structadapter_a59a5588ccfe1b0eefe45fcb9188b2f0a}{rx\_rings} = (\textcolor{keyword}{struct }\hyperlink{structrx__ring}{rx\_ring} *) \hyperlink{_memory_leak_detector_malloc_macros_8h_ab8b25cd8f16d4a6552afe4e65c4f082d}{malloc}(\textcolor{keyword}{sizeof}(\textcolor{keyword}{struct} 
      \hyperlink{structrx__ring}{rx\_ring}) *
1337                               adapter->\hyperlink{structadapter_a8befb466d4a5a6a432dc1648230e0a65}{num\_queues});
1338 
1339     \textcolor{keywordflow}{if} (adapter->\hyperlink{structadapter_a59a5588ccfe1b0eefe45fcb9188b2f0a}{rx\_rings} == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}) \{
1340         error = -ENOMEM;
1341         \textcolor{keywordflow}{goto} rx\_fail;
1342     \}
1343 
1344     memset(adapter->\hyperlink{structadapter_a59a5588ccfe1b0eefe45fcb9188b2f0a}{rx\_rings}, 0, \textcolor{keyword}{sizeof}(\textcolor{keyword}{struct} \hyperlink{structrx__ring}{rx\_ring}) *
1345                         adapter->\hyperlink{structadapter_a8befb466d4a5a6a432dc1648230e0a65}{num\_queues});
1346 
1347     \textcolor{keywordflow}{for} (i = 0; i < adapter->\hyperlink{structadapter_a8befb466d4a5a6a432dc1648230e0a65}{num\_queues}; i++) \{
1348 
1349         \textcolor{keywordflow}{if} (sem\_init(&adapter->\hyperlink{structadapter_a59a5588ccfe1b0eefe45fcb9188b2f0a}{rx\_rings}[i].\hyperlink{structrx__ring_ac301e000199ad937f060277b0736d4e1}{lock}, 0, 1) != 0) \{
1350             error = errno;
1351             \textcolor{keywordflow}{goto} rx\_desc;
1352         \}
1353 
1354         \textcolor{keywordflow}{if} (sem\_wait(&adapter->\hyperlink{structadapter_a59a5588ccfe1b0eefe45fcb9188b2f0a}{rx\_rings}[i].\hyperlink{structrx__ring_ac301e000199ad937f060277b0736d4e1}{lock}) != 0) \{
1355             error = errno;
1356             \textcolor{keywordflow}{goto} rx\_desc;
1357         \}
1358 
1359         ubuf.queue = i;
1360         error = ioctl(dev, \hyperlink{kmod_2igb_2igb_8h_aefd40da0e720216e9322763f34db10f9}{IGB\_IOCTL\_MAP\_RX\_RING}, &ubuf);
1361         \textcolor{keywordflow}{if} (error < 0) \{
1362 
1363             \textcolor{keywordflow}{if}(error == -EINVAL)
1364                 \textcolor{keywordflow}{goto} rx\_fail;
1365 
1366             error = EBUSY;
1367             \textcolor{keywordflow}{goto} rx\_desc;
1368         \}
1369 
1370         \textcolor{keywordflow}{if} (ubuf.physaddr % 128)
1371             printf(\textcolor{stringliteral}{"warning: rx ring addr (0x%lx) is not a 128 byte-aligned\(\backslash\)n"},
1372                 ubuf.physaddr);
1373 
1374         adapter->\hyperlink{structadapter_a59a5588ccfe1b0eefe45fcb9188b2f0a}{rx\_rings}[i].\hyperlink{structrx__ring_a7b5f7d41a39b44612fd251f290500ba5}{rxdma}.\hyperlink{structresource_ac1f7f4ff311d1bc193e88d7cd3230bc6}{paddr} = ubuf.physaddr;
1375         adapter->\hyperlink{structadapter_a59a5588ccfe1b0eefe45fcb9188b2f0a}{rx\_rings}[i].\hyperlink{structrx__ring_a7b5f7d41a39b44612fd251f290500ba5}{rxdma}.\hyperlink{structresource_a83be2978ea6cb76ae7b9be1c9819e0fe}{mmap\_size} = ubuf.mmap\_size;
1376         adapter->\hyperlink{structadapter_a59a5588ccfe1b0eefe45fcb9188b2f0a}{rx\_rings}[i].\hyperlink{structrx__ring_a40ec79b3b6a780e7f5c90dea8b3160bf}{rx\_base} = \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
1377         adapter->\hyperlink{structadapter_a59a5588ccfe1b0eefe45fcb9188b2f0a}{rx\_rings}[i].\hyperlink{structrx__ring_a40ec79b3b6a780e7f5c90dea8b3160bf}{rx\_base} =
1378             mmap(\hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}, ubuf.mmap\_size, PROT\_READ | PROT\_WRITE,
1379                  MAP\_SHARED, adapter->\hyperlink{structadapter_ae57c5756a3672ea1541cbc6dfd283161}{ldev}, ubuf.pa);
1380 
1381         \textcolor{keywordflow}{if} (adapter->\hyperlink{structadapter_a59a5588ccfe1b0eefe45fcb9188b2f0a}{rx\_rings}[i].\hyperlink{structrx__ring_a40ec79b3b6a780e7f5c90dea8b3160bf}{rx\_base} == MAP\_FAILED) \{
1382             error = -ENOMEM;
1383             \textcolor{keywordflow}{goto} rx\_desc;
1384         \}
1385 
1386         adapter->\hyperlink{structadapter_a59a5588ccfe1b0eefe45fcb9188b2f0a}{rx\_rings}[i].\hyperlink{structrx__ring_a807e6014970a3d469e197cd9ec25229c}{adapter} = \hyperlink{structrx__ring_a807e6014970a3d469e197cd9ec25229c}{adapter};
1387         adapter->\hyperlink{structadapter_a59a5588ccfe1b0eefe45fcb9188b2f0a}{rx\_rings}[i].\hyperlink{structrx__ring_af754e6af13b532f2bebcaa3828ea795c}{me} = i;
1388 
1389         adapter->\hyperlink{structadapter_a7a36fc7297d99f6b73c4b6a194b33efd}{num\_rx\_desc} = ubuf.mmap\_size /
1390                        \textcolor{keyword}{sizeof}(\textcolor{keyword}{union }\hyperlink{unione1000__adv__rx__desc}{e1000\_adv\_rx\_desc});
1391 
1392         \textcolor{comment}{/*}
1393 \textcolor{comment}{         * num\_rx\_desc must be always a multiple of 8 because the value of}
1394 \textcolor{comment}{         * RDLEN must be a multipe of 128 and each descriptor has 16 bytes.}
1395 \textcolor{comment}{         */}
1396         \textcolor{keywordflow}{if} (adapter->\hyperlink{structadapter_a7a36fc7297d99f6b73c4b6a194b33efd}{num\_rx\_desc} % 8)
1397             printf(\textcolor{stringliteral}{"num\_rx\_desc(%d) is not a multiple of 8\(\backslash\)n"},
1398                 adapter->\hyperlink{structadapter_a7a36fc7297d99f6b73c4b6a194b33efd}{num\_rx\_desc});
1399 
1400         memset((\textcolor{keywordtype}{void} *)adapter->\hyperlink{structadapter_a59a5588ccfe1b0eefe45fcb9188b2f0a}{rx\_rings}[i].\hyperlink{structrx__ring_a40ec79b3b6a780e7f5c90dea8b3160bf}{rx\_base}, 0, ubuf.mmap\_size);
1401         adapter->\hyperlink{structadapter_a59a5588ccfe1b0eefe45fcb9188b2f0a}{rx\_rings}[i].\hyperlink{structrx__ring_abe41cfe713ffac28a8f678c51082df25}{rx\_buffers} =
1402             (\textcolor{keyword}{struct }\hyperlink{structigb__rx__buffer}{igb\_rx\_buffer} *)
1403                 \hyperlink{_memory_leak_detector_malloc_macros_8h_ab8b25cd8f16d4a6552afe4e65c4f082d}{malloc}(\textcolor{keyword}{sizeof}(\textcolor{keyword}{struct} \hyperlink{structigb__rx__buffer}{igb\_rx\_buffer}) *
1404                        adapter->\hyperlink{structadapter_a7a36fc7297d99f6b73c4b6a194b33efd}{num\_rx\_desc});
1405 
1406         \textcolor{keywordflow}{if} (adapter->\hyperlink{structadapter_a59a5588ccfe1b0eefe45fcb9188b2f0a}{rx\_rings}[i].\hyperlink{structrx__ring_abe41cfe713ffac28a8f678c51082df25}{rx\_buffers} == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}) \{
1407             error = -ENOMEM;
1408             \textcolor{keywordflow}{goto} rx\_desc;
1409         \}
1410 
1411         memset(adapter->\hyperlink{structadapter_a59a5588ccfe1b0eefe45fcb9188b2f0a}{rx\_rings}[i].\hyperlink{structrx__ring_abe41cfe713ffac28a8f678c51082df25}{rx\_buffers}, 0,
1412                \textcolor{keyword}{sizeof}(\textcolor{keyword}{struct} \hyperlink{structigb__rx__buffer}{igb\_rx\_buffer}) * adapter->\hyperlink{structadapter_a7a36fc7297d99f6b73c4b6a194b33efd}{num\_rx\_desc});
1413 
1414         \textcolor{keywordflow}{if} (sem\_post(&adapter->\hyperlink{structadapter_a59a5588ccfe1b0eefe45fcb9188b2f0a}{rx\_rings}[i].\hyperlink{structrx__ring_ac301e000199ad937f060277b0736d4e1}{lock}) != 0) \{
1415             error = errno;
1416             \textcolor{keywordflow}{goto} rx\_desc;
1417         \}
1418     \}
1419 
1420     \textcolor{keywordflow}{return} 0;
1421 
1422 rx\_desc:
1423     \textcolor{keywordflow}{for} (i = 0; i < adapter->\hyperlink{structadapter_a8befb466d4a5a6a432dc1648230e0a65}{num\_queues}; i++) \{
1424         \textcolor{keywordflow}{if} (adapter->\hyperlink{structadapter_a59a5588ccfe1b0eefe45fcb9188b2f0a}{rx\_rings}[i].\hyperlink{structrx__ring_a40ec79b3b6a780e7f5c90dea8b3160bf}{rx\_base})
1425             munmap(adapter->\hyperlink{structadapter_a59a5588ccfe1b0eefe45fcb9188b2f0a}{rx\_rings}[i].\hyperlink{structrx__ring_a40ec79b3b6a780e7f5c90dea8b3160bf}{rx\_base},
1426                    adapter->\hyperlink{structadapter_a59a5588ccfe1b0eefe45fcb9188b2f0a}{rx\_rings}[i].\hyperlink{structrx__ring_a7b5f7d41a39b44612fd251f290500ba5}{rxdma}.\hyperlink{structresource_a83be2978ea6cb76ae7b9be1c9819e0fe}{mmap\_size});
1427         ubuf.queue = i;
1428         ioctl(dev, \hyperlink{kmod_2igb_2igb_8h_ab77372222ac94c91f428f15b2a41445e}{IGB\_IOCTL\_UNMAP\_RX\_RING}, &ubuf);
1429 
1430         sem\_destroy(&adapter->\hyperlink{structadapter_a59a5588ccfe1b0eefe45fcb9188b2f0a}{rx\_rings}[i].\hyperlink{structrx__ring_ac301e000199ad937f060277b0736d4e1}{lock});
1431     \};
1432 rx\_fail:
1433     \hyperlink{_memory_leak_detector_malloc_macros_8h_aa7157aa9480bb73f090dca36776419bf}{free}(adapter->\hyperlink{structadapter_a59a5588ccfe1b0eefe45fcb9188b2f0a}{rx\_rings});
1434     adapter->\hyperlink{structadapter_a59a5588ccfe1b0eefe45fcb9188b2f0a}{rx\_rings} = \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
1435     \textcolor{keywordflow}{return} error;
1436 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{igb_8c_ac7a39260a8612878b8bca07572027f75_icgraph}
\end{center}
\end{figure}


\index{igb.\+c@{igb.\+c}!igb\+\_\+attach@{igb\+\_\+attach}}
\index{igb\+\_\+attach@{igb\+\_\+attach}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{igb\+\_\+attach(char $\ast$dev\+\_\+path, device\+\_\+t $\ast$pdev)}{igb_attach(char *dev_path, device_t *pdev)}}]{\setlength{\rightskip}{0pt plus 5cm}int igb\+\_\+attach (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{dev\+\_\+path, }
\item[{{\bf device\+\_\+t} $\ast$}]{pdev}
\end{DoxyParamCaption}
)}\hypertarget{igb_8c_a8c1d26054ca159adda99c2ad1f1c54d7}{}\label{igb_8c_a8c1d26054ca159adda99c2ad1f1c54d7}


igb.\+c 파일의 132 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
133 \{
134     \textcolor{keyword}{struct }\hyperlink{structadapter}{adapter} *\hyperlink{structadapter}{adapter};
135     \textcolor{keyword}{struct }\hyperlink{structigb__bind__cmd}{igb\_bind\_cmd} bind = \{0\};
136     \textcolor{keywordtype}{int} error = 0;
137     \textcolor{keywordtype}{bool} locked = \textcolor{keyword}{false};
138 
139     \textcolor{keywordflow}{if} (pdev == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
140         \textcolor{keywordflow}{return} -EINVAL;
141 
142     adapter = (\textcolor{keyword}{struct }adapter *)pdev->\hyperlink{struct__device__t_ad517770dac2061381b2008850ff12e6c}{private\_data};
143 
144     if (adapter != \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
145         \textcolor{keywordflow}{return} -EBUSY;
146 
147     \textcolor{comment}{/* allocate an adapter */}
148     pdev->\hyperlink{struct__device__t_ad517770dac2061381b2008850ff12e6c}{private\_data} = \hyperlink{_memory_leak_detector_malloc_macros_8h_ab8b25cd8f16d4a6552afe4e65c4f082d}{malloc}(\textcolor{keyword}{sizeof}(\textcolor{keyword}{struct} adapter));
149     \textcolor{keywordflow}{if} (pdev->\hyperlink{struct__device__t_ad517770dac2061381b2008850ff12e6c}{private\_data} == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
150         \textcolor{keywordflow}{return} -ENXIO;
151 
152     memset(pdev->\hyperlink{struct__device__t_ad517770dac2061381b2008850ff12e6c}{private\_data}, 0, \textcolor{keyword}{sizeof}(\textcolor{keyword}{struct} adapter));
153 
154     adapter = (\textcolor{keyword}{struct }adapter *)pdev->\hyperlink{struct__device__t_ad517770dac2061381b2008850ff12e6c}{private\_data};
155 
156     adapter->\hyperlink{structadapter_ae57c5756a3672ea1541cbc6dfd283161}{ldev} = open(\textcolor{stringliteral}{"/dev/igb\_avb"}, O\_RDWR);
157 
158     \textcolor{keywordflow}{if} (adapter->\hyperlink{structadapter_ae57c5756a3672ea1541cbc6dfd283161}{ldev} < 0) \{
159         error = -ENXIO;
160         \textcolor{keywordflow}{goto} err\_prebind;
161     \}
162 
163     \textcolor{keywordflow}{if} (\hyperlink{igb_8c_a7fcc5ae922167895160aed1c771d5e62}{igb\_create\_lock}(adapter) != 0) \{
164         error = -errno;
165         \textcolor{keywordflow}{goto} err\_bind;
166     \}
167 
168     adapter->\hyperlink{structadapter_aa5805c5e936174e5092bf7a5b78e7e64}{active} = 1;
169 
170     \textcolor{keywordflow}{if} (\hyperlink{igb_8c_a791fd0757e3ca1833df21ee94c17b855}{igb\_lock}(pdev) != 0) \{
171         error = -errno;
172         \textcolor{keywordflow}{goto} err\_bind;
173     \}
174 
175     locked = \textcolor{keyword}{true};
176 
177     \textcolor{comment}{/*}
178 \textcolor{comment}{     * dev\_path should look something "0000:01:00.0"}
179 \textcolor{comment}{     */}
180 
181     strncpy(bind.\hyperlink{structigb__bind__cmd_a88d38e6b8b8e975415f5cef8fbfe2b74}{iface}, dev\_path, \hyperlink{linux__hal__i210_8cpp_a3d5e72fee0b5b7de1b68e1152bc7a87d}{IGB\_BIND\_NAMESZ} - 1);
182 
183     \textcolor{keywordflow}{if} (ioctl(adapter->\hyperlink{structadapter_ae57c5756a3672ea1541cbc6dfd283161}{ldev}, \hyperlink{kmod_2igb_2igb_8h_a0e61aa1b1967066dcfb50420a215cbf9}{IGB\_BIND}, &bind) < 0) \{
184         error = -ENXIO;
185         \textcolor{keywordflow}{goto} err\_bind;
186     \}
187 
188     adapter->\hyperlink{structadapter_a0ca05bc0e64b6eb88e6fb380b688af4e}{csr}.\hyperlink{structresource_ac1f7f4ff311d1bc193e88d7cd3230bc6}{paddr} = 0;
189     adapter->\hyperlink{structadapter_a0ca05bc0e64b6eb88e6fb380b688af4e}{csr}.\hyperlink{structresource_a83be2978ea6cb76ae7b9be1c9819e0fe}{mmap\_size} = bind.\hyperlink{structigb__bind__cmd_ac76710c49696b7df6ecbef456496ea50}{mmap\_size};
190 
191     \textcolor{comment}{/* Determine hardware and mac info */}
192     adapter->\hyperlink{structadapter_a7d5953861471302be6287c989e0b20ba}{hw}.\hyperlink{structe1000__hw_a80302a87767931f95dfc264df7d0d253}{vendor\_id} = pdev->\hyperlink{struct__device__t_acf35ed7d091ed0ee4ff208efe53a64bf}{pci\_vendor\_id};
193     adapter->\hyperlink{structadapter_a7d5953861471302be6287c989e0b20ba}{hw}.\hyperlink{structe1000__hw_acba8e06f20df2e05fadf4696cfdbc552}{device\_id} = pdev->\hyperlink{struct__device__t_acf35ed7d091ed0ee4ff208efe53a64bf}{pci\_vendor\_id};
194     adapter->\hyperlink{structadapter_a7d5953861471302be6287c989e0b20ba}{hw}.\hyperlink{structe1000__hw_a32f1ac5d313951f7044fdf5bb63ee596}{revision\_id} = 0;
195     adapter->\hyperlink{structadapter_a7d5953861471302be6287c989e0b20ba}{hw}.\hyperlink{structe1000__hw_a68f96c77fc612053fdb728712c4e7591}{subsystem\_vendor\_id} = 0;
196     adapter->\hyperlink{structadapter_a7d5953861471302be6287c989e0b20ba}{hw}.\hyperlink{structe1000__hw_ad22f037dfd3918464c6a5baadb0775d1}{subsystem\_device\_id} = 0;
197 
198     \textcolor{comment}{/* Set MAC type early for PCI setup */}
199     adapter->\hyperlink{structadapter_a7d5953861471302be6287c989e0b20ba}{hw}.\hyperlink{structe1000__hw_aab7fce7aa13ba97459b3b65acf02f520}{mac}.\hyperlink{structe1000__mac__info_aa278e9fd67ac539e410e444a48db5455}{type} = \hyperlink{kmod_2igb_2e1000__hw_8h_a7f5871256d483a73ddb176218998f3a7a0a02928ffbcef71081d6ed205e44c5b2}{e1000\_i210};
200 
201     \textcolor{comment}{/* Setup PCI resources */}
202     error = \hyperlink{igb_8c_ac2793cb8a8e3320094491f518adfdfb1}{igb\_allocate\_pci\_resources}(adapter);
203     \textcolor{keywordflow}{if} (error)
204         \textcolor{keywordflow}{goto} err\_pci;
205 
206     \textcolor{comment}{/*}
207 \textcolor{comment}{     * Set the frame limits assuming}
208 \textcolor{comment}{     * standard ethernet sized frames.}
209 \textcolor{comment}{     */}
210     adapter->\hyperlink{structadapter_a09c29b0090a82147afdb50ae0013b9c6}{max\_frame\_size} = 1518;
211     adapter->\hyperlink{structadapter_a027b06fbbd3bf1152365ce98101e4583}{min\_frame\_size} = 64;
212 
213     \textcolor{comment}{/*}
214 \textcolor{comment}{     * Copy the permanent MAC address out of the EEPROM}
215 \textcolor{comment}{     */}
216     \textcolor{keywordflow}{if} (\hyperlink{igb_8c_aef7aae6f7e25f628d6313de3911827e5}{igb\_read\_mac\_addr}(&adapter->\hyperlink{structadapter_a7d5953861471302be6287c989e0b20ba}{hw}) < 0) \{
217         error = -EIO;
218         \textcolor{keywordflow}{goto} err\_late;
219     \}
220 
221     \textcolor{keywordflow}{if} (\hyperlink{igb_8c_a4072fbeaba958ad7c81990de452139da}{igb\_unlock}(pdev) != 0) \{
222         error = -errno;
223         \textcolor{keywordflow}{goto} err\_gen;
224     \}
225 
226     \textcolor{keywordflow}{return} 0;
227 
228 err\_late:
229 err\_pci:
230     \hyperlink{igb_8c_a598861e7bb5e9769bde5e4dbb853fda8}{igb\_free\_pci\_resources}(adapter);
231 err\_bind:
232     \textcolor{keywordflow}{if} (locked)
233         (void) \hyperlink{igb_8c_a4072fbeaba958ad7c81990de452139da}{igb\_unlock}(pdev);
234     \textcolor{keywordflow}{if} (adapter && adapter->\hyperlink{structadapter_ac26455511b5639f92b1eadeae2f8e20e}{memlock}) \{
235         (void) munmap(adapter->\hyperlink{structadapter_ac26455511b5639f92b1eadeae2f8e20e}{memlock}, \textcolor{keyword}{sizeof}(pthread\_mutex\_t));
236         adapter->\hyperlink{structadapter_ac26455511b5639f92b1eadeae2f8e20e}{memlock} = \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
237     \}
238     close(adapter->\hyperlink{structadapter_ae57c5756a3672ea1541cbc6dfd283161}{ldev});
239 err\_prebind:
240     \hyperlink{_memory_leak_detector_malloc_macros_8h_aa7157aa9480bb73f090dca36776419bf}{free}(pdev->\hyperlink{struct__device__t_ad517770dac2061381b2008850ff12e6c}{private\_data});
241     pdev->\hyperlink{struct__device__t_ad517770dac2061381b2008850ff12e6c}{private\_data} = \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
242 
243 err\_gen:
244     \textcolor{keywordflow}{return} error;
245 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=312pt]{igb_8c_a8c1d26054ca159adda99c2ad1f1c54d7_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{igb_8c_a8c1d26054ca159adda99c2ad1f1c54d7_icgraph}
\end{center}
\end{figure}


\index{igb.\+c@{igb.\+c}!igb\+\_\+attach\+\_\+rx@{igb\+\_\+attach\+\_\+rx}}
\index{igb\+\_\+attach\+\_\+rx@{igb\+\_\+attach\+\_\+rx}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{igb\+\_\+attach\+\_\+rx(device\+\_\+t $\ast$pdev)}{igb_attach_rx(device_t *pdev)}}]{\setlength{\rightskip}{0pt plus 5cm}int igb\+\_\+attach\+\_\+rx (
\begin{DoxyParamCaption}
\item[{{\bf device\+\_\+t} $\ast$}]{pdev}
\end{DoxyParamCaption}
)}\hypertarget{igb_8c_a357bc6278f681d74b36ac5d26cb2b6c5}{}\label{igb_8c_a357bc6278f681d74b36ac5d26cb2b6c5}


igb.\+c 파일의 285 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
286 \{
287     \textcolor{keywordtype}{int} error;
288     \textcolor{keyword}{struct }\hyperlink{structadapter}{adapter} *\hyperlink{structadapter}{adapter};
289 
290     \textcolor{keywordflow}{if} (pdev == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
291         \textcolor{keywordflow}{return} -EINVAL;
292 
293     adapter = (\textcolor{keyword}{struct }adapter *)pdev->\hyperlink{struct__device__t_ad517770dac2061381b2008850ff12e6c}{private\_data};
294 
295     if (adapter == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
296         \textcolor{keywordflow}{return} -EINVAL;
297 
298     \textcolor{keywordflow}{if} (\hyperlink{igb_8c_a791fd0757e3ca1833df21ee94c17b855}{igb\_lock}(pdev) != 0)
299         \textcolor{keywordflow}{return} errno;
300 
301     \textcolor{comment}{/*}
302 \textcolor{comment}{     * Allocate and Setup Rx Queues}
303 \textcolor{comment}{     */}
304     adapter->\hyperlink{structadapter_a8befb466d4a5a6a432dc1648230e0a65}{num\_queues} = 2;  \textcolor{comment}{/* XXX parameterize this */}
305     error = \hyperlink{igb_8c_ac7a39260a8612878b8bca07572027f75}{igb\_allocate\_rx\_queues}(adapter);
306     \textcolor{keywordflow}{if} (error) \{
307         adapter->\hyperlink{structadapter_a8befb466d4a5a6a432dc1648230e0a65}{num\_queues} = 0;
308         \textcolor{keywordflow}{goto} release;
309     \}
310 
311 release:
312     \textcolor{keywordflow}{if} (\hyperlink{igb_8c_a4072fbeaba958ad7c81990de452139da}{igb\_unlock}(pdev) != 0)
313         \textcolor{keywordflow}{return} errno;
314 
315     \textcolor{keywordflow}{return} error;
316 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=310pt]{igb_8c_a357bc6278f681d74b36ac5d26cb2b6c5_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{igb_8c_a357bc6278f681d74b36ac5d26cb2b6c5_icgraph}
\end{center}
\end{figure}


\index{igb.\+c@{igb.\+c}!igb\+\_\+attach\+\_\+tx@{igb\+\_\+attach\+\_\+tx}}
\index{igb\+\_\+attach\+\_\+tx@{igb\+\_\+attach\+\_\+tx}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{igb\+\_\+attach\+\_\+tx(device\+\_\+t $\ast$pdev)}{igb_attach_tx(device_t *pdev)}}]{\setlength{\rightskip}{0pt plus 5cm}int igb\+\_\+attach\+\_\+tx (
\begin{DoxyParamCaption}
\item[{{\bf device\+\_\+t} $\ast$}]{pdev}
\end{DoxyParamCaption}
)}\hypertarget{igb_8c_a1165811ba4373e6d86067dca098df2ef}{}\label{igb_8c_a1165811ba4373e6d86067dca098df2ef}


igb.\+c 파일의 247 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
248 \{
249     \textcolor{keywordtype}{int} error;
250     \textcolor{keyword}{struct }\hyperlink{structadapter}{adapter} *\hyperlink{structadapter}{adapter};
251 
252     \textcolor{keywordflow}{if} (pdev == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
253         \textcolor{keywordflow}{return} -EINVAL;
254 
255     adapter = (\textcolor{keyword}{struct }adapter *)pdev->\hyperlink{struct__device__t_ad517770dac2061381b2008850ff12e6c}{private\_data};
256 
257     if (adapter == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
258         \textcolor{keywordflow}{return} -EINVAL;
259 
260     \textcolor{keywordflow}{if} (\hyperlink{igb_8c_a791fd0757e3ca1833df21ee94c17b855}{igb\_lock}(pdev) != 0)
261         \textcolor{keywordflow}{return} -errno;
262 
263     \textcolor{comment}{/* Allocate and Setup Queues */}
264     adapter->\hyperlink{structadapter_a8befb466d4a5a6a432dc1648230e0a65}{num\_queues} = 2;  \textcolor{comment}{/* XXX parameterize this */}
265     error = \hyperlink{igb_8c_a3090d15b20de07b55d9b4d22ab65b84d}{igb\_allocate\_queues}(adapter);
266     \textcolor{keywordflow}{if} (error) \{
267         adapter->\hyperlink{structadapter_a8befb466d4a5a6a432dc1648230e0a65}{num\_queues} = 0;
268         \textcolor{keywordflow}{goto} release;
269     \}
270 
271     \textcolor{comment}{/*}
272 \textcolor{comment}{     * Start from a known state, which means}
273 \textcolor{comment}{     * reset the transmit queues we own to a known}
274 \textcolor{comment}{     * starting state.}
275 \textcolor{comment}{     */}
276     \hyperlink{igb_8c_afa49e6907f7179625e2267faa054d250}{igb\_reset}(adapter);
277 
278 release:
279     \textcolor{keywordflow}{if} (\hyperlink{igb_8c_a4072fbeaba958ad7c81990de452139da}{igb\_unlock}(pdev) != 0)
280         \textcolor{keywordflow}{return} -errno;
281 
282     \textcolor{keywordflow}{return} error;
283 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=296pt]{igb_8c_a1165811ba4373e6d86067dca098df2ef_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=260pt]{igb_8c_a1165811ba4373e6d86067dca098df2ef_icgraph}
\end{center}
\end{figure}


\index{igb.\+c@{igb.\+c}!igb\+\_\+clean@{igb\+\_\+clean}}
\index{igb\+\_\+clean@{igb\+\_\+clean}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{igb\+\_\+clean(device\+\_\+t $\ast$dev, struct igb\+\_\+packet $\ast$$\ast$cleaned\+\_\+packets)}{igb_clean(device_t *dev, struct igb_packet **cleaned_packets)}}]{\setlength{\rightskip}{0pt plus 5cm}void igb\+\_\+clean (
\begin{DoxyParamCaption}
\item[{{\bf device\+\_\+t} $\ast$}]{dev, }
\item[{struct {\bf igb\+\_\+packet} $\ast$$\ast$}]{cleaned\+\_\+packets}
\end{DoxyParamCaption}
)}\hypertarget{igb_8c_a03eaebcc1732abe4fd77c1f79c8e2fee}{}\label{igb_8c_a03eaebcc1732abe4fd77c1f79c8e2fee}


igb.\+c 파일의 1214 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
1215 \{
1216     \textcolor{keyword}{struct }\hyperlink{structe1000__tx__desc}{e1000\_tx\_desc} *tx\_desc, *eop\_desc;
1217     \textcolor{keyword}{struct }\hyperlink{structigb__packet}{igb\_packet} *last\_reclaimed;
1218     \textcolor{keyword}{struct }\hyperlink{structigb__tx__buffer}{igb\_tx\_buffer} *tx\_buffer;
1219     \textcolor{keyword}{struct }\hyperlink{structadapter}{adapter} *\hyperlink{structadapter}{adapter};
1220     \textcolor{keyword}{struct }\hyperlink{structtx__ring}{tx\_ring} *txr;
1221     \textcolor{keywordtype}{int} first, last, \hyperlink{mrp_validate_8c_a5992b274cfdcacdbc1fa8347fd01ebde}{done}, processed, i;
1222 
1223     \textcolor{keywordflow}{if} (dev == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
1224         \textcolor{keywordflow}{return};
1225 
1226     adapter = (\textcolor{keyword}{struct }adapter *)dev->\hyperlink{struct__device__t_ad517770dac2061381b2008850ff12e6c}{private\_data};
1227     if (adapter == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
1228         \textcolor{keywordflow}{return};
1229 
1230     \textcolor{keywordflow}{if} (cleaned\_packets == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
1231         \textcolor{keywordflow}{return};
1232 
1233     *cleaned\_packets = \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}; \textcolor{comment}{/* nothing reclaimed yet */}
1234 
1235     \textcolor{keywordflow}{if} (\hyperlink{igb_8c_a791fd0757e3ca1833df21ee94c17b855}{igb\_lock}(dev) != 0)
1236         \textcolor{keywordflow}{return};
1237 
1238     \textcolor{keywordflow}{for} (i = 0; i < adapter->\hyperlink{structadapter_a8befb466d4a5a6a432dc1648230e0a65}{num\_queues}; i++) \{
1239         txr = &adapter->\hyperlink{structadapter_aec689462327aa3bf0e8a73e7cca2ae55}{tx\_rings}[i];
1240 
1241         \textcolor{keywordflow}{if} (txr->\hyperlink{structtx__ring_a3f8acb3cacc1230f5a5b78b1b6cf7c2a}{tx\_avail} == adapter->\hyperlink{structadapter_ab0bd5866ff13aa7c17436220693a3d2d}{num\_tx\_desc}) \{
1242             txr->\hyperlink{structtx__ring_ac2917164cdb60559cb6fb4367f48ca24}{queue\_status} = \hyperlink{igb__internal_8h_a9138123bbc894907c2c1bbea11e95c21}{IGB\_QUEUE\_IDLE};
1243             \textcolor{keywordflow}{continue};
1244         \}
1245 
1246         processed = 0;
1247         first = txr->\hyperlink{structtx__ring_a6b93808fe90341d9209770bf06dcdc6c}{next\_to\_clean};
1248         tx\_desc = &txr->\hyperlink{structtx__ring_afcf2ae577a4363723c3403d160dd4d01}{tx\_base}[first];
1249         tx\_buffer = &txr->\hyperlink{structtx__ring_a9b0485752fc6d8befa2f35ebd45710db}{tx\_buffers}[first];
1250         last = tx\_buffer->\hyperlink{structigb__tx__buffer_af565101ee13ca100904a7ac5b7564a3d}{next\_eop};
1251         eop\_desc = &txr->\hyperlink{structtx__ring_afcf2ae577a4363723c3403d160dd4d01}{tx\_base}[last];
1252 
1253         \textcolor{comment}{/*}
1254 \textcolor{comment}{         * What this does is get the index of the}
1255 \textcolor{comment}{         * first descriptor AFTER the EOP of the}
1256 \textcolor{comment}{         * first packet, that way we can do the}
1257 \textcolor{comment}{         * simple comparison on the inner while loop.}
1258 \textcolor{comment}{         */}
1259         \textcolor{keywordflow}{if} (++last == adapter->\hyperlink{structadapter_ab0bd5866ff13aa7c17436220693a3d2d}{num\_tx\_desc})
1260             last = 0;
1261         done = last;
1262 
1263         \textcolor{keywordflow}{while} (eop\_desc->\hyperlink{structe1000__tx__desc_af3e5d27ab120986fbbcd3deff79bf164}{upper}.\hyperlink{structe1000__tx__desc_a784a603c692747097c58fa4011c3761d}{fields}.status & \hyperlink{kmod_2igb_2e1000__defines_8h_a591e23674955e1c5db690fcab744cd54}{E1000\_TXD\_STAT\_DD}) \{
1264             \textcolor{keywordflow}{if} (tx\_buffer->\hyperlink{structigb__tx__buffer_ac6186670bb595d9f22c89b6dc2779d14}{packet})
1265                 last\_reclaimed = tx\_buffer->\hyperlink{structigb__tx__buffer_ac6186670bb595d9f22c89b6dc2779d14}{packet};
1266 
1267             \textcolor{comment}{/* We clean the range of the packet */}
1268             \textcolor{keywordflow}{while} (first != done) \{
1269                 \textcolor{keywordflow}{if} (tx\_buffer->\hyperlink{structigb__tx__buffer_ac6186670bb595d9f22c89b6dc2779d14}{packet}) \{
1270                     tx\_buffer->\hyperlink{structigb__tx__buffer_ac6186670bb595d9f22c89b6dc2779d14}{packet}->\hyperlink{structigb__packet_a72ee6ebc78f9345554cf78b10226b87f}{dmatime} =
1271                         (0xffffffff) &
1272                          tx\_desc->\hyperlink{structe1000__tx__desc_a87d79130b57fb21eedf04b9d3945c3d6}{buffer\_addr};
1273                     \textcolor{comment}{/* tx\_buffer->packet->dmatime +=}
1274 \textcolor{comment}{                     *  (tx\_desc->buffer\_addr >> 32) *}
1275 \textcolor{comment}{                     *   1000000000;}
1276 \textcolor{comment}{                     */}
1277                     txr->\hyperlink{structtx__ring_a7056b21e5e7773c9205b38f00a3a75c2}{bytes} += tx\_buffer->\hyperlink{structigb__tx__buffer_ac6186670bb595d9f22c89b6dc2779d14}{packet}->\hyperlink{structigb__packet_a0c5f469bd681fb46e6f4203d5338e99f}{len};
1278                     if (*cleaned\_packets == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}) \{
1279                         *cleaned\_packets =
1280                             tx\_buffer->\hyperlink{structigb__tx__buffer_ac6186670bb595d9f22c89b6dc2779d14}{packet};
1281                     \} \textcolor{keywordflow}{else} \{
1282                         last\_reclaimed->\hyperlink{structigb__packet_a1a20432d28f575630a2562c1c728a40f}{next} =
1283                             tx\_buffer->\hyperlink{structigb__tx__buffer_ac6186670bb595d9f22c89b6dc2779d14}{packet};
1284                     \}
1285                     last\_reclaimed = tx\_buffer->\hyperlink{structigb__tx__buffer_ac6186670bb595d9f22c89b6dc2779d14}{packet};
1286 
1287                     tx\_buffer->\hyperlink{structigb__tx__buffer_ac6186670bb595d9f22c89b6dc2779d14}{packet} = \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
1288                 \}
1289                 tx\_buffer->\hyperlink{structigb__tx__buffer_af565101ee13ca100904a7ac5b7564a3d}{next\_eop} = -1;
1290                 tx\_desc->\hyperlink{structe1000__tx__desc_af3e5d27ab120986fbbcd3deff79bf164}{upper}.\hyperlink{structe1000__tx__desc_afc5d3d82c86bd8827a6251a93986acf8}{data} = 0;
1291                 tx\_desc->\hyperlink{structe1000__tx__desc_aa48d5c36921e2d5fc081bf4c2e5cd8d6}{lower}.\hyperlink{structe1000__tx__desc_afc5d3d82c86bd8827a6251a93986acf8}{data} = 0;
1292                 tx\_desc->\hyperlink{structe1000__tx__desc_a87d79130b57fb21eedf04b9d3945c3d6}{buffer\_addr} = 0;
1293                 ++txr->\hyperlink{structtx__ring_a3f8acb3cacc1230f5a5b78b1b6cf7c2a}{tx\_avail};
1294                 ++processed;
1295 
1296                 \textcolor{keywordflow}{if} (++first == adapter->\hyperlink{structadapter_ab0bd5866ff13aa7c17436220693a3d2d}{num\_tx\_desc})
1297                     first = 0;
1298 
1299                 tx\_buffer = &txr->\hyperlink{structtx__ring_a9b0485752fc6d8befa2f35ebd45710db}{tx\_buffers}[first];
1300                 tx\_desc = &txr->\hyperlink{structtx__ring_afcf2ae577a4363723c3403d160dd4d01}{tx\_base}[first];
1301             \}
1302             ++txr->\hyperlink{structtx__ring_a5ff69346aaa72fb9bf0c095156ddccbb}{packets};
1303             \textcolor{comment}{/* See if we can continue to the next packet */}
1304             last = tx\_buffer->\hyperlink{structigb__tx__buffer_af565101ee13ca100904a7ac5b7564a3d}{next\_eop};
1305             \textcolor{keywordflow}{if} (last != -1) \{
1306                 eop\_desc = &txr->\hyperlink{structtx__ring_afcf2ae577a4363723c3403d160dd4d01}{tx\_base}[last];
1307                 \textcolor{comment}{/* Get new done point */}
1308                 \textcolor{keywordflow}{if} (++last == adapter->\hyperlink{structadapter_ab0bd5866ff13aa7c17436220693a3d2d}{num\_tx\_desc})
1309                     last = 0;
1310                 done = last;
1311             \} \textcolor{keywordflow}{else}
1312                 \textcolor{keywordflow}{break};
1313         \}
1314 
1315         txr->\hyperlink{structtx__ring_a6b93808fe90341d9209770bf06dcdc6c}{next\_to\_clean} = first;
1316 
1317         \textcolor{keywordflow}{if} (txr->\hyperlink{structtx__ring_a3f8acb3cacc1230f5a5b78b1b6cf7c2a}{tx\_avail} >= \hyperlink{igb__internal_8h_ac7640c2640ab6ad9852e1575eadb1329}{IGB\_QUEUE\_THRESHOLD})
1318             txr->\hyperlink{structtx__ring_ac2917164cdb60559cb6fb4367f48ca24}{queue\_status} &= ~\hyperlink{igb__internal_8h_adfddb078be1e5adaafc9ac965879a0be}{IGB\_QUEUE\_DEPLETED};
1319     \}
1320     \hyperlink{igb_8c_a4072fbeaba958ad7c81990de452139da}{igb\_unlock}(dev);
1321 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=237pt]{igb_8c_a03eaebcc1732abe4fd77c1f79c8e2fee_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{igb_8c_a03eaebcc1732abe4fd77c1f79c8e2fee_icgraph}
\end{center}
\end{figure}


\index{igb.\+c@{igb.\+c}!igb\+\_\+clear\+\_\+flex\+\_\+filter@{igb\+\_\+clear\+\_\+flex\+\_\+filter}}
\index{igb\+\_\+clear\+\_\+flex\+\_\+filter@{igb\+\_\+clear\+\_\+flex\+\_\+filter}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{igb\+\_\+clear\+\_\+flex\+\_\+filter(device\+\_\+t $\ast$dev, unsigned int filter\+\_\+id)}{igb_clear_flex_filter(device_t *dev, unsigned int filter_id)}}]{\setlength{\rightskip}{0pt plus 5cm}int igb\+\_\+clear\+\_\+flex\+\_\+filter (
\begin{DoxyParamCaption}
\item[{{\bf device\+\_\+t} $\ast$}]{dev, }
\item[{unsigned int}]{filter\+\_\+id}
\end{DoxyParamCaption}
)}\hypertarget{igb_8c_a4f4ed06dde00dd89730d8968ac3e9f46}{}\label{igb_8c_a4f4ed06dde00dd89730d8968ac3e9f46}


igb.\+c 파일의 2435 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
2436 \{
2437     \textcolor{keyword}{struct }\hyperlink{structadapter}{adapter} *\hyperlink{structadapter}{adapter};
2438     \textcolor{keyword}{struct }\hyperlink{structe1000__hw}{e1000\_hw} *hw;
2439     \hyperlink{lib_2igb_2e1000__osdep_8h_a64e91c10a0d8fb627e92932050284264}{u32} wufc;
2440 
2441     \textcolor{keywordflow}{if} (dev == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
2442         \textcolor{keywordflow}{return} -EINVAL;
2443 
2444     adapter = (\textcolor{keyword}{struct }adapter *)dev->\hyperlink{struct__device__t_ad517770dac2061381b2008850ff12e6c}{private\_data};
2445     if (adapter == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
2446         \textcolor{keywordflow}{return} -ENXIO;
2447 
2448     \textcolor{keywordflow}{if} (filter\_id > 7)
2449         \textcolor{keywordflow}{return} -EINVAL;
2450 
2451 
2452     hw = &adapter->\hyperlink{structadapter_a7d5953861471302be6287c989e0b20ba}{hw};
2453 
2454     wufc = \hyperlink{kmod_2igb_2e1000__osdep_8h_a28390efdfdfb1e1cd1b033d021906a47}{E1000\_READ\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_a6f8e4ba2de0f8a1b9a41223ca4f62d55}{E1000\_WUFC});
2455     wufc &= ~(\hyperlink{kmod_2igb_2e1000__defines_8h_acd3fb505efb2986f034a804387cc5e3b}{E1000\_WUFC\_FLX0} << filter\_id);
2456     \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_a6f8e4ba2de0f8a1b9a41223ca4f62d55}{E1000\_WUFC}, wufc);
2457 
2458     \textcolor{keywordflow}{return} 0;
2459 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{igb_8c_a4f4ed06dde00dd89730d8968ac3e9f46_icgraph}
\end{center}
\end{figure}


\index{igb.\+c@{igb.\+c}!igb\+\_\+create\+\_\+lock@{igb\+\_\+create\+\_\+lock}}
\index{igb\+\_\+create\+\_\+lock@{igb\+\_\+create\+\_\+lock}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{igb\+\_\+create\+\_\+lock(struct adapter $\ast$adapter)}{igb_create_lock(struct adapter *adapter)}}]{\setlength{\rightskip}{0pt plus 5cm}static int igb\+\_\+create\+\_\+lock (
\begin{DoxyParamCaption}
\item[{struct {\bf adapter} $\ast$}]{adapter}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{igb_8c_a7fcc5ae922167895160aed1c771d5e62}{}\label{igb_8c_a7fcc5ae922167895160aed1c771d5e62}


igb.\+c 파일의 2461 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
2462 \{
2463     \textcolor{keywordtype}{int} error = -1;
2464     \textcolor{keywordtype}{int} fd = -1;
2465     \textcolor{keywordtype}{bool} locked = \textcolor{keyword}{false};
2466     \textcolor{keyword}{struct }flock fl;
2467     \textcolor{keyword}{struct }stat stat;
2468     mode\_t fmode = S\_IRUSR|S\_IWUSR|S\_IRGRP|S\_IWGRP;
2469 
2470     \textcolor{keywordtype}{bool} attr\_allocated = \textcolor{keyword}{false};
2471     pthread\_mutexattr\_t attr;
2472 
2473     \textcolor{keywordflow}{if} (!adapter) \{
2474         errno = EINVAL;
2475         \textcolor{keywordflow}{goto} \hyperlink{gst__avb__playbin_8c_a6ce68847c12434f60d1b2654a3dc3409}{err};
2476     \}
2477 
2478     \textcolor{keywordflow}{if} (adapter->\hyperlink{structadapter_ac26455511b5639f92b1eadeae2f8e20e}{memlock}) \{  \textcolor{comment}{// already created}
2479         errno = EINVAL;
2480         \textcolor{keywordflow}{goto} \hyperlink{gst__avb__playbin_8c_a6ce68847c12434f60d1b2654a3dc3409}{err};
2481     \}
2482 
2483     \textcolor{comment}{/*}
2484 \textcolor{comment}{     * inter-process syncronization}
2485 \textcolor{comment}{     *}
2486 \textcolor{comment}{     * Use a posix mutex for inter-process syncronization}
2487 \textcolor{comment}{     *}
2488 \textcolor{comment}{     * igb lib used a posix named semaphore to protect concurrent accesses}
2489 \textcolor{comment}{     * from multiple processes. But since the posix semaphore cannot be}
2490 \textcolor{comment}{     * automatically released on process termination, if some process holding}
2491 \textcolor{comment}{     * the semaphore terminates without releasing it, other processes cannot}
2492 \textcolor{comment}{     * acquire the semaphore afterward. This could potentially cause a denial}
2493 \textcolor{comment}{     * of service condition.}
2494 \textcolor{comment}{     */}
2495 
2496     fd = shm\_open(\hyperlink{igb_8c_adb750b9f7efbe2a8f60f02dd4a9343d1}{IGB\_SEM}, O\_RDWR|O\_CREAT|O\_CLOEXEC, fmode);
2497     \textcolor{keywordflow}{if} (fd < 0)
2498         \textcolor{keywordflow}{goto} \hyperlink{gst__avb__playbin_8c_a6ce68847c12434f60d1b2654a3dc3409}{err};
2499 
2500     (void) fchmod(fd, fmode); \textcolor{comment}{// just to make sure fmode is applied}
2501 
2502     \textcolor{comment}{// shared memory holding the mutex instance}
2503     adapter->\hyperlink{structadapter_ac26455511b5639f92b1eadeae2f8e20e}{memlock} = (pthread\_mutex\_t*) mmap(\hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}, \textcolor{keyword}{sizeof}(pthread\_mutex\_t),
2504                             PROT\_READ|PROT\_WRITE, MAP\_SHARED, fd, 0);
2505     \textcolor{keywordflow}{if} (!adapter->\hyperlink{structadapter_ac26455511b5639f92b1eadeae2f8e20e}{memlock})
2506         \textcolor{keywordflow}{goto} \hyperlink{gst__avb__playbin_8c_a6ce68847c12434f60d1b2654a3dc3409}{err};
2507 
2508     \textcolor{comment}{/*}
2509 \textcolor{comment}{     * Exclusive access lock}
2510 \textcolor{comment}{     *}
2511 \textcolor{comment}{     * At this moment the posix mutex in the shared memory might not be}
2512 \textcolor{comment}{     * available yet and it needs initialization. We need to protect the}
2513 \textcolor{comment}{     * initialization code otherwise multiple processes could concurrently}
2514 \textcolor{comment}{     * do initialization. Create an exclusive access section by applying}
2515 \textcolor{comment}{     * the file-lock against the shared memory file.}
2516 \textcolor{comment}{     *}
2517 \textcolor{comment}{     * By the way the file-lock itself could safely be used for inter-process}
2518 \textcolor{comment}{     * synchronization because it also automatically gets unlocked on process}
2519 \textcolor{comment}{     * termination. But it is slower than the posix-mutex. So we should use}
2520 \textcolor{comment}{     * the posix-mutex once its initialization done.}
2521 \textcolor{comment}{     */}
2522     fl.l\_type = F\_WRLCK;
2523     fl.l\_whence = SEEK\_SET;
2524     fl.l\_start = 0;
2525     fl.l\_len = 1;
2526     fl.l\_pid = getpid();
2527 
2528     \textcolor{keywordflow}{if} (fcntl(fd, F\_SETLKW, &fl) != 0)
2529         \textcolor{keywordflow}{goto} \hyperlink{gst__avb__playbin_8c_a6ce68847c12434f60d1b2654a3dc3409}{err};
2530 
2531     locked = \textcolor{keyword}{true};
2532 
2533     \textcolor{keywordflow}{if} (fstat(fd, &stat) != 0)
2534         \textcolor{keywordflow}{goto} \hyperlink{gst__avb__playbin_8c_a6ce68847c12434f60d1b2654a3dc3409}{err};
2535 
2536     \textcolor{keywordflow}{if} (stat.st\_size == 0) \{ \textcolor{comment}{// file is empty, do initialization}
2537         \textcolor{comment}{/*}
2538 \textcolor{comment}{         * file-size becomes non-zero and given that when other processes}
2539 \textcolor{comment}{         * attach lib igb we can skip the initialization code for the mutex.}
2540 \textcolor{comment}{         */}
2541         \textcolor{keywordflow}{if} (ftruncate(fd, \textcolor{keyword}{sizeof}(pthread\_mutex\_t)) != 0)
2542             \textcolor{keywordflow}{goto} \hyperlink{gst__avb__playbin_8c_a6ce68847c12434f60d1b2654a3dc3409}{err};
2543 
2544         \textcolor{keywordflow}{if} (pthread\_mutexattr\_init(&attr) != 0)
2545             \textcolor{keywordflow}{goto} \hyperlink{gst__avb__playbin_8c_a6ce68847c12434f60d1b2654a3dc3409}{err};
2546 
2547         attr\_allocated = \textcolor{keyword}{true};
2548 
2549         \textcolor{comment}{// to be used for both inter-process and inter-thread synchronization}
2550         \textcolor{keywordflow}{if} (pthread\_mutexattr\_setpshared(&attr, PTHREAD\_PROCESS\_SHARED) != 0)
2551             \textcolor{keywordflow}{goto} \hyperlink{gst__avb__playbin_8c_a6ce68847c12434f60d1b2654a3dc3409}{err};
2552 
2553         \textcolor{comment}{// to avoid dead lock due to a dead process holding the semaphore}
2554         \textcolor{keywordflow}{if} (pthread\_mutexattr\_setrobust(&attr, PTHREAD\_MUTEX\_ROBUST) != 0)
2555             \textcolor{keywordflow}{goto} \hyperlink{gst__avb__playbin_8c_a6ce68847c12434f60d1b2654a3dc3409}{err};
2556 
2557         \textcolor{keywordflow}{if} (pthread\_mutex\_init(adapter->\hyperlink{structadapter_ac26455511b5639f92b1eadeae2f8e20e}{memlock}, &attr) != 0)
2558             \textcolor{keywordflow}{goto} \hyperlink{gst__avb__playbin_8c_a6ce68847c12434f60d1b2654a3dc3409}{err};
2559     \}
2560 
2561     error = 0;
2562 \hyperlink{gst__avb__playbin_8c_a6ce68847c12434f60d1b2654a3dc3409}{err}:
2563     \textcolor{comment}{// no actual effect but to avoid a warning from a static code analyzer}
2564     \textcolor{keywordflow}{if} (attr\_allocated)
2565         (void) pthread\_mutexattr\_destroy(&attr);
2566 
2567     \textcolor{keywordflow}{if} (error != 0) \{
2568         error = -errno;
2569         \textcolor{keywordflow}{if} (adapter && adapter->\hyperlink{structadapter_ac26455511b5639f92b1eadeae2f8e20e}{memlock}) \{
2570             (void) munmap(adapter->\hyperlink{structadapter_ac26455511b5639f92b1eadeae2f8e20e}{memlock}, \textcolor{keyword}{sizeof}(pthread\_mutex\_t));
2571             adapter->\hyperlink{structadapter_ac26455511b5639f92b1eadeae2f8e20e}{memlock} = \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
2572         \}
2573     \}
2574 
2575     \textcolor{keywordflow}{if} (fd >= 0) \{
2576         \textcolor{keywordflow}{if} (locked) \{
2577             fl.l\_type = F\_UNLCK;
2578             (void) fcntl(fd, F\_SETLK, &fl);
2579         \}
2580         (void) close(fd);
2581     \}
2582 
2583     \textcolor{keywordflow}{return} error;
2584 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{igb_8c_a7fcc5ae922167895160aed1c771d5e62_icgraph}
\end{center}
\end{figure}


\index{igb.\+c@{igb.\+c}!igb\+\_\+detach@{igb\+\_\+detach}}
\index{igb\+\_\+detach@{igb\+\_\+detach}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{igb\+\_\+detach(device\+\_\+t $\ast$dev)}{igb_detach(device_t *dev)}}]{\setlength{\rightskip}{0pt plus 5cm}int igb\+\_\+detach (
\begin{DoxyParamCaption}
\item[{{\bf device\+\_\+t} $\ast$}]{dev}
\end{DoxyParamCaption}
)}\hypertarget{igb_8c_a234eba39e755b10f3ad1652c95072a77}{}\label{igb_8c_a234eba39e755b10f3ad1652c95072a77}


igb.\+c 파일의 318 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
319 \{
320     \textcolor{keyword}{struct }\hyperlink{structadapter}{adapter} *\hyperlink{structadapter}{adapter};
321 
322     \textcolor{keywordflow}{if} (dev == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
323         \textcolor{keywordflow}{return} -EINVAL;
324     adapter = (\textcolor{keyword}{struct }adapter *)dev->\hyperlink{struct__device__t_ad517770dac2061381b2008850ff12e6c}{private\_data};
325     if (adapter == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
326         \textcolor{keywordflow}{return} -ENXIO;
327 
328     \textcolor{keywordflow}{if} (\hyperlink{igb_8c_a791fd0757e3ca1833df21ee94c17b855}{igb\_lock}(dev) != 0)
329         \textcolor{keywordflow}{goto} err\_nolock;
330 
331     \textcolor{comment}{/*}
332 \textcolor{comment}{     * Prevent access to device after calling igb\_detach since associated}
333 \textcolor{comment}{     * resources will be freed up from here thus in particular multi-thread}
334 \textcolor{comment}{     * application other thread must not access device if this flag is off.}
335 \textcolor{comment}{     */}
336     adapter->\hyperlink{structadapter_aa5805c5e936174e5092bf7a5b78e7e64}{active} = 0;
337 
338     \hyperlink{igb_8c_afa49e6907f7179625e2267faa054d250}{igb\_reset}(adapter);
339 
340     \hyperlink{igb_8c_a4072fbeaba958ad7c81990de452139da}{igb\_unlock}(dev);
341 
342     \hyperlink{igb_8c_a598861e7bb5e9769bde5e4dbb853fda8}{igb\_free\_pci\_resources}(adapter);
343 
344     \textcolor{keywordflow}{if} (adapter->\hyperlink{structadapter_aec689462327aa3bf0e8a73e7cca2ae55}{tx\_rings})
345         \hyperlink{igb_8c_a6a40edaa22ec396808c4e534609acd40}{igb\_free\_transmit\_structures}(adapter);
346 
347     \textcolor{keywordflow}{if} (adapter->\hyperlink{structadapter_a59a5588ccfe1b0eefe45fcb9188b2f0a}{rx\_rings})
348         \hyperlink{igb_8c_a963d0751ad152e084b08017d83e5d701}{igb\_free\_receive\_structures}(adapter);
349 
350 err\_nolock:
351     \textcolor{keywordflow}{if} (adapter->\hyperlink{structadapter_ac26455511b5639f92b1eadeae2f8e20e}{memlock}) \{
352         \textcolor{comment}{/*}
353 \textcolor{comment}{         * Do not unmap the shared memory region holding the pthread mutex.}
354 \textcolor{comment}{         *}
355 \textcolor{comment}{         * (void) munmap(adapter->memlock, sizeof(pthread\_mutex\_t));}
356 \textcolor{comment}{         *}
357 \textcolor{comment}{         * The pthread mutex is configured as a robust type mutex so that}
358 \textcolor{comment}{         * it can automatically be unlocked on process termination if needed.}
359 \textcolor{comment}{         * In order to complete the cleanup, the memory region holding the}
360 \textcolor{comment}{         * mutex instance must be accessible until that cleanup timing.}
361 \textcolor{comment}{         * Therefore we should not unmap the memory region here, otherwise}
362 \textcolor{comment}{         * the cleanup may fail.}
363 \textcolor{comment}{         *}
364 \textcolor{comment}{         * The mapped regions will automatically be unmapped at the end of}
365 \textcolor{comment}{         * the process termination.}
366 \textcolor{comment}{         */}
367         adapter->\hyperlink{structadapter_ac26455511b5639f92b1eadeae2f8e20e}{memlock} = \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
368     \}
369 
370     close(adapter->\hyperlink{structadapter_ae57c5756a3672ea1541cbc6dfd283161}{ldev});
371 
372     \hyperlink{_memory_leak_detector_malloc_macros_8h_aa7157aa9480bb73f090dca36776419bf}{free}(dev->\hyperlink{struct__device__t_ad517770dac2061381b2008850ff12e6c}{private\_data});
373     dev->\hyperlink{struct__device__t_ad517770dac2061381b2008850ff12e6c}{private\_data} = \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
374     \textcolor{keywordflow}{return} 0;
375 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{igb_8c_a234eba39e755b10f3ad1652c95072a77_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{igb_8c_a234eba39e755b10f3ad1652c95072a77_icgraph}
\end{center}
\end{figure}


\index{igb.\+c@{igb.\+c}!igb\+\_\+dma\+\_\+free\+\_\+page@{igb\+\_\+dma\+\_\+free\+\_\+page}}
\index{igb\+\_\+dma\+\_\+free\+\_\+page@{igb\+\_\+dma\+\_\+free\+\_\+page}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{igb\+\_\+dma\+\_\+free\+\_\+page(device\+\_\+t $\ast$dev, struct igb\+\_\+dma\+\_\+alloc $\ast$dma)}{igb_dma_free_page(device_t *dev, struct igb_dma_alloc *dma)}}]{\setlength{\rightskip}{0pt plus 5cm}void igb\+\_\+dma\+\_\+free\+\_\+page (
\begin{DoxyParamCaption}
\item[{{\bf device\+\_\+t} $\ast$}]{dev, }
\item[{struct {\bf igb\+\_\+dma\+\_\+alloc} $\ast$}]{dma}
\end{DoxyParamCaption}
)}\hypertarget{igb_8c_a850c73e1871342ff79fe6f0a5e6c26f3}{}\label{igb_8c_a850c73e1871342ff79fe6f0a5e6c26f3}


igb.\+c 파일의 712 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
713 \{
714     \textcolor{keyword}{struct }\hyperlink{structadapter}{adapter} *\hyperlink{structadapter}{adapter};
715     \textcolor{keyword}{struct }\hyperlink{structigb__buf__cmd}{igb\_buf\_cmd}      ubuf;
716 
717     \textcolor{keywordflow}{if} (dev == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
718         \textcolor{keywordflow}{return};
719     \textcolor{keywordflow}{if} (dma == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
720         \textcolor{keywordflow}{return};
721 
722     adapter = (\textcolor{keyword}{struct }adapter *)dev->\hyperlink{struct__device__t_ad517770dac2061381b2008850ff12e6c}{private\_data};
723     if (adapter == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
724         \textcolor{keywordflow}{return};
725 
726     munmap(dma->\hyperlink{structigb__dma__alloc_a1a7aec22103dc161f23a441da520af5b}{dma\_vaddr},
727         dma->\hyperlink{structigb__dma__alloc_a8258a70481ee5ece54c23de98e767611}{mmap\_size});
728 
729     ubuf.physaddr = dma->\hyperlink{structigb__dma__alloc_a634628ebb0fecc5be46345b286cce0ef}{dma\_paddr};
730 
731     \textcolor{keywordflow}{if} (\hyperlink{igb_8c_a791fd0757e3ca1833df21ee94c17b855}{igb\_lock}(dev) != 0)
732         \textcolor{keywordflow}{goto} \hyperlink{gst__avb__playbin_8c_a6ce68847c12434f60d1b2654a3dc3409}{err};
733 
734     ioctl(adapter->\hyperlink{structadapter_ae57c5756a3672ea1541cbc6dfd283161}{ldev}, \hyperlink{kmod_2igb_2igb_8h_a56337cbcf4b8cbf0639e27c2e6450421}{IGB\_IOCTL\_UNMAPBUF}, &ubuf);
735     \textcolor{keywordflow}{if} (\hyperlink{igb_8c_a4072fbeaba958ad7c81990de452139da}{igb\_unlock}(dev) != 0)
736         \textcolor{keywordflow}{goto} \hyperlink{gst__avb__playbin_8c_a6ce68847c12434f60d1b2654a3dc3409}{err};
737 
738     dma->\hyperlink{structigb__dma__alloc_a634628ebb0fecc5be46345b286cce0ef}{dma\_paddr} = 0;
739     dma->\hyperlink{structigb__dma__alloc_a1a7aec22103dc161f23a441da520af5b}{dma\_vaddr} = \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
740     dma->\hyperlink{structigb__dma__alloc_a8258a70481ee5ece54c23de98e767611}{mmap\_size} = 0;
741 
742 \hyperlink{gst__avb__playbin_8c_a6ce68847c12434f60d1b2654a3dc3409}{err}:
743     \textcolor{keywordflow}{return};
744 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=280pt]{igb_8c_a850c73e1871342ff79fe6f0a5e6c26f3_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{igb_8c_a850c73e1871342ff79fe6f0a5e6c26f3_icgraph}
\end{center}
\end{figure}


\index{igb.\+c@{igb.\+c}!igb\+\_\+dma\+\_\+malloc\+\_\+page@{igb\+\_\+dma\+\_\+malloc\+\_\+page}}
\index{igb\+\_\+dma\+\_\+malloc\+\_\+page@{igb\+\_\+dma\+\_\+malloc\+\_\+page}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{igb\+\_\+dma\+\_\+malloc\+\_\+page(device\+\_\+t $\ast$dev, struct igb\+\_\+dma\+\_\+alloc $\ast$dma)}{igb_dma_malloc_page(device_t *dev, struct igb_dma_alloc *dma)}}]{\setlength{\rightskip}{0pt plus 5cm}int igb\+\_\+dma\+\_\+malloc\+\_\+page (
\begin{DoxyParamCaption}
\item[{{\bf device\+\_\+t} $\ast$}]{dev, }
\item[{struct {\bf igb\+\_\+dma\+\_\+alloc} $\ast$}]{dma}
\end{DoxyParamCaption}
)}\hypertarget{igb_8c_a4e2589d22e959c35c0902ef79ed3f059}{}\label{igb_8c_a4e2589d22e959c35c0902ef79ed3f059}


igb.\+c 파일의 666 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
667 \{
668     \textcolor{keyword}{struct }\hyperlink{structadapter}{adapter} *\hyperlink{structadapter}{adapter};
669     \textcolor{keywordtype}{int} error = 0;
670     \textcolor{keyword}{struct }\hyperlink{structigb__buf__cmd}{igb\_buf\_cmd} ubuf = \{0\};
671 
672     \textcolor{keywordflow}{if} (dev == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
673         \textcolor{keywordflow}{return} -EINVAL;
674     \textcolor{keywordflow}{if} (dma == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
675         \textcolor{keywordflow}{return} -EINVAL;
676 
677     adapter = (\textcolor{keyword}{struct }adapter *)dev->\hyperlink{struct__device__t_ad517770dac2061381b2008850ff12e6c}{private\_data};
678     if (adapter == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
679         \textcolor{keywordflow}{return} -ENXIO;
680 
681     \textcolor{keywordflow}{if} (\hyperlink{igb_8c_a791fd0757e3ca1833df21ee94c17b855}{igb\_lock}(dev) != 0) \{
682         error = errno;
683         \textcolor{keywordflow}{goto} \hyperlink{gst__avb__playbin_8c_a6ce68847c12434f60d1b2654a3dc3409}{err};
684     \}
685     error = ioctl(adapter->\hyperlink{structadapter_ae57c5756a3672ea1541cbc6dfd283161}{ldev}, \hyperlink{kmod_2igb_2igb_8h_adf93032d2ef77fa393c4b66b54154d61}{IGB\_IOCTL\_MAPBUF}, &ubuf);
686     \textcolor{keywordflow}{if} (\hyperlink{igb_8c_a4072fbeaba958ad7c81990de452139da}{igb\_unlock}(dev) != 0) \{
687         error = errno;
688         \textcolor{keywordflow}{goto} \hyperlink{gst__avb__playbin_8c_a6ce68847c12434f60d1b2654a3dc3409}{err};
689     \}
690 
691     \textcolor{keywordflow}{if} (error < 0) \{
692         \textcolor{keywordflow}{if}(error != -EINVAL)
693             error = -ENOMEM;
694         \textcolor{keywordflow}{goto} \hyperlink{gst__avb__playbin_8c_a6ce68847c12434f60d1b2654a3dc3409}{err};
695     \}
696 
697     dma->\hyperlink{structigb__dma__alloc_a634628ebb0fecc5be46345b286cce0ef}{dma\_paddr} = ubuf.\hyperlink{structigb__buf__cmd_a49f357a5ff181876b6c641e455b18b20}{physaddr};
698     dma->\hyperlink{structigb__dma__alloc_a8258a70481ee5ece54c23de98e767611}{mmap\_size} = ubuf.\hyperlink{structigb__buf__cmd_ac76710c49696b7df6ecbef456496ea50}{mmap\_size};
699     dma->\hyperlink{structigb__dma__alloc_a1a7aec22103dc161f23a441da520af5b}{dma\_vaddr} = (\textcolor{keywordtype}{void} *)mmap(\hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL},
700                       ubuf.\hyperlink{structigb__buf__cmd_ac76710c49696b7df6ecbef456496ea50}{mmap\_size},
701                       PROT\_READ | PROT\_WRITE,
702                       MAP\_SHARED,
703                       adapter->\hyperlink{structadapter_ae57c5756a3672ea1541cbc6dfd283161}{ldev},
704                       ubuf.\hyperlink{structigb__buf__cmd_a16daee3847fb6e540a1285a3951ff169}{pa});
705 
706     \textcolor{keywordflow}{if} (dma->\hyperlink{structigb__dma__alloc_a1a7aec22103dc161f23a441da520af5b}{dma\_vaddr} == MAP\_FAILED)
707         error = -ENOMEM;
708 \hyperlink{gst__avb__playbin_8c_a6ce68847c12434f60d1b2654a3dc3409}{err}:
709     \textcolor{keywordflow}{return} error;
710 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=292pt]{igb_8c_a4e2589d22e959c35c0902ef79ed3f059_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{igb_8c_a4e2589d22e959c35c0902ef79ed3f059_icgraph}
\end{center}
\end{figure}


\index{igb.\+c@{igb.\+c}!igb\+\_\+free\+\_\+pci\+\_\+resources@{igb\+\_\+free\+\_\+pci\+\_\+resources}}
\index{igb\+\_\+free\+\_\+pci\+\_\+resources@{igb\+\_\+free\+\_\+pci\+\_\+resources}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{igb\+\_\+free\+\_\+pci\+\_\+resources(struct adapter $\ast$adapter)}{igb_free_pci_resources(struct adapter *adapter)}}]{\setlength{\rightskip}{0pt plus 5cm}static void igb\+\_\+free\+\_\+pci\+\_\+resources (
\begin{DoxyParamCaption}
\item[{struct {\bf adapter} $\ast$}]{adapter}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{igb_8c_a598861e7bb5e9769bde5e4dbb853fda8}{}\label{igb_8c_a598861e7bb5e9769bde5e4dbb853fda8}


igb.\+c 파일의 658 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
659 \{
660     munmap(adapter->\hyperlink{structadapter_a7d5953861471302be6287c989e0b20ba}{hw}.\hyperlink{structe1000__hw_a54127b9ee5d8173dc068cf8c43a0600f}{hw\_addr}, adapter->\hyperlink{structadapter_a0ca05bc0e64b6eb88e6fb380b688af4e}{csr}.\hyperlink{structresource_a83be2978ea6cb76ae7b9be1c9819e0fe}{mmap\_size});
661 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{igb_8c_a598861e7bb5e9769bde5e4dbb853fda8_icgraph}
\end{center}
\end{figure}


\index{igb.\+c@{igb.\+c}!igb\+\_\+free\+\_\+receive\+\_\+buffers@{igb\+\_\+free\+\_\+receive\+\_\+buffers}}
\index{igb\+\_\+free\+\_\+receive\+\_\+buffers@{igb\+\_\+free\+\_\+receive\+\_\+buffers}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{igb\+\_\+free\+\_\+receive\+\_\+buffers(struct rx\+\_\+ring $\ast$rxr)}{igb_free_receive_buffers(struct rx_ring *rxr)}}]{\setlength{\rightskip}{0pt plus 5cm}static void igb\+\_\+free\+\_\+receive\+\_\+buffers (
\begin{DoxyParamCaption}
\item[{struct {\bf rx\+\_\+ring} $\ast$}]{rxr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{igb_8c_a6dd8c22e48f62fd8dedba075039d6747}{}\label{igb_8c_a6dd8c22e48f62fd8dedba075039d6747}


igb.\+c 파일의 1595 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
1596 \{
1597     \textcolor{keyword}{struct }\hyperlink{structadapter}{adapter} *\hyperlink{structadapter}{adapter} = rxr->\hyperlink{structrx__ring_a807e6014970a3d469e197cd9ec25229c}{adapter};
1598     \textcolor{keyword}{struct }\hyperlink{structigb__rx__buffer}{igb\_rx\_buffer} *rxbuf;
1599     \textcolor{keywordtype}{int} i;
1600 
1601     \textcolor{comment}{/* Cleanup any existing buffers */}
1602     \textcolor{keywordflow}{if} (rxr->\hyperlink{structrx__ring_abe41cfe713ffac28a8f678c51082df25}{rx\_buffers} != \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}) \{
1603         \textcolor{keywordflow}{for} (i = 0; i < adapter->\hyperlink{structadapter_a7a36fc7297d99f6b73c4b6a194b33efd}{num\_rx\_desc}; i++) \{
1604             rxbuf = &rxr->\hyperlink{structrx__ring_abe41cfe713ffac28a8f678c51082df25}{rx\_buffers}[i];
1605             rxbuf->\hyperlink{structigb__rx__buffer_af565101ee13ca100904a7ac5b7564a3d}{next\_eop} = 0;
1606             rxbuf->\hyperlink{structigb__rx__buffer_ac6186670bb595d9f22c89b6dc2779d14}{packet} = \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
1607         \}
1608         \textcolor{keywordflow}{if} (rxr->\hyperlink{structrx__ring_abe41cfe713ffac28a8f678c51082df25}{rx\_buffers} != \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}) \{
1609             \hyperlink{_memory_leak_detector_malloc_macros_8h_aa7157aa9480bb73f090dca36776419bf}{free}(rxr->\hyperlink{structrx__ring_abe41cfe713ffac28a8f678c51082df25}{rx\_buffers});
1610             rxr->\hyperlink{structrx__ring_abe41cfe713ffac28a8f678c51082df25}{rx\_buffers} = \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
1611         \}
1612     \}
1613 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{igb_8c_a6dd8c22e48f62fd8dedba075039d6747_icgraph}
\end{center}
\end{figure}


\index{igb.\+c@{igb.\+c}!igb\+\_\+free\+\_\+receive\+\_\+ring@{igb\+\_\+free\+\_\+receive\+\_\+ring}}
\index{igb\+\_\+free\+\_\+receive\+\_\+ring@{igb\+\_\+free\+\_\+receive\+\_\+ring}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{igb\+\_\+free\+\_\+receive\+\_\+ring(struct rx\+\_\+ring $\ast$rxr)}{igb_free_receive_ring(struct rx_ring *rxr)}}]{\setlength{\rightskip}{0pt plus 5cm}static void igb\+\_\+free\+\_\+receive\+\_\+ring (
\begin{DoxyParamCaption}
\item[{struct {\bf rx\+\_\+ring} $\ast$}]{rxr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{igb_8c_aec1cca14ce5797701742e519f394cbbc}{}\label{igb_8c_aec1cca14ce5797701742e519f394cbbc}


igb.\+c 파일의 1438 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
1439 \{
1440     \textcolor{keyword}{struct }\hyperlink{structadapter}{adapter} *\hyperlink{structadapter}{adapter} = rxr->\hyperlink{structrx__ring_a807e6014970a3d469e197cd9ec25229c}{adapter};
1441     \textcolor{keyword}{struct }\hyperlink{structigb__rx__buffer}{igb\_rx\_buffer} *rxbuf;
1442     \textcolor{keywordtype}{int} i;
1443 
1444     \textcolor{keywordflow}{for} (i = 0; i < adapter->\hyperlink{structadapter_a7a36fc7297d99f6b73c4b6a194b33efd}{num\_rx\_desc}; i++) \{
1445         rxbuf = &rxr->\hyperlink{structrx__ring_abe41cfe713ffac28a8f678c51082df25}{rx\_buffers}[i];
1446         rxbuf->\hyperlink{structigb__rx__buffer_af565101ee13ca100904a7ac5b7564a3d}{next\_eop} = 0;
1447         rxbuf->\hyperlink{structigb__rx__buffer_ac6186670bb595d9f22c89b6dc2779d14}{packet} = \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
1448     \}
1449 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{igb_8c_aec1cca14ce5797701742e519f394cbbc_icgraph}
\end{center}
\end{figure}


\index{igb.\+c@{igb.\+c}!igb\+\_\+free\+\_\+receive\+\_\+structures@{igb\+\_\+free\+\_\+receive\+\_\+structures}}
\index{igb\+\_\+free\+\_\+receive\+\_\+structures@{igb\+\_\+free\+\_\+receive\+\_\+structures}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{igb\+\_\+free\+\_\+receive\+\_\+structures(struct adapter $\ast$adapter)}{igb_free_receive_structures(struct adapter *adapter)}}]{\setlength{\rightskip}{0pt plus 5cm}static void igb\+\_\+free\+\_\+receive\+\_\+structures (
\begin{DoxyParamCaption}
\item[{struct {\bf adapter} $\ast$}]{adapter}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{igb_8c_a963d0751ad152e084b08017d83e5d701}{}\label{igb_8c_a963d0751ad152e084b08017d83e5d701}


igb.\+c 파일의 1569 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
1570 \{
1571     \textcolor{keyword}{struct }\hyperlink{structrx__ring}{rx\_ring} *rxr = adapter->\hyperlink{structadapter_a59a5588ccfe1b0eefe45fcb9188b2f0a}{rx\_rings};
1572     \textcolor{keywordtype}{int} i;
1573     \textcolor{keyword}{struct }\hyperlink{structigb__buf__cmd}{igb\_buf\_cmd} ubuf;
1574 
1575     \textcolor{keywordflow}{for} (i = 0; i < adapter->\hyperlink{structadapter_a8befb466d4a5a6a432dc1648230e0a65}{num\_queues}; i++, rxr++) \{
1576         (void)sem\_wait(&adapter->\hyperlink{structadapter_a59a5588ccfe1b0eefe45fcb9188b2f0a}{rx\_rings}[i].\hyperlink{structrx__ring_ac301e000199ad937f060277b0736d4e1}{lock});
1577 
1578         \textcolor{keywordflow}{if} (rxr->\hyperlink{structrx__ring_a40ec79b3b6a780e7f5c90dea8b3160bf}{rx\_base}) \{
1579             memset(rxr->\hyperlink{structrx__ring_a40ec79b3b6a780e7f5c90dea8b3160bf}{rx\_base}, 0, rxr->\hyperlink{structrx__ring_a7b5f7d41a39b44612fd251f290500ba5}{rxdma}.\hyperlink{structresource_a83be2978ea6cb76ae7b9be1c9819e0fe}{mmap\_size});
1580             munmap(rxr->\hyperlink{structrx__ring_a40ec79b3b6a780e7f5c90dea8b3160bf}{rx\_base}, rxr->\hyperlink{structrx__ring_a7b5f7d41a39b44612fd251f290500ba5}{rxdma}.\hyperlink{structresource_a83be2978ea6cb76ae7b9be1c9819e0fe}{mmap\_size});
1581         \}
1582         ubuf.queue = i;
1583         ioctl(adapter->\hyperlink{structadapter_ae57c5756a3672ea1541cbc6dfd283161}{ldev}, \hyperlink{kmod_2igb_2igb_8h_ab77372222ac94c91f428f15b2a41445e}{IGB\_IOCTL\_UNMAP\_RX\_RING}, &ubuf);
1584         \hyperlink{igb_8c_a6dd8c22e48f62fd8dedba075039d6747}{igb\_free\_receive\_buffers}(rxr);
1585 
1586         (void)sem\_destroy(&adapter->\hyperlink{structadapter_a59a5588ccfe1b0eefe45fcb9188b2f0a}{rx\_rings}[i].\hyperlink{structrx__ring_ac301e000199ad937f060277b0736d4e1}{lock});
1587     \}
1588 
1589     \hyperlink{_memory_leak_detector_malloc_macros_8h_aa7157aa9480bb73f090dca36776419bf}{free}(adapter->\hyperlink{structadapter_a59a5588ccfe1b0eefe45fcb9188b2f0a}{rx\_rings});
1590     adapter->\hyperlink{structadapter_a59a5588ccfe1b0eefe45fcb9188b2f0a}{rx\_rings} = \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
1591 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{igb_8c_a963d0751ad152e084b08017d83e5d701_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{igb_8c_a963d0751ad152e084b08017d83e5d701_icgraph}
\end{center}
\end{figure}


\index{igb.\+c@{igb.\+c}!igb\+\_\+free\+\_\+transmit\+\_\+structures@{igb\+\_\+free\+\_\+transmit\+\_\+structures}}
\index{igb\+\_\+free\+\_\+transmit\+\_\+structures@{igb\+\_\+free\+\_\+transmit\+\_\+structures}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{igb\+\_\+free\+\_\+transmit\+\_\+structures(struct adapter $\ast$adapter)}{igb_free_transmit_structures(struct adapter *adapter)}}]{\setlength{\rightskip}{0pt plus 5cm}static void igb\+\_\+free\+\_\+transmit\+\_\+structures (
\begin{DoxyParamCaption}
\item[{struct {\bf adapter} $\ast$}]{adapter}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{igb_8c_a6a40edaa22ec396808c4e534609acd40}{}\label{igb_8c_a6a40edaa22ec396808c4e534609acd40}


igb.\+c 파일의 906 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
907 \{
908     \textcolor{keywordtype}{int} i;
909     \textcolor{keyword}{struct }\hyperlink{structigb__buf__cmd}{igb\_buf\_cmd} ubuf = \{0\};
910 
911     \textcolor{keywordflow}{for} (i = 0; i < adapter->\hyperlink{structadapter_a8befb466d4a5a6a432dc1648230e0a65}{num\_queues}; i++) \{
912         \textcolor{keywordflow}{if} (adapter->\hyperlink{structadapter_aec689462327aa3bf0e8a73e7cca2ae55}{tx\_rings}[i].\hyperlink{structtx__ring_afcf2ae577a4363723c3403d160dd4d01}{tx\_base})
913             munmap(adapter->\hyperlink{structadapter_aec689462327aa3bf0e8a73e7cca2ae55}{tx\_rings}[i].\hyperlink{structtx__ring_afcf2ae577a4363723c3403d160dd4d01}{tx\_base},
914                    adapter->\hyperlink{structadapter_aec689462327aa3bf0e8a73e7cca2ae55}{tx\_rings}[i].\hyperlink{structtx__ring_aefdccf596fff8b81ada9dd89b75697a8}{txdma}.\hyperlink{structresource_a83be2978ea6cb76ae7b9be1c9819e0fe}{mmap\_size});
915         ubuf.\hyperlink{structigb__buf__cmd_a6be361df991687a3b78645e3e8fa853d}{queue} = i;
916         ioctl(adapter->\hyperlink{structadapter_ae57c5756a3672ea1541cbc6dfd283161}{ldev}, \hyperlink{kmod_2igb_2igb_8h_a8a326cbb1aaa2d97a9f0f6aaf674c8b8}{IGB\_IOCTL\_UNMAPRING}, &ubuf);
917         \hyperlink{_memory_leak_detector_malloc_macros_8h_aa7157aa9480bb73f090dca36776419bf}{free}(adapter->\hyperlink{structadapter_aec689462327aa3bf0e8a73e7cca2ae55}{tx\_rings}[i].\hyperlink{structtx__ring_a9b0485752fc6d8befa2f35ebd45710db}{tx\_buffers});
918     \}
919 
920     \hyperlink{_memory_leak_detector_malloc_macros_8h_aa7157aa9480bb73f090dca36776419bf}{free}(adapter->\hyperlink{structadapter_aec689462327aa3bf0e8a73e7cca2ae55}{tx\_rings});
921     adapter->\hyperlink{structadapter_aec689462327aa3bf0e8a73e7cca2ae55}{tx\_rings} = \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
922 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{igb_8c_a6a40edaa22ec396808c4e534609acd40_icgraph}
\end{center}
\end{figure}


\index{igb.\+c@{igb.\+c}!igb\+\_\+get\+\_\+mac\+\_\+addr@{igb\+\_\+get\+\_\+mac\+\_\+addr}}
\index{igb\+\_\+get\+\_\+mac\+\_\+addr@{igb\+\_\+get\+\_\+mac\+\_\+addr}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{igb\+\_\+get\+\_\+mac\+\_\+addr(device\+\_\+t $\ast$dev, u\+\_\+int8\+\_\+t mac\+\_\+addr[E\+T\+H\+\_\+\+A\+D\+D\+R\+\_\+\+L\+EN])}{igb_get_mac_addr(device_t *dev, u_int8_t mac_addr[ETH_ADDR_LEN])}}]{\setlength{\rightskip}{0pt plus 5cm}int igb\+\_\+get\+\_\+mac\+\_\+addr (
\begin{DoxyParamCaption}
\item[{{\bf device\+\_\+t} $\ast$}]{dev, }
\item[{u\+\_\+int8\+\_\+t}]{mac\+\_\+addr\mbox{[}\+E\+T\+H\+\_\+\+A\+D\+D\+R\+\_\+\+L\+E\+N\mbox{]}}
\end{DoxyParamCaption}
)}\hypertarget{igb_8c_a257a2d309437e1cf4b696915dda16871}{}\label{igb_8c_a257a2d309437e1cf4b696915dda16871}


igb.\+c 파일의 2308 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
2309 \{
2310     \textcolor{keyword}{struct }\hyperlink{structadapter}{adapter} *\hyperlink{structadapter}{adapter};
2311     \textcolor{keyword}{struct }\hyperlink{structe1000__hw}{e1000\_hw} *hw;
2312 
2313     \textcolor{keywordflow}{if} (dev == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
2314         \textcolor{keywordflow}{return} -EINVAL;
2315     adapter = (\textcolor{keyword}{struct }adapter *)dev->\hyperlink{struct__device__t_ad517770dac2061381b2008850ff12e6c}{private\_data};
2316     if (adapter == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
2317         \textcolor{keywordflow}{return} -ENXIO;
2318 
2319     hw = &adapter->\hyperlink{structadapter_a7d5953861471302be6287c989e0b20ba}{hw};
2320 
2321     memcpy(mac\_addr, hw->\hyperlink{structe1000__hw_aab7fce7aa13ba97459b3b65acf02f520}{mac}.\hyperlink{structe1000__mac__info_afee13f7d77f1101ef9c6c76654220344}{addr}, \hyperlink{kmod_2igb_2e1000__defines_8h_a78fc3e3fe5c33412e9f47a214f6e0415}{ETH\_ADDR\_LEN});
2322     \textcolor{keywordflow}{return} 0;
2323 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=296pt]{igb_8c_a257a2d309437e1cf4b696915dda16871_icgraph}
\end{center}
\end{figure}


\index{igb.\+c@{igb.\+c}!igb\+\_\+get\+\_\+wallclock@{igb\+\_\+get\+\_\+wallclock}}
\index{igb\+\_\+get\+\_\+wallclock@{igb\+\_\+get\+\_\+wallclock}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{igb\+\_\+get\+\_\+wallclock(device\+\_\+t $\ast$dev, u\+\_\+int64\+\_\+t $\ast$curtime, u\+\_\+int64\+\_\+t $\ast$rdtsc)}{igb_get_wallclock(device_t *dev, u_int64_t *curtime, u_int64_t *rdtsc)}}]{\setlength{\rightskip}{0pt plus 5cm}int igb\+\_\+get\+\_\+wallclock (
\begin{DoxyParamCaption}
\item[{{\bf device\+\_\+t} $\ast$}]{dev, }
\item[{u\+\_\+int64\+\_\+t $\ast$}]{curtime, }
\item[{u\+\_\+int64\+\_\+t $\ast$}]{rdtsc}
\end{DoxyParamCaption}
)}\hypertarget{igb_8c_aa45f65b8e5ac2a1d1d1a7081c499a690}{}\label{igb_8c_aa45f65b8e5ac2a1d1d1a7081c499a690}


igb.\+c 파일의 1864 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
1865 \{
1866     u\_int64\_t t0 = 0, t1 = -1;
1867     u\_int32\_t duration = -1;
1868     u\_int32\_t timh, timl, tsauxc;
1869     \textcolor{keyword}{struct }\hyperlink{structadapter}{adapter} *\hyperlink{structadapter}{adapter};
1870     \textcolor{keyword}{struct }\hyperlink{structe1000__hw}{e1000\_hw} *hw;
1871     \textcolor{keywordtype}{int} error = 0;
1872     \textcolor{keywordtype}{int} iter = 0;
1873 
1874     \textcolor{keywordflow}{if} (dev == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
1875         \textcolor{keywordflow}{return} -EINVAL;
1876 
1877     adapter = (\textcolor{keyword}{struct }adapter *)dev->\hyperlink{struct__device__t_ad517770dac2061381b2008850ff12e6c}{private\_data};
1878     if (adapter == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
1879         \textcolor{keywordflow}{return} -ENXIO;
1880 
1881     hw = &adapter->\hyperlink{structadapter_a7d5953861471302be6287c989e0b20ba}{hw};
1882 
1883     \textcolor{keywordflow}{if} (\hyperlink{igb_8c_a791fd0757e3ca1833df21ee94c17b855}{igb\_lock}(dev) != 0)
1884         \textcolor{keywordflow}{return} errno;
1885 
1886     \textcolor{comment}{/* sample the timestamp bracketed by the RDTSC */}
1887     \textcolor{keywordflow}{for} (iter = 0; iter < \hyperlink{igb_8c_acd517c6f195c75b9dd0f3aad65326f3b}{MAX\_ITER} && t1 - t0 > \hyperlink{igb_8c_aa9d89e374be1585846f0890ab560f8d6}{MIN\_WALLCLOCK\_TSC\_WINDOW};
1888          ++iter) \{
1889         tsauxc = \hyperlink{kmod_2igb_2e1000__osdep_8h_a28390efdfdfb1e1cd1b033d021906a47}{E1000\_READ\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_a1ee0cd85a463ac527b53571e14cb5fa1}{E1000\_TSAUXC});
1890         tsauxc |= \hyperlink{kmod_2igb_2e1000__defines_8h_ab4093171e6ae6e4763fc8fabd493cd5f}{E1000\_TSAUXC\_SAMP\_AUTO};
1891 
1892         \textcolor{comment}{/* Invalidate AUXSTMPH/L0 */}
1893         \hyperlink{kmod_2igb_2e1000__osdep_8h_a28390efdfdfb1e1cd1b033d021906a47}{E1000\_READ\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_a6e4766997a20894097f07dc2e23fa21c}{E1000\_AUXSTMPH0});
1894         \hyperlink{igb_8c_aa7a036d8ae3af2ea70fb4cbdf1f25fbd}{rdtscpll}(&t0);
1895         \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_a1ee0cd85a463ac527b53571e14cb5fa1}{E1000\_TSAUXC}, tsauxc);
1896         \hyperlink{igb_8c_aa7a036d8ae3af2ea70fb4cbdf1f25fbd}{rdtscpll}(&t1);
1897 
1898         \textcolor{keywordflow}{if} (t1 - t0 < duration) \{
1899             duration = t1 - t0;
1900             timl = \hyperlink{kmod_2igb_2e1000__osdep_8h_a28390efdfdfb1e1cd1b033d021906a47}{E1000\_READ\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_aff5f56d97179c61e5b1d566cbf17f094}{E1000\_AUXSTMPL0});
1901             timh = \hyperlink{kmod_2igb_2e1000__osdep_8h_a28390efdfdfb1e1cd1b033d021906a47}{E1000\_READ\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_a6e4766997a20894097f07dc2e23fa21c}{E1000\_AUXSTMPH0});
1902 
1903             \textcolor{keywordflow}{if} (curtime)
1904                 *curtime = (u\_int64\_t)timh * 1000000000 +
1905                        (u\_int64\_t)timl;
1906             \textcolor{keywordflow}{if} (rdtsc)
1907                 \textcolor{comment}{/* average */}
1908                 *rdtsc = (t1 - t0) / 2 + t0;
1909         \}
1910     \}
1911 
1912     \textcolor{keywordflow}{if} (\hyperlink{igb_8c_a4072fbeaba958ad7c81990de452139da}{igb\_unlock}(dev) != 0) \{
1913         error = errno;
1914         \textcolor{keywordflow}{goto} \hyperlink{gst__avb__playbin_8c_a6ce68847c12434f60d1b2654a3dc3409}{err};
1915     \}
1916 
1917     \textcolor{comment}{/* Return the window size * -1 */}
1918     \textcolor{keywordflow}{return} -duration;
1919 
1920 \hyperlink{gst__avb__playbin_8c_a6ce68847c12434f60d1b2654a3dc3409}{err}:
1921     \textcolor{keywordflow}{return} error;
1922 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=273pt]{igb_8c_aa45f65b8e5ac2a1d1d1a7081c499a690_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=248pt]{igb_8c_aa45f65b8e5ac2a1d1d1a7081c499a690_icgraph}
\end{center}
\end{figure}


\index{igb.\+c@{igb.\+c}!igb\+\_\+gettime@{igb\+\_\+gettime}}
\index{igb\+\_\+gettime@{igb\+\_\+gettime}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{igb\+\_\+gettime(device\+\_\+t $\ast$dev, clockid\+\_\+t clk\+\_\+id, u\+\_\+int64\+\_\+t $\ast$curtime, struct timespec $\ast$system\+\_\+time)}{igb_gettime(device_t *dev, clockid_t clk_id, u_int64_t *curtime, struct timespec *system_time)}}]{\setlength{\rightskip}{0pt plus 5cm}int igb\+\_\+gettime (
\begin{DoxyParamCaption}
\item[{{\bf device\+\_\+t} $\ast$}]{dev, }
\item[{clockid\+\_\+t}]{clk\+\_\+id, }
\item[{u\+\_\+int64\+\_\+t $\ast$}]{curtime, }
\item[{struct timespec $\ast$}]{system\+\_\+time}
\end{DoxyParamCaption}
)}\hypertarget{igb_8c_a2ad1701694c890809c969274ec597931}{}\label{igb_8c_a2ad1701694c890809c969274ec597931}


igb.\+c 파일의 1955 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
1957 \{
1958     \textcolor{keyword}{struct }timespec t0 = \{ 0, 0 \}, t1 = \{ .tv\_sec = 4, .tv\_nsec = 0 \};
1959     u\_int32\_t timh, timl, tsauxc;
1960     u\_int32\_t duration = -1;
1961     \textcolor{keyword}{struct }\hyperlink{structadapter}{adapter} *\hyperlink{structadapter}{adapter};
1962     \textcolor{keyword}{struct }\hyperlink{structe1000__hw}{e1000\_hw} *hw;
1963     \textcolor{keywordtype}{int} error = 0;
1964     \textcolor{keywordtype}{int} iter = 0;
1965 
1966     \textcolor{keywordflow}{if} (dev == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
1967         \textcolor{keywordflow}{return} -EINVAL;
1968     adapter = (\textcolor{keyword}{struct }adapter *)dev->\hyperlink{struct__device__t_ad517770dac2061381b2008850ff12e6c}{private\_data};
1969     if (adapter == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
1970         \textcolor{keywordflow}{return} -ENXIO;
1971 
1972     hw = &adapter->\hyperlink{structadapter_a7d5953861471302be6287c989e0b20ba}{hw};
1973 
1974     \textcolor{keywordflow}{if} (\hyperlink{igb_8c_a791fd0757e3ca1833df21ee94c17b855}{igb\_lock}(dev) != 0)
1975         \textcolor{keywordflow}{return} errno;
1976 
1977     \textcolor{comment}{/* sample the timestamp bracketed by the clock\_gettime() */}
1978     \textcolor{keywordflow}{for} (iter = 0; iter < MAX\_ITER && duration > \hyperlink{igb_8c_a89ab2f32a0f28c0dd70cf0597008808a}{MIN\_SYSCLOCK\_WINDOW};
1979          ++iter) \{
1980         u\_int32\_t duration\_c;
1981 
1982         tsauxc = \hyperlink{kmod_2igb_2e1000__osdep_8h_a28390efdfdfb1e1cd1b033d021906a47}{E1000\_READ\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_a1ee0cd85a463ac527b53571e14cb5fa1}{E1000\_TSAUXC});
1983         tsauxc |= \hyperlink{kmod_2igb_2e1000__defines_8h_ab4093171e6ae6e4763fc8fabd493cd5f}{E1000\_TSAUXC\_SAMP\_AUTO};
1984 
1985         \textcolor{comment}{/* Invalidate AUXSTMPH/L0 */}
1986         \hyperlink{kmod_2igb_2e1000__osdep_8h_a28390efdfdfb1e1cd1b033d021906a47}{E1000\_READ\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_a6e4766997a20894097f07dc2e23fa21c}{E1000\_AUXSTMPH0});
1987         clock\_gettime(clk\_id, &t0);
1988         \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_a1ee0cd85a463ac527b53571e14cb5fa1}{E1000\_TSAUXC}, tsauxc);
1989         \hyperlink{igb_8c_aaf70944cc9bd58b4497abeb70c220890}{\_\_sync}();
1990         clock\_gettime(clk\_id, &t1);
1991 
1992         \hyperlink{igb_8c_ab85ff62741520edc013979580b140b56}{timespec\_subtract}(&t1, &t0);
1993         duration\_c = \hyperlink{igb_8c_a4b64a260ae06308aa59a1cc415b605fd}{TS2NS}(t1);
1994         \textcolor{keywordflow}{if} (duration\_c < duration) \{
1995             duration = duration\_c;
1996             timl = \hyperlink{kmod_2igb_2e1000__osdep_8h_a28390efdfdfb1e1cd1b033d021906a47}{E1000\_READ\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_aff5f56d97179c61e5b1d566cbf17f094}{E1000\_AUXSTMPL0});
1997             timh = \hyperlink{kmod_2igb_2e1000__osdep_8h_a28390efdfdfb1e1cd1b033d021906a47}{E1000\_READ\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_a6e4766997a20894097f07dc2e23fa21c}{E1000\_AUXSTMPH0});
1998 
1999             \textcolor{keywordflow}{if} (curtime)
2000                 *curtime = (u\_int64\_t)timh * 1000000000 +
2001                        (u\_int64\_t)timl;
2002             \textcolor{keywordflow}{if} (system\_time)
2003                 *system\_time =
2004                     \hyperlink{igb_8c_a83c184a21a1b1cceb3a3229e9f165245}{timespec\_addns}(&t0, duration/2);
2005         \}
2006     \}
2007 
2008     \textcolor{keywordflow}{if} (\hyperlink{igb_8c_a4072fbeaba958ad7c81990de452139da}{igb\_unlock}(dev) != 0) \{
2009         error = errno;
2010         \textcolor{keywordflow}{goto} \hyperlink{gst__avb__playbin_8c_a6ce68847c12434f60d1b2654a3dc3409}{err};
2011     \}
2012     \textcolor{comment}{/* Return the window size * -1 */}
2013     \textcolor{keywordflow}{return} -duration;
2014 
2015 \hyperlink{gst__avb__playbin_8c_a6ce68847c12434f60d1b2654a3dc3409}{err}:
2016     \textcolor{keywordflow}{return} error;
2017 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=280pt]{igb_8c_a2ad1701694c890809c969274ec597931_cgraph}
\end{center}
\end{figure}


\index{igb.\+c@{igb.\+c}!igb\+\_\+init@{igb\+\_\+init}}
\index{igb\+\_\+init@{igb\+\_\+init}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{igb\+\_\+init(device\+\_\+t $\ast$dev)}{igb_init(device_t *dev)}}]{\setlength{\rightskip}{0pt plus 5cm}int igb\+\_\+init (
\begin{DoxyParamCaption}
\item[{{\bf device\+\_\+t} $\ast$}]{dev}
\end{DoxyParamCaption}
)}\hypertarget{igb_8c_a923b0ffcf94a4a6ac8f36a7bacd6b0f3}{}\label{igb_8c_a923b0ffcf94a4a6ac8f36a7bacd6b0f3}


igb.\+c 파일의 508 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
509 \{
510     \textcolor{keyword}{struct }\hyperlink{structadapter}{adapter} *\hyperlink{structadapter}{adapter};
511 
512     \textcolor{keywordflow}{if} (dev == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
513         \textcolor{keywordflow}{return} -EINVAL;
514     adapter = (\textcolor{keyword}{struct }adapter *)dev->\hyperlink{struct__device__t_ad517770dac2061381b2008850ff12e6c}{private\_data};
515     if (adapter == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
516         \textcolor{keywordflow}{return} -ENXIO;
517 
518     \textcolor{keywordflow}{if} (\hyperlink{igb_8c_a791fd0757e3ca1833df21ee94c17b855}{igb\_lock}(dev) != 0)
519         \textcolor{keywordflow}{return} errno;
520 
521     \hyperlink{igb_8c_afa49e6907f7179625e2267faa054d250}{igb\_reset}(adapter);
522 
523     \textcolor{comment}{/* Prepare transmit descriptors and buffers */}
524     \textcolor{keywordflow}{if} (adapter->\hyperlink{structadapter_aec689462327aa3bf0e8a73e7cca2ae55}{tx\_rings}) \{
525         \hyperlink{igb_8c_ab90de8e2832d77cf89310e4e86f5bce3}{igb\_setup\_transmit\_structures}(adapter);
526         \hyperlink{igb_8c_afe8ec56d1a800f2a02b47a1744c43e4f}{igb\_initialize\_transmit\_units}(adapter);
527     \}
528 
529     \textcolor{keywordflow}{if} (adapter->\hyperlink{structadapter_a59a5588ccfe1b0eefe45fcb9188b2f0a}{rx\_rings}) \{
530         \hyperlink{igb_8c_a1d555819a110fd3491fc4d2f0a69c2ac}{igb\_setup\_receive\_structures}(adapter);
531         \hyperlink{igb_8c_a7e188d0bfc699ebde4636a227e012953}{igb\_initialize\_receive\_units}(adapter);
532     \}
533 
534     \textcolor{keywordflow}{if} (\hyperlink{igb_8c_a4072fbeaba958ad7c81990de452139da}{igb\_unlock}(dev) != 0)
535         \textcolor{keywordflow}{return} errno;
536 
537     \textcolor{keywordflow}{return} 0;
538 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{igb_8c_a923b0ffcf94a4a6ac8f36a7bacd6b0f3_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{igb_8c_a923b0ffcf94a4a6ac8f36a7bacd6b0f3_icgraph}
\end{center}
\end{figure}


\index{igb.\+c@{igb.\+c}!igb\+\_\+initialize\+\_\+receive\+\_\+units@{igb\+\_\+initialize\+\_\+receive\+\_\+units}}
\index{igb\+\_\+initialize\+\_\+receive\+\_\+units@{igb\+\_\+initialize\+\_\+receive\+\_\+units}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{igb\+\_\+initialize\+\_\+receive\+\_\+units(struct adapter $\ast$adapter)}{igb_initialize_receive_units(struct adapter *adapter)}}]{\setlength{\rightskip}{0pt plus 5cm}static void igb\+\_\+initialize\+\_\+receive\+\_\+units (
\begin{DoxyParamCaption}
\item[{struct {\bf adapter} $\ast$}]{adapter}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{igb_8c_a7e188d0bfc699ebde4636a227e012953}{}\label{igb_8c_a7e188d0bfc699ebde4636a227e012953}


igb.\+c 파일의 1488 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
1489 \{
1490     \textcolor{keyword}{struct }\hyperlink{structrx__ring}{rx\_ring} *rxr = adapter->\hyperlink{structadapter_a59a5588ccfe1b0eefe45fcb9188b2f0a}{rx\_rings};
1491     \textcolor{keyword}{struct }\hyperlink{structe1000__hw}{e1000\_hw} *hw = &adapter->\hyperlink{structadapter_a7d5953861471302be6287c989e0b20ba}{hw};
1492     \hyperlink{lib_2igb_2e1000__osdep_8h_a64e91c10a0d8fb627e92932050284264}{u32} rctl, rxcsum, srrctl = 0;
1493     \textcolor{keywordtype}{int} i;
1494 
1495     \textcolor{comment}{/*}
1496 \textcolor{comment}{     * Make sure receives are disabled while setting}
1497 \textcolor{comment}{     * up the descriptor ring}
1498 \textcolor{comment}{     */}
1499     rctl = \hyperlink{kmod_2igb_2e1000__osdep_8h_a28390efdfdfb1e1cd1b033d021906a47}{E1000\_READ\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_a5f1910b475d9e03e92a2500b9b15923d}{E1000\_RCTL});
1500     \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_a5f1910b475d9e03e92a2500b9b15923d}{E1000\_RCTL}, rctl & ~
      \hyperlink{kmod_2igb_2e1000__defines_8h_aa97177426e645aa60186848bf1e307f9}{E1000\_RCTL\_EN});
1501 
1502     rctl &= ~\hyperlink{kmod_2igb_2e1000__defines_8h_a971c5121d62f10f50fafb91ed135319d}{E1000\_RCTL\_LPE};
1503     srrctl |= 2048 >> \hyperlink{kmod_2igb_2e1000__82575_8h_a928a58e08843d4a88f81351ecd20611d}{E1000\_SRRCTL\_BSIZEPKT\_SHIFT};
1504     srrctl |= \hyperlink{kmod_2igb_2e1000__82575_8h_a562fda6f95cf9dd4250bfba7e26154e5}{E1000\_SRRCTL\_DESCTYPE\_ADV\_ONEBUF};
1505     rctl |= \hyperlink{kmod_2igb_2e1000__defines_8h_a31eed70768b347fc8f8168c8b9e50b4b}{E1000\_RCTL\_SZ\_2048};
1506 
1507     \textcolor{comment}{/* Setup the Base and Length of the Rx Descriptor Rings */}
1508     \textcolor{keywordflow}{for} (i = 0; i < adapter->\hyperlink{structadapter_a8befb466d4a5a6a432dc1648230e0a65}{num\_queues}; i++, rxr++) \{
1509         \hyperlink{lib_2igb_2e1000__osdep_8h_a1d8f78f95a414480659f3182e6067b80}{u64} bus\_addr = rxr->\hyperlink{structrx__ring_a7b5f7d41a39b44612fd251f290500ba5}{rxdma}.\hyperlink{structresource_ac1f7f4ff311d1bc193e88d7cd3230bc6}{paddr};
1510         \hyperlink{lib_2igb_2e1000__osdep_8h_a64e91c10a0d8fb627e92932050284264}{u32} rxdctl;
1511 
1512         \textcolor{comment}{/* Disable this Queue */}
1513         \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_a9563ac19965d3bd0892fd15f0c3a1dbd}{E1000\_RXDCTL}(i), 0);
1514 
1515         \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_a17f1bb8471b4b2b1fb0470923048d2d3}{E1000\_RDLEN}(i),
1516                 adapter->\hyperlink{structadapter_a7a36fc7297d99f6b73c4b6a194b33efd}{num\_rx\_desc} *
1517                     \textcolor{keyword}{sizeof}(\textcolor{keyword}{union} \hyperlink{unione1000__adv__rx__desc}{e1000\_adv\_rx\_desc}));
1518         \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_aaf1d5a8109540a3722cc498cca111a11}{E1000\_RDBAH}(i),
1519                 (\hyperlink{parse_8c_a6eb1e68cc391dd753bc8ce896dbb8315}{uint32\_t})(bus\_addr >> 32));
1520         \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_a9d831ba9f9151b22077f2a398ead76fd}{E1000\_RDBAL}(i),
1521                 (\hyperlink{parse_8c_a6eb1e68cc391dd753bc8ce896dbb8315}{uint32\_t})bus\_addr);
1522         \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_a80b27d5f09656b9586e29f25a9d35268}{E1000\_SRRCTL}(i), srrctl);
1523 
1524         \textcolor{comment}{/* Enable this Queue */}
1525         rxdctl = \hyperlink{kmod_2igb_2e1000__osdep_8h_a28390efdfdfb1e1cd1b033d021906a47}{E1000\_READ\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_a9563ac19965d3bd0892fd15f0c3a1dbd}{E1000\_RXDCTL}(i));
1526         rxdctl |= \hyperlink{kmod_2igb_2e1000__82575_8h_a9260450cfb7c0bcfb1efc9c6ee010d85}{E1000\_RXDCTL\_QUEUE\_ENABLE};
1527         rxdctl &= 0xFFF00000;
1528         rxdctl |= \hyperlink{kmod_2igb_2igb_8h_a68bff36ef813c1553435f46e214a8f9b}{IGB\_RX\_PTHRESH};
1529         rxdctl |= \hyperlink{kmod_2igb_2igb_8h_a6b7211566791a39b6add7fb096e4ceb7}{IGB\_RX\_HTHRESH} << 8;
1530         rxdctl |= \hyperlink{kmod_2igb_2igb_8h_a84c26037da9675309cc9a5c357bc29bc}{IGB\_RX\_WTHRESH} << 16;
1531         \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_a9563ac19965d3bd0892fd15f0c3a1dbd}{E1000\_RXDCTL}(i), rxdctl);
1532     \}
1533 
1534     \textcolor{comment}{/*}
1535 \textcolor{comment}{     * Setup for RX MultiQueue}
1536 \textcolor{comment}{     * Non RSS setup}
1537 \textcolor{comment}{     */}
1538     rxcsum = \hyperlink{kmod_2igb_2e1000__osdep_8h_a28390efdfdfb1e1cd1b033d021906a47}{E1000\_READ\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_a703c619569891b36de40dc0c4ff353f8}{E1000\_RXCSUM});
1539     rxcsum |= \hyperlink{kmod_2igb_2e1000__defines_8h_aa2f7561b70278a6f4f80ca0ac09674c4}{E1000\_RXCSUM\_IPPCSE};
1540     \textcolor{comment}{/*  rxcsum &= ~E1000\_RXCSUM\_TUOFL; */}
1541     \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_a703c619569891b36de40dc0c4ff353f8}{E1000\_RXCSUM}, rxcsum);
1542 
1543     \textcolor{comment}{/* Setup the Receive Control Register */}
1544     rctl &= ~(3 << \hyperlink{kmod_2igb_2e1000__defines_8h_a25c4c5d2afdae5c8c9e07c6738c34af4}{E1000\_RCTL\_MO\_SHIFT});
1545     rctl |= \hyperlink{kmod_2igb_2e1000__defines_8h_aa97177426e645aa60186848bf1e307f9}{E1000\_RCTL\_EN} | \hyperlink{kmod_2igb_2e1000__defines_8h_a17076adde5c827e417fdfe91b18e2a3a}{E1000\_RCTL\_BAM} | 
      \hyperlink{kmod_2igb_2e1000__defines_8h_a98cb2659d00c9eb58f1e74f67314eb02}{E1000\_RCTL\_LBM\_NO} |
1546         \hyperlink{kmod_2igb_2e1000__defines_8h_a239793aed9f1706663c437b3480be00c}{E1000\_RCTL\_RDMTS\_HALF};
1547     \textcolor{comment}{/* Strip CRC bytes. */}
1548     rctl |= \hyperlink{kmod_2igb_2e1000__defines_8h_abe9288b42d2b584db3f756725c1383e9}{E1000\_RCTL\_SECRC};
1549     \textcolor{comment}{/* Make sure VLAN Filters are off */}
1550     rctl &= ~\hyperlink{kmod_2igb_2e1000__defines_8h_ab7bd9a12bf6e072e3b6464f572b1a8a6}{E1000\_RCTL\_VFE};
1551     \textcolor{comment}{/* Don't store bad packets */}
1552     rctl &= ~\hyperlink{kmod_2igb_2e1000__defines_8h_a58fe79a2b6dad8db9fba18dd88eb37b5}{E1000\_RCTL\_SBP};
1553 
1554     \textcolor{comment}{/* Enable Receives */}
1555     \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_a5f1910b475d9e03e92a2500b9b15923d}{E1000\_RCTL}, rctl);
1556 
1557     \textcolor{comment}{/*}
1558 \textcolor{comment}{     * Setup the HW Rx Head and Tail Descriptor Pointers}
1559 \textcolor{comment}{     *   - needs to be after enable}
1560 \textcolor{comment}{     */}
1561     \textcolor{keywordflow}{for} (i = 0; i < adapter->\hyperlink{structadapter_a8befb466d4a5a6a432dc1648230e0a65}{num\_queues}; i++) \{
1562         rxr = &adapter->\hyperlink{structadapter_a59a5588ccfe1b0eefe45fcb9188b2f0a}{rx\_rings}[i];
1563         \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_aafeb8e2f7e7472fb876aa5306cebb1c1}{E1000\_RDH}(i), rxr->
      \hyperlink{structrx__ring_a3a6765383612ad483dfc252f8a16a87d}{next\_to\_check});
1564         \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_aaa0d18a293a9a7f4ed08cfde93918f8c}{E1000\_RDT}(i), rxr->
      \hyperlink{structrx__ring_aab3e5ae9f841cbc34fddab6abd9ed519}{next\_to\_refresh});
1565     \}
1566 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{igb_8c_a7e188d0bfc699ebde4636a227e012953_icgraph}
\end{center}
\end{figure}


\index{igb.\+c@{igb.\+c}!igb\+\_\+initialize\+\_\+transmit\+\_\+units@{igb\+\_\+initialize\+\_\+transmit\+\_\+units}}
\index{igb\+\_\+initialize\+\_\+transmit\+\_\+units@{igb\+\_\+initialize\+\_\+transmit\+\_\+units}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{igb\+\_\+initialize\+\_\+transmit\+\_\+units(struct adapter $\ast$adapter)}{igb_initialize_transmit_units(struct adapter *adapter)}}]{\setlength{\rightskip}{0pt plus 5cm}static void igb\+\_\+initialize\+\_\+transmit\+\_\+units (
\begin{DoxyParamCaption}
\item[{struct {\bf adapter} $\ast$}]{adapter}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{igb_8c_afe8ec56d1a800f2a02b47a1744c43e4f}{}\label{igb_8c_afe8ec56d1a800f2a02b47a1744c43e4f}


igb.\+c 파일의 875 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
876 \{
877     \textcolor{keyword}{struct }\hyperlink{structtx__ring}{tx\_ring} *txr = adapter->\hyperlink{structadapter_aec689462327aa3bf0e8a73e7cca2ae55}{tx\_rings};
878     \textcolor{keyword}{struct }\hyperlink{structe1000__hw}{e1000\_hw} *hw = &adapter->\hyperlink{structadapter_a7d5953861471302be6287c989e0b20ba}{hw};
879     \hyperlink{lib_2igb_2e1000__osdep_8h_a64e91c10a0d8fb627e92932050284264}{u32} txdctl;
880     \textcolor{keywordtype}{int} i;
881 
882     txdctl = 0;
883 
884     \textcolor{comment}{/* Setup the Tx Descriptor Rings */}
885     \textcolor{keywordflow}{for} (i = 0; i < adapter->\hyperlink{structadapter_a8befb466d4a5a6a432dc1648230e0a65}{num\_queues}; i++, txr++) \{
886         txdctl = 0;
887         \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_a8bf12553d73f6bac2b9a7845386357df}{E1000\_TXDCTL}(i), txdctl);
888 
889         \textcolor{comment}{/* Setup the HW Tx Head and Tail descriptor pointers */}
890         \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_a1f489d0247c236b2a8fe28141377f69c}{E1000\_TDT}(i), 0);
891         \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_a10c344281bdc006b96fd0a08b719e065}{E1000\_TDH}(i), 0);
892 
893         txr->\hyperlink{structtx__ring_ac2917164cdb60559cb6fb4367f48ca24}{queue\_status} = \hyperlink{igb__internal_8h_a9138123bbc894907c2c1bbea11e95c21}{IGB\_QUEUE\_IDLE};
894 
895         txdctl |= \hyperlink{kmod_2igb_2igb_8h_ae5f8a96fe2a307fc812058366eaae67e}{IGB\_TX\_PTHRESH};
896         txdctl |= \hyperlink{kmod_2igb_2igb_8h_ae6ac5557f89f50f4a26bb0ba541300bf}{IGB\_TX\_HTHRESH} << 8;
897         txdctl |= \hyperlink{igb__internal_8h_af2f5dce46d23dd6d692f9a5618bd5a51}{IGB\_TX\_WTHRESH} << 16;
898         txdctl |= \hyperlink{kmod_2igb_2e1000__82575_8h_ab4f9e73c71b951d5b59a16c782c11e7e}{E1000\_TXDCTL\_PRIORITY};
899         txdctl |= \hyperlink{kmod_2igb_2e1000__82575_8h_a8478cded14fe1defbc6dbbd1fa50897c}{E1000\_TXDCTL\_QUEUE\_ENABLE};
900         \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_a8bf12553d73f6bac2b9a7845386357df}{E1000\_TXDCTL}(i), txdctl);
901     \}
902 
903 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{igb_8c_afe8ec56d1a800f2a02b47a1744c43e4f_icgraph}
\end{center}
\end{figure}


\index{igb.\+c@{igb.\+c}!igb\+\_\+lock@{igb\+\_\+lock}}
\index{igb\+\_\+lock@{igb\+\_\+lock}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{igb\+\_\+lock(device\+\_\+t $\ast$dev)}{igb_lock(device_t *dev)}}]{\setlength{\rightskip}{0pt plus 5cm}int igb\+\_\+lock (
\begin{DoxyParamCaption}
\item[{{\bf device\+\_\+t} $\ast$}]{dev}
\end{DoxyParamCaption}
)}\hypertarget{igb_8c_a791fd0757e3ca1833df21ee94c17b855}{}\label{igb_8c_a791fd0757e3ca1833df21ee94c17b855}


igb.\+c 파일의 1151 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
1152 \{
1153     \textcolor{keyword}{struct }\hyperlink{structadapter}{adapter} *\hyperlink{structadapter}{adapter};
1154     \textcolor{keywordtype}{int} error = -1;
1155 
1156     \textcolor{keywordflow}{if} (dev == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
1157         \textcolor{keywordflow}{return} -ENODEV;
1158 
1159     adapter = (\textcolor{keyword}{struct }adapter *)dev->\hyperlink{struct__device__t_ad517770dac2061381b2008850ff12e6c}{private\_data};
1160     if (adapter == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
1161         \textcolor{keywordflow}{return} -ENXIO;
1162 
1163     \textcolor{keywordflow}{if} (adapter->\hyperlink{structadapter_aa5805c5e936174e5092bf7a5b78e7e64}{active} != 1) \textcolor{comment}{// detach in progress}
1164         \textcolor{keywordflow}{return} -ENXIO;
1165 
1166     \textcolor{keywordflow}{if} (!adapter->\hyperlink{structadapter_ac26455511b5639f92b1eadeae2f8e20e}{memlock})
1167         \textcolor{keywordflow}{return} -ENXIO;
1168 
1169     error = pthread\_mutex\_lock(adapter->\hyperlink{structadapter_ac26455511b5639f92b1eadeae2f8e20e}{memlock});
1170     \textcolor{keywordflow}{switch} (error) \{
1171         \textcolor{keywordflow}{case} 0:
1172             \textcolor{keywordflow}{break};
1173         \textcolor{keywordflow}{case} EOWNERDEAD:
1174             \textcolor{comment}{// some process terminated without unlocking the mutex}
1175             \textcolor{keywordflow}{if} (pthread\_mutex\_consistent(adapter->\hyperlink{structadapter_ac26455511b5639f92b1eadeae2f8e20e}{memlock}) != 0)
1176                 \textcolor{keywordflow}{return} -errno;
1177             \textcolor{keywordflow}{break};
1178         \textcolor{keywordflow}{default}:
1179             \textcolor{keywordflow}{return} -errno;
1180             \textcolor{keywordflow}{break};
1181     \}
1182 
1183     \textcolor{keywordflow}{if} (adapter->\hyperlink{structadapter_aa5805c5e936174e5092bf7a5b78e7e64}{active} != 1) \{
1184         (void) pthread\_mutex\_unlock(adapter->\hyperlink{structadapter_ac26455511b5639f92b1eadeae2f8e20e}{memlock});
1185         \textcolor{keywordflow}{return} -ENXIO;
1186     \}
1187 
1188     \textcolor{keywordflow}{return} 0;
1189 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=550pt]{igb_8c_a791fd0757e3ca1833df21ee94c17b855_icgraph}
\end{center}
\end{figure}


\index{igb.\+c@{igb.\+c}!igb\+\_\+probe@{igb\+\_\+probe}}
\index{igb\+\_\+probe@{igb\+\_\+probe}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{igb\+\_\+probe(device\+\_\+t $\ast$dev)}{igb_probe(device_t *dev)}}]{\setlength{\rightskip}{0pt plus 5cm}int igb\+\_\+probe (
\begin{DoxyParamCaption}
\item[{{\bf device\+\_\+t} $\ast$}]{dev}
\end{DoxyParamCaption}
)}\hypertarget{igb_8c_acd158f7434074c560d468d5acd878f06}{}\label{igb_8c_acd158f7434074c560d468d5acd878f06}


igb.\+c 파일의 107 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
108 \{
109     \hyperlink{struct__igb__vendor__info__t}{igb\_vendor\_info\_t} *ent;
110 
111     \textcolor{keywordflow}{if} (dev == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
112         \textcolor{keywordflow}{return} -EINVAL;
113 
114     \textcolor{keywordflow}{if} (dev->\hyperlink{struct__device__t_acf35ed7d091ed0ee4ff208efe53a64bf}{pci\_vendor\_id} != \hyperlink{igb__internal_8h_a3d5a955f05a7b442fbada47a4d6ed1b9}{IGB\_VENDOR\_ID})
115         \textcolor{keywordflow}{return} -ENXIO;
116 
117     ent = \hyperlink{igb_8c_a9519a91bae2a9829950d6c2b88a7cd26}{igb\_vendor\_info\_array};
118     \textcolor{keywordflow}{while} (ent->\hyperlink{struct__igb__vendor__info__t_a39273a5704a715a766f66c08e9b2437c}{vendor\_id} != 0) \{
119         \textcolor{keywordflow}{if} ((dev->\hyperlink{struct__device__t_acf35ed7d091ed0ee4ff208efe53a64bf}{pci\_vendor\_id} == ent->\hyperlink{struct__igb__vendor__info__t_a39273a5704a715a766f66c08e9b2437c}{vendor\_id}) &&
120             (dev->\hyperlink{struct__device__t_a779b4e4fce4f634938e41a308e6a7a19}{pci\_device\_id} == ent->\hyperlink{struct__igb__vendor__info__t_a2d805c7d6d45d66052531bff7b2aa1ab}{device\_id})) \{
121 
122             \textcolor{keywordflow}{return} 0;
123         \}
124         ent++;
125     \}
126 
127     \textcolor{keywordflow}{return} -ENXIO;
128 \}
\end{DoxyCode}
\index{igb.\+c@{igb.\+c}!igb\+\_\+read\+\_\+mac\+\_\+addr@{igb\+\_\+read\+\_\+mac\+\_\+addr}}
\index{igb\+\_\+read\+\_\+mac\+\_\+addr@{igb\+\_\+read\+\_\+mac\+\_\+addr}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{igb\+\_\+read\+\_\+mac\+\_\+addr(struct e1000\+\_\+hw $\ast$hw)}{igb_read_mac_addr(struct e1000_hw *hw)}}]{\setlength{\rightskip}{0pt plus 5cm}static int igb\+\_\+read\+\_\+mac\+\_\+addr (
\begin{DoxyParamCaption}
\item[{struct {\bf e1000\+\_\+hw} $\ast$}]{hw}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{igb_8c_aef7aae6f7e25f628d6313de3911827e5}{}\label{igb_8c_aef7aae6f7e25f628d6313de3911827e5}


igb.\+c 파일의 622 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
623 \{
624     \hyperlink{lib_2igb_2e1000__osdep_8h_a64e91c10a0d8fb627e92932050284264}{u32} rar\_high;
625     \hyperlink{lib_2igb_2e1000__osdep_8h_a64e91c10a0d8fb627e92932050284264}{u32} rar\_low;
626     \hyperlink{lib_2igb_2e1000__osdep_8h_acdc9cf0314be0ae5a01d6d4379a95edd}{u16} i;
627 
628     rar\_high = \hyperlink{kmod_2igb_2e1000__osdep_8h_a28390efdfdfb1e1cd1b033d021906a47}{E1000\_READ\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_a505199655b6c76ef205e6325561c69ea}{E1000\_RAH}(0));
629     rar\_low = \hyperlink{kmod_2igb_2e1000__osdep_8h_a28390efdfdfb1e1cd1b033d021906a47}{E1000\_READ\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_aef2f9cf55ba75ef025ea8e83d2019494}{E1000\_RAL}(0));
630 
631     \textcolor{keywordflow}{for} (i = 0; i < \hyperlink{kmod_2igb_2e1000__defines_8h_afb0a338c456e808198e313f492636f4c}{E1000\_RAL\_MAC\_ADDR\_LEN}; i++)
632         hw->\hyperlink{structe1000__hw_aab7fce7aa13ba97459b3b65acf02f520}{mac}.\hyperlink{structe1000__mac__info_a3d29a6a963467666bcb77c7e0b40fbf8}{perm\_addr}[i] = (\hyperlink{lib_2igb_2e1000__osdep_8h_a8baca7e76da9e0e11ce3a275dd19130c}{u8})(rar\_low >> (i*8));
633 
634     \textcolor{keywordflow}{for} (i = 0; i < \hyperlink{kmod_2igb_2e1000__defines_8h_abe498b9047282600f17029c7705caa9d}{E1000\_RAH\_MAC\_ADDR\_LEN}; i++)
635         hw->\hyperlink{structe1000__hw_aab7fce7aa13ba97459b3b65acf02f520}{mac}.\hyperlink{structe1000__mac__info_a3d29a6a963467666bcb77c7e0b40fbf8}{perm\_addr}[i+4] = (\hyperlink{lib_2igb_2e1000__osdep_8h_a8baca7e76da9e0e11ce3a275dd19130c}{u8})(rar\_high >> (i*8));
636 
637     \textcolor{keywordflow}{for} (i = 0; i < \hyperlink{kmod_2igb_2e1000__defines_8h_a78fc3e3fe5c33412e9f47a214f6e0415}{ETH\_ADDR\_LEN}; i++)
638         hw->\hyperlink{structe1000__hw_aab7fce7aa13ba97459b3b65acf02f520}{mac}.\hyperlink{structe1000__mac__info_afee13f7d77f1101ef9c6c76654220344}{addr}[i] = hw->\hyperlink{structe1000__hw_aab7fce7aa13ba97459b3b65acf02f520}{mac}.\hyperlink{structe1000__mac__info_a3d29a6a963467666bcb77c7e0b40fbf8}{perm\_addr}[i];
639 
640     \textcolor{keywordflow}{return} 0;
641 
642 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{igb_8c_aef7aae6f7e25f628d6313de3911827e5_icgraph}
\end{center}
\end{figure}


\index{igb.\+c@{igb.\+c}!igb\+\_\+readreg@{igb\+\_\+readreg}}
\index{igb\+\_\+readreg@{igb\+\_\+readreg}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{igb\+\_\+readreg(device\+\_\+t $\ast$dev, u\+\_\+int32\+\_\+t reg, u\+\_\+int32\+\_\+t $\ast$data)}{igb_readreg(device_t *dev, u_int32_t reg, u_int32_t *data)}}]{\setlength{\rightskip}{0pt plus 5cm}void igb\+\_\+readreg (
\begin{DoxyParamCaption}
\item[{{\bf device\+\_\+t} $\ast$}]{dev, }
\item[{u\+\_\+int32\+\_\+t}]{reg, }
\item[{u\+\_\+int32\+\_\+t $\ast$}]{data}
\end{DoxyParamCaption}
)}\hypertarget{igb_8c_aee4e5308f98a08ff4036b3a9b3ab7784}{}\label{igb_8c_aee4e5308f98a08ff4036b3a9b3ab7784}


igb.\+c 파일의 1134 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
1135 \{
1136     \textcolor{keyword}{struct }\hyperlink{structadapter}{adapter} *\hyperlink{structadapter}{adapter};
1137 
1138     \textcolor{keywordflow}{if} (dev == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
1139         \textcolor{keywordflow}{return};
1140 
1141     adapter = (\textcolor{keyword}{struct }adapter *)dev->\hyperlink{struct__device__t_ad517770dac2061381b2008850ff12e6c}{private\_data};
1142     if (adapter == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
1143         \textcolor{keywordflow}{return};
1144 
1145     \textcolor{keywordflow}{if} (data == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
1146         \textcolor{keywordflow}{return};
1147 
1148     *data = \hyperlink{kmod_2igb_2e1000__osdep_8h_a28390efdfdfb1e1cd1b033d021906a47}{E1000\_READ\_REG}(&(adapter->\hyperlink{structadapter_a7d5953861471302be6287c989e0b20ba}{hw}), reg);
1149 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{igb_8c_aee4e5308f98a08ff4036b3a9b3ab7784_icgraph}
\end{center}
\end{figure}


\index{igb.\+c@{igb.\+c}!igb\+\_\+receive@{igb\+\_\+receive}}
\index{igb\+\_\+receive@{igb\+\_\+receive}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{igb\+\_\+receive(device\+\_\+t $\ast$dev, unsigned int queue\+\_\+index, struct igb\+\_\+packet $\ast$$\ast$received\+\_\+packets, u\+\_\+int32\+\_\+t $\ast$count)}{igb_receive(device_t *dev, unsigned int queue_index, struct igb_packet **received_packets, u_int32_t *count)}}]{\setlength{\rightskip}{0pt plus 5cm}int igb\+\_\+receive (
\begin{DoxyParamCaption}
\item[{{\bf device\+\_\+t} $\ast$}]{dev, }
\item[{unsigned int}]{queue\+\_\+index, }
\item[{struct {\bf igb\+\_\+packet} $\ast$$\ast$}]{received\+\_\+packets, }
\item[{u\+\_\+int32\+\_\+t $\ast$}]{count}
\end{DoxyParamCaption}
)}\hypertarget{igb_8c_aa7d218e2a22d2aae6d98318b477526dd}{}\label{igb_8c_aa7d218e2a22d2aae6d98318b477526dd}


igb.\+c 파일의 1707 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
1709 \{
1710     \textcolor{keyword}{struct }\hyperlink{structadapter}{adapter} *\hyperlink{structadapter}{adapter};
1711     \textcolor{keyword}{struct }\hyperlink{structrx__ring}{rx\_ring} *rxr;
1712     \textcolor{keyword}{union }\hyperlink{unione1000__adv__rx__desc}{e1000\_adv\_rx\_desc} *cur;
1713     \textcolor{keywordtype}{bool} eop = \hyperlink{maap__log_8h_aa93f0eb578d23995850d61f7d61c55c1}{FALSE};
1714     u\_int32\_t staterr = 0;
1715     u\_int32\_t desc    = 0;
1716     u\_int32\_t max\_pkt = 0;
1717     \textcolor{keyword}{struct }\hyperlink{structigb__packet}{igb\_packet} *curr\_pkt = \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
1718     \textcolor{keyword}{struct }\hyperlink{structigb__packet}{igb\_packet} *prev\_pkt = \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
1719 
1720     \textcolor{keywordflow}{if} (dev == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
1721         \textcolor{keywordflow}{return} -EINVAL;
1722 
1723     adapter = (\textcolor{keyword}{struct }adapter *)dev->\hyperlink{struct__device__t_ad517770dac2061381b2008850ff12e6c}{private\_data};
1724     if (adapter == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
1725         \textcolor{keywordflow}{return} -ENXIO;
1726 
1727     \textcolor{keywordflow}{if} (adapter->\hyperlink{structadapter_aa5805c5e936174e5092bf7a5b78e7e64}{active} != 1) \textcolor{comment}{// detach in progress}
1728         \textcolor{keywordflow}{return} -ENXIO;
1729 
1730     \textcolor{keywordflow}{if} (queue\_index > adapter->\hyperlink{structadapter_a8befb466d4a5a6a432dc1648230e0a65}{num\_queues})
1731         \textcolor{keywordflow}{return} -EINVAL;
1732 
1733     rxr = &(adapter->\hyperlink{structadapter_a59a5588ccfe1b0eefe45fcb9188b2f0a}{rx\_rings}[queue\_index]);
1734     \textcolor{keywordflow}{if} (!rxr)
1735         \textcolor{keywordflow}{return} -EINVAL;
1736 
1737     \textcolor{keywordflow}{if} (count == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
1738         \textcolor{keywordflow}{return} -EINVAL;
1739 
1740     max\_pkt = *count;
1741     *count  = 0;
1742 
1743     \textcolor{keywordflow}{if} (received\_packets == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
1744         \textcolor{keywordflow}{return} -EINVAL;
1745 
1746     *received\_packets = \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}; \textcolor{comment}{/* nothing reclaimed yet */}
1747 
1748     \textcolor{keywordflow}{if} (sem\_trywait(&rxr->\hyperlink{structrx__ring_ac301e000199ad937f060277b0736d4e1}{lock}) != 0)
1749         \textcolor{keywordflow}{return} errno; \textcolor{comment}{/* EAGAIN */}
1750 
1751     \textcolor{keywordflow}{if} (adapter->\hyperlink{structadapter_aa5805c5e936174e5092bf7a5b78e7e64}{active} != 1) \{
1752         sem\_post(&rxr->\hyperlink{structrx__ring_ac301e000199ad937f060277b0736d4e1}{lock});
1753         \textcolor{keywordflow}{return} -ENXIO;
1754     \}
1755 
1756     \textcolor{comment}{/* Main clean loop - receive packets until no more}
1757 \textcolor{comment}{     * received\_packets[]}
1758 \textcolor{comment}{     */}
1759     \textcolor{keywordflow}{for} (desc = rxr->\hyperlink{structrx__ring_a3a6765383612ad483dfc252f8a16a87d}{next\_to\_check}; *count < max\_pkt;) \{
1760         cur = &(rxr->\hyperlink{structrx__ring_a40ec79b3b6a780e7f5c90dea8b3160bf}{rx\_base}[desc]);
1761 \textcolor{preprocessor}{#ifdef DEBUG}
1762         \textcolor{keywordflow}{if} (i%2)
1763             printf(\textcolor{stringliteral}{"\(\backslash\)033[2A"});
1764 
1765         printf(\textcolor{stringliteral}{"desc.status\_error=%x desc.length=%x desc.vlan=%x desc.rss=%x desc.pkt\_info=%x
       desc.hdr\_info=%x\(\backslash\)n"},
1766                 cur->\hyperlink{unione1000__adv__rx__desc_ae205a722536b37bd9f0eedd0e08869cf}{wb}.\hyperlink{unione1000__adv__rx__desc_a5684937edd4489f4f26f63d2d1976f5e}{upper}.status\_error,
1767                 cur->\hyperlink{unione1000__adv__rx__desc_ae205a722536b37bd9f0eedd0e08869cf}{wb}.\hyperlink{unione1000__adv__rx__desc_a5684937edd4489f4f26f63d2d1976f5e}{upper}.length,
1768                 cur->\hyperlink{unione1000__adv__rx__desc_ae205a722536b37bd9f0eedd0e08869cf}{wb}.\hyperlink{unione1000__adv__rx__desc_a5684937edd4489f4f26f63d2d1976f5e}{upper}.vlan,
1769                 cur->\hyperlink{unione1000__adv__rx__desc_ae205a722536b37bd9f0eedd0e08869cf}{wb}.\hyperlink{unione1000__adv__rx__desc_aa2f13e7f6127e8f784f2ac021f73a6d1}{lower}.hi\_dword.rss,
1770                 cur->\hyperlink{unione1000__adv__rx__desc_ae205a722536b37bd9f0eedd0e08869cf}{wb}.\hyperlink{unione1000__adv__rx__desc_aa2f13e7f6127e8f784f2ac021f73a6d1}{lower}.lo\_dword.hs\_rss.pkt\_info,
1771                 cur->\hyperlink{unione1000__adv__rx__desc_ae205a722536b37bd9f0eedd0e08869cf}{wb}.\hyperlink{unione1000__adv__rx__desc_aa2f13e7f6127e8f784f2ac021f73a6d1}{lower}.lo\_dword.hs\_rss.hdr\_info);
1772 \textcolor{preprocessor}{#endif}
1773         staterr = le32toh(cur->\hyperlink{unione1000__adv__rx__desc_ae205a722536b37bd9f0eedd0e08869cf}{wb}.\hyperlink{unione1000__adv__rx__desc_a5684937edd4489f4f26f63d2d1976f5e}{upper}.status\_error);
1774         \textcolor{keywordflow}{if} ((staterr & \hyperlink{kmod_2igb_2e1000__defines_8h_a649e0efd4109f144991ab4f2983b520d}{E1000\_RXD\_STAT\_DD}) == 0)
1775             \textcolor{keywordflow}{break};
1776 
1777         cur->\hyperlink{unione1000__adv__rx__desc_ae205a722536b37bd9f0eedd0e08869cf}{wb}.\hyperlink{unione1000__adv__rx__desc_a5684937edd4489f4f26f63d2d1976f5e}{upper}.status\_error = 0;
1778 
1779         eop = ((staterr & \hyperlink{kmod_2igb_2e1000__defines_8h_ab383d985677c59b94439eb1a431c4c38}{E1000\_RXD\_STAT\_EOP}) ==
1780                 \hyperlink{kmod_2igb_2e1000__defines_8h_ab383d985677c59b94439eb1a431c4c38}{E1000\_RXD\_STAT\_EOP});
1781 
1782         \textcolor{keywordflow}{if} (eop) \{
1783             \textcolor{comment}{/*}
1784 \textcolor{comment}{             * Free the frame (all segments) if we're at EOP and}
1785 \textcolor{comment}{             * it's an error.}
1786 \textcolor{comment}{             *}
1787 \textcolor{comment}{             * The datasheet states that EOP + status is only valid}
1788 \textcolor{comment}{             * for the final segment in a multi-segment frame.}
1789 \textcolor{comment}{             */}
1790             \textcolor{keywordflow}{if} (staterr & \hyperlink{kmod_2igb_2e1000__defines_8h_a6406f41e45cd1399de8bb7acb1c87031}{E1000\_RXDEXT\_ERR\_FRAME\_ERR\_MASK}) \{
1791                 ++rxr->\hyperlink{structrx__ring_a8e02d86f1d47bd0e3c5b45ffb9ba9d79}{rx\_discarded};
1792                 printf (\textcolor{stringliteral}{"discard error packet\(\backslash\)n"});
1793                 \hyperlink{igb_8c_ad8f45b19c3bd6aca50b6b6b599e3a3b5}{igb\_refresh\_buffers}(dev, queue\_index,
1794                         &rxr->\hyperlink{structrx__ring_abe41cfe713ffac28a8f678c51082df25}{rx\_buffers}[desc].\hyperlink{structigb__rx__buffer_ac6186670bb595d9f22c89b6dc2779d14}{packet}, 1);
1795             \} \textcolor{keywordflow}{else} \{
1796                 \textcolor{comment}{/*}
1797 \textcolor{comment}{                 * add new packet to list of received packets}
1798 \textcolor{comment}{                 * to return}
1799 \textcolor{comment}{                 */}
1800                 curr\_pkt = rxr->\hyperlink{structrx__ring_abe41cfe713ffac28a8f678c51082df25}{rx\_buffers}[desc].\hyperlink{structigb__rx__buffer_ac6186670bb595d9f22c89b6dc2779d14}{packet};
1801                 curr\_pkt->\hyperlink{structigb__packet_a0c5f469bd681fb46e6f4203d5338e99f}{len} = cur->\hyperlink{unione1000__adv__rx__desc_ae205a722536b37bd9f0eedd0e08869cf}{wb}.\hyperlink{unione1000__adv__rx__desc_a5684937edd4489f4f26f63d2d1976f5e}{upper}.length;
1802 
1803                 \textcolor{keywordflow}{if} (*received\_packets == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
1804                     *received\_packets = curr\_pkt;
1805                 \textcolor{keywordflow}{if} (prev\_pkt)
1806                     prev\_pkt->\hyperlink{structigb__packet_a1a20432d28f575630a2562c1c728a40f}{next} = curr\_pkt;
1807                 prev\_pkt = curr\_pkt;
1808                 (*count)++;
1809 
1810                 ++rxr->\hyperlink{structrx__ring_aa3bebfb174ded875865a321225aa30ac}{rx\_packets};
1811             \}
1812         \} \textcolor{keywordflow}{else} \{
1813             \textcolor{comment}{/* multi-segment frame is not supported yet */}
1814             ++rxr->\hyperlink{structrx__ring_a8e02d86f1d47bd0e3c5b45ffb9ba9d79}{rx\_discarded};
1815             printf (\textcolor{stringliteral}{"discard non-eop packet\(\backslash\)n"});
1816             \hyperlink{igb_8c_ad8f45b19c3bd6aca50b6b6b599e3a3b5}{igb\_refresh\_buffers}(dev, queue\_index,
1817                     &rxr->\hyperlink{structrx__ring_abe41cfe713ffac28a8f678c51082df25}{rx\_buffers}[desc].\hyperlink{structigb__rx__buffer_ac6186670bb595d9f22c89b6dc2779d14}{packet}, 1);
1818         \}
1819 next\_desc:
1820         \textcolor{comment}{/* Advance our pointers to the next descriptor. */}
1821         \textcolor{keywordflow}{if} (++desc == adapter->\hyperlink{structadapter_a7a36fc7297d99f6b73c4b6a194b33efd}{num\_rx\_desc})
1822             desc = 0;
1823     \}
1824 
1825     rxr->\hyperlink{structrx__ring_a3a6765383612ad483dfc252f8a16a87d}{next\_to\_check} = desc;
1826 
1827     \textcolor{keywordflow}{if} (sem\_post(&rxr->\hyperlink{structrx__ring_ac301e000199ad937f060277b0736d4e1}{lock}) != 0)
1828         \textcolor{keywordflow}{return} errno;
1829 
1830     \textcolor{keywordflow}{if} (*received\_packets == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}) \{
1831         \textcolor{comment}{/* nothing reclaimed yet */}
1832         errno = EAGAIN;
1833         \textcolor{keywordflow}{return} errno;
1834     \}
1835 
1836     \textcolor{keywordflow}{return} 0;
1837 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=282pt]{igb_8c_aa7d218e2a22d2aae6d98318b477526dd_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=339pt]{igb_8c_aa7d218e2a22d2aae6d98318b477526dd_icgraph}
\end{center}
\end{figure}


\index{igb.\+c@{igb.\+c}!igb\+\_\+refresh\+\_\+buffers@{igb\+\_\+refresh\+\_\+buffers}}
\index{igb\+\_\+refresh\+\_\+buffers@{igb\+\_\+refresh\+\_\+buffers}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{igb\+\_\+refresh\+\_\+buffers(device\+\_\+t $\ast$dev, u\+\_\+int32\+\_\+t idx, struct igb\+\_\+packet $\ast$$\ast$rxbuf\+\_\+packets, u\+\_\+int32\+\_\+t num\+\_\+bufs)}{igb_refresh_buffers(device_t *dev, u_int32_t idx, struct igb_packet **rxbuf_packets, u_int32_t num_bufs)}}]{\setlength{\rightskip}{0pt plus 5cm}int igb\+\_\+refresh\+\_\+buffers (
\begin{DoxyParamCaption}
\item[{{\bf device\+\_\+t} $\ast$}]{dev, }
\item[{u\+\_\+int32\+\_\+t}]{idx, }
\item[{struct {\bf igb\+\_\+packet} $\ast$$\ast$}]{rxbuf\+\_\+packets, }
\item[{u\+\_\+int32\+\_\+t}]{num\+\_\+bufs}
\end{DoxyParamCaption}
)}\hypertarget{igb_8c_ad8f45b19c3bd6aca50b6b6b599e3a3b5}{}\label{igb_8c_ad8f45b19c3bd6aca50b6b6b599e3a3b5}


igb.\+c 파일의 1623 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
1625 \{
1626     \textcolor{keyword}{struct }\hyperlink{structigb__packet}{igb\_packet} *cur\_pkt;
1627     \textcolor{keyword}{struct }\hyperlink{structadapter}{adapter} *\hyperlink{structadapter}{adapter};
1628     \textcolor{keyword}{struct }\hyperlink{structrx__ring}{rx\_ring} *rxr;
1629     u\_int32\_t i, j, bufs\_used;
1630     \textcolor{keywordtype}{bool} refreshed = \hyperlink{maap__log_8h_aa93f0eb578d23995850d61f7d61c55c1}{FALSE};
1631 
1632     \textcolor{keywordflow}{if} (dev == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
1633         \textcolor{keywordflow}{return} -EINVAL;
1634 
1635     adapter = (\textcolor{keyword}{struct }adapter *)dev->\hyperlink{struct__device__t_ad517770dac2061381b2008850ff12e6c}{private\_data};
1636     if (adapter == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
1637         \textcolor{keywordflow}{return} -EINVAL;
1638 
1639     \textcolor{keywordflow}{if} (adapter->\hyperlink{structadapter_aa5805c5e936174e5092bf7a5b78e7e64}{active} != 1) \textcolor{comment}{// detach in progress}
1640         \textcolor{keywordflow}{return} -ENXIO;
1641 
1642     \textcolor{keywordflow}{if} (rxbuf\_packets == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
1643         \textcolor{keywordflow}{return} -EINVAL;
1644 
1645     \textcolor{keywordflow}{if} (idx > 1)
1646         \textcolor{keywordflow}{return} -EINVAL;
1647 
1648     rxr = &adapter->\hyperlink{structadapter_a59a5588ccfe1b0eefe45fcb9188b2f0a}{rx\_rings}[idx];
1649     \textcolor{keywordflow}{if} (rxr == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
1650         \textcolor{keywordflow}{return} -EINVAL;
1651 
1652     \textcolor{keywordflow}{if} (sem\_trywait(&rxr->\hyperlink{structrx__ring_ac301e000199ad937f060277b0736d4e1}{lock}) != 0)
1653         \textcolor{keywordflow}{return} errno; \textcolor{comment}{/* EAGAIN */}
1654 
1655     \textcolor{keywordflow}{if} (adapter->\hyperlink{structadapter_aa5805c5e936174e5092bf7a5b78e7e64}{active} != 1) \{
1656         sem\_post(&rxr->\hyperlink{structrx__ring_ac301e000199ad937f060277b0736d4e1}{lock});
1657         \textcolor{keywordflow}{return} -ENXIO;
1658     \}
1659 
1660     i = j = rxr->\hyperlink{structrx__ring_aab3e5ae9f841cbc34fddab6abd9ed519}{next\_to\_refresh};
1661     cur\_pkt = *rxbuf\_packets;
1662 
1663     \textcolor{comment}{/*}
1664 \textcolor{comment}{     * Get one descriptor beyond}
1665 \textcolor{comment}{     * our work mark to control}
1666 \textcolor{comment}{     * the loop.}
1667 \textcolor{comment}{     */}
1668     \textcolor{keywordflow}{if} (++j == adapter->\hyperlink{structadapter_a7a36fc7297d99f6b73c4b6a194b33efd}{num\_rx\_desc})
1669         j = 0;
1670 
1671     bufs\_used = 0;
1672 
1673     \textcolor{keywordflow}{while} (bufs\_used < num\_bufs) \{
1674         \textcolor{keywordflow}{if} (!cur\_pkt)
1675             \textcolor{keywordflow}{break};
1676         rxr->\hyperlink{structrx__ring_a40ec79b3b6a780e7f5c90dea8b3160bf}{rx\_base}[i].\hyperlink{unione1000__adv__rx__desc_a749e71ccb083af11bad0fec38094928e}{read}.\hyperlink{unione1000__adv__rx__desc_ac260c56b31b07a2c96981d6612f1a4c2}{pkt\_addr} =
1677             htole64(cur\_pkt->\hyperlink{structigb__packet_a1134ed5d4a74917c76b796e82cd4206f}{map}.\hyperlink{structresource_ac1f7f4ff311d1bc193e88d7cd3230bc6}{paddr} + cur\_pkt->\hyperlink{structigb__packet_a29b5297d3393519050e3126c4cb07c1c}{offset});
1678         rxr->\hyperlink{structrx__ring_abe41cfe713ffac28a8f678c51082df25}{rx\_buffers}[i].\hyperlink{structigb__rx__buffer_ac6186670bb595d9f22c89b6dc2779d14}{packet} = cur\_pkt;
1679 
1680         refreshed = \hyperlink{maap__log_8h_aa8cecfc5c5c054d2875c03e77b7be15d}{TRUE}; \textcolor{comment}{/* I feel wefreshed :) */}
1681 
1682         i = j; \textcolor{comment}{/* our next is precalculated */}
1683         rxr->\hyperlink{structrx__ring_aab3e5ae9f841cbc34fddab6abd9ed519}{next\_to\_refresh} = i;
1684         \textcolor{keywordflow}{if} (++j == adapter->\hyperlink{structadapter_a7a36fc7297d99f6b73c4b6a194b33efd}{num\_rx\_desc})
1685             j = 0;
1686         bufs\_used++;
1687         cur\_pkt = cur\_pkt->\hyperlink{structigb__packet_a1a20432d28f575630a2562c1c728a40f}{next};
1688     \}
1689 
1690     \textcolor{keywordflow}{if} (refreshed) \textcolor{comment}{/* update tail */}
1691         \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(&adapter->\hyperlink{structadapter_a7d5953861471302be6287c989e0b20ba}{hw},
1692                 \hyperlink{kmod_2igb_2e1000__regs_8h_aaa0d18a293a9a7f4ed08cfde93918f8c}{E1000\_RDT}(rxr->\hyperlink{structrx__ring_af754e6af13b532f2bebcaa3828ea795c}{me}), rxr->\hyperlink{structrx__ring_aab3e5ae9f841cbc34fddab6abd9ed519}{next\_to\_refresh});
1693 
1694     \textcolor{keywordflow}{if} (sem\_post(&rxr->\hyperlink{structrx__ring_ac301e000199ad937f060277b0736d4e1}{lock}) != 0)
1695         \textcolor{keywordflow}{return} errno;
1696 
1697     \textcolor{keywordflow}{return} 0;
1698 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{igb_8c_ad8f45b19c3bd6aca50b6b6b599e3a3b5_icgraph}
\end{center}
\end{figure}


\index{igb.\+c@{igb.\+c}!igb\+\_\+reset@{igb\+\_\+reset}}
\index{igb\+\_\+reset@{igb\+\_\+reset}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{igb\+\_\+reset(struct adapter $\ast$adapter)}{igb_reset(struct adapter *adapter)}}]{\setlength{\rightskip}{0pt plus 5cm}static void igb\+\_\+reset (
\begin{DoxyParamCaption}
\item[{struct {\bf adapter} $\ast$}]{adapter}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{igb_8c_afa49e6907f7179625e2267faa054d250}{}\label{igb_8c_afa49e6907f7179625e2267faa054d250}


igb.\+c 파일의 541 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
542 \{
543     \textcolor{keyword}{struct }\hyperlink{structtx__ring}{tx\_ring} *txr = adapter->\hyperlink{structadapter_aec689462327aa3bf0e8a73e7cca2ae55}{tx\_rings};
544     \textcolor{keyword}{struct }\hyperlink{structrx__ring}{rx\_ring} *rxr = adapter->\hyperlink{structadapter_a59a5588ccfe1b0eefe45fcb9188b2f0a}{rx\_rings};
545     \textcolor{keyword}{struct }\hyperlink{structe1000__hw}{e1000\_hw} *hw = &adapter->\hyperlink{structadapter_a7d5953861471302be6287c989e0b20ba}{hw};
546     \hyperlink{lib_2igb_2e1000__osdep_8h_a64e91c10a0d8fb627e92932050284264}{u32} txdctl, srrctl;
547     \textcolor{keywordtype}{int} i;
548 
549     srrctl = 0;
550     txdctl = 0;
551 
552     \textcolor{comment}{/* Set up the Tx Descriptor Rings, leave queues idle */}
553     \textcolor{keywordflow}{if} (adapter->\hyperlink{structadapter_aec689462327aa3bf0e8a73e7cca2ae55}{tx\_rings} == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}) \{
554 \textcolor{preprocessor}{#if DEBUG}
555         printf(\textcolor{stringliteral}{"txr null\(\backslash\)n"});
556 \textcolor{preprocessor}{#endif}
557     \} \textcolor{keywordflow}{else} \{
558         \textcolor{keywordflow}{for} (i = 0; i < adapter->\hyperlink{structadapter_a8befb466d4a5a6a432dc1648230e0a65}{num\_queues}; i++, txr++) \{
559             \hyperlink{lib_2igb_2e1000__osdep_8h_a1d8f78f95a414480659f3182e6067b80}{u64} bus\_addr = txr->\hyperlink{structtx__ring_aefdccf596fff8b81ada9dd89b75697a8}{txdma}.\hyperlink{structresource_ac1f7f4ff311d1bc193e88d7cd3230bc6}{paddr};
560 
561             \textcolor{comment}{/* idle the queue */}
562             txdctl |= \hyperlink{kmod_2igb_2igb_8h_ae5f8a96fe2a307fc812058366eaae67e}{IGB\_TX\_PTHRESH};
563             txdctl |= \hyperlink{kmod_2igb_2igb_8h_ae6ac5557f89f50f4a26bb0ba541300bf}{IGB\_TX\_HTHRESH} << 8;
564             txdctl |= \hyperlink{igb__internal_8h_af2f5dce46d23dd6d692f9a5618bd5a51}{IGB\_TX\_WTHRESH} << 16;
565             \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_a8bf12553d73f6bac2b9a7845386357df}{E1000\_TXDCTL}(i), txdctl);
566 
567             \textcolor{comment}{/* reset the descriptor head/tail */}
568             \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_ac389d5cfd9faa639c6e4858f0ad86ffc}{E1000\_TDLEN}(i),
569                     adapter->\hyperlink{structadapter_ab0bd5866ff13aa7c17436220693a3d2d}{num\_tx\_desc} *
570                     \textcolor{keyword}{sizeof}(\textcolor{keyword}{struct} \hyperlink{structe1000__tx__desc}{e1000\_tx\_desc}));
571             \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_a926320794ef17704f3348c33ef861400}{E1000\_TDBAH}(i),
572                     (u\_int32\_t)(bus\_addr >> 32));
573             \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_a0becbafa5ce5226e7013b46ab501822a}{E1000\_TDBAL}(i),
574                     (u\_int32\_t)bus\_addr);
575 
576             \textcolor{comment}{/* Setup the HW Tx Head and Tail descriptor pointers */}
577             \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_a1f489d0247c236b2a8fe28141377f69c}{E1000\_TDT}(i), 0);
578             \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_a10c344281bdc006b96fd0a08b719e065}{E1000\_TDH}(i), 0);
579 
580             txr->\hyperlink{structtx__ring_ac2917164cdb60559cb6fb4367f48ca24}{queue\_status} = \hyperlink{igb__internal_8h_a9138123bbc894907c2c1bbea11e95c21}{IGB\_QUEUE\_IDLE};
581         \}
582     \}
583 
584     srrctl |= 2048 >> \hyperlink{kmod_2igb_2e1000__82575_8h_a928a58e08843d4a88f81351ecd20611d}{E1000\_SRRCTL\_BSIZEPKT\_SHIFT};
585     srrctl |= \hyperlink{kmod_2igb_2e1000__82575_8h_a562fda6f95cf9dd4250bfba7e26154e5}{E1000\_SRRCTL\_DESCTYPE\_ADV\_ONEBUF};
586 
587     \textcolor{comment}{/* Setup the Base and Length of the Rx Descriptor Rings */}
588     \textcolor{keywordflow}{if} (adapter->\hyperlink{structadapter_a59a5588ccfe1b0eefe45fcb9188b2f0a}{rx\_rings} == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}) \{
589 \textcolor{preprocessor}{#if DEBUG}
590         printf(\textcolor{stringliteral}{"rxr null\(\backslash\)n"});
591 \textcolor{preprocessor}{#endif}
592     \} \textcolor{keywordflow}{else} \{
593 
594         \textcolor{keywordflow}{for} (i = 0; i < adapter->\hyperlink{structadapter_a8befb466d4a5a6a432dc1648230e0a65}{num\_queues}; i++, rxr++) \{
595             \hyperlink{lib_2igb_2e1000__osdep_8h_a1d8f78f95a414480659f3182e6067b80}{u64} bus\_addr = rxr->\hyperlink{structrx__ring_a7b5f7d41a39b44612fd251f290500ba5}{rxdma}.\hyperlink{structresource_ac1f7f4ff311d1bc193e88d7cd3230bc6}{paddr};
596             \hyperlink{lib_2igb_2e1000__osdep_8h_a64e91c10a0d8fb627e92932050284264}{u32} rxdctl;
597 
598             \textcolor{comment}{/* Disable this Queue */}
599             \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_a9563ac19965d3bd0892fd15f0c3a1dbd}{E1000\_RXDCTL}(i), 0);
600 
601             \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_a17f1bb8471b4b2b1fb0470923048d2d3}{E1000\_RDLEN}(i),
602                     adapter->\hyperlink{structadapter_a7a36fc7297d99f6b73c4b6a194b33efd}{num\_rx\_desc} *
603                     \textcolor{keyword}{sizeof}(\textcolor{keyword}{union} \hyperlink{unione1000__adv__rx__desc}{e1000\_adv\_rx\_desc}));
604             \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_aaf1d5a8109540a3722cc498cca111a11}{E1000\_RDBAH}(i),
605                     (\hyperlink{parse_8c_a6eb1e68cc391dd753bc8ce896dbb8315}{uint32\_t})(bus\_addr >> 32));
606             \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_a9d831ba9f9151b22077f2a398ead76fd}{E1000\_RDBAL}(i),
607                     (\hyperlink{parse_8c_a6eb1e68cc391dd753bc8ce896dbb8315}{uint32\_t})bus\_addr);
608             \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_a80b27d5f09656b9586e29f25a9d35268}{E1000\_SRRCTL}(i), srrctl);
609 
610             \textcolor{comment}{/* Enable this Queue */}
611             rxdctl = \hyperlink{kmod_2igb_2e1000__osdep_8h_a28390efdfdfb1e1cd1b033d021906a47}{E1000\_READ\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_a9563ac19965d3bd0892fd15f0c3a1dbd}{E1000\_RXDCTL}(i));
612             rxdctl |= \hyperlink{kmod_2igb_2e1000__82575_8h_a9260450cfb7c0bcfb1efc9c6ee010d85}{E1000\_RXDCTL\_QUEUE\_ENABLE};
613             rxdctl &= 0xFFF00000;
614             rxdctl |= \hyperlink{kmod_2igb_2igb_8h_a68bff36ef813c1553435f46e214a8f9b}{IGB\_RX\_PTHRESH};
615             rxdctl |= \hyperlink{kmod_2igb_2igb_8h_a6b7211566791a39b6add7fb096e4ceb7}{IGB\_RX\_HTHRESH} << 8;
616             rxdctl |= \hyperlink{kmod_2igb_2igb_8h_a84c26037da9675309cc9a5c357bc29bc}{IGB\_RX\_WTHRESH} << 16;
617             \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_a9563ac19965d3bd0892fd15f0c3a1dbd}{E1000\_RXDCTL}(i), rxdctl);
618         \}
619     \}
620 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{igb_8c_afa49e6907f7179625e2267faa054d250_icgraph}
\end{center}
\end{figure}


\index{igb.\+c@{igb.\+c}!igb\+\_\+resume@{igb\+\_\+resume}}
\index{igb\+\_\+resume@{igb\+\_\+resume}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{igb\+\_\+resume(device\+\_\+t $\ast$dev)}{igb_resume(device_t *dev)}}]{\setlength{\rightskip}{0pt plus 5cm}int igb\+\_\+resume (
\begin{DoxyParamCaption}
\item[{{\bf device\+\_\+t} $\ast$}]{dev}
\end{DoxyParamCaption}
)}\hypertarget{igb_8c_a8c75a4c23961007c7acd70607a34537f}{}\label{igb_8c_a8c75a4c23961007c7acd70607a34537f}


igb.\+c 파일의 441 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
442 \{
443     \textcolor{keyword}{struct }\hyperlink{structadapter}{adapter} *\hyperlink{structadapter}{adapter};
444     \textcolor{keyword}{struct }\hyperlink{structtx__ring}{tx\_ring} *txr;
445     \textcolor{keyword}{struct }\hyperlink{structrx__ring}{rx\_ring} *rxr;
446     \textcolor{keyword}{struct }\hyperlink{structe1000__hw}{e1000\_hw} *hw;
447     \hyperlink{lib_2igb_2e1000__osdep_8h_a64e91c10a0d8fb627e92932050284264}{u32} txdctl, srrctl = 0;
448     \textcolor{keywordtype}{int} i;
449 
450     \textcolor{keywordflow}{if} (dev == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
451         \textcolor{keywordflow}{return} -EINVAL;
452     adapter = (\textcolor{keyword}{struct }adapter *)dev->\hyperlink{struct__device__t_ad517770dac2061381b2008850ff12e6c}{private\_data};
453     if (adapter == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
454         \textcolor{keywordflow}{return} -ENXIO;
455 
456     txr = adapter->\hyperlink{structadapter_aec689462327aa3bf0e8a73e7cca2ae55}{tx\_rings};
457     rxr = adapter->\hyperlink{structadapter_a59a5588ccfe1b0eefe45fcb9188b2f0a}{rx\_rings};
458     hw = &adapter->\hyperlink{structadapter_a7d5953861471302be6287c989e0b20ba}{hw};
459 
460     txdctl = 0;
461 
462     \textcolor{keywordflow}{if} (\hyperlink{igb_8c_a791fd0757e3ca1833df21ee94c17b855}{igb\_lock}(dev) != 0)
463         \textcolor{keywordflow}{return} errno;
464 
465     \textcolor{comment}{/* resume but don't reset the Tx Descriptor Rings */}
466     \textcolor{keywordflow}{for} (i = 0; i < adapter->\hyperlink{structadapter_a8befb466d4a5a6a432dc1648230e0a65}{num\_queues}; i++, txr++) \{
467         \textcolor{comment}{/* idle the queue */}
468         txdctl |= \hyperlink{kmod_2igb_2igb_8h_ae5f8a96fe2a307fc812058366eaae67e}{IGB\_TX\_PTHRESH};
469         txdctl |= \hyperlink{kmod_2igb_2igb_8h_ae6ac5557f89f50f4a26bb0ba541300bf}{IGB\_TX\_HTHRESH} << 8;
470         txdctl |= \hyperlink{igb__internal_8h_af2f5dce46d23dd6d692f9a5618bd5a51}{IGB\_TX\_WTHRESH} << 16;
471         txdctl |= \hyperlink{kmod_2igb_2e1000__82575_8h_ab4f9e73c71b951d5b59a16c782c11e7e}{E1000\_TXDCTL\_PRIORITY};
472         txdctl |= \hyperlink{kmod_2igb_2e1000__82575_8h_a8478cded14fe1defbc6dbbd1fa50897c}{E1000\_TXDCTL\_QUEUE\_ENABLE};
473         \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_a8bf12553d73f6bac2b9a7845386357df}{E1000\_TXDCTL}(i), txdctl);
474         txr->\hyperlink{structtx__ring_ac2917164cdb60559cb6fb4367f48ca24}{queue\_status} = \hyperlink{igb__internal_8h_a30986f3c29524d4e014427b2f21291b7}{IGB\_QUEUE\_WORKING};
475     \}
476 
477     srrctl |= 2048 >> \hyperlink{kmod_2igb_2e1000__82575_8h_a928a58e08843d4a88f81351ecd20611d}{E1000\_SRRCTL\_BSIZEPKT\_SHIFT};
478     srrctl |= \hyperlink{kmod_2igb_2e1000__82575_8h_a562fda6f95cf9dd4250bfba7e26154e5}{E1000\_SRRCTL\_DESCTYPE\_ADV\_ONEBUF};
479 
480     \textcolor{keywordflow}{for} (i = 0; i < adapter->\hyperlink{structadapter_a8befb466d4a5a6a432dc1648230e0a65}{num\_queues}; i++, rxr++) \{
481         \hyperlink{lib_2igb_2e1000__osdep_8h_a1d8f78f95a414480659f3182e6067b80}{u64} bus\_addr = rxr->\hyperlink{structrx__ring_a7b5f7d41a39b44612fd251f290500ba5}{rxdma}.\hyperlink{structresource_ac1f7f4ff311d1bc193e88d7cd3230bc6}{paddr};
482         \hyperlink{lib_2igb_2e1000__osdep_8h_a64e91c10a0d8fb627e92932050284264}{u32} rxdctl;
483 
484         \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_a17f1bb8471b4b2b1fb0470923048d2d3}{E1000\_RDLEN}(i),
485                 adapter->\hyperlink{structadapter_a7a36fc7297d99f6b73c4b6a194b33efd}{num\_rx\_desc} *
486                 \textcolor{keyword}{sizeof}(\textcolor{keyword}{union} \hyperlink{unione1000__adv__rx__desc}{e1000\_adv\_rx\_desc}));
487         \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_aaf1d5a8109540a3722cc498cca111a11}{E1000\_RDBAH}(i),
488                 (\hyperlink{parse_8c_a6eb1e68cc391dd753bc8ce896dbb8315}{uint32\_t})(bus\_addr >> 32));
489         \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_a9d831ba9f9151b22077f2a398ead76fd}{E1000\_RDBAL}(i),
490                 (\hyperlink{parse_8c_a6eb1e68cc391dd753bc8ce896dbb8315}{uint32\_t})bus\_addr);
491         \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_a80b27d5f09656b9586e29f25a9d35268}{E1000\_SRRCTL}(i), srrctl);
492         \textcolor{comment}{/* Enable this Queue */}
493         rxdctl = \hyperlink{kmod_2igb_2e1000__osdep_8h_a28390efdfdfb1e1cd1b033d021906a47}{E1000\_READ\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_a9563ac19965d3bd0892fd15f0c3a1dbd}{E1000\_RXDCTL}(i));
494         rxdctl |= \hyperlink{kmod_2igb_2e1000__82575_8h_a9260450cfb7c0bcfb1efc9c6ee010d85}{E1000\_RXDCTL\_QUEUE\_ENABLE};
495         rxdctl &= 0xFFF00000;
496         rxdctl |= \hyperlink{kmod_2igb_2igb_8h_a68bff36ef813c1553435f46e214a8f9b}{IGB\_RX\_PTHRESH};
497         rxdctl |= \hyperlink{kmod_2igb_2igb_8h_a6b7211566791a39b6add7fb096e4ceb7}{IGB\_RX\_HTHRESH} << 8;
498         rxdctl |= \hyperlink{kmod_2igb_2igb_8h_a84c26037da9675309cc9a5c357bc29bc}{IGB\_RX\_WTHRESH} << 16;
499         \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_a9563ac19965d3bd0892fd15f0c3a1dbd}{E1000\_RXDCTL}(i), rxdctl);
500     \}
501 
502     \textcolor{keywordflow}{if} (\hyperlink{igb_8c_a4072fbeaba958ad7c81990de452139da}{igb\_unlock}(dev) != 0)
503         \textcolor{keywordflow}{return} errno;
504 
505     \textcolor{keywordflow}{return} 0;
506 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=246pt]{igb_8c_a8c75a4c23961007c7acd70607a34537f_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{igb_8c_a8c75a4c23961007c7acd70607a34537f_icgraph}
\end{center}
\end{figure}


\index{igb.\+c@{igb.\+c}!igb\+\_\+set\+\_\+class\+\_\+bandwidth@{igb\+\_\+set\+\_\+class\+\_\+bandwidth}}
\index{igb\+\_\+set\+\_\+class\+\_\+bandwidth@{igb\+\_\+set\+\_\+class\+\_\+bandwidth}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{igb\+\_\+set\+\_\+class\+\_\+bandwidth(device\+\_\+t $\ast$dev, u\+\_\+int32\+\_\+t class\+\_\+a, u\+\_\+int32\+\_\+t class\+\_\+b, u\+\_\+int32\+\_\+t tpktsz\+\_\+a, u\+\_\+int32\+\_\+t tpktsz\+\_\+b)}{igb_set_class_bandwidth(device_t *dev, u_int32_t class_a, u_int32_t class_b, u_int32_t tpktsz_a, u_int32_t tpktsz_b)}}]{\setlength{\rightskip}{0pt plus 5cm}int igb\+\_\+set\+\_\+class\+\_\+bandwidth (
\begin{DoxyParamCaption}
\item[{{\bf device\+\_\+t} $\ast$}]{dev, }
\item[{u\+\_\+int32\+\_\+t}]{class\+\_\+a, }
\item[{u\+\_\+int32\+\_\+t}]{class\+\_\+b, }
\item[{u\+\_\+int32\+\_\+t}]{tpktsz\+\_\+a, }
\item[{u\+\_\+int32\+\_\+t}]{tpktsz\+\_\+b}
\end{DoxyParamCaption}
)}\hypertarget{igb_8c_a8d49a6fa54c79c1b5bd5b6f006eeb8e1}{}\label{igb_8c_a8d49a6fa54c79c1b5bd5b6f006eeb8e1}


igb.\+c 파일의 2019 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
2021 \{
2022     u\_int32\_t tqavctrl;
2023     u\_int32\_t tqavcc0, tqavcc1;
2024     u\_int32\_t tqavhc0, tqavhc1;
2025     u\_int32\_t class\_a\_idle, class\_b\_idle;
2026     u\_int32\_t linkrate;
2027     \textcolor{keyword}{struct }\hyperlink{structadapter}{adapter} *\hyperlink{structadapter}{adapter};
2028     \textcolor{keyword}{struct }\hyperlink{structe1000__hw}{e1000\_hw} *hw;
2029     \textcolor{keyword}{struct }\hyperlink{structigb__link__cmd}{igb\_link\_cmd} link = \{0\};
2030     \textcolor{keywordtype}{int} \hyperlink{gst__avb__playbin_8c_a6ce68847c12434f60d1b2654a3dc3409}{err};
2031     \textcolor{keywordtype}{float} class\_a\_percent, class\_b\_percent;
2032     \textcolor{keywordtype}{int} error = 0;
2033 
2034     \textcolor{keywordflow}{if} (dev == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
2035         \textcolor{keywordflow}{return} -EINVAL;
2036     adapter = (\textcolor{keyword}{struct }adapter *)dev->\hyperlink{struct__device__t_ad517770dac2061381b2008850ff12e6c}{private\_data};
2037     if (adapter == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
2038         \textcolor{keywordflow}{return} -ENXIO;
2039 
2040     hw = &adapter->\hyperlink{structadapter_a7d5953861471302be6287c989e0b20ba}{hw};
2041 
2042     \textcolor{comment}{/* get current link speed */}
2043 
2044     err = ioctl(adapter->\hyperlink{structadapter_ae57c5756a3672ea1541cbc6dfd283161}{ldev}, \hyperlink{kmod_2igb_2igb_8h_a2d0bef93ec76fee9599ad683a3538085}{IGB\_LINKSPEED}, &link);
2045 
2046     \textcolor{keywordflow}{if} (err)
2047         \textcolor{keywordflow}{return} -ENXIO;
2048 
2049     \textcolor{keywordflow}{if} (link.\hyperlink{structigb__link__cmd_ac27e774ae49a8be876d42d59686aec61}{up} == 0)
2050         \textcolor{keywordflow}{return} -EINVAL;
2051 
2052     \textcolor{keywordflow}{if} (link.\hyperlink{structigb__link__cmd_a0d3e0f150bbdbd462d4a6dd4c20f5def}{speed} < 100)
2053         \textcolor{keywordflow}{return} -EINVAL;
2054 
2055     \textcolor{keywordflow}{if} (link.\hyperlink{structigb__link__cmd_ab97627644bbfa45fd434e6f2493c8918}{duplex} != \hyperlink{kmod_2igb_2e1000__defines_8h_af504250cb09e83fc0ccf68c2552f67c5}{FULL\_DUPLEX})
2056         \textcolor{keywordflow}{return} -EINVAL;
2057 
2058     \textcolor{keywordflow}{if} (tpktsz\_a < 64)
2059         tpktsz\_a = 64; \textcolor{comment}{/* minimum ethernet frame size */}
2060 
2061     \textcolor{keywordflow}{if} (tpktsz\_a > 1500)
2062         \textcolor{keywordflow}{return} -EINVAL;
2063 
2064     \textcolor{keywordflow}{if} (tpktsz\_b < 64)
2065         tpktsz\_b = 64; \textcolor{comment}{/* minimum ethernet frame size */}
2066 
2067     \textcolor{keywordflow}{if} (tpktsz\_b > 1500)
2068         \textcolor{keywordflow}{return} -EINVAL;
2069 
2070     \textcolor{keywordflow}{if} (\hyperlink{igb_8c_a791fd0757e3ca1833df21ee94c17b855}{igb\_lock}(dev) != 0)
2071         \textcolor{keywordflow}{return} errno;
2072 
2073     tqavctrl = \hyperlink{kmod_2igb_2e1000__osdep_8h_a28390efdfdfb1e1cd1b033d021906a47}{E1000\_READ\_REG}(hw, \hyperlink{lib_2igb_2e1000__regs_8h_af5b34da72cbeec51623bef02c6cd814e}{E1000\_TQAVCTRL});
2074 
2075     \textcolor{keywordflow}{if} ((class\_a + class\_b) == 0) \{
2076         \textcolor{comment}{/* disable the Qav shaper */}
2077         tqavctrl &= ~\hyperlink{lib_2igb_2e1000__defines_8h_a6d5c189da73b3f0aabb76ce93417590a}{E1000\_TQAVCTRL\_TX\_ARB};
2078         \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{lib_2igb_2e1000__regs_8h_af5b34da72cbeec51623bef02c6cd814e}{E1000\_TQAVCTRL}, tqavctrl);
2079         \textcolor{keywordflow}{goto} unlock;
2080     \}
2081 
2082     tqavcc0 = \hyperlink{kmod_2igb_2e1000__defines_8h_a9b571bca82ac197f7f3fa403ac8a680f}{E1000\_TQAVCC\_QUEUEMODE};
2083     tqavcc1 = \hyperlink{kmod_2igb_2e1000__defines_8h_a9b571bca82ac197f7f3fa403ac8a680f}{E1000\_TQAVCC\_QUEUEMODE};
2084 
2085     linkrate = \hyperlink{lib_2igb_2e1000__defines_8h_a6c27d7866575aa969a08adde61019135}{E1000\_TQAVCC\_LINKRATE};
2086 
2087     \textcolor{comment}{/*}
2088 \textcolor{comment}{     * class\_a and class\_b are the packets-per-(respective)observation}
2089 \textcolor{comment}{     * interval (125 usec for class A, 250 usec for class B)}
2090 \textcolor{comment}{     * these parameters are also used when establishing the MSRP}
2091 \textcolor{comment}{     * talker advertise attribute (as well as the tpktsize)}
2092 \textcolor{comment}{     *}
2093 \textcolor{comment}{     * note that class\_a and class\_b are independent of the media}
2094 \textcolor{comment}{     * rate. For our idle slope calculation, we need to scale the}
2095 \textcolor{comment}{     * (tpktsz + (media overhead)) * rate -> percentage of media rate.}
2096 \textcolor{comment}{     */}
2097 
2098     \textcolor{comment}{/* 12=Ethernet IPG,}
2099 \textcolor{comment}{     * 8=Preamble+Start of Frame,}
2100 \textcolor{comment}{     * 18=Mac Header with VLAN+Etype,}
2101 \textcolor{comment}{     * 4=CRC}
2102 \textcolor{comment}{     */}
2103     class\_a\_percent = (float)((tpktsz\_a + (12 + 8 + 18 + 4)) * class\_a);
2104     class\_b\_percent = (float)((tpktsz\_b + (12 + 8 + 18 + 4)) * class\_b);
2105 
2106     class\_a\_percent /= 0.000125; \textcolor{comment}{/* class A observation window */}
2107     class\_b\_percent /= 0.000250; \textcolor{comment}{/* class B observation window */}
2108 
2109     \textcolor{keywordflow}{if} (link.\hyperlink{structigb__link__cmd_a0d3e0f150bbdbd462d4a6dd4c20f5def}{speed} == 100) \{
2110         \textcolor{comment}{/* bytes-per-sec @ 100Mbps */}
2111         class\_a\_percent /= (100000000.0 / 8);
2112         class\_b\_percent /= (100000000.0 / 8);
2113         class\_a\_idle = (u\_int32\_t)(class\_a\_percent * 0.2 *
2114                 (\textcolor{keywordtype}{float})linkrate + 0.5);
2115         class\_b\_idle = (u\_int32\_t)(class\_b\_percent * 0.2 *
2116                 (\textcolor{keywordtype}{float})linkrate + 0.5);
2117     \} \textcolor{keywordflow}{else} \{
2118         \textcolor{comment}{/* bytes-per-sec @ 1Gbps */}
2119         class\_a\_percent /= (1000000000.0 / 8);
2120         class\_b\_percent /= (1000000000.0 / 8);
2121         class\_a\_idle = (u\_int32\_t)(class\_a\_percent *
2122                 2.0 * (\textcolor{keywordtype}{float})linkrate + 0.5);
2123         class\_b\_idle = (u\_int32\_t)(class\_b\_percent * 2.0 *
2124                 (\textcolor{keywordtype}{float})linkrate + 0.5);
2125     \}
2126 
2127     \textcolor{keywordflow}{if} ((class\_a\_percent + class\_b\_percent) > 0.75) \{
2128         error = -EINVAL;
2129         \textcolor{keywordflow}{goto} unlock;
2130     \}
2131     tqavcc0 |= class\_a\_idle;
2132     tqavcc1 |= class\_b\_idle;
2133 
2134     \textcolor{comment}{/*}
2135 \textcolor{comment}{     * hiCredit is the number of idleslope credits accumulated due to delay}
2136 \textcolor{comment}{     *}
2137 \textcolor{comment}{     * we assume the maxInterferenceSize is 18 + 4 + 1500 (1522).}
2138 \textcolor{comment}{     * Note: if EEE is enabled, we should use for maxInterferenceSize}
2139 \textcolor{comment}{     * the overhead of link recovery (a media-specific quantity).}
2140 \textcolor{comment}{     */}
2141     tqavhc0 = 0x80000000 + (class\_a\_idle * 1522 / linkrate); \textcolor{comment}{/* L.10 */}
2142 
2143     \textcolor{comment}{/*}
2144 \textcolor{comment}{     * Class B high credit is is the same, except the delay}
2145 \textcolor{comment}{     * is the MaxBurstSize of Class A + maxInterferenceSize of non-SR}
2146 \textcolor{comment}{     * traffic}
2147 \textcolor{comment}{     *}
2148 \textcolor{comment}{     * L.41}
2149 \textcolor{comment}{     * max Class B delay = (1522 + tpktsz\_a) / (linkrate - class\_a\_idle)}
2150 \textcolor{comment}{     */}
2151 
2152     tqavhc1 = 0x80000000 + (class\_b\_idle * ((1522 + tpktsz\_a) /
2153                         (linkrate - class\_a\_idle)));
2154 
2155     \textcolor{comment}{/* implicitly enable the Qav shaper */}
2156     tqavctrl |= \hyperlink{lib_2igb_2e1000__defines_8h_a6d5c189da73b3f0aabb76ce93417590a}{E1000\_TQAVCTRL\_TX\_ARB};
2157     \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{lib_2igb_2e1000__regs_8h_a42b5935c3f52545c04c35bd09e09e901}{E1000\_TQAVHC}(0), tqavhc0);
2158     \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{lib_2igb_2e1000__regs_8h_a1fe5dc50dcf597581479dfe2f07ec59f}{E1000\_TQAVCC}(0), tqavcc0);
2159     \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{lib_2igb_2e1000__regs_8h_a42b5935c3f52545c04c35bd09e09e901}{E1000\_TQAVHC}(1), tqavhc1);
2160     \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{lib_2igb_2e1000__regs_8h_a1fe5dc50dcf597581479dfe2f07ec59f}{E1000\_TQAVCC}(1), tqavcc1);
2161     \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{lib_2igb_2e1000__regs_8h_af5b34da72cbeec51623bef02c6cd814e}{E1000\_TQAVCTRL}, tqavctrl);
2162 
2163 unlock:
2164     \textcolor{keywordflow}{if} (\hyperlink{igb_8c_a4072fbeaba958ad7c81990de452139da}{igb\_unlock}(dev) != 0)
2165         error = errno;
2166 
2167     \textcolor{keywordflow}{return} error;
2168 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=305pt]{igb_8c_a8d49a6fa54c79c1b5bd5b6f006eeb8e1_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{igb_8c_a8d49a6fa54c79c1b5bd5b6f006eeb8e1_icgraph}
\end{center}
\end{figure}


\index{igb.\+c@{igb.\+c}!igb\+\_\+set\+\_\+class\+\_\+bandwidth2@{igb\+\_\+set\+\_\+class\+\_\+bandwidth2}}
\index{igb\+\_\+set\+\_\+class\+\_\+bandwidth2@{igb\+\_\+set\+\_\+class\+\_\+bandwidth2}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{igb\+\_\+set\+\_\+class\+\_\+bandwidth2(device\+\_\+t $\ast$dev, u\+\_\+int32\+\_\+t class\+\_\+a\+\_\+bytes\+\_\+per\+\_\+second, u\+\_\+int32\+\_\+t class\+\_\+b\+\_\+bytes\+\_\+per\+\_\+second)}{igb_set_class_bandwidth2(device_t *dev, u_int32_t class_a_bytes_per_second, u_int32_t class_b_bytes_per_second)}}]{\setlength{\rightskip}{0pt plus 5cm}int igb\+\_\+set\+\_\+class\+\_\+bandwidth2 (
\begin{DoxyParamCaption}
\item[{{\bf device\+\_\+t} $\ast$}]{dev, }
\item[{u\+\_\+int32\+\_\+t}]{class\+\_\+a\+\_\+bytes\+\_\+per\+\_\+second, }
\item[{u\+\_\+int32\+\_\+t}]{class\+\_\+b\+\_\+bytes\+\_\+per\+\_\+second}
\end{DoxyParamCaption}
)}\hypertarget{igb_8c_a08432a2e3faf4dc22641a6ee75f309c9}{}\label{igb_8c_a08432a2e3faf4dc22641a6ee75f309c9}


igb.\+c 파일의 2170 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
2172 \{
2173     u\_int32\_t tqavctrl;
2174     u\_int32\_t tqavcc0, tqavcc1;
2175     u\_int32\_t tqavhc0, tqavhc1;
2176     u\_int32\_t class\_a\_idle, class\_b\_idle;
2177     u\_int32\_t linkrate;
2178     u\_int32\_t tpktsz\_a;
2179     \textcolor{keywordtype}{int} temp;
2180     \textcolor{keyword}{struct }\hyperlink{structadapter}{adapter} *\hyperlink{structadapter}{adapter};
2181     \textcolor{keyword}{struct }\hyperlink{structe1000__hw}{e1000\_hw} *hw;
2182     \textcolor{keyword}{struct }\hyperlink{structigb__link__cmd}{igb\_link\_cmd} link = \{0\};
2183     \textcolor{keywordtype}{int} \hyperlink{gst__avb__playbin_8c_a6ce68847c12434f60d1b2654a3dc3409}{err};
2184     \textcolor{keywordtype}{float} class\_a\_percent, class\_b\_percent;
2185     \textcolor{keywordtype}{int} error = 0;
2186 
2187     \textcolor{keywordflow}{if} (dev == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
2188         \textcolor{keywordflow}{return} -EINVAL;
2189 
2190     adapter = (\textcolor{keyword}{struct }adapter *)dev->\hyperlink{struct__device__t_ad517770dac2061381b2008850ff12e6c}{private\_data};
2191     if (adapter == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
2192         \textcolor{keywordflow}{return} -ENXIO;
2193 
2194     hw = &adapter->\hyperlink{structadapter_a7d5953861471302be6287c989e0b20ba}{hw};
2195 
2196     \textcolor{comment}{/* get current link speed */}
2197 
2198     err = ioctl(adapter->\hyperlink{structadapter_ae57c5756a3672ea1541cbc6dfd283161}{ldev}, \hyperlink{kmod_2igb_2igb_8h_a2d0bef93ec76fee9599ad683a3538085}{IGB\_LINKSPEED}, &link);
2199 
2200     \textcolor{keywordflow}{if} (err)
2201         \textcolor{keywordflow}{return} -ENXIO;
2202 
2203     \textcolor{keywordflow}{if} (link.\hyperlink{structigb__link__cmd_ac27e774ae49a8be876d42d59686aec61}{up} == 0)
2204         \textcolor{keywordflow}{return} -EINVAL;
2205 
2206     \textcolor{keywordflow}{if} (link.\hyperlink{structigb__link__cmd_a0d3e0f150bbdbd462d4a6dd4c20f5def}{speed} < 100)
2207         \textcolor{keywordflow}{return} -EINVAL;
2208 
2209     \textcolor{keywordflow}{if} (link.\hyperlink{structigb__link__cmd_ab97627644bbfa45fd434e6f2493c8918}{duplex} != \hyperlink{kmod_2igb_2e1000__defines_8h_af504250cb09e83fc0ccf68c2552f67c5}{FULL\_DUPLEX})
2210         \textcolor{keywordflow}{return} -EINVAL;
2211 
2212     \textcolor{keywordflow}{if} (\hyperlink{igb_8c_a791fd0757e3ca1833df21ee94c17b855}{igb\_lock}(dev) != 0)
2213         \textcolor{keywordflow}{return} errno;
2214 
2215     tqavctrl = \hyperlink{kmod_2igb_2e1000__osdep_8h_a28390efdfdfb1e1cd1b033d021906a47}{E1000\_READ\_REG}(hw, \hyperlink{lib_2igb_2e1000__regs_8h_af5b34da72cbeec51623bef02c6cd814e}{E1000\_TQAVCTRL});
2216 
2217     \textcolor{keywordflow}{if} ((class\_a\_bytes\_per\_second + class\_b\_bytes\_per\_second) == 0) \{
2218         \textcolor{comment}{/* disable the Qav shaper */}
2219         tqavctrl &= ~\hyperlink{lib_2igb_2e1000__defines_8h_a6d5c189da73b3f0aabb76ce93417590a}{E1000\_TQAVCTRL\_TX\_ARB};
2220         \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{lib_2igb_2e1000__regs_8h_af5b34da72cbeec51623bef02c6cd814e}{E1000\_TQAVCTRL}, tqavctrl);
2221         \textcolor{keywordflow}{goto} unlock;
2222     \}
2223 
2224     tqavcc0 = \hyperlink{kmod_2igb_2e1000__defines_8h_a9b571bca82ac197f7f3fa403ac8a680f}{E1000\_TQAVCC\_QUEUEMODE};
2225     tqavcc1 = \hyperlink{kmod_2igb_2e1000__defines_8h_a9b571bca82ac197f7f3fa403ac8a680f}{E1000\_TQAVCC\_QUEUEMODE};
2226 
2227     linkrate = \hyperlink{lib_2igb_2e1000__defines_8h_a6c27d7866575aa969a08adde61019135}{E1000\_TQAVCC\_LINKRATE};
2228 
2229     \textcolor{comment}{/* it is needed for Class B high credit calculations}
2230 \textcolor{comment}{     * so we need to guess it}
2231 \textcolor{comment}{     * TODO: check if it is right}
2232 \textcolor{comment}{     */}
2233     temp = class\_a\_bytes\_per\_second / 8000 - (12 + 8 + 18 + 4);
2234     \textcolor{keywordflow}{if} (temp > 0)
2235         tpktsz\_a = temp;
2236     \textcolor{keywordflow}{else}
2237         tpktsz\_a = 0;
2238     \textcolor{comment}{/* TODO: in igb\_set\_class\_bandwidth if given tpktsz\_a < 64}
2239 \textcolor{comment}{     * (for example 0) then the 64 value will be used even if}
2240 \textcolor{comment}{     * there is no class\_A streams (class\_a is 0)}
2241 \textcolor{comment}{     * I suspect that this is error, so we use 0 here.}
2242 \textcolor{comment}{     */}
2243 
2244     class\_a\_percent = class\_a\_bytes\_per\_second;
2245     class\_b\_percent = class\_b\_bytes\_per\_second;
2246 
2247     \textcolor{keywordflow}{if} (link.\hyperlink{structigb__link__cmd_a0d3e0f150bbdbd462d4a6dd4c20f5def}{speed} == 100) \{
2248         \textcolor{comment}{/* bytes-per-sec @ 100Mbps */}
2249         class\_a\_percent /= (100000000.0 / 8);
2250         class\_b\_percent /= (100000000.0 / 8);
2251         class\_a\_idle = (u\_int32\_t)(class\_a\_percent * 0.2 *
2252                 (\textcolor{keywordtype}{float})linkrate + 0.5);
2253         class\_b\_idle = (u\_int32\_t)(class\_b\_percent * 0.2 *
2254                 (\textcolor{keywordtype}{float})linkrate + 0.5);
2255     \} \textcolor{keywordflow}{else} \{
2256         \textcolor{comment}{/* bytes-per-sec @ 1Gbps */}
2257         class\_a\_percent /= (1000000000.0 / 8);
2258         class\_b\_percent /= (1000000000.0 / 8);
2259         class\_a\_idle = (u\_int32\_t)(class\_a\_percent * 2.0 *
2260                 (\textcolor{keywordtype}{float})linkrate + 0.5);
2261         class\_b\_idle = (u\_int32\_t)(class\_b\_percent * 2.0 *
2262                 (\textcolor{keywordtype}{float})linkrate + 0.5);
2263     \}
2264 
2265     \textcolor{keywordflow}{if} ((class\_a\_percent + class\_b\_percent) > 0.75) \{
2266         error = -EINVAL;
2267         \textcolor{keywordflow}{goto} unlock;
2268     \}
2269     tqavcc0 |= class\_a\_idle;
2270     tqavcc1 |= class\_b\_idle;
2271 
2272     \textcolor{comment}{/*}
2273 \textcolor{comment}{     * hiCredit is the number of idleslope credits accumulated due to delay}
2274 \textcolor{comment}{     *}
2275 \textcolor{comment}{     * we assume the maxInterferenceSize is 18 + 4 + 1500 (1522).}
2276 \textcolor{comment}{     * Note: if EEE is enabled, we should use for maxInterferenceSize}
2277 \textcolor{comment}{     * the overhead of link recovery (a media-specific quantity).}
2278 \textcolor{comment}{     */}
2279     tqavhc0 = 0x80000000 + (class\_a\_idle * 1522 / linkrate); \textcolor{comment}{/* L.10 */}
2280 
2281     \textcolor{comment}{/*}
2282 \textcolor{comment}{     * Class B high credit is is the same, except the delay}
2283 \textcolor{comment}{     * is the MaxBurstSize of Class A + maxInterferenceSize of non-SR}
2284 \textcolor{comment}{     * traffic}
2285 \textcolor{comment}{     *}
2286 \textcolor{comment}{     * L.41}
2287 \textcolor{comment}{     * max Class B delay = (1522 + tpktsz\_a) / (linkrate - class\_a\_idle)}
2288 \textcolor{comment}{     */}
2289 
2290     tqavhc1 = 0x80000000 + (class\_b\_idle * ((1522 + tpktsz\_a) /
2291                 (linkrate - class\_a\_idle)));
2292 
2293     \textcolor{comment}{/* implicitly enable the Qav shaper */}
2294     tqavctrl |= \hyperlink{lib_2igb_2e1000__defines_8h_a6d5c189da73b3f0aabb76ce93417590a}{E1000\_TQAVCTRL\_TX\_ARB};
2295     \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{lib_2igb_2e1000__regs_8h_a42b5935c3f52545c04c35bd09e09e901}{E1000\_TQAVHC}(0), tqavhc0);
2296     \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{lib_2igb_2e1000__regs_8h_a1fe5dc50dcf597581479dfe2f07ec59f}{E1000\_TQAVCC}(0), tqavcc0);
2297     \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{lib_2igb_2e1000__regs_8h_a42b5935c3f52545c04c35bd09e09e901}{E1000\_TQAVHC}(1), tqavhc1);
2298     \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{lib_2igb_2e1000__regs_8h_a1fe5dc50dcf597581479dfe2f07ec59f}{E1000\_TQAVCC}(1), tqavcc1);
2299     \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{lib_2igb_2e1000__regs_8h_af5b34da72cbeec51623bef02c6cd814e}{E1000\_TQAVCTRL}, tqavctrl);
2300 
2301 unlock:
2302     \textcolor{keywordflow}{if} (\hyperlink{igb_8c_a4072fbeaba958ad7c81990de452139da}{igb\_unlock}(dev) != 0)
2303         error = errno;
2304 
2305     \textcolor{keywordflow}{return} error;
2306 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=310pt]{igb_8c_a08432a2e3faf4dc22641a6ee75f309c9_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{igb_8c_a08432a2e3faf4dc22641a6ee75f309c9_icgraph}
\end{center}
\end{figure}


\index{igb.\+c@{igb.\+c}!igb\+\_\+setup\+\_\+flex\+\_\+filter@{igb\+\_\+setup\+\_\+flex\+\_\+filter}}
\index{igb\+\_\+setup\+\_\+flex\+\_\+filter@{igb\+\_\+setup\+\_\+flex\+\_\+filter}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{igb\+\_\+setup\+\_\+flex\+\_\+filter(device\+\_\+t $\ast$dev, unsigned int queue\+\_\+id, unsigned int filter\+\_\+id, unsigned int filter\+\_\+len, u\+\_\+int8\+\_\+t $\ast$filter, u\+\_\+int8\+\_\+t $\ast$mask)}{igb_setup_flex_filter(device_t *dev, unsigned int queue_id, unsigned int filter_id, unsigned int filter_len, u_int8_t *filter, u_int8_t *mask)}}]{\setlength{\rightskip}{0pt plus 5cm}int igb\+\_\+setup\+\_\+flex\+\_\+filter (
\begin{DoxyParamCaption}
\item[{{\bf device\+\_\+t} $\ast$}]{dev, }
\item[{unsigned int}]{queue\+\_\+id, }
\item[{unsigned int}]{filter\+\_\+id, }
\item[{unsigned int}]{filter\+\_\+len, }
\item[{u\+\_\+int8\+\_\+t $\ast$}]{filter, }
\item[{u\+\_\+int8\+\_\+t $\ast$}]{mask}
\end{DoxyParamCaption}
)}\hypertarget{igb_8c_a27cde3a06b5513af43c11c40fc5503dc}{}\label{igb_8c_a27cde3a06b5513af43c11c40fc5503dc}


igb.\+c 파일의 2325 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
2328 \{
2329     \textcolor{keyword}{struct }\hyperlink{structadapter}{adapter} *\hyperlink{structadapter}{adapter};
2330     \textcolor{keyword}{struct }\hyperlink{structe1000__hw}{e1000\_hw} *hw;
2331     \hyperlink{lib_2igb_2e1000__osdep_8h_a64e91c10a0d8fb627e92932050284264}{u32} i = 0, j, k;
2332     \hyperlink{lib_2igb_2e1000__osdep_8h_a64e91c10a0d8fb627e92932050284264}{u32} fhft, wufc;
2333     u\_int8\_t *filter\_buf = filter;
2334 
2335     \textcolor{keywordflow}{if} (dev == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
2336         \textcolor{keywordflow}{return} -EINVAL;
2337 
2338     adapter = (\textcolor{keyword}{struct }adapter *)dev->\hyperlink{struct__device__t_ad517770dac2061381b2008850ff12e6c}{private\_data};
2339     if (adapter == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
2340         \textcolor{keywordflow}{return} -ENXIO;
2341 
2342     \textcolor{keywordflow}{if} (filter\_id > 7)
2343         \textcolor{keywordflow}{return} -EINVAL;
2344 
2345     \textcolor{keywordflow}{if} (queue\_id > 1)
2346         \textcolor{keywordflow}{return} -EINVAL;
2347 
2348     \textcolor{keywordflow}{if} (filter\_len > 128)
2349         \textcolor{keywordflow}{return} -EINVAL;
2350 
2351     \textcolor{keywordflow}{if} (filter\_len % 8) \{
2352         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} aligned\_filter\_len = ((filter\_len + (8 - 1)) / 8) * 8;
2353 
2354         printf (\textcolor{stringliteral}{"warning: filter\_len(%d) should be a 8 byte aligned value\(\backslash\)n"},
2355                     filter\_len);
2356 
2357         filter\_buf = \hyperlink{_memory_leak_detector_malloc_macros_8h_a7cbb7b79af9d539af55b59dfc3598390}{calloc}(1, aligned\_filter\_len);
2358         \textcolor{keywordflow}{if} (!filter\_buf)
2359             \textcolor{keywordflow}{return} -ENOMEM;
2360 
2361         memcpy((\textcolor{keywordtype}{void}*)filter\_buf, (\textcolor{keywordtype}{void}*)filter, (\textcolor{keywordtype}{size\_t})filter\_len);
2362         filter\_len = aligned\_filter\_len;
2363     \}
2364 
2365     hw = &adapter->\hyperlink{structadapter_a7d5953861471302be6287c989e0b20ba}{hw};
2366 
2367     \textcolor{comment}{/*}
2368 \textcolor{comment}{     * example pattern to set to match on the following in a Magic Packet}
2369 \textcolor{comment}{     * 0x00: xx xx xx xx xx xx xx xx  xx xx xx xx 08 00 45 00}
2370 \textcolor{comment}{     * 0x10: xx xx xx xx xx xx xx 11  xx xx xx xx xx xx xx xx}
2371 \textcolor{comment}{     * 0x20: xx xx xx xx 00 07 00 86  xx xx ff ff ff ff ff ff}
2372 \textcolor{comment}{     * 0x30: m0 m1 m2 m3 m4 m5 xx xx  xx xx xx xx xx xx xx xx}
2373 \textcolor{comment}{     *}
2374 \textcolor{comment}{     * Where m0-m5 are the 6 bytes of the mac address in network order}
2375 \textcolor{comment}{     *}
2376 \textcolor{comment}{     * example code follows}
2377 \textcolor{comment}{     *}
2378 \textcolor{comment}{     * ethertype should be IP which is 0x0800}
2379 \textcolor{comment}{     * filter[0x0C] = 0x08;}
2380 \textcolor{comment}{     * filter[0x0D] = 0x00;}
2381 \textcolor{comment}{}
2382 \textcolor{comment}{     * verify IPv4 and header length 20}
2383 \textcolor{comment}{     * filter[0x0E] = 0x45;}
2384 \textcolor{comment}{     * filter[0x0F] = 0x00;}
2385 \textcolor{comment}{     * mask[1] = 0xF0;}
2386 \textcolor{comment}{}
2387 \textcolor{comment}{     * verify L3 protocol is UDP}
2388 \textcolor{comment}{     * filter[0x17] = 0x11;}
2389 \textcolor{comment}{     * mask[2] = 0x80;}
2390 \textcolor{comment}{}
2391 \textcolor{comment}{     * verify source and destination port numbers}
2392 \textcolor{comment}{     * filter[0x24] = 0x00;}
2393 \textcolor{comment}{     * filter[0x25] = 0x07;}
2394 \textcolor{comment}{     * filter[0x26] = 0x00;}
2395 \textcolor{comment}{     * filter[0x27] = 0x86;}
2396 \textcolor{comment}{     * mask[4] = 0xF0;}
2397 \textcolor{comment}{}
2398 \textcolor{comment}{* add start filter of 6 bytes all 0xFF}
2399 \textcolor{comment}{     * memset(&filter[0x2a], 0xff, 6);}
2400 \textcolor{comment}{     * mask[5] = 0xFC;}
2401 \textcolor{comment}{}
2402 \textcolor{comment}{     * add mac address}
2403 \textcolor{comment}{     * memcpy(&filter[0x30], hw->mac.addr, 6);}
2404 \textcolor{comment}{     * mask[6] |= 0x3F;}
2405 \textcolor{comment}{     */}
2406 
2407     \textcolor{keywordflow}{while} (i < filter\_len) \{
2408         \textcolor{keywordflow}{for} (j = 0; j < 8; j += 4) \{
2409             fhft = 0;
2410             \textcolor{keywordflow}{for} (k = 0; k < 4; k++)
2411                 fhft |= ((\hyperlink{lib_2igb_2e1000__osdep_8h_a64e91c10a0d8fb627e92932050284264}{u32})(filter\_buf[i + j + k])) << (k * 8);
2412             \hyperlink{kmod_2igb_2e1000__osdep_8h_a573888f2e2956f04a7c2429d75c74c2f}{E1000\_WRITE\_REG\_ARRAY}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_ae981635b89cf694de6e67f78c394f8c9}{E1000\_FHFT}(filter\_id),
2413                     (i/2) + (j/4), fhft);
2414         \}
2415         \hyperlink{kmod_2igb_2e1000__osdep_8h_a573888f2e2956f04a7c2429d75c74c2f}{E1000\_WRITE\_REG\_ARRAY}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_ae981635b89cf694de6e67f78c394f8c9}{E1000\_FHFT}(filter\_id),
2416                 (i/2) + 2, mask[i/8]);
2417         i += 8;
2418     \}
2419 
2420     \hyperlink{kmod_2igb_2e1000__osdep_8h_a573888f2e2956f04a7c2429d75c74c2f}{E1000\_WRITE\_REG\_ARRAY}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_ae981635b89cf694de6e67f78c394f8c9}{E1000\_FHFT}(filter\_id),
2421             63, (queue\_id << 8) | filter\_len);
2422 
2423     \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_a3774795f5bd608df3f717379ef6dc1b5}{E1000\_WUC}, 0x21); \textcolor{comment}{/* XXX is this right ? */}
2424 
2425     wufc = \hyperlink{kmod_2igb_2e1000__osdep_8h_a28390efdfdfb1e1cd1b033d021906a47}{E1000\_READ\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_a6f8e4ba2de0f8a1b9a41223ca4f62d55}{E1000\_WUFC});
2426     wufc |= (\hyperlink{kmod_2igb_2e1000__defines_8h_acd3fb505efb2986f034a804387cc5e3b}{E1000\_WUFC\_FLX0} << filter\_id) | \hyperlink{lib_2igb_2e1000__defines_8h_a945ed94613427d200c7ce7d6061e6542}{E1000\_WUFC\_FLEX\_HQ};
2427     \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_a6f8e4ba2de0f8a1b9a41223ca4f62d55}{E1000\_WUFC}, wufc);
2428 
2429     \textcolor{keywordflow}{if} (filter\_buf && (filter\_buf != filter))
2430         \hyperlink{_memory_leak_detector_malloc_macros_8h_aa7157aa9480bb73f090dca36776419bf}{free}(filter\_buf);
2431 
2432     \textcolor{keywordflow}{return} 0;
2433 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{igb_8c_a27cde3a06b5513af43c11c40fc5503dc_icgraph}
\end{center}
\end{figure}


\index{igb.\+c@{igb.\+c}!igb\+\_\+setup\+\_\+receive\+\_\+ring@{igb\+\_\+setup\+\_\+receive\+\_\+ring}}
\index{igb\+\_\+setup\+\_\+receive\+\_\+ring@{igb\+\_\+setup\+\_\+receive\+\_\+ring}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{igb\+\_\+setup\+\_\+receive\+\_\+ring(struct rx\+\_\+ring $\ast$rxr)}{igb_setup_receive_ring(struct rx_ring *rxr)}}]{\setlength{\rightskip}{0pt plus 5cm}static void igb\+\_\+setup\+\_\+receive\+\_\+ring (
\begin{DoxyParamCaption}
\item[{struct {\bf rx\+\_\+ring} $\ast$}]{rxr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{igb_8c_a7782563000c24cdd2e094c5d22172c9d}{}\label{igb_8c_a7782563000c24cdd2e094c5d22172c9d}


igb.\+c 파일의 1452 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
1453 \{
1454     \textcolor{keyword}{struct }\hyperlink{structadapter}{adapter} *\hyperlink{structadapter}{adapter} = rxr->\hyperlink{structrx__ring_a807e6014970a3d469e197cd9ec25229c}{adapter};
1455 
1456     (void)sem\_wait(&rxr->\hyperlink{structrx__ring_ac301e000199ad937f060277b0736d4e1}{lock});
1457 
1458     \textcolor{comment}{/* Clear the ring contents */}
1459     memset((\textcolor{keywordtype}{void} *)rxr->\hyperlink{structrx__ring_a40ec79b3b6a780e7f5c90dea8b3160bf}{rx\_base},  0,
1460            (\textcolor{keyword}{sizeof}(\textcolor{keyword}{union} \hyperlink{unione1000__adv__rx__desc}{e1000\_adv\_rx\_desc})) * adapter->
      \hyperlink{structadapter_a7a36fc7297d99f6b73c4b6a194b33efd}{num\_rx\_desc});
1461 
1462     memset(rxr->\hyperlink{structrx__ring_abe41cfe713ffac28a8f678c51082df25}{rx\_buffers}, 0, \textcolor{keyword}{sizeof}(\textcolor{keyword}{struct} \hyperlink{structigb__rx__buffer}{igb\_rx\_buffer}) *
1463                    rxr->\hyperlink{structrx__ring_a807e6014970a3d469e197cd9ec25229c}{adapter}->\hyperlink{structadapter_a7a36fc7297d99f6b73c4b6a194b33efd}{num\_rx\_desc});
1464 
1465     \textcolor{comment}{/* Free current RX buffer structures */}
1466     \hyperlink{igb_8c_aec1cca14ce5797701742e519f394cbbc}{igb\_free\_receive\_ring}(rxr);
1467 
1468     \textcolor{comment}{/* Setup our descriptor indices */}
1469     rxr->\hyperlink{structrx__ring_a3a6765383612ad483dfc252f8a16a87d}{next\_to\_check} = 0;
1470     rxr->\hyperlink{structrx__ring_aab3e5ae9f841cbc34fddab6abd9ed519}{next\_to\_refresh} = 0;
1471     rxr->\hyperlink{structrx__ring_a531d11bd600d2183a8bee4aa70c0652e}{rx\_split\_packets} = 0;
1472     rxr->\hyperlink{structrx__ring_a7959281142289cfe755e1b3279559b5f}{rx\_bytes} = 0;
1473 
1474     (void)sem\_post(&rxr->\hyperlink{structrx__ring_ac301e000199ad937f060277b0736d4e1}{lock});
1475 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=341pt]{igb_8c_a7782563000c24cdd2e094c5d22172c9d_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{igb_8c_a7782563000c24cdd2e094c5d22172c9d_icgraph}
\end{center}
\end{figure}


\index{igb.\+c@{igb.\+c}!igb\+\_\+setup\+\_\+receive\+\_\+structures@{igb\+\_\+setup\+\_\+receive\+\_\+structures}}
\index{igb\+\_\+setup\+\_\+receive\+\_\+structures@{igb\+\_\+setup\+\_\+receive\+\_\+structures}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{igb\+\_\+setup\+\_\+receive\+\_\+structures(struct adapter $\ast$adapter)}{igb_setup_receive_structures(struct adapter *adapter)}}]{\setlength{\rightskip}{0pt plus 5cm}static void igb\+\_\+setup\+\_\+receive\+\_\+structures (
\begin{DoxyParamCaption}
\item[{struct {\bf adapter} $\ast$}]{adapter}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{igb_8c_a1d555819a110fd3491fc4d2f0a69c2ac}{}\label{igb_8c_a1d555819a110fd3491fc4d2f0a69c2ac}


igb.\+c 파일의 1478 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
1479 \{
1480     \textcolor{keyword}{struct }\hyperlink{structrx__ring}{rx\_ring} *rxr = adapter->\hyperlink{structadapter_a59a5588ccfe1b0eefe45fcb9188b2f0a}{rx\_rings};
1481     \textcolor{keywordtype}{int} i;
1482 
1483     \textcolor{keywordflow}{for} (i = 0; i < adapter->\hyperlink{structadapter_a8befb466d4a5a6a432dc1648230e0a65}{num\_queues}; i++, rxr++)
1484         \hyperlink{igb_8c_a7782563000c24cdd2e094c5d22172c9d}{igb\_setup\_receive\_ring}(rxr);
1485 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{igb_8c_a1d555819a110fd3491fc4d2f0a69c2ac_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{igb_8c_a1d555819a110fd3491fc4d2f0a69c2ac_icgraph}
\end{center}
\end{figure}


\index{igb.\+c@{igb.\+c}!igb\+\_\+setup\+\_\+transmit\+\_\+ring@{igb\+\_\+setup\+\_\+transmit\+\_\+ring}}
\index{igb\+\_\+setup\+\_\+transmit\+\_\+ring@{igb\+\_\+setup\+\_\+transmit\+\_\+ring}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{igb\+\_\+setup\+\_\+transmit\+\_\+ring(struct tx\+\_\+ring $\ast$txr)}{igb_setup_transmit_ring(struct tx_ring *txr)}}]{\setlength{\rightskip}{0pt plus 5cm}static void igb\+\_\+setup\+\_\+transmit\+\_\+ring (
\begin{DoxyParamCaption}
\item[{struct {\bf tx\+\_\+ring} $\ast$}]{txr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{igb_8c_a9c5d92d7861904dde94814d52798648f}{}\label{igb_8c_a9c5d92d7861904dde94814d52798648f}


igb.\+c 파일의 845 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
846 \{
847     \textcolor{keyword}{struct }\hyperlink{structadapter}{adapter} *\hyperlink{structadapter}{adapter} = txr->\hyperlink{structtx__ring_a807e6014970a3d469e197cd9ec25229c}{adapter};
848 
849     \textcolor{comment}{/* Clear the old descriptor contents */}
850     memset((\textcolor{keywordtype}{void} *)txr->\hyperlink{structtx__ring_afcf2ae577a4363723c3403d160dd4d01}{tx\_base},  0,
851            (\textcolor{keyword}{sizeof}(\textcolor{keyword}{union} \hyperlink{unione1000__adv__tx__desc}{e1000\_adv\_tx\_desc})) * adapter->
      \hyperlink{structadapter_ab0bd5866ff13aa7c17436220693a3d2d}{num\_tx\_desc});
852 
853     memset(txr->\hyperlink{structtx__ring_a9b0485752fc6d8befa2f35ebd45710db}{tx\_buffers}, 0, \textcolor{keyword}{sizeof}(\textcolor{keyword}{struct} \hyperlink{structigb__tx__buffer}{igb\_tx\_buffer}) *
854                    txr->\hyperlink{structtx__ring_a807e6014970a3d469e197cd9ec25229c}{adapter}->\hyperlink{structadapter_ab0bd5866ff13aa7c17436220693a3d2d}{num\_tx\_desc});
855 
856     \textcolor{comment}{/* Reset indices */}
857     txr->\hyperlink{structtx__ring_a11612fa87762d1d1e6a7eccfb865b805}{next\_avail\_desc} = 0;
858     txr->\hyperlink{structtx__ring_a6b93808fe90341d9209770bf06dcdc6c}{next\_to\_clean} = 0;
859 
860     \textcolor{comment}{/* Set number of descriptors available */}
861     txr->\hyperlink{structtx__ring_a3f8acb3cacc1230f5a5b78b1b6cf7c2a}{tx\_avail} = adapter->\hyperlink{structadapter_ab0bd5866ff13aa7c17436220693a3d2d}{num\_tx\_desc};
862 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{igb_8c_a9c5d92d7861904dde94814d52798648f_icgraph}
\end{center}
\end{figure}


\index{igb.\+c@{igb.\+c}!igb\+\_\+setup\+\_\+transmit\+\_\+structures@{igb\+\_\+setup\+\_\+transmit\+\_\+structures}}
\index{igb\+\_\+setup\+\_\+transmit\+\_\+structures@{igb\+\_\+setup\+\_\+transmit\+\_\+structures}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{igb\+\_\+setup\+\_\+transmit\+\_\+structures(struct adapter $\ast$adapter)}{igb_setup_transmit_structures(struct adapter *adapter)}}]{\setlength{\rightskip}{0pt plus 5cm}static void igb\+\_\+setup\+\_\+transmit\+\_\+structures (
\begin{DoxyParamCaption}
\item[{struct {\bf adapter} $\ast$}]{adapter}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{igb_8c_ab90de8e2832d77cf89310e4e86f5bce3}{}\label{igb_8c_ab90de8e2832d77cf89310e4e86f5bce3}


igb.\+c 파일의 865 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
866 \{
867     \textcolor{keyword}{struct }\hyperlink{structtx__ring}{tx\_ring} *txr = adapter->\hyperlink{structadapter_aec689462327aa3bf0e8a73e7cca2ae55}{tx\_rings};
868     \textcolor{keywordtype}{int} i;
869 
870     \textcolor{keywordflow}{for} (i = 0; i < adapter->\hyperlink{structadapter_a8befb466d4a5a6a432dc1648230e0a65}{num\_queues}; i++, txr++)
871         \hyperlink{igb_8c_a9c5d92d7861904dde94814d52798648f}{igb\_setup\_transmit\_ring}(txr);
872 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=335pt]{igb_8c_ab90de8e2832d77cf89310e4e86f5bce3_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{igb_8c_ab90de8e2832d77cf89310e4e86f5bce3_icgraph}
\end{center}
\end{figure}


\index{igb.\+c@{igb.\+c}!igb\+\_\+suspend@{igb\+\_\+suspend}}
\index{igb\+\_\+suspend@{igb\+\_\+suspend}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{igb\+\_\+suspend(device\+\_\+t $\ast$dev)}{igb_suspend(device_t *dev)}}]{\setlength{\rightskip}{0pt plus 5cm}int igb\+\_\+suspend (
\begin{DoxyParamCaption}
\item[{{\bf device\+\_\+t} $\ast$}]{dev}
\end{DoxyParamCaption}
)}\hypertarget{igb_8c_a19a337cedcfe8b1bd0ad95b02764e0c2}{}\label{igb_8c_a19a337cedcfe8b1bd0ad95b02764e0c2}


igb.\+c 파일의 377 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
378 \{
379     \textcolor{keyword}{struct }\hyperlink{structadapter}{adapter} *\hyperlink{structadapter}{adapter};
380     \textcolor{keyword}{struct }\hyperlink{structtx__ring}{tx\_ring} *txr;
381     \textcolor{keyword}{struct }\hyperlink{structrx__ring}{rx\_ring} *rxr;
382     \textcolor{keyword}{struct }\hyperlink{structe1000__hw}{e1000\_hw} *hw;
383     \hyperlink{lib_2igb_2e1000__osdep_8h_a64e91c10a0d8fb627e92932050284264}{u32} txdctl, srrctl = 0;
384     \textcolor{keywordtype}{int} i;
385 
386     \textcolor{keywordflow}{if} (dev == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
387         \textcolor{keywordflow}{return} -EINVAL;
388     adapter = (\textcolor{keyword}{struct }adapter *)dev->\hyperlink{struct__device__t_ad517770dac2061381b2008850ff12e6c}{private\_data};
389     if (adapter == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
390         \textcolor{keywordflow}{return} -ENXIO;
391 
392     txr = adapter->\hyperlink{structadapter_aec689462327aa3bf0e8a73e7cca2ae55}{tx\_rings};
393     rxr = adapter->\hyperlink{structadapter_a59a5588ccfe1b0eefe45fcb9188b2f0a}{rx\_rings};
394     hw = &adapter->\hyperlink{structadapter_a7d5953861471302be6287c989e0b20ba}{hw};
395 
396     txdctl = 0;
397 
398     \textcolor{keywordflow}{if} (\hyperlink{igb_8c_a791fd0757e3ca1833df21ee94c17b855}{igb\_lock}(dev) != 0)
399         \textcolor{keywordflow}{return} errno;
400 
401     \textcolor{comment}{/* stop but don't reset the Tx Descriptor Rings */}
402     \textcolor{keywordflow}{for} (i = 0; i < adapter->\hyperlink{structadapter_a8befb466d4a5a6a432dc1648230e0a65}{num\_queues}; i++, txr++) \{
403         txdctl |= \hyperlink{kmod_2igb_2igb_8h_ae5f8a96fe2a307fc812058366eaae67e}{IGB\_TX\_PTHRESH};
404         txdctl |= \hyperlink{kmod_2igb_2igb_8h_ae6ac5557f89f50f4a26bb0ba541300bf}{IGB\_TX\_HTHRESH} << 8;
405         txdctl |= \hyperlink{igb__internal_8h_af2f5dce46d23dd6d692f9a5618bd5a51}{IGB\_TX\_WTHRESH} << 16;
406         \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_a8bf12553d73f6bac2b9a7845386357df}{E1000\_TXDCTL}(i), txdctl);
407         txr->\hyperlink{structtx__ring_ac2917164cdb60559cb6fb4367f48ca24}{queue\_status} = \hyperlink{igb__internal_8h_a9138123bbc894907c2c1bbea11e95c21}{IGB\_QUEUE\_IDLE};
408     \}
409 
410     srrctl |= 2048 >> \hyperlink{kmod_2igb_2e1000__82575_8h_a928a58e08843d4a88f81351ecd20611d}{E1000\_SRRCTL\_BSIZEPKT\_SHIFT};
411     srrctl |= \hyperlink{kmod_2igb_2e1000__82575_8h_a562fda6f95cf9dd4250bfba7e26154e5}{E1000\_SRRCTL\_DESCTYPE\_ADV\_ONEBUF};
412 
413     \textcolor{keywordflow}{for} (i = 0; i < adapter->\hyperlink{structadapter_a8befb466d4a5a6a432dc1648230e0a65}{num\_queues}; i++, rxr++) \{
414         \hyperlink{lib_2igb_2e1000__osdep_8h_a1d8f78f95a414480659f3182e6067b80}{u64} bus\_addr = rxr->\hyperlink{structrx__ring_a7b5f7d41a39b44612fd251f290500ba5}{rxdma}.\hyperlink{structresource_ac1f7f4ff311d1bc193e88d7cd3230bc6}{paddr};
415         \hyperlink{lib_2igb_2e1000__osdep_8h_a64e91c10a0d8fb627e92932050284264}{u32} rxdctl;
416 
417         \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_a17f1bb8471b4b2b1fb0470923048d2d3}{E1000\_RDLEN}(i),
418                 adapter->\hyperlink{structadapter_a7a36fc7297d99f6b73c4b6a194b33efd}{num\_rx\_desc} *
419                 \textcolor{keyword}{sizeof}(\textcolor{keyword}{union} \hyperlink{unione1000__adv__rx__desc}{e1000\_adv\_rx\_desc}));
420         \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_aaf1d5a8109540a3722cc498cca111a11}{E1000\_RDBAH}(i),
421                 (\hyperlink{parse_8c_a6eb1e68cc391dd753bc8ce896dbb8315}{uint32\_t})(bus\_addr >> 32));
422         \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_a9d831ba9f9151b22077f2a398ead76fd}{E1000\_RDBAL}(i),
423                 (\hyperlink{parse_8c_a6eb1e68cc391dd753bc8ce896dbb8315}{uint32\_t})bus\_addr);
424         \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_a80b27d5f09656b9586e29f25a9d35268}{E1000\_SRRCTL}(i), srrctl);
425         \textcolor{comment}{/* Enable this Queue */}
426         rxdctl = \hyperlink{kmod_2igb_2e1000__osdep_8h_a28390efdfdfb1e1cd1b033d021906a47}{E1000\_READ\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_a9563ac19965d3bd0892fd15f0c3a1dbd}{E1000\_RXDCTL}(i));
427         rxdctl |= \hyperlink{kmod_2igb_2e1000__82575_8h_a9260450cfb7c0bcfb1efc9c6ee010d85}{E1000\_RXDCTL\_QUEUE\_ENABLE};
428         rxdctl &= 0xFFF00000;
429         rxdctl |= \hyperlink{kmod_2igb_2igb_8h_a68bff36ef813c1553435f46e214a8f9b}{IGB\_RX\_PTHRESH};
430         rxdctl |= \hyperlink{kmod_2igb_2igb_8h_a6b7211566791a39b6add7fb096e4ceb7}{IGB\_RX\_HTHRESH} << 8;
431         rxdctl |= \hyperlink{kmod_2igb_2igb_8h_a84c26037da9675309cc9a5c357bc29bc}{IGB\_RX\_WTHRESH} << 16;
432         \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(hw, \hyperlink{kmod_2igb_2e1000__regs_8h_a9563ac19965d3bd0892fd15f0c3a1dbd}{E1000\_RXDCTL}(i), rxdctl);
433     \}
434 
435     \textcolor{keywordflow}{if} (\hyperlink{igb_8c_a4072fbeaba958ad7c81990de452139da}{igb\_unlock}(dev) != 0)
436         \textcolor{keywordflow}{return} errno;
437 
438     \textcolor{keywordflow}{return} 0;
439 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=250pt]{igb_8c_a19a337cedcfe8b1bd0ad95b02764e0c2_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{igb_8c_a19a337cedcfe8b1bd0ad95b02764e0c2_icgraph}
\end{center}
\end{figure}


\index{igb.\+c@{igb.\+c}!igb\+\_\+trigger@{igb\+\_\+trigger}}
\index{igb\+\_\+trigger@{igb\+\_\+trigger}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{igb\+\_\+trigger(device\+\_\+t $\ast$dev, u\+\_\+int32\+\_\+t data)}{igb_trigger(device_t *dev, u_int32_t data)}}]{\setlength{\rightskip}{0pt plus 5cm}void igb\+\_\+trigger (
\begin{DoxyParamCaption}
\item[{{\bf device\+\_\+t} $\ast$}]{dev, }
\item[{u\+\_\+int32\+\_\+t}]{data}
\end{DoxyParamCaption}
)}\hypertarget{igb_8c_a5864a4d842dc6705be6cb1f684d8c2b8}{}\label{igb_8c_a5864a4d842dc6705be6cb1f684d8c2b8}


igb.\+c 파일의 1101 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
1102 \{
1103     \textcolor{keyword}{struct }\hyperlink{structadapter}{adapter} *\hyperlink{structadapter}{adapter};
1104 
1105     \textcolor{keywordflow}{if} (dev == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
1106         \textcolor{keywordflow}{return};
1107 
1108     adapter = (\textcolor{keyword}{struct }adapter *)dev->\hyperlink{struct__device__t_ad517770dac2061381b2008850ff12e6c}{private\_data};
1109     if (adapter == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
1110         \textcolor{keywordflow}{return};
1111 
1112     \textcolor{keywordflow}{if} (\hyperlink{igb_8c_a791fd0757e3ca1833df21ee94c17b855}{igb\_lock}(dev) != 0)
1113         \textcolor{keywordflow}{return};
1114 
1115     \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(&(adapter->\hyperlink{structadapter_a7d5953861471302be6287c989e0b20ba}{hw}), \hyperlink{kmod_2igb_2e1000__regs_8h_a4cdcff696f12c6417679df91388abe66}{E1000\_WUS}, data);
1116     \textcolor{keywordflow}{if} (\hyperlink{igb_8c_a4072fbeaba958ad7c81990de452139da}{igb\_unlock}(dev) != 0)
1117         \textcolor{keywordflow}{return};
1118 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=241pt]{igb_8c_a5864a4d842dc6705be6cb1f684d8c2b8_cgraph}
\end{center}
\end{figure}


\index{igb.\+c@{igb.\+c}!igb\+\_\+tx\+\_\+ctx\+\_\+setup@{igb\+\_\+tx\+\_\+ctx\+\_\+setup}}
\index{igb\+\_\+tx\+\_\+ctx\+\_\+setup@{igb\+\_\+tx\+\_\+ctx\+\_\+setup}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{igb\+\_\+tx\+\_\+ctx\+\_\+setup(struct tx\+\_\+ring $\ast$txr, struct igb\+\_\+packet $\ast$packet)}{igb_tx_ctx_setup(struct tx_ring *txr, struct igb_packet *packet)}}]{\setlength{\rightskip}{0pt plus 5cm}static void igb\+\_\+tx\+\_\+ctx\+\_\+setup (
\begin{DoxyParamCaption}
\item[{struct {\bf tx\+\_\+ring} $\ast$}]{txr, }
\item[{struct {\bf igb\+\_\+packet} $\ast$}]{packet}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{igb_8c_aaa210ea8eb28fd252bc89ffd3491f863}{}\label{igb_8c_aaa210ea8eb28fd252bc89ffd3491f863}


igb.\+c 파일의 925 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
926 \{
927     \textcolor{keyword}{struct }\hyperlink{structadapter}{adapter} *\hyperlink{structadapter}{adapter} = txr->\hyperlink{structtx__ring_a807e6014970a3d469e197cd9ec25229c}{adapter};
928     \textcolor{keyword}{struct }\hyperlink{structe1000__adv__tx__context__desc}{e1000\_adv\_tx\_context\_desc} *TXD;
929     \textcolor{keyword}{struct }\hyperlink{structigb__tx__buffer}{igb\_tx\_buffer} *tx\_buffer;
930     \hyperlink{lib_2igb_2e1000__osdep_8h_a64e91c10a0d8fb627e92932050284264}{u32} type\_tucmd\_mlhl;
931     \textcolor{keywordtype}{int} ctxd;
932     u\_int64\_t remapped\_time;
933 
934     ctxd = txr->\hyperlink{structtx__ring_a11612fa87762d1d1e6a7eccfb865b805}{next\_avail\_desc};
935     tx\_buffer = &txr->\hyperlink{structtx__ring_a9b0485752fc6d8befa2f35ebd45710db}{tx\_buffers}[ctxd];
936     TXD = (\textcolor{keyword}{struct }\hyperlink{structe1000__adv__tx__context__desc}{e1000\_adv\_tx\_context\_desc} *) &txr->
      \hyperlink{structtx__ring_afcf2ae577a4363723c3403d160dd4d01}{tx\_base}[ctxd];
937 
938     type\_tucmd\_mlhl = \hyperlink{kmod_2igb_2e1000__82575_8h_a5c676340c307610ad3387349bdce7ee5}{E1000\_ADVTXD\_DCMD\_DEXT} | 
      \hyperlink{kmod_2igb_2e1000__82575_8h_a4f06aa66f910a2cc662ee6dec93b8307}{E1000\_ADVTXD\_DTYP\_CTXT};
939 
940     \textcolor{comment}{/* Now copy bits into descriptor */}
941     TXD->\hyperlink{structe1000__adv__tx__context__desc_a5a8c54c0a1c30c075af11263ab99321d}{vlan\_macip\_lens} = 0;
942     TXD->\hyperlink{structe1000__adv__tx__context__desc_a251c33f69d1fa3c146567989e12b0a01}{type\_tucmd\_mlhl} = htole32(type\_tucmd\_mlhl);
943     TXD->\hyperlink{structe1000__adv__tx__context__desc_aeccd92c709cb5d406170f00d06c9121b}{mss\_l4len\_idx} = 0;
944 
945     \textcolor{comment}{/* remap the 64-bit nsec time to the value represented in the desc */}
946     remapped\_time = packet->\hyperlink{structigb__packet_a7f67203ca8a69ba9e8d49e1233601ff6}{attime} - ((packet->\hyperlink{structigb__packet_a7f67203ca8a69ba9e8d49e1233601ff6}{attime} / 1000000000) *
947                       1000000000);
948 
949     remapped\_time /= 32; \textcolor{comment}{/* scale to 32 nsec increments */}
950 
951     TXD->\hyperlink{structe1000__adv__tx__context__desc_aef3db1466b2e6df9cc3ddcb45f125097}{seqnum\_seed} = remapped\_time;
952 
953     tx\_buffer->\hyperlink{structigb__tx__buffer_ac6186670bb595d9f22c89b6dc2779d14}{packet} = \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
954     tx\_buffer->\hyperlink{structigb__tx__buffer_af565101ee13ca100904a7ac5b7564a3d}{next\_eop} = -1;
955 
956 
957     \textcolor{comment}{/* We've consumed the first desc, adjust counters */}
958     \textcolor{keywordflow}{if} (++ctxd == adapter->\hyperlink{structadapter_ab0bd5866ff13aa7c17436220693a3d2d}{num\_tx\_desc})
959         ctxd = 0;
960     txr->\hyperlink{structtx__ring_a11612fa87762d1d1e6a7eccfb865b805}{next\_avail\_desc} = ctxd;
961     --txr->\hyperlink{structtx__ring_a3f8acb3cacc1230f5a5b78b1b6cf7c2a}{tx\_avail};
962 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{igb_8c_aaa210ea8eb28fd252bc89ffd3491f863_icgraph}
\end{center}
\end{figure}


\index{igb.\+c@{igb.\+c}!igb\+\_\+unlock@{igb\+\_\+unlock}}
\index{igb\+\_\+unlock@{igb\+\_\+unlock}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{igb\+\_\+unlock(device\+\_\+t $\ast$dev)}{igb_unlock(device_t *dev)}}]{\setlength{\rightskip}{0pt plus 5cm}int igb\+\_\+unlock (
\begin{DoxyParamCaption}
\item[{{\bf device\+\_\+t} $\ast$}]{dev}
\end{DoxyParamCaption}
)}\hypertarget{igb_8c_a4072fbeaba958ad7c81990de452139da}{}\label{igb_8c_a4072fbeaba958ad7c81990de452139da}


igb.\+c 파일의 1191 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
1192 \{
1193     \textcolor{keyword}{struct }\hyperlink{structadapter}{adapter} *\hyperlink{structadapter}{adapter};
1194 
1195     \textcolor{keywordflow}{if} (dev == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
1196         \textcolor{keywordflow}{return} -ENODEV;
1197 
1198     adapter = (\textcolor{keyword}{struct }adapter *)dev->\hyperlink{struct__device__t_ad517770dac2061381b2008850ff12e6c}{private\_data};
1199     if (adapter == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
1200         \textcolor{keywordflow}{return} -ENXIO;
1201 
1202     \textcolor{keywordflow}{if} (!adapter->\hyperlink{structadapter_ac26455511b5639f92b1eadeae2f8e20e}{memlock})
1203         \textcolor{keywordflow}{return} -ENXIO;
1204 
1205     \textcolor{keywordflow}{return} pthread\_mutex\_unlock(adapter->\hyperlink{structadapter_ac26455511b5639f92b1eadeae2f8e20e}{memlock});
1206 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=550pt]{igb_8c_a4072fbeaba958ad7c81990de452139da_icgraph}
\end{center}
\end{figure}


\index{igb.\+c@{igb.\+c}!igb\+\_\+writereg@{igb\+\_\+writereg}}
\index{igb\+\_\+writereg@{igb\+\_\+writereg}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{igb\+\_\+writereg(device\+\_\+t $\ast$dev, u\+\_\+int32\+\_\+t reg, u\+\_\+int32\+\_\+t data)}{igb_writereg(device_t *dev, u_int32_t reg, u_int32_t data)}}]{\setlength{\rightskip}{0pt plus 5cm}void igb\+\_\+writereg (
\begin{DoxyParamCaption}
\item[{{\bf device\+\_\+t} $\ast$}]{dev, }
\item[{u\+\_\+int32\+\_\+t}]{reg, }
\item[{u\+\_\+int32\+\_\+t}]{data}
\end{DoxyParamCaption}
)}\hypertarget{igb_8c_a5ad072e861f3e0a4d595da0629ee71b7}{}\label{igb_8c_a5ad072e861f3e0a4d595da0629ee71b7}


igb.\+c 파일의 1120 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
1121 \{
1122     \textcolor{keyword}{struct }\hyperlink{structadapter}{adapter} *\hyperlink{structadapter}{adapter};
1123 
1124     \textcolor{keywordflow}{if} (dev == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
1125         \textcolor{keywordflow}{return};
1126 
1127     adapter = (\textcolor{keyword}{struct }adapter *)dev->\hyperlink{struct__device__t_ad517770dac2061381b2008850ff12e6c}{private\_data};
1128     if (adapter == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
1129         \textcolor{keywordflow}{return};
1130 
1131     \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(&(adapter->\hyperlink{structadapter_a7d5953861471302be6287c989e0b20ba}{hw}), reg, data);
1132 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{igb_8c_a5ad072e861f3e0a4d595da0629ee71b7_icgraph}
\end{center}
\end{figure}


\index{igb.\+c@{igb.\+c}!igb\+\_\+xmit@{igb\+\_\+xmit}}
\index{igb\+\_\+xmit@{igb\+\_\+xmit}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{igb\+\_\+xmit(device\+\_\+t $\ast$dev, unsigned int queue\+\_\+index, struct igb\+\_\+packet $\ast$packet)}{igb_xmit(device_t *dev, unsigned int queue_index, struct igb_packet *packet)}}]{\setlength{\rightskip}{0pt plus 5cm}int igb\+\_\+xmit (
\begin{DoxyParamCaption}
\item[{{\bf device\+\_\+t} $\ast$}]{dev, }
\item[{unsigned int}]{queue\+\_\+index, }
\item[{struct {\bf igb\+\_\+packet} $\ast$}]{packet}
\end{DoxyParamCaption}
)}\hypertarget{igb_8c_a6c8e23bd2a93ab63646fd498ac8e2127}{}\label{igb_8c_a6c8e23bd2a93ab63646fd498ac8e2127}


igb.\+c 파일의 976 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
977 \{
978     \textcolor{keyword}{struct }\hyperlink{structadapter}{adapter} *\hyperlink{structadapter}{adapter};
979     \textcolor{keyword}{struct }\hyperlink{structtx__ring}{tx\_ring} *txr;
980     \textcolor{keyword}{struct }\hyperlink{structigb__tx__buffer}{igb\_tx\_buffer} *tx\_buffer;
981     \textcolor{keyword}{union }\hyperlink{unione1000__adv__tx__desc}{e1000\_adv\_tx\_desc} *txd = \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
982     \hyperlink{lib_2igb_2e1000__osdep_8h_a64e91c10a0d8fb627e92932050284264}{u32} \hyperlink{unione1000__adv__tx__desc_a4cb6b6e659b19e9e2254f5aca281ad64}{cmd\_type\_len}, \hyperlink{unione1000__adv__tx__desc_a818b8293604ff9a71784eb27809bb907}{olinfo\_status} = 0;
983     \textcolor{keywordtype}{int} i, first, last = 0;
984     \textcolor{keywordtype}{int} error = 0;
985 
986     \textcolor{keywordflow}{if} (dev == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
987         \textcolor{keywordflow}{return} -EINVAL;
988 
989     adapter = (\textcolor{keyword}{struct }adapter *)dev->\hyperlink{struct__device__t_ad517770dac2061381b2008850ff12e6c}{private\_data};
990     if (adapter == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
991         \textcolor{keywordflow}{return} -ENXIO;
992 
993     txr = &adapter->\hyperlink{structadapter_aec689462327aa3bf0e8a73e7cca2ae55}{tx\_rings}[queue\_index];
994     \textcolor{keywordflow}{if} (!txr)
995         \textcolor{keywordflow}{return} -EINVAL;
996 
997     \textcolor{keywordflow}{if} (queue\_index > adapter->\hyperlink{structadapter_a8befb466d4a5a6a432dc1648230e0a65}{num\_queues})
998         \textcolor{keywordflow}{return} -EINVAL;
999 
1000     \textcolor{keywordflow}{if} (packet == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
1001         \textcolor{keywordflow}{return} -EINVAL;
1002 
1003     \textcolor{keywordflow}{if} (\hyperlink{igb_8c_a791fd0757e3ca1833df21ee94c17b855}{igb\_lock}(dev) != 0)
1004         \textcolor{keywordflow}{return} errno;
1005 
1006     packet->\hyperlink{structigb__packet_a1a20432d28f575630a2562c1c728a40f}{next} = \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}; \textcolor{comment}{/* used for cleanup */}
1007 
1008     \textcolor{comment}{/* Set basic descriptor constants */}
1009     cmd\_type\_len = \hyperlink{kmod_2igb_2e1000__82575_8h_af1119c378640adccff025940beea0eb8}{E1000\_ADVTXD\_DTYP\_DATA};
1010     cmd\_type\_len |= \hyperlink{kmod_2igb_2e1000__82575_8h_a9850ab08c96d0c82e399b20aea196730}{E1000\_ADVTXD\_DCMD\_IFCS} | 
      \hyperlink{kmod_2igb_2e1000__82575_8h_a5c676340c307610ad3387349bdce7ee5}{E1000\_ADVTXD\_DCMD\_DEXT};
1011 
1012     \textcolor{comment}{/* cmd\_type\_len |= E1000\_ADVTXD\_DCMD\_VLE; to enable VLAN insertion */}
1013 
1014     \textcolor{comment}{/*}
1015 \textcolor{comment}{     * Map the packet for DMA}
1016 \textcolor{comment}{     *}
1017 \textcolor{comment}{     * Capture the first descriptor index,}
1018 \textcolor{comment}{     * this descriptor will have the index}
1019 \textcolor{comment}{     * of the EOP which is the only one that}
1020 \textcolor{comment}{     * now gets a DONE bit writeback.}
1021 \textcolor{comment}{     */}
1022     first = txr->\hyperlink{structtx__ring_a11612fa87762d1d1e6a7eccfb865b805}{next\_avail\_desc};
1023     tx\_buffer = &txr->\hyperlink{structtx__ring_a9b0485752fc6d8befa2f35ebd45710db}{tx\_buffers}[first];
1024 
1025     \textcolor{comment}{/*}
1026 \textcolor{comment}{     * Make sure we don't overrun the ring,}
1027 \textcolor{comment}{     * we need nsegs descriptors and one for}
1028 \textcolor{comment}{     * the context descriptor used for the}
1029 \textcolor{comment}{     * offloads.}
1030 \textcolor{comment}{     */}
1031     \textcolor{keywordflow}{if} (txr->\hyperlink{structtx__ring_a3f8acb3cacc1230f5a5b78b1b6cf7c2a}{tx\_avail} <= 2) \{
1032         error = ENOSPC;
1033         \textcolor{keywordflow}{goto} unlock;
1034     \}
1035 
1036     \textcolor{comment}{/*}
1037 \textcolor{comment}{     * Set up the context descriptor to specify}
1038 \textcolor{comment}{     * launchtimes for the packet.}
1039 \textcolor{comment}{     */}
1040     \hyperlink{igb_8c_aaa210ea8eb28fd252bc89ffd3491f863}{igb\_tx\_ctx\_setup}(txr, packet);
1041 
1042     \textcolor{comment}{/*}
1043 \textcolor{comment}{     * for performance monitoring, report the DMA time of the tx desc wb}
1044 \textcolor{comment}{     */}
1045     olinfo\_status |= \hyperlink{lib_2igb_2e1000__defines_8h_a673fc68ace11cca3435d58fdf1d0ba34}{E1000\_TXD\_DMA\_TXDWB};
1046 
1047     \textcolor{comment}{/* set payload length */}
1048     olinfo\_status |= packet->\hyperlink{structigb__packet_a0c5f469bd681fb46e6f4203d5338e99f}{len} << \hyperlink{kmod_2igb_2e1000__82575_8h_a90a7ff976dc2df4f79f1c8f69ef8f566}{E1000\_ADVTXD\_PAYLEN\_SHIFT};
1049 
1050     \textcolor{comment}{/* Set up our transmit descriptors */}
1051     i = txr->\hyperlink{structtx__ring_a11612fa87762d1d1e6a7eccfb865b805}{next\_avail\_desc};
1052 
1053     \textcolor{comment}{/* we assume every packet is contiguous */}
1054 
1055     tx\_buffer = &txr->\hyperlink{structtx__ring_a9b0485752fc6d8befa2f35ebd45710db}{tx\_buffers}[i];
1056     txd = (\textcolor{keyword}{union }\hyperlink{unione1000__adv__tx__desc}{e1000\_adv\_tx\_desc} *)&txr->\hyperlink{structtx__ring_afcf2ae577a4363723c3403d160dd4d01}{tx\_base}[i];
1057 
1058     txd->\hyperlink{unione1000__adv__tx__desc_ac2e42c3635da1c7c222910caff36e03a}{read}.\hyperlink{unione1000__adv__tx__desc_a87d79130b57fb21eedf04b9d3945c3d6}{buffer\_addr} = htole64(packet->\hyperlink{structigb__packet_a1134ed5d4a74917c76b796e82cd4206f}{map}.\hyperlink{structresource_ac1f7f4ff311d1bc193e88d7cd3230bc6}{paddr} + packet->
      \hyperlink{structigb__packet_a29b5297d3393519050e3126c4cb07c1c}{offset});
1059     txd->\hyperlink{unione1000__adv__tx__desc_ac2e42c3635da1c7c222910caff36e03a}{read}.\hyperlink{unione1000__adv__tx__desc_a4cb6b6e659b19e9e2254f5aca281ad64}{cmd\_type\_len} = htole32(cmd\_type\_len | packet->\hyperlink{structigb__packet_a0c5f469bd681fb46e6f4203d5338e99f}{len});
1060     txd->\hyperlink{unione1000__adv__tx__desc_ac2e42c3635da1c7c222910caff36e03a}{read}.\hyperlink{unione1000__adv__tx__desc_a818b8293604ff9a71784eb27809bb907}{olinfo\_status} = htole32(olinfo\_status);
1061     last = i;
1062     \textcolor{keywordflow}{if} (++i == adapter->\hyperlink{structadapter_ab0bd5866ff13aa7c17436220693a3d2d}{num\_tx\_desc})
1063         i = 0;
1064     tx\_buffer->\hyperlink{structigb__tx__buffer_ac6186670bb595d9f22c89b6dc2779d14}{packet} = \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
1065     tx\_buffer->\hyperlink{structigb__tx__buffer_af565101ee13ca100904a7ac5b7564a3d}{next\_eop} = -1;
1066 
1067     txr->\hyperlink{structtx__ring_a11612fa87762d1d1e6a7eccfb865b805}{next\_avail\_desc} = i;
1068     txr->\hyperlink{structtx__ring_a3f8acb3cacc1230f5a5b78b1b6cf7c2a}{tx\_avail}--;
1069     tx\_buffer->\hyperlink{structigb__tx__buffer_ac6186670bb595d9f22c89b6dc2779d14}{packet} = packet;
1070 
1071     \textcolor{comment}{/*}
1072 \textcolor{comment}{     * Last Descriptor of Packet}
1073 \textcolor{comment}{     * needs End Of Packet (EOP)}
1074 \textcolor{comment}{     * and Report Status (RS)}
1075 \textcolor{comment}{     */}
1076     txd->\hyperlink{unione1000__adv__tx__desc_ac2e42c3635da1c7c222910caff36e03a}{read}.\hyperlink{unione1000__adv__tx__desc_a4cb6b6e659b19e9e2254f5aca281ad64}{cmd\_type\_len} |=
1077         htole32(\hyperlink{kmod_2igb_2e1000__82575_8h_a37abcf117660bf86dc532dea2f6dcdeb}{E1000\_ADVTXD\_DCMD\_EOP} | 
      \hyperlink{kmod_2igb_2e1000__82575_8h_acf70c67afff0cdbb066133d078c86eaa}{E1000\_ADVTXD\_DCMD\_RS});
1078 
1079     \textcolor{comment}{/*}
1080 \textcolor{comment}{     * Keep track in the first buffer which}
1081 \textcolor{comment}{     * descriptor will be written back}
1082 \textcolor{comment}{     */}
1083     tx\_buffer = &txr->\hyperlink{structtx__ring_a9b0485752fc6d8befa2f35ebd45710db}{tx\_buffers}[first];
1084     tx\_buffer->\hyperlink{structigb__tx__buffer_af565101ee13ca100904a7ac5b7564a3d}{next\_eop} = last;
1085 
1086     \textcolor{comment}{/*}
1087 \textcolor{comment}{     * Advance the Transmit Descriptor Tail (TDT), this tells the E1000}
1088 \textcolor{comment}{     * that this frame is available to transmit.}
1089 \textcolor{comment}{     */}
1090 
1091     \hyperlink{kmod_2igb_2e1000__osdep_8h_a1abfc0be38040f1742629204b6e61865}{E1000\_WRITE\_REG}(&adapter->\hyperlink{structadapter_a7d5953861471302be6287c989e0b20ba}{hw}, \hyperlink{kmod_2igb_2e1000__regs_8h_a1f489d0247c236b2a8fe28141377f69c}{E1000\_TDT}(txr->\hyperlink{structtx__ring_af754e6af13b532f2bebcaa3828ea795c}{me}), i);
1092     ++txr->\hyperlink{structtx__ring_aecff768191caa8237ae27ddfac500aaa}{tx\_packets};
1093 
1094 unlock:
1095     \textcolor{keywordflow}{if} (\hyperlink{igb_8c_a4072fbeaba958ad7c81990de452139da}{igb\_unlock}(dev) != 0)
1096         \textcolor{keywordflow}{return} errno;
1097 
1098     \textcolor{keywordflow}{return} error;
1099 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=260pt]{igb_8c_a6c8e23bd2a93ab63646fd498ac8e2127_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{igb_8c_a6c8e23bd2a93ab63646fd498ac8e2127_icgraph}
\end{center}
\end{figure}


\index{igb.\+c@{igb.\+c}!rdtscpll@{rdtscpll}}
\index{rdtscpll@{rdtscpll}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{rdtscpll(uint64\+\_\+t $\ast$val)}{rdtscpll(uint64_t *val)}}]{\setlength{\rightskip}{0pt plus 5cm}static void rdtscpll (
\begin{DoxyParamCaption}
\item[{{\bf uint64\+\_\+t} $\ast$}]{val}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{igb_8c_aa7a036d8ae3af2ea70fb4cbdf1f25fbd}{}\label{igb_8c_aa7a036d8ae3af2ea70fb4cbdf1f25fbd}


igb.\+c 파일의 1843 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
1844 \{
1845     \hyperlink{parse_8c_a6eb1e68cc391dd753bc8ce896dbb8315}{uint32\_t} high, low;
1846 
1847     \_\_asm\_\_ \_\_volatile\_\_(\textcolor{stringliteral}{"lfence;"}
1848                           \textcolor{stringliteral}{"rdtsc;"}
1849                           : \textcolor{stringliteral}{"=d"}(high), \textcolor{stringliteral}{"=a"}(low)
1850                           :
1851                           : \textcolor{stringliteral}{"memory"});
1852     *val = high;
1853     *val = (*val << 32) | low;
1854 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=332pt]{igb_8c_aa7a036d8ae3af2ea70fb4cbdf1f25fbd_icgraph}
\end{center}
\end{figure}


\index{igb.\+c@{igb.\+c}!timespec\+\_\+addns@{timespec\+\_\+addns}}
\index{timespec\+\_\+addns@{timespec\+\_\+addns}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{timespec\+\_\+addns(struct timespec $\ast$a, unsigned long addns)}{timespec_addns(struct timespec *a, unsigned long addns)}}]{\setlength{\rightskip}{0pt plus 5cm}struct timespec timespec\+\_\+addns (
\begin{DoxyParamCaption}
\item[{struct timespec $\ast$}]{a, }
\item[{unsigned long}]{addns}
\end{DoxyParamCaption}
)}\hypertarget{igb_8c_a83c184a21a1b1cceb3a3229e9f165245}{}\label{igb_8c_a83c184a21a1b1cceb3a3229e9f165245}


igb.\+c 파일의 1937 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
1938 \{
1939     a->tv\_nsec = a->tv\_nsec + (addns % 1000000000);
1940     \textcolor{keywordflow}{if} (a->tv\_nsec > 1000000000) \{
1941         \textcolor{comment}{/* carry */}
1942         a->tv\_nsec -= 1000000000;
1943         ++a->tv\_sec;
1944     \}
1945 
1946     a->tv\_sec = a->tv\_sec + addns/1000000000;
1947     \textcolor{keywordflow}{return} *a;
1948 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=271pt]{igb_8c_a83c184a21a1b1cceb3a3229e9f165245_icgraph}
\end{center}
\end{figure}


\index{igb.\+c@{igb.\+c}!timespec\+\_\+subtract@{timespec\+\_\+subtract}}
\index{timespec\+\_\+subtract@{timespec\+\_\+subtract}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{timespec\+\_\+subtract(struct timespec $\ast$a, struct timespec $\ast$b)}{timespec_subtract(struct timespec *a, struct timespec *b)}}]{\setlength{\rightskip}{0pt plus 5cm}struct timespec timespec\+\_\+subtract (
\begin{DoxyParamCaption}
\item[{struct timespec $\ast$}]{a, }
\item[{struct timespec $\ast$}]{b}
\end{DoxyParamCaption}
)}\hypertarget{igb_8c_ab85ff62741520edc013979580b140b56}{}\label{igb_8c_ab85ff62741520edc013979580b140b56}


igb.\+c 파일의 1924 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
1925 \{
1926     a->tv\_nsec = a->tv\_nsec - b->tv\_nsec;
1927     \textcolor{keywordflow}{if} (a->tv\_nsec < 0) \{
1928         \textcolor{comment}{/* borrow */}
1929         a->tv\_nsec += 1000000000;
1930         --a->tv\_sec;
1931     \}
1932 
1933     a->tv\_sec = a->tv\_sec - b->tv\_sec;
1934     \textcolor{keywordflow}{return} *a;
1935 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=280pt]{igb_8c_ab85ff62741520edc013979580b140b56_icgraph}
\end{center}
\end{figure}


\index{igb.\+c@{igb.\+c}!T\+S2\+NS@{T\+S2\+NS}}
\index{T\+S2\+NS@{T\+S2\+NS}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{T\+S2\+N\+S(struct timespec ts)}{TS2NS(struct timespec ts)}}]{\setlength{\rightskip}{0pt plus 5cm}static u\+\_\+int32\+\_\+t T\+S2\+NS (
\begin{DoxyParamCaption}
\item[{struct timespec}]{ts}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{igb_8c_a4b64a260ae06308aa59a1cc415b605fd}{}\label{igb_8c_a4b64a260ae06308aa59a1cc415b605fd}


igb.\+c 파일의 1950 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
1951 \{
1952     \textcolor{keywordflow}{return} ((ts.tv\_sec*1000000000)+ts.tv\_nsec);
1953 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=232pt]{igb_8c_a4b64a260ae06308aa59a1cc415b605fd_icgraph}
\end{center}
\end{figure}




\subsection{변수 문서화}
\index{igb.\+c@{igb.\+c}!igb\+\_\+vendor\+\_\+info\+\_\+array@{igb\+\_\+vendor\+\_\+info\+\_\+array}}
\index{igb\+\_\+vendor\+\_\+info\+\_\+array@{igb\+\_\+vendor\+\_\+info\+\_\+array}!igb.\+c@{igb.\+c}}
\subsubsection[{\texorpdfstring{igb\+\_\+vendor\+\_\+info\+\_\+array}{igb_vendor_info_array}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf igb\+\_\+vendor\+\_\+info\+\_\+t} igb\+\_\+vendor\+\_\+info\+\_\+array\mbox{[}$\,$\mbox{]}\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{igb_8c_a9519a91bae2a9829950d6c2b88a7cd26}{}\label{igb_8c_a9519a91bae2a9829950d6c2b88a7cd26}
{\bfseries 초기값\+:}
\begin{DoxyCode}
= \{
    \{ 0x8086, \hyperlink{kmod_2igb_2e1000__hw_8h_a6ef33013b15c6f54c68ca8ee78d6558c}{E1000\_DEV\_ID\_I210\_COPPER}, \hyperlink{igb__internal_8h_a13e5db1ce39cc8d13a6747e95e355275}{PCI\_ANY\_ID}, 
      \hyperlink{igb__internal_8h_a13e5db1ce39cc8d13a6747e95e355275}{PCI\_ANY\_ID}, 0\},
    \{ 0x8086, \hyperlink{kmod_2igb_2e1000__hw_8h_aee2f070891e957588cd19b7ec16ae7cb}{E1000\_DEV\_ID\_I210\_COPPER\_FLASHLESS},
        \hyperlink{igb__internal_8h_a13e5db1ce39cc8d13a6747e95e355275}{PCI\_ANY\_ID}, \hyperlink{igb__internal_8h_a13e5db1ce39cc8d13a6747e95e355275}{PCI\_ANY\_ID}, 0\},
    \{ 0x8086, \hyperlink{kmod_2igb_2e1000__hw_8h_af7b9318c02cca76b24800edb23f550ea}{E1000\_DEV\_ID\_I210\_COPPER\_IT}, \hyperlink{igb__internal_8h_a13e5db1ce39cc8d13a6747e95e355275}{PCI\_ANY\_ID}, 
      \hyperlink{igb__internal_8h_a13e5db1ce39cc8d13a6747e95e355275}{PCI\_ANY\_ID}, 0\},
    \{ 0x8086, \hyperlink{kmod_2igb_2e1000__hw_8h_a21c09e5e53d69e63d266c0af68ead59a}{E1000\_DEV\_ID\_I210\_COPPER\_OEM1},
        \hyperlink{igb__internal_8h_a13e5db1ce39cc8d13a6747e95e355275}{PCI\_ANY\_ID}, \hyperlink{igb__internal_8h_a13e5db1ce39cc8d13a6747e95e355275}{PCI\_ANY\_ID}, 0\},
    \{ 0x8086, \hyperlink{kmod_2igb_2e1000__hw_8h_ab61426ff738177c7c6f789477c64f53c}{E1000\_DEV\_ID\_I210\_FIBER}, \hyperlink{igb__internal_8h_a13e5db1ce39cc8d13a6747e95e355275}{PCI\_ANY\_ID}, 
      \hyperlink{igb__internal_8h_a13e5db1ce39cc8d13a6747e95e355275}{PCI\_ANY\_ID}, 0\},
    \{ 0x8086, \hyperlink{kmod_2igb_2e1000__hw_8h_a04906351eeddabd96f5be8c3da71ff68}{E1000\_DEV\_ID\_I210\_SERDES}, \hyperlink{igb__internal_8h_a13e5db1ce39cc8d13a6747e95e355275}{PCI\_ANY\_ID}, 
      \hyperlink{igb__internal_8h_a13e5db1ce39cc8d13a6747e95e355275}{PCI\_ANY\_ID}, 0\},
    \{ 0x8086, \hyperlink{kmod_2igb_2e1000__hw_8h_a7f2f322249c33d6bf280ca5797495732}{E1000\_DEV\_ID\_I210\_SERDES\_FLASHLESS},
        \hyperlink{igb__internal_8h_a13e5db1ce39cc8d13a6747e95e355275}{PCI\_ANY\_ID}, \hyperlink{igb__internal_8h_a13e5db1ce39cc8d13a6747e95e355275}{PCI\_ANY\_ID}, 0\},
    \{ 0x8086, \hyperlink{kmod_2igb_2e1000__hw_8h_aee379281a69dffb77588be761aec1a95}{E1000\_DEV\_ID\_I210\_SGMII}, \hyperlink{igb__internal_8h_a13e5db1ce39cc8d13a6747e95e355275}{PCI\_ANY\_ID}, 
      \hyperlink{igb__internal_8h_a13e5db1ce39cc8d13a6747e95e355275}{PCI\_ANY\_ID}, 0\},
    \{ 0x8086, \hyperlink{kmod_2igb_2e1000__hw_8h_a18dbf291d9922d8dd01b1136bac39da0}{E1000\_DEV\_ID\_I210\_AUTOMOTIVE}, 
      \hyperlink{igb__internal_8h_a13e5db1ce39cc8d13a6747e95e355275}{PCI\_ANY\_ID}, \hyperlink{igb__internal_8h_a13e5db1ce39cc8d13a6747e95e355275}{PCI\_ANY\_ID}, 0\},
    
    \{ 0, 0, 0, 0, 0\}
\}
\end{DoxyCode}


igb.\+c 파일의 70 번째 라인에서 정의되었습니다.

