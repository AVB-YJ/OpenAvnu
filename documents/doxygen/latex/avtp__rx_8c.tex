\hypertarget{avtp__rx_8c}{}\section{lib/avtp\+\_\+pipeline/platform/\+Linux/rawsock/avtp\+\_\+rx.c 파일 참조}
\label{avtp__rx_8c}\index{lib/avtp\+\_\+pipeline/platform/\+Linux/rawsock/avtp\+\_\+rx.\+c@{lib/avtp\+\_\+pipeline/platform/\+Linux/rawsock/avtp\+\_\+rx.\+c}}
{\ttfamily \#include $<$stdlib.\+h$>$}\\*
{\ttfamily \#include $<$stdio.\+h$>$}\\*
{\ttfamily \#include $<$ctype.\+h$>$}\\*
{\ttfamily \#include $<$glib.\+h$>$}\\*
{\ttfamily \#include \char`\"{}openavb\+\_\+rawsock.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}openavb\+\_\+avtp.\+h\char`\"{}}\\*
avtp\+\_\+rx.\+c에 대한 include 의존 그래프
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{avtp__rx_8c__incl}
\end{center}
\end{figure}
\subsection*{매크로}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{avtp__rx_8c_a4c04f59831e0bea1d495e08237bb816b}{M\+A\+X\+\_\+\+N\+U\+M\+\_\+\+F\+R\+A\+M\+ES}~10
\item 
\#define \hyperlink{avtp__rx_8c_a876704225d1c5ecd8b0fc85315f88397}{N\+U\+M\+\_\+\+S\+T\+R\+E\+A\+MS}~256
\item 
\#define \hyperlink{avtp__rx_8c_aad8560c5d8b6b834271c0f40e3854be9}{R\+E\+P\+O\+R\+T\+\_\+\+S\+E\+C\+O\+N\+DS}~10
\end{DoxyCompactItemize}
\subsection*{함수}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{avtp__rx_8c_a51c5f18b7b31155a1957e1997bcd85da}{timespec\+\_\+cmp} (struct timespec $\ast$a, struct timespec $\ast$b)
\item 
void \hyperlink{avtp__rx_8c_a1fef2c2f282fced8ca994f549332d361}{dump\+Ascii} (\hyperlink{openavb__types__base__pub_8h_aa63ef7b996d5487ce35a5a66601f3e73}{U8} $\ast$p\+Frame, int i, int $\ast$j)
\item 
void \hyperlink{avtp__rx_8c_a0313c4c55e50cead2ef49d50f4fbe8ec}{dump\+Frame\+Content} (\hyperlink{openavb__types__base__pub_8h_aa63ef7b996d5487ce35a5a66601f3e73}{U8} $\ast$p\+Frame, \hyperlink{openavb__types__base__pub_8h_a696390429f2f3b644bde8d0322a24124}{U32} len)
\item 
void \hyperlink{avtp__rx_8c_a93d6cb62eaeaf41d16b18a13e0386f03}{dump\+Frame} (\hyperlink{openavb__types__base__pub_8h_aa63ef7b996d5487ce35a5a66601f3e73}{U8} $\ast$p\+Frame, \hyperlink{openavb__types__base__pub_8h_a696390429f2f3b644bde8d0322a24124}{U32} len, \hyperlink{structhdr__info__t}{hdr\+\_\+info\+\_\+t} $\ast$hdr)
\item 
int \hyperlink{avtp__rx_8c_a0ddf1224851353fc92bfbff6f499fa97}{main} (int argc, char $\ast$argv\mbox{[}$\,$\mbox{]})
\end{DoxyCompactItemize}
\subsection*{변수}
\begin{DoxyCompactItemize}
\item 
static int \hyperlink{avtp__rx_8c_af3d6d4ec5b93edfddc9de51233ae9f7e}{ethertype} = \hyperlink{rawsock__impl_8h_a07fb0f2498c8b8dd62cc44da13bb092a}{E\+T\+H\+E\+R\+T\+Y\+P\+E\+\_\+8021Q}
\item 
static \hyperlink{avb__gptp_8h_af6a258d8f3ee5206d682d799316314b1}{bool} \hyperlink{avtp__rx_8c_acf182b7b2127314d5d00c6df827734b5}{b\+Running} = \hyperlink{lib_2igb_2e1000__osdep_8h_aa8cecfc5c5c054d2875c03e77b7be15d}{T\+R\+UE}
\item 
static char $\ast$ \hyperlink{avtp__rx_8c_af663a7576d2f8f288bb3996381484cd3}{interface} = \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{N\+U\+LL}
\item 
static G\+Option\+Entry \hyperlink{avtp__rx_8c_a76565232f25302e8cb99c60a629034cc}{entries} \mbox{[}$\,$\mbox{]}
\end{DoxyCompactItemize}


\subsection{매크로 문서화}
\index{avtp\+\_\+rx.\+c@{avtp\+\_\+rx.\+c}!M\+A\+X\+\_\+\+N\+U\+M\+\_\+\+F\+R\+A\+M\+ES@{M\+A\+X\+\_\+\+N\+U\+M\+\_\+\+F\+R\+A\+M\+ES}}
\index{M\+A\+X\+\_\+\+N\+U\+M\+\_\+\+F\+R\+A\+M\+ES@{M\+A\+X\+\_\+\+N\+U\+M\+\_\+\+F\+R\+A\+M\+ES}!avtp\+\_\+rx.\+c@{avtp\+\_\+rx.\+c}}
\subsubsection[{\texorpdfstring{M\+A\+X\+\_\+\+N\+U\+M\+\_\+\+F\+R\+A\+M\+ES}{MAX_NUM_FRAMES}}]{\setlength{\rightskip}{0pt plus 5cm}\#define M\+A\+X\+\_\+\+N\+U\+M\+\_\+\+F\+R\+A\+M\+ES~10}\hypertarget{avtp__rx_8c_a4c04f59831e0bea1d495e08237bb816b}{}\label{avtp__rx_8c_a4c04f59831e0bea1d495e08237bb816b}


avtp\+\_\+rx.\+c 파일의 44 번째 라인에서 정의되었습니다.

\index{avtp\+\_\+rx.\+c@{avtp\+\_\+rx.\+c}!N\+U\+M\+\_\+\+S\+T\+R\+E\+A\+MS@{N\+U\+M\+\_\+\+S\+T\+R\+E\+A\+MS}}
\index{N\+U\+M\+\_\+\+S\+T\+R\+E\+A\+MS@{N\+U\+M\+\_\+\+S\+T\+R\+E\+A\+MS}!avtp\+\_\+rx.\+c@{avtp\+\_\+rx.\+c}}
\subsubsection[{\texorpdfstring{N\+U\+M\+\_\+\+S\+T\+R\+E\+A\+MS}{NUM_STREAMS}}]{\setlength{\rightskip}{0pt plus 5cm}\#define N\+U\+M\+\_\+\+S\+T\+R\+E\+A\+MS~256}\hypertarget{avtp__rx_8c_a876704225d1c5ecd8b0fc85315f88397}{}\label{avtp__rx_8c_a876704225d1c5ecd8b0fc85315f88397}


avtp\+\_\+rx.\+c 파일의 50 번째 라인에서 정의되었습니다.

\index{avtp\+\_\+rx.\+c@{avtp\+\_\+rx.\+c}!R\+E\+P\+O\+R\+T\+\_\+\+S\+E\+C\+O\+N\+DS@{R\+E\+P\+O\+R\+T\+\_\+\+S\+E\+C\+O\+N\+DS}}
\index{R\+E\+P\+O\+R\+T\+\_\+\+S\+E\+C\+O\+N\+DS@{R\+E\+P\+O\+R\+T\+\_\+\+S\+E\+C\+O\+N\+DS}!avtp\+\_\+rx.\+c@{avtp\+\_\+rx.\+c}}
\subsubsection[{\texorpdfstring{R\+E\+P\+O\+R\+T\+\_\+\+S\+E\+C\+O\+N\+DS}{REPORT_SECONDS}}]{\setlength{\rightskip}{0pt plus 5cm}\#define R\+E\+P\+O\+R\+T\+\_\+\+S\+E\+C\+O\+N\+DS~10}\hypertarget{avtp__rx_8c_aad8560c5d8b6b834271c0f40e3854be9}{}\label{avtp__rx_8c_aad8560c5d8b6b834271c0f40e3854be9}


avtp\+\_\+rx.\+c 파일의 51 번째 라인에서 정의되었습니다.



\subsection{함수 문서화}
\index{avtp\+\_\+rx.\+c@{avtp\+\_\+rx.\+c}!dump\+Ascii@{dump\+Ascii}}
\index{dump\+Ascii@{dump\+Ascii}!avtp\+\_\+rx.\+c@{avtp\+\_\+rx.\+c}}
\subsubsection[{\texorpdfstring{dump\+Ascii(\+U8 $\ast$p\+Frame, int i, int $\ast$j)}{dumpAscii(U8 *pFrame, int i, int *j)}}]{\setlength{\rightskip}{0pt plus 5cm}void dump\+Ascii (
\begin{DoxyParamCaption}
\item[{{\bf U8} $\ast$}]{p\+Frame, }
\item[{int}]{i, }
\item[{int $\ast$}]{j}
\end{DoxyParamCaption}
)}\hypertarget{avtp__rx_8c_a1fef2c2f282fced8ca994f549332d361}{}\label{avtp__rx_8c_a1fef2c2f282fced8ca994f549332d361}


avtp\+\_\+rx.\+c 파일의 74 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
75 \{
76     \textcolor{keywordtype}{char} \hyperlink{shaper__daemon_8c_a4e1e0e72dd773439e333c84dd762a9c3}{c};
77 
78     printf(\textcolor{stringliteral}{"  "});
79     
80     \textcolor{keywordflow}{while} (*j <= i) \{
81         c = pFrame[*j];
82         *j += 1;
83         \textcolor{keywordflow}{if} (!isprint(c) || isspace(c))
84             c = \textcolor{charliteral}{'.'};
85         printf(\textcolor{stringliteral}{"%c"}, c);
86     \}
87 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{avtp__rx_8c_a1fef2c2f282fced8ca994f549332d361_icgraph}
\end{center}
\end{figure}


\index{avtp\+\_\+rx.\+c@{avtp\+\_\+rx.\+c}!dump\+Frame@{dump\+Frame}}
\index{dump\+Frame@{dump\+Frame}!avtp\+\_\+rx.\+c@{avtp\+\_\+rx.\+c}}
\subsubsection[{\texorpdfstring{dump\+Frame(\+U8 $\ast$p\+Frame, U32 len, hdr\+\_\+info\+\_\+t $\ast$hdr)}{dumpFrame(U8 *pFrame, U32 len, hdr_info_t *hdr)}}]{\setlength{\rightskip}{0pt plus 5cm}void dump\+Frame (
\begin{DoxyParamCaption}
\item[{{\bf U8} $\ast$}]{p\+Frame, }
\item[{{\bf U32}}]{len, }
\item[{{\bf hdr\+\_\+info\+\_\+t} $\ast$}]{hdr}
\end{DoxyParamCaption}
)}\hypertarget{avtp__rx_8c_a93d6cb62eaeaf41d16b18a13e0386f03}{}\label{avtp__rx_8c_a93d6cb62eaeaf41d16b18a13e0386f03}


avtp\+\_\+rx.\+c 파일의 120 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
121 \{
122     printf(\textcolor{stringliteral}{"Frame received, ethertype=0x%x len=%u\(\backslash\)n"}, hdr->\hyperlink{structhdr__info__t_a54283e441ba9b75fc494232121266e2c}{ethertype}, len);
123     printf(\textcolor{stringliteral}{"src: %s\(\backslash\)n"}, ether\_ntoa((\textcolor{keyword}{const} \textcolor{keyword}{struct} ether\_addr*)hdr->\hyperlink{structhdr__info__t_a603b5aebe0d4619ae32b09cd6612535f}{shost}));
124     printf(\textcolor{stringliteral}{"dst: %s\(\backslash\)n"}, ether\_ntoa((\textcolor{keyword}{const} \textcolor{keyword}{struct} ether\_addr*)hdr->\hyperlink{structhdr__info__t_a5a0b8fa2025e75a8db03f7a23cadc04e}{dhost}));
125     \textcolor{keywordflow}{if} (hdr->\hyperlink{structhdr__info__t_aae65321fd27fc2507a499a3f00660a93}{vlan}) \{
126         printf(\textcolor{stringliteral}{"VLAN pcp=%u, vid=%u\(\backslash\)n"}, (\textcolor{keywordtype}{unsigned})hdr->\hyperlink{structhdr__info__t_a394deccdf47e8dd6b4e6329e6fe0f8fc}{vlan\_pcp}, hdr->
      \hyperlink{structhdr__info__t_aed62b55d4664ac7c198517a01adc4f6b}{vlan\_vid}); 
127     \}
128     \hyperlink{avtp__rx_8c_a0313c4c55e50cead2ef49d50f4fbe8ec}{dumpFrameContent}(pFrame, len);
129     printf(\textcolor{stringliteral}{"\(\backslash\)n"});
130 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{avtp__rx_8c_a93d6cb62eaeaf41d16b18a13e0386f03_cgraph}
\end{center}
\end{figure}


\index{avtp\+\_\+rx.\+c@{avtp\+\_\+rx.\+c}!dump\+Frame\+Content@{dump\+Frame\+Content}}
\index{dump\+Frame\+Content@{dump\+Frame\+Content}!avtp\+\_\+rx.\+c@{avtp\+\_\+rx.\+c}}
\subsubsection[{\texorpdfstring{dump\+Frame\+Content(\+U8 $\ast$p\+Frame, U32 len)}{dumpFrameContent(U8 *pFrame, U32 len)}}]{\setlength{\rightskip}{0pt plus 5cm}void dump\+Frame\+Content (
\begin{DoxyParamCaption}
\item[{{\bf U8} $\ast$}]{p\+Frame, }
\item[{{\bf U32}}]{len}
\end{DoxyParamCaption}
)}\hypertarget{avtp__rx_8c_a0313c4c55e50cead2ef49d50f4fbe8ec}{}\label{avtp__rx_8c_a0313c4c55e50cead2ef49d50f4fbe8ec}


avtp\+\_\+rx.\+c 파일의 89 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
90 \{
91     \textcolor{keywordtype}{int} i = 0, j = 0;
92     \textcolor{keywordflow}{while} (\hyperlink{maap__log_8h_aa8cecfc5c5c054d2875c03e77b7be15d}{TRUE}) \{
93         \textcolor{keywordflow}{if} (i % 16 == 0) \{
94             \textcolor{keywordflow}{if} (i != 0 ) \{
95                 \textcolor{comment}{// end of line stuff}
96                 \hyperlink{avtp__rx_8c_a1fef2c2f282fced8ca994f549332d361}{dumpAscii}(pFrame, (i < len ? i : len), &j);
97                 printf(\textcolor{stringliteral}{"\(\backslash\)n"});
98 
99                 \textcolor{keywordflow}{if} (i >= len)
100                     \textcolor{keywordflow}{break};
101             \}
102             \textcolor{keywordflow}{if} (i+1 < len) \{
103                 \textcolor{comment}{// start of line stuff}
104                 printf(\textcolor{stringliteral}{"0x%4.4d:  "}, i);
105             \}
106         \}
107         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (i % 2 == 0) \{
108             printf(\textcolor{stringliteral}{"  "});
109         \}
110 
111         \textcolor{keywordflow}{if} (i >= len)
112             printf(\textcolor{stringliteral}{"  "});
113         \textcolor{keywordflow}{else}
114             printf(\textcolor{stringliteral}{"%2.2x"}, pFrame[i]);
115 
116         i += 1;
117     \}
118 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=281pt]{avtp__rx_8c_a0313c4c55e50cead2ef49d50f4fbe8ec_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=287pt]{avtp__rx_8c_a0313c4c55e50cead2ef49d50f4fbe8ec_icgraph}
\end{center}
\end{figure}


\index{avtp\+\_\+rx.\+c@{avtp\+\_\+rx.\+c}!main@{main}}
\index{main@{main}!avtp\+\_\+rx.\+c@{avtp\+\_\+rx.\+c}}
\subsubsection[{\texorpdfstring{main(int argc, char $\ast$argv[])}{main(int argc, char *argv[])}}]{\setlength{\rightskip}{0pt plus 5cm}int main (
\begin{DoxyParamCaption}
\item[{int}]{argc, }
\item[{char $\ast$}]{argv\mbox{[}$\,$\mbox{]}}
\end{DoxyParamCaption}
)}\hypertarget{avtp__rx_8c_a0ddf1224851353fc92bfbff6f499fa97}{}\label{avtp__rx_8c_a0ddf1224851353fc92bfbff6f499fa97}


avtp\+\_\+rx.\+c 파일의 132 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
133 \{
134     GError *error = \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
135     GOptionContext *context;
136 
137     context = g\_option\_context\_new(\textcolor{stringliteral}{"- rawsock listenr"});
138     g\_option\_context\_add\_main\_entries(context, \hyperlink{avtp__rx_8c_a76565232f25302e8cb99c60a629034cc}{entries}, \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL});
139     \textcolor{keywordflow}{if} (!g\_option\_context\_parse(context, &argc, &argv, &error))
140     \{
141         printf(\textcolor{stringliteral}{"error: %s\(\backslash\)n"}, error->message);
142         exit(1);
143     \}
144 
145     \textcolor{keywordflow}{if} (\hyperlink{avtp__rx_8c_af663a7576d2f8f288bb3996381484cd3}{interface} == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}) \{
146         printf(\textcolor{stringliteral}{"error: must specify network interface\(\backslash\)n"});
147         exit(2);
148     \}
149 
150     \textcolor{keywordtype}{void}* rs = \hyperlink{openavb__rawsock_8c_a51a8d60253a8bab7c193b36bf743d12f}{openavbRawsockOpen}(\hyperlink{avtp__rx_8c_af663a7576d2f8f288bb3996381484cd3}{interface}, \hyperlink{maap__log_8h_aa8cecfc5c5c054d2875c03e77b7be15d}{TRUE}, 
      \hyperlink{maap__log_8h_aa93f0eb578d23995850d61f7d61c55c1}{FALSE}, \hyperlink{avtp__rx_8c_af3d6d4ec5b93edfddc9de51233ae9f7e}{ethertype}, 0, \hyperlink{avtp__rx_8c_a4c04f59831e0bea1d495e08237bb816b}{MAX\_NUM\_FRAMES});
151     \textcolor{keywordflow}{if} (!rs) \{
152         printf(\textcolor{stringliteral}{"error: failed to open raw socket (are you root?)\(\backslash\)n"});
153         exit(3);
154     \}
155 
156     \hyperlink{structhdr__info__t}{hdr\_info\_t} hdr;
157     \hyperlink{openavb__types__base__pub_8h_aa63ef7b996d5487ce35a5a66601f3e73}{U8} *pBuf, *pFrame, tmp8;
158     \hyperlink{openavb__types__base__pub_8h_a696390429f2f3b644bde8d0322a24124}{U32} offset, len;
159     \hyperlink{openavb__types__base__pub_8h_a0a0a322d5fa4a546d293a77ba8b4a71f}{U16} uid, i;
160 
161     \textcolor{keywordtype}{long} nTotal = 0, nRecv[\hyperlink{avtp__rx_8c_a876704225d1c5ecd8b0fc85315f88397}{NUM\_STREAMS}];
162     \textcolor{keywordflow}{for} (i = 0; i < \hyperlink{avtp__rx_8c_a876704225d1c5ecd8b0fc85315f88397}{NUM\_STREAMS}; i++)
163         nRecv[i] = 0;
164     
165     \textcolor{keyword}{struct }timespec now, report;
166     clock\_gettime(CLOCK\_MONOTONIC, &report);
167     report.tv\_sec += \hyperlink{avtp__rx_8c_aad8560c5d8b6b834271c0f40e3854be9}{REPORT\_SECONDS};
168 
169     \textcolor{keywordflow}{while} (\hyperlink{avtp__rx_8c_acf182b7b2127314d5d00c6df827734b5}{bRunning}) \{
170         pBuf = \hyperlink{openavb__rawsock_8h_ab4beedf5fcac2ab0b3aaf41095a0dbc1}{openavbRawsockGetRxFrame}(rs, 1000, &offset, &len);
171         \textcolor{keywordflow}{if} (pBuf) \{
172             pFrame = pBuf + offset;
173 
174             offset = \hyperlink{openavb__rawsock_8h_a9e622aafeae5b3aacba4996de08b554a}{openavbRawsockRxParseHdr}(rs, pBuf, &hdr);
175             \textcolor{keywordflow}{if} ((\textcolor{keywordtype}{int})offset < 0) \{
176                 printf(\textcolor{stringliteral}{"error parsing frame header"});
177             \}
178             \textcolor{keywordflow}{else} \{
179 \textcolor{preprocessor}{#ifndef UBUNTU}
180                 \textcolor{keywordflow}{if} (hdr.\hyperlink{structhdr__info__t_a54283e441ba9b75fc494232121266e2c}{ethertype} == \hyperlink{openavb__avtp_8h_a07fb0f2498c8b8dd62cc44da13bb092a}{ETHERTYPE\_8021Q}) \{
181                     \textcolor{comment}{// Oh!  Need to look past the VLAN tag}
182                     \hyperlink{openavb__types__base__pub_8h_a0a0a322d5fa4a546d293a77ba8b4a71f}{U16} vlan\_bits = ntohs(*(\hyperlink{openavb__types__base__pub_8h_a0a0a322d5fa4a546d293a77ba8b4a71f}{U16} *)(pFrame + offset));
183                     hdr.\hyperlink{structhdr__info__t_aae65321fd27fc2507a499a3f00660a93}{vlan} = \hyperlink{maap__log_8h_aa8cecfc5c5c054d2875c03e77b7be15d}{TRUE};
184                     hdr.\hyperlink{structhdr__info__t_aed62b55d4664ac7c198517a01adc4f6b}{vlan\_vid} = vlan\_bits & 0x0FFF;
185                     hdr.\hyperlink{structhdr__info__t_a394deccdf47e8dd6b4e6329e6fe0f8fc}{vlan\_pcp} = (vlan\_bits >> 13) & 0x0007;
186                     offset += 2;
187                     hdr.\hyperlink{structhdr__info__t_a54283e441ba9b75fc494232121266e2c}{ethertype} = ntohs(*(\hyperlink{openavb__types__base__pub_8h_a0a0a322d5fa4a546d293a77ba8b4a71f}{U16} *)(pFrame + offset));
188                     offset += 2;
189                 \}
190 \textcolor{preprocessor}{#endif}
191 
192                 \textcolor{keywordflow}{if} (hdr.\hyperlink{structhdr__info__t_a54283e441ba9b75fc494232121266e2c}{ethertype} == \hyperlink{openavb__avtp_8h_a5e6dfe517d14f65222b866a550498e5f}{ETHERTYPE\_AVTP}) \{
193                     \textcolor{comment}{//dumpFrame(pFrame + offset, len - offset, &hdr);}
194 
195                     \textcolor{comment}{// Look for stream data frames}
196                     \textcolor{comment}{// (ignore control frames, including MAAP)}
197                     tmp8 = *(pFrame + offset);
198                     \textcolor{keywordflow}{if} ((tmp8 & 0x80) == 0) \{
199                         \textcolor{comment}{// Find the unique ID in the streamID}
200                         uid = htons(*(\hyperlink{openavb__types__base__pub_8h_a0a0a322d5fa4a546d293a77ba8b4a71f}{U16}*)(pFrame + offset + 10));
201                         \textcolor{keywordflow}{if} (uid < NUM\_STREAMS)
202                             nRecv[uid]++;
203                         nTotal++;
204                     \}
205                 \}
206             \}
207 
208             \hyperlink{openavb__rawsock_8h_ab9af76bc21dc0112d657252bd61b1219}{openavbRawsockRelRxFrame}(rs, pBuf);
209         \}
210         
211         clock\_gettime(CLOCK\_MONOTONIC, &now);
212         \textcolor{keywordflow}{if} (\hyperlink{avtp__rx_8c_a51c5f18b7b31155a1957e1997bcd85da}{timespec\_cmp}(&now, &report) >= 0) \{
213             printf(\textcolor{stringliteral}{"total=%ld\(\backslash\)t"}, nTotal);
214             nTotal = 0;
215             \textcolor{keywordflow}{for} (i = 0; i < NUM\_STREAMS-1; i++) \{
216                 \textcolor{keywordflow}{if} (nRecv[i] > 0) \{
217                     printf(\textcolor{stringliteral}{"%d=%ld\(\backslash\)t"}, i, nRecv[i]);
218                     nRecv[i] = 0;
219                 \}
220             \}
221             printf(\textcolor{stringliteral}{"\(\backslash\)n"});
222             report.tv\_sec += \hyperlink{avtp__rx_8c_aad8560c5d8b6b834271c0f40e3854be9}{REPORT\_SECONDS};
223         \}
224     \}
225 
226     \hyperlink{openavb__rawsock_8h_ae1e456bd2922c4ed8fc8263cc65d98d1}{openavbRawsockClose}(rs);
227     \textcolor{keywordflow}{return} 0;
228 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=550pt]{avtp__rx_8c_a0ddf1224851353fc92bfbff6f499fa97_cgraph}
\end{center}
\end{figure}


\index{avtp\+\_\+rx.\+c@{avtp\+\_\+rx.\+c}!timespec\+\_\+cmp@{timespec\+\_\+cmp}}
\index{timespec\+\_\+cmp@{timespec\+\_\+cmp}!avtp\+\_\+rx.\+c@{avtp\+\_\+rx.\+c}}
\subsubsection[{\texorpdfstring{timespec\+\_\+cmp(struct timespec $\ast$a, struct timespec $\ast$b)}{timespec_cmp(struct timespec *a, struct timespec *b)}}]{\setlength{\rightskip}{0pt plus 5cm}int timespec\+\_\+cmp (
\begin{DoxyParamCaption}
\item[{struct timespec $\ast$}]{a, }
\item[{struct timespec $\ast$}]{b}
\end{DoxyParamCaption}
)}\hypertarget{avtp__rx_8c_a51c5f18b7b31155a1957e1997bcd85da}{}\label{avtp__rx_8c_a51c5f18b7b31155a1957e1997bcd85da}


avtp\+\_\+rx.\+c 파일의 59 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
60 \{
61     \textcolor{keywordflow}{if} (a->tv\_sec > b->tv\_sec)
62         \textcolor{keywordflow}{return} 1;
63     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (a->tv\_sec < b->tv\_sec)
64         \textcolor{keywordflow}{return} -1;
65     \textcolor{keywordflow}{else} \{
66         \textcolor{keywordflow}{if} (a->tv\_nsec > b->tv\_nsec)
67             \textcolor{keywordflow}{return} 1;
68         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (a->tv\_nsec < b->tv\_nsec)
69             \textcolor{keywordflow}{return} -1;
70     \}
71     \textcolor{keywordflow}{return} 0;
72 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=234pt]{avtp__rx_8c_a51c5f18b7b31155a1957e1997bcd85da_icgraph}
\end{center}
\end{figure}




\subsection{변수 문서화}
\index{avtp\+\_\+rx.\+c@{avtp\+\_\+rx.\+c}!b\+Running@{b\+Running}}
\index{b\+Running@{b\+Running}!avtp\+\_\+rx.\+c@{avtp\+\_\+rx.\+c}}
\subsubsection[{\texorpdfstring{b\+Running}{bRunning}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf bool} b\+Running = {\bf T\+R\+UE}\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{avtp__rx_8c_acf182b7b2127314d5d00c6df827734b5}{}\label{avtp__rx_8c_acf182b7b2127314d5d00c6df827734b5}


avtp\+\_\+rx.\+c 파일의 46 번째 라인에서 정의되었습니다.

\index{avtp\+\_\+rx.\+c@{avtp\+\_\+rx.\+c}!entries@{entries}}
\index{entries@{entries}!avtp\+\_\+rx.\+c@{avtp\+\_\+rx.\+c}}
\subsubsection[{\texorpdfstring{entries}{entries}}]{\setlength{\rightskip}{0pt plus 5cm}G\+Option\+Entry entries\mbox{[}$\,$\mbox{]}\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{avtp__rx_8c_a76565232f25302e8cb99c60a629034cc}{}\label{avtp__rx_8c_a76565232f25302e8cb99c60a629034cc}
{\bfseries 초기값\+:}
\begin{DoxyCode}
=
\{
  \{ \textcolor{stringliteral}{"interface"}, \textcolor{charliteral}{'i'}, 0, G\_OPTION\_ARG\_STRING, &\hyperlink{avtp__rx_8c_af663a7576d2f8f288bb3996381484cd3}{interface}, \textcolor{stringliteral}{"network interface"}, \textcolor{stringliteral}{"NAME"} \},
  \{ \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} \}
\}
\end{DoxyCode}


avtp\+\_\+rx.\+c 파일의 53 번째 라인에서 정의되었습니다.

\index{avtp\+\_\+rx.\+c@{avtp\+\_\+rx.\+c}!ethertype@{ethertype}}
\index{ethertype@{ethertype}!avtp\+\_\+rx.\+c@{avtp\+\_\+rx.\+c}}
\subsubsection[{\texorpdfstring{ethertype}{ethertype}}]{\setlength{\rightskip}{0pt plus 5cm}int ethertype = {\bf E\+T\+H\+E\+R\+T\+Y\+P\+E\+\_\+8021Q}\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{avtp__rx_8c_af3d6d4ec5b93edfddc9de51233ae9f7e}{}\label{avtp__rx_8c_af3d6d4ec5b93edfddc9de51233ae9f7e}


avtp\+\_\+rx.\+c 파일의 41 번째 라인에서 정의되었습니다.

\index{avtp\+\_\+rx.\+c@{avtp\+\_\+rx.\+c}!interface@{interface}}
\index{interface@{interface}!avtp\+\_\+rx.\+c@{avtp\+\_\+rx.\+c}}
\subsubsection[{\texorpdfstring{interface}{interface}}]{\setlength{\rightskip}{0pt plus 5cm}char$\ast$ interface = {\bf N\+U\+LL}\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{avtp__rx_8c_af663a7576d2f8f288bb3996381484cd3}{}\label{avtp__rx_8c_af663a7576d2f8f288bb3996381484cd3}


avtp\+\_\+rx.\+c 파일의 48 번째 라인에서 정의되었습니다.

