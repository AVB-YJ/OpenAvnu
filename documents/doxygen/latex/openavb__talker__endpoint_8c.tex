\hypertarget{openavb__talker__endpoint_8c}{}\section{lib/avtp\+\_\+pipeline/tl/openavb\+\_\+talker\+\_\+endpoint.c 파일 참조}
\label{openavb__talker__endpoint_8c}\index{lib/avtp\+\_\+pipeline/tl/openavb\+\_\+talker\+\_\+endpoint.\+c@{lib/avtp\+\_\+pipeline/tl/openavb\+\_\+talker\+\_\+endpoint.\+c}}
{\ttfamily \#include $<$stdlib.\+h$>$}\\*
{\ttfamily \#include $<$string.\+h$>$}\\*
{\ttfamily \#include \char`\"{}openavb\+\_\+platform.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}openavb\+\_\+trace.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}openavb\+\_\+tl.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}openavb\+\_\+endpoint.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}openavb\+\_\+avtp.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}openavb\+\_\+talker.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}openavb\+\_\+time.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}openavb\+\_\+avdecc\+\_\+msg.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}openavb\+\_\+log.\+h\char`\"{}}\\*
openavb\+\_\+talker\+\_\+endpoint.\+c에 대한 include 의존 그래프
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{openavb__talker__endpoint_8c__incl}
\end{center}
\end{figure}
\subsection*{매크로}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{openavb__talker__endpoint_8c_abcfb21b6495585fe36058f57a9fe58fc}{A\+V\+B\+\_\+\+L\+O\+G\+\_\+\+C\+O\+M\+P\+O\+N\+E\+NT}~\char`\"{}Talker\char`\"{}
\end{DoxyCompactItemize}
\subsection*{함수}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{openavb__talker__endpoint_8c_a286e27f8aca460f0e104d9e3d587eac6}{openavb\+Ept\+Clnt\+Notify\+Tlkr\+Of\+Srp\+Cb} (int endpoint\+Handle, \hyperlink{struct_a_v_b_stream_i_d__t}{A\+V\+B\+Stream\+I\+D\+\_\+t} $\ast$stream\+ID, char $\ast$\hyperlink{aaf-talker_8c_ac7b430acaa92a7a26fbcdad47d2efc20}{ifname}, \hyperlink{openavb__types__base__pub_8h_aa63ef7b996d5487ce35a5a66601f3e73}{U8} dest\+Addr\mbox{[}$\,$\mbox{]}, \hyperlink{openavb__srp__api_8h_afecaf0f6deca515a5b80d49fa8c3db8b}{openavb\+Srp\+Lsnr\+Decl\+Subtype\+\_\+t} lsnr\+Decl, \hyperlink{openavb__types__base__pub_8h_aa63ef7b996d5487ce35a5a66601f3e73}{U8} sr\+Class, \hyperlink{openavb__types__base__pub_8h_a696390429f2f3b644bde8d0322a24124}{U32} class\+Rate, \hyperlink{openavb__types__base__pub_8h_a0a0a322d5fa4a546d293a77ba8b4a71f}{U16} vlan\+ID, \hyperlink{openavb__types__base__pub_8h_aa63ef7b996d5487ce35a5a66601f3e73}{U8} \hyperlink{aaf-talker_8c_acec9ce2df15222151ad66fcb1d74eb9f}{priority}, \hyperlink{openavb__types__base__pub_8h_a0a0a322d5fa4a546d293a77ba8b4a71f}{U16} fwmark)
\item 
\hyperlink{avb__gptp_8h_af6a258d8f3ee5206d682d799316314b1}{bool} \hyperlink{openavb__talker__endpoint_8c_a8a14b94cdaf2df77758c0ff8466137db}{openavb\+T\+L\+Run\+Talker\+Init} (\hyperlink{structtl__state__t}{tl\+\_\+state\+\_\+t} $\ast$p\+T\+L\+State)
\item 
void \hyperlink{openavb__talker__endpoint_8c_acbf24f0edf0c4e46ad7622dc23209965}{openavb\+T\+L\+Run\+Talker\+Finish} (\hyperlink{structtl__state__t}{tl\+\_\+state\+\_\+t} $\ast$p\+T\+L\+State)
\end{DoxyCompactItemize}


\subsection{매크로 문서화}
\index{openavb\+\_\+talker\+\_\+endpoint.\+c@{openavb\+\_\+talker\+\_\+endpoint.\+c}!A\+V\+B\+\_\+\+L\+O\+G\+\_\+\+C\+O\+M\+P\+O\+N\+E\+NT@{A\+V\+B\+\_\+\+L\+O\+G\+\_\+\+C\+O\+M\+P\+O\+N\+E\+NT}}
\index{A\+V\+B\+\_\+\+L\+O\+G\+\_\+\+C\+O\+M\+P\+O\+N\+E\+NT@{A\+V\+B\+\_\+\+L\+O\+G\+\_\+\+C\+O\+M\+P\+O\+N\+E\+NT}!openavb\+\_\+talker\+\_\+endpoint.\+c@{openavb\+\_\+talker\+\_\+endpoint.\+c}}
\subsubsection[{\texorpdfstring{A\+V\+B\+\_\+\+L\+O\+G\+\_\+\+C\+O\+M\+P\+O\+N\+E\+NT}{AVB_LOG_COMPONENT}}]{\setlength{\rightskip}{0pt plus 5cm}\#define A\+V\+B\+\_\+\+L\+O\+G\+\_\+\+C\+O\+M\+P\+O\+N\+E\+NT~\char`\"{}Talker\char`\"{}}\hypertarget{openavb__talker__endpoint_8c_abcfb21b6495585fe36058f57a9fe58fc}{}\label{openavb__talker__endpoint_8c_abcfb21b6495585fe36058f57a9fe58fc}


openavb\+\_\+talker\+\_\+endpoint.\+c 파일의 50 번째 라인에서 정의되었습니다.



\subsection{함수 문서화}
\index{openavb\+\_\+talker\+\_\+endpoint.\+c@{openavb\+\_\+talker\+\_\+endpoint.\+c}!openavb\+Ept\+Clnt\+Notify\+Tlkr\+Of\+Srp\+Cb@{openavb\+Ept\+Clnt\+Notify\+Tlkr\+Of\+Srp\+Cb}}
\index{openavb\+Ept\+Clnt\+Notify\+Tlkr\+Of\+Srp\+Cb@{openavb\+Ept\+Clnt\+Notify\+Tlkr\+Of\+Srp\+Cb}!openavb\+\_\+talker\+\_\+endpoint.\+c@{openavb\+\_\+talker\+\_\+endpoint.\+c}}
\subsubsection[{\texorpdfstring{openavb\+Ept\+Clnt\+Notify\+Tlkr\+Of\+Srp\+Cb(int endpoint\+Handle, A\+V\+B\+Stream\+I\+D\+\_\+t $\ast$stream\+I\+D, char $\ast$ifname, U8 dest\+Addr[], openavb\+Srp\+Lsnr\+Decl\+Subtype\+\_\+t lsnr\+Decl, U8 sr\+Class, U32 class\+Rate, U16 vlan\+I\+D, U8 priority, U16 fwmark)}{openavbEptClntNotifyTlkrOfSrpCb(int endpointHandle, AVBStreamID_t *streamID, char *ifname, U8 destAddr[], openavbSrpLsnrDeclSubtype_t lsnrDecl, U8 srClass, U32 classRate, U16 vlanID, U8 priority, U16 fwmark)}}]{\setlength{\rightskip}{0pt plus 5cm}void openavb\+Ept\+Clnt\+Notify\+Tlkr\+Of\+Srp\+Cb (
\begin{DoxyParamCaption}
\item[{int}]{endpoint\+Handle, }
\item[{{\bf A\+V\+B\+Stream\+I\+D\+\_\+t} $\ast$}]{stream\+ID, }
\item[{char $\ast$}]{ifname, }
\item[{{\bf U8}}]{dest\+Addr\mbox{[}$\,$\mbox{]}, }
\item[{{\bf openavb\+Srp\+Lsnr\+Decl\+Subtype\+\_\+t}}]{lsnr\+Decl, }
\item[{{\bf U8}}]{sr\+Class, }
\item[{{\bf U32}}]{class\+Rate, }
\item[{{\bf U16}}]{vlan\+ID, }
\item[{{\bf U8}}]{priority, }
\item[{{\bf U16}}]{fwmark}
\end{DoxyParamCaption}
)}\hypertarget{openavb__talker__endpoint_8c_a286e27f8aca460f0e104d9e3d587eac6}{}\label{openavb__talker__endpoint_8c_a286e27f8aca460f0e104d9e3d587eac6}


openavb\+\_\+talker\+\_\+endpoint.\+c 파일의 56 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
66 \{
67     \hyperlink{build_2sdk__eavb_2openavb__trace__pub_8h_ab2bfc814f0447a6d975e8332be197b85}{AVB\_TRACE\_ENTRY}(\hyperlink{openavb__trace_8h_ae679116a5251aad926d752e57edbb7d3}{AVB\_TRACE\_TL});
68 
69     \hyperlink{structtl__state__t}{tl\_state\_t} *pTLState = \hyperlink{openavb__tl_8h_ad2f38bb797230bf2c03c44f4742a9815}{TLHandleListGet}(endpointHandle);
70     \hyperlink{structtalker__data__t}{talker\_data\_t} *pTalkerData = pTLState->\hyperlink{structtl__state__t_a18baa6360ea16357a2e906bc9bc4e61e}{pPvtTalkerData};
71 
72     \textcolor{keywordflow}{if} (!pTLState) \{
73         \hyperlink{build_2sdk__eavb_2openavb__log__pub_8h_a6e7cd550837a0406e98b81a840d10ea9}{AVB\_LOG\_WARNING}(\textcolor{stringliteral}{"Unable to get talker from endpoint handle."});
74         \textcolor{keywordflow}{return};
75     \}
76 
77     \textcolor{comment}{// If not a talker, ignore this callback.}
78     \textcolor{keywordflow}{if} (pTLState->\hyperlink{structtl__state__t_a7b8161c0e9a273c59fbc1dfda943953e}{cfg}.\hyperlink{structopenavb__tl__cfg__t_a172ec388c6d270261a61a789b78dff45}{role} != \hyperlink{openavb__types__base__pub_8h_a590fdc081b8544206aabd58e32a6f6a2ad24b3afc356fd635f96a32dd89a1b6a2}{AVB\_ROLE\_TALKER}) \{
79         \hyperlink{build_2sdk__eavb_2openavb__log__pub_8h_a28a4d0350d530ad95c95b8383c00cd9c}{AVB\_LOG\_DEBUG}(\textcolor{stringliteral}{"Ignoring Talker callback"});
80         \textcolor{keywordflow}{return};
81     \}
82 
83     \hyperlink{build_2sdk__eavb_2openavb__log__pub_8h_afcf1f0c1d10ae9efe3782eb6cae78355}{AVB\_LOGF\_DEBUG}(\textcolor{stringliteral}{"%s streaming=%d, lsnrDecl=%d"}, \_\_FUNCTION\_\_, pTLState->
      \hyperlink{structtl__state__t_a3aa3817b2cc5c2c4382ceb050c83225d}{bStreaming}, lsnrDecl);
84 
85     \hyperlink{structopenavb__tl__cfg__t}{openavb\_tl\_cfg\_t} *pCfg = &pTLState->\hyperlink{structtl__state__t_a7b8161c0e9a273c59fbc1dfda943953e}{cfg};
86 
87     \textcolor{keywordflow}{if} (!pTLState->\hyperlink{structtl__state__t_a3aa3817b2cc5c2c4382ceb050c83225d}{bStreaming}) \{
88         \textcolor{keywordflow}{if} (lsnrDecl == \hyperlink{openavb__srp__api_8h_a29de1a69fde0f78e2ca9ae3141c2bcd6a90a7c8c87911ef06e381b583de92d954}{openavbSrp\_LDSt\_Ready}
89             || lsnrDecl == \hyperlink{openavb__srp__api_8h_a29de1a69fde0f78e2ca9ae3141c2bcd6aee0f4927d670396870ea49810b8f9933}{openavbSrp\_LDSt\_Ready\_Failed}) \{
90 
91             \textcolor{comment}{// Save the data provided by endpoint/SRP}
92             \textcolor{keywordflow}{if} (!pCfg->\hyperlink{structopenavb__tl__cfg__t_a6a7c2523839aee5440af6ea2c11d8c02}{ifname}[0]) \{
93                 strncpy(pTalkerData->\hyperlink{structtalker__data__t_a11d6071e5fa37b0c5776e17651485f11}{ifname}, \hyperlink{aaf-talker_8c_ac7b430acaa92a7a26fbcdad47d2efc20}{ifname}, \textcolor{keyword}{sizeof}(pTalkerData->
      \hyperlink{structtalker__data__t_a11d6071e5fa37b0c5776e17651485f11}{ifname}) - 1);
94             \} \textcolor{keywordflow}{else} \{
95                 strncpy(pTalkerData->\hyperlink{structtalker__data__t_a11d6071e5fa37b0c5776e17651485f11}{ifname}, pCfg->\hyperlink{structopenavb__tl__cfg__t_a6a7c2523839aee5440af6ea2c11d8c02}{ifname}, \textcolor{keyword}{sizeof}(pTalkerData->
      \hyperlink{structtalker__data__t_a11d6071e5fa37b0c5776e17651485f11}{ifname}) - 1);
96             \}
97             memcpy(&pTalkerData->\hyperlink{structtalker__data__t_a989c1ccd88811e9926203a07d587bc21}{streamID}, streamID, \textcolor{keyword}{sizeof}(
      \hyperlink{struct_a_v_b_stream_i_d__t}{AVBStreamID\_t}));
98             memcpy(&pTalkerData->\hyperlink{structtalker__data__t_a016f2167ae2143dcacd762c10be2f614}{destAddr}, destAddr, \hyperlink{openavb__avdecc__pub_8h_a9822d89774e0d6ddaa06503950130423}{ETH\_ALEN});
99             pTalkerData->\hyperlink{structtalker__data__t_a0ce524f0210a76139ed0aa1ae3ff24f4}{srClass} = srClass;
100             pTalkerData->\hyperlink{structtalker__data__t_a0bf28249cb23ce65c155693440118df5}{classRate} = classRate;
101             pTalkerData->\hyperlink{structtalker__data__t_a6f9e150f3345cb797072070d8972aec8}{vlanID} = vlanID;
102             pTalkerData->\hyperlink{structtalker__data__t_aeceb46fe9886e43a65d96da0339c43fb}{vlanPCP} = \hyperlink{aaf-talker_8c_acec9ce2df15222151ad66fcb1d74eb9f}{priority};
103             pTalkerData->\hyperlink{structtalker__data__t_a2feeac72308795682394e8b3796d9502}{fwmark} = fwmark;
104 
105             \textcolor{comment}{// We should start streaming}
106             \hyperlink{build_2sdk__eavb_2openavb__log__pub_8h_a2be7e90c7cb63f12b221ed1cd4999185}{AVB\_LOGF\_INFO}(\textcolor{stringliteral}{"Starting stream: "}\hyperlink{build_2sdk__eavb_2openavb__log__pub_8h_a0b0c4c2befb547f1b5df6955851d64c1}{STREAMID\_FORMAT}, 
      \hyperlink{build_2sdk__eavb_2openavb__log__pub_8h_aadd7c634873e1e0a405e5b211ad50368}{STREAMID\_ARGS}(streamID));
107             \hyperlink{openavb__talker_8c_ae8606805d02aa469fecd07c1d45baee6}{talkerStartStream}(pTLState);
108         \}
109         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (lsnrDecl == \hyperlink{openavb__srp__api_8h_a29de1a69fde0f78e2ca9ae3141c2bcd6a0ec4c208a0590a3c0dca2be4bc2eb82f}{openavbSrp\_LDSt\_Stream\_Info}) \{
110             \textcolor{comment}{// Stream information is available does NOT mean listener is ready. Stream not started yet.}
111             \textcolor{keywordflow}{if} (!pCfg->\hyperlink{structopenavb__tl__cfg__t_a6a7c2523839aee5440af6ea2c11d8c02}{ifname}[0]) \{
112                 strncpy(pTalkerData->\hyperlink{structtalker__data__t_a11d6071e5fa37b0c5776e17651485f11}{ifname}, \hyperlink{aaf-talker_8c_ac7b430acaa92a7a26fbcdad47d2efc20}{ifname}, \textcolor{keyword}{sizeof}(pTalkerData->
      \hyperlink{structtalker__data__t_a11d6071e5fa37b0c5776e17651485f11}{ifname}) - 1);
113             \} \textcolor{keywordflow}{else} \{
114                 strncpy(pTalkerData->\hyperlink{structtalker__data__t_a11d6071e5fa37b0c5776e17651485f11}{ifname}, pCfg->\hyperlink{structopenavb__tl__cfg__t_a6a7c2523839aee5440af6ea2c11d8c02}{ifname}, \textcolor{keyword}{sizeof}(pTalkerData->
      \hyperlink{structtalker__data__t_a11d6071e5fa37b0c5776e17651485f11}{ifname}) - 1);
115             \}
116             memcpy(&pTalkerData->\hyperlink{structtalker__data__t_a989c1ccd88811e9926203a07d587bc21}{streamID}, streamID, \textcolor{keyword}{sizeof}(
      \hyperlink{struct_a_v_b_stream_i_d__t}{AVBStreamID\_t}));
117             memcpy(&pTalkerData->\hyperlink{structtalker__data__t_a016f2167ae2143dcacd762c10be2f614}{destAddr}, destAddr, \hyperlink{openavb__avdecc__pub_8h_a9822d89774e0d6ddaa06503950130423}{ETH\_ALEN});
118             pTalkerData->\hyperlink{structtalker__data__t_a0ce524f0210a76139ed0aa1ae3ff24f4}{srClass} = srClass;
119             pTalkerData->\hyperlink{structtalker__data__t_a0bf28249cb23ce65c155693440118df5}{classRate} = classRate;
120             pTalkerData->\hyperlink{structtalker__data__t_a6f9e150f3345cb797072070d8972aec8}{vlanID} = vlanID;
121             pTalkerData->\hyperlink{structtalker__data__t_aeceb46fe9886e43a65d96da0339c43fb}{vlanPCP} = \hyperlink{aaf-talker_8c_acec9ce2df15222151ad66fcb1d74eb9f}{priority};
122             pTalkerData->\hyperlink{structtalker__data__t_a2feeac72308795682394e8b3796d9502}{fwmark} = fwmark;
123         \}
124     \}
125     \textcolor{keywordflow}{else} \{
126         \textcolor{keywordflow}{if} (lsnrDecl != \hyperlink{openavb__srp__api_8h_a29de1a69fde0f78e2ca9ae3141c2bcd6a90a7c8c87911ef06e381b583de92d954}{openavbSrp\_LDSt\_Ready}
127             && lsnrDecl != \hyperlink{openavb__srp__api_8h_a29de1a69fde0f78e2ca9ae3141c2bcd6aee0f4927d670396870ea49810b8f9933}{openavbSrp\_LDSt\_Ready\_Failed}) \{
128             \textcolor{comment}{// Nobody is listening any more}
129             \hyperlink{build_2sdk__eavb_2openavb__log__pub_8h_a2be7e90c7cb63f12b221ed1cd4999185}{AVB\_LOGF\_INFO}(\textcolor{stringliteral}{"Stopping stream: "}\hyperlink{build_2sdk__eavb_2openavb__log__pub_8h_a0b0c4c2befb547f1b5df6955851d64c1}{STREAMID\_FORMAT}, 
      \hyperlink{build_2sdk__eavb_2openavb__log__pub_8h_aadd7c634873e1e0a405e5b211ad50368}{STREAMID\_ARGS}(streamID));
130             \hyperlink{openavb__talker_8c_a13fe82a1d76cbe265f5b24ee4a93a302}{talkerStopStream}(pTLState);
131         \}
132     \}
133 
134     \textcolor{comment}{// Let the AVDECC Msg server know our current stream ID, in case it was updated by MAAP.}
135     \textcolor{keywordflow}{if} (pTLState->\hyperlink{structtl__state__t_a0ec8286c7813affa4fbe99bc5ce31f5a}{avdeccMsgHandle} != 
      \hyperlink{openavb__avdecc__msg_8h_a5fdff136eff2cceabd49fb4a854e748a}{AVB\_AVDECC\_MSG\_HANDLE\_INVALID}) \{
136         \textcolor{keywordflow}{if} (!\hyperlink{openavb__avdecc__msg_8h_a56f0eb7feb81204e5500ad7736c72d53}{openavbAvdeccMsgClntTalkerStreamID}(pTLState->
      \hyperlink{structtl__state__t_a0ec8286c7813affa4fbe99bc5ce31f5a}{avdeccMsgHandle},
137                 pTalkerData->\hyperlink{structtalker__data__t_a0ce524f0210a76139ed0aa1ae3ff24f4}{srClass}, pTalkerData->\hyperlink{structtalker__data__t_a989c1ccd88811e9926203a07d587bc21}{streamID}.\hyperlink{struct_a_v_b_stream_i_d__t_a48d52ffa49f2036631c913b36c85de02}{addr}, pTalkerData->
      \hyperlink{structtalker__data__t_a989c1ccd88811e9926203a07d587bc21}{streamID}.\hyperlink{struct_a_v_b_stream_i_d__t_a7f5a958848a2b027d9f08e063b2e16a1}{uniqueID},
138                 pTalkerData->\hyperlink{structtalker__data__t_a016f2167ae2143dcacd762c10be2f614}{destAddr}, pTalkerData->\hyperlink{structtalker__data__t_a6f9e150f3345cb797072070d8972aec8}{vlanID})) \{
139             \hyperlink{build_2sdk__eavb_2openavb__log__pub_8h_ac8495212c30dbf627b5ae3a9f01f4e2a}{AVB\_LOG\_ERROR}(\textcolor{stringliteral}{"openavbAvdeccMsgClntTalkerStreamID() failed"});
140         \}
141     \}
142 
143     \hyperlink{build_2sdk__eavb_2openavb__trace__pub_8h_a0906ddd9e84cc650a76634fe8ff766d7}{AVB\_TRACE\_EXIT}(\hyperlink{openavb__trace_8h_ae679116a5251aad926d752e57edbb7d3}{AVB\_TRACE\_TL});
144 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{openavb__talker__endpoint_8c_a286e27f8aca460f0e104d9e3d587eac6_cgraph}
\end{center}
\end{figure}


\index{openavb\+\_\+talker\+\_\+endpoint.\+c@{openavb\+\_\+talker\+\_\+endpoint.\+c}!openavb\+T\+L\+Run\+Talker\+Finish@{openavb\+T\+L\+Run\+Talker\+Finish}}
\index{openavb\+T\+L\+Run\+Talker\+Finish@{openavb\+T\+L\+Run\+Talker\+Finish}!openavb\+\_\+talker\+\_\+endpoint.\+c@{openavb\+\_\+talker\+\_\+endpoint.\+c}}
\subsubsection[{\texorpdfstring{openavb\+T\+L\+Run\+Talker\+Finish(tl\+\_\+state\+\_\+t $\ast$p\+T\+L\+State)}{openavbTLRunTalkerFinish(tl_state_t *pTLState)}}]{\setlength{\rightskip}{0pt plus 5cm}void openavb\+T\+L\+Run\+Talker\+Finish (
\begin{DoxyParamCaption}
\item[{{\bf tl\+\_\+state\+\_\+t} $\ast$}]{p\+T\+L\+State}
\end{DoxyParamCaption}
)}\hypertarget{openavb__talker__endpoint_8c_acbf24f0edf0c4e46ad7622dc23209965}{}\label{openavb__talker__endpoint_8c_acbf24f0edf0c4e46ad7622dc23209965}


openavb\+\_\+talker\+\_\+endpoint.\+c 파일의 197 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
198 \{
199 \}
\end{DoxyCode}
\index{openavb\+\_\+talker\+\_\+endpoint.\+c@{openavb\+\_\+talker\+\_\+endpoint.\+c}!openavb\+T\+L\+Run\+Talker\+Init@{openavb\+T\+L\+Run\+Talker\+Init}}
\index{openavb\+T\+L\+Run\+Talker\+Init@{openavb\+T\+L\+Run\+Talker\+Init}!openavb\+\_\+talker\+\_\+endpoint.\+c@{openavb\+\_\+talker\+\_\+endpoint.\+c}}
\subsubsection[{\texorpdfstring{openavb\+T\+L\+Run\+Talker\+Init(tl\+\_\+state\+\_\+t $\ast$p\+T\+L\+State)}{openavbTLRunTalkerInit(tl_state_t *pTLState)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf bool} openavb\+T\+L\+Run\+Talker\+Init (
\begin{DoxyParamCaption}
\item[{{\bf tl\+\_\+state\+\_\+t} $\ast$}]{p\+T\+L\+State}
\end{DoxyParamCaption}
)}\hypertarget{openavb__talker__endpoint_8c_a8a14b94cdaf2df77758c0ff8466137db}{}\label{openavb__talker__endpoint_8c_a8a14b94cdaf2df77758c0ff8466137db}


openavb\+\_\+talker\+\_\+endpoint.\+c 파일의 146 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
147 \{
148     \hyperlink{structopenavb__tl__cfg__t}{openavb\_tl\_cfg\_t} *pCfg = &pTLState->\hyperlink{structtl__state__t_a7b8161c0e9a273c59fbc1dfda943953e}{cfg};
149     \hyperlink{structtalker__data__t}{talker\_data\_t} *pTalkerData = pTLState->\hyperlink{structtl__state__t_a18baa6360ea16357a2e906bc9bc4e61e}{pPvtTalkerData};
150 
151     \hyperlink{struct_a_v_b_stream_i_d__t}{AVBStreamID\_t} streamID;
152     memset(&streamID, 0, \textcolor{keyword}{sizeof}(\hyperlink{struct_a_v_b_stream_i_d__t}{AVBStreamID\_t}));
153     \textcolor{keywordflow}{if} (pCfg->\hyperlink{structopenavb__tl__cfg__t_aad445ea3a27a465a885b5d56648ad282}{stream\_addr}.\hyperlink{structcfg__mac__t_af2bc5d41ceefb37a387542f87c90ccb8}{mac})
154         memcpy(streamID.\hyperlink{struct_a_v_b_stream_i_d__t_a48d52ffa49f2036631c913b36c85de02}{addr}, pCfg->\hyperlink{structopenavb__tl__cfg__t_aad445ea3a27a465a885b5d56648ad282}{stream\_addr}.\hyperlink{structcfg__mac__t_af2bc5d41ceefb37a387542f87c90ccb8}{mac}, \hyperlink{openavb__avdecc__pub_8h_a9822d89774e0d6ddaa06503950130423}{ETH\_ALEN});
155     streamID.\hyperlink{struct_a_v_b_stream_i_d__t_a7f5a958848a2b027d9f08e063b2e16a1}{uniqueID} = pCfg->\hyperlink{structopenavb__tl__cfg__t_a511b2a26fe61b945ced1dd0bab9f2d1b}{stream\_uid};
156 
157     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} maxBitrate = 0;
158     \textcolor{keywordflow}{if} (pCfg->\hyperlink{structopenavb__tl__cfg__t_a93f5e2efe8b8bbdac95c0beca4a2e236}{intf\_cb}.\hyperlink{structopenavb__intf__cb__t_a43b6a9d9343f06ff21f680a90c9529f6}{intf\_get\_src\_bitrate\_cb} != 
      \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}) \{
159         maxBitrate = pCfg->\hyperlink{structopenavb__tl__cfg__t_a93f5e2efe8b8bbdac95c0beca4a2e236}{intf\_cb}.\hyperlink{structopenavb__intf__cb__t_a43b6a9d9343f06ff21f680a90c9529f6}{intf\_get\_src\_bitrate\_cb}(pTLState->
      \hyperlink{structtl__state__t_a19b6a37a9e1222c5c08444ea175d6a45}{pMediaQ});
160     \}
161     \textcolor{keywordflow}{if} (maxBitrate > 0) \{
162         \textcolor{keywordflow}{if} (pCfg->\hyperlink{structopenavb__tl__cfg__t_a0a631fd45cd5f56f47a927e435f21a38}{map\_cb}.\hyperlink{structopenavb__map__cb__t_a51d32b904dad1b9f7dd1d6169128d806}{map\_set\_src\_bitrate\_cb} != 
      \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}) \{
163             pCfg->\hyperlink{structopenavb__tl__cfg__t_a0a631fd45cd5f56f47a927e435f21a38}{map\_cb}.\hyperlink{structopenavb__map__cb__t_a51d32b904dad1b9f7dd1d6169128d806}{map\_set\_src\_bitrate\_cb}(pTLState->
      \hyperlink{structtl__state__t_a19b6a37a9e1222c5c08444ea175d6a45}{pMediaQ}, maxBitrate);
164         \}
165 
166         \textcolor{keywordflow}{if} (pCfg->\hyperlink{structopenavb__tl__cfg__t_a0a631fd45cd5f56f47a927e435f21a38}{map\_cb}.\hyperlink{structopenavb__map__cb__t_af91d6f178bc808c13b21abab3861accb}{map\_get\_max\_interval\_frames\_cb} != 
      \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}) \{
167             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} map\_intv\_frames = pCfg->\hyperlink{structopenavb__tl__cfg__t_a0a631fd45cd5f56f47a927e435f21a38}{map\_cb}.
      \hyperlink{structopenavb__map__cb__t_af91d6f178bc808c13b21abab3861accb}{map\_get\_max\_interval\_frames\_cb}(pTLState->\hyperlink{structtl__state__t_a19b6a37a9e1222c5c08444ea175d6a45}{pMediaQ}, pTLState->
      \hyperlink{structtl__state__t_a7b8161c0e9a273c59fbc1dfda943953e}{cfg}.\hyperlink{structopenavb__tl__cfg__t_a39d4e73b306d801de38536c43ef7a5e8}{sr\_class});
168             pCfg->\hyperlink{structopenavb__tl__cfg__t_abf63c5094d06b48eb2da41a9cf3e1d00}{max\_interval\_frames} = map\_intv\_frames > 0 ? map\_intv\_frames : pCfg->
      \hyperlink{structopenavb__tl__cfg__t_abf63c5094d06b48eb2da41a9cf3e1d00}{max\_interval\_frames};
169         \}
170     \}
171     pTalkerData->\hyperlink{structtalker__data__t_ab928eca0e7b010a8cc3a80be5bc8adcc}{tSpec}.\hyperlink{struct_a_v_b_t_spec__t_aa6e25cae4ef3413612cb1acd7164d6f2}{maxIntervalFrames} = pCfg->
      \hyperlink{structopenavb__tl__cfg__t_abf63c5094d06b48eb2da41a9cf3e1d00}{max\_interval\_frames};
172 
173     \textcolor{comment}{// The TSpec frame size is the L2 payload - i.e. no Ethernet headers, VLAN, FCS, etc...}
174     pTalkerData->\hyperlink{structtalker__data__t_ab928eca0e7b010a8cc3a80be5bc8adcc}{tSpec}.\hyperlink{struct_a_v_b_t_spec__t_ad06f76488c0370d7fcf0b26e71c07699}{maxFrameSize} = pCfg->\hyperlink{structopenavb__tl__cfg__t_a0a631fd45cd5f56f47a927e435f21a38}{map\_cb}.
      \hyperlink{structopenavb__map__cb__t_ac87069ceed64005bb4a3c8fbb3da8357}{map\_max\_data\_size\_cb}(pTLState->\hyperlink{structtl__state__t_a19b6a37a9e1222c5c08444ea175d6a45}{pMediaQ});
175 
176     \hyperlink{build_2sdk__eavb_2openavb__log__pub_8h_a2be7e90c7cb63f12b221ed1cd4999185}{AVB\_LOGF\_INFO}(\textcolor{stringliteral}{"Register "}\hyperlink{build_2sdk__eavb_2openavb__log__pub_8h_a0b0c4c2befb547f1b5df6955851d64c1}{STREAMID\_FORMAT}\textcolor{stringliteral}{": class: %c frame size: %d  frame
       interval: %d"}, \hyperlink{build_2sdk__eavb_2openavb__log__pub_8h_aadd7c634873e1e0a405e5b211ad50368}{STREAMID\_ARGS}(&streamID), \hyperlink{avb__sched_8h_a827ea10887f7f8085c7f0aabb2fca2f9}{AVB\_CLASS\_LABEL}(pCfg->
      \hyperlink{structopenavb__tl__cfg__t_a39d4e73b306d801de38536c43ef7a5e8}{sr\_class}), pTalkerData->\hyperlink{structtalker__data__t_ab928eca0e7b010a8cc3a80be5bc8adcc}{tSpec}.\hyperlink{struct_a_v_b_t_spec__t_ad06f76488c0370d7fcf0b26e71c07699}{maxFrameSize}, pTalkerData->
      \hyperlink{structtalker__data__t_ab928eca0e7b010a8cc3a80be5bc8adcc}{tSpec}.\hyperlink{struct_a_v_b_t_spec__t_aa6e25cae4ef3413612cb1acd7164d6f2}{maxIntervalFrames});
177 
178     \textcolor{comment}{// Tell endpoint to register our stream.}
179     \textcolor{comment}{// SRP will send out talker declarations on the LAN.}
180     \textcolor{comment}{// If there are listeners, we'll get callback (above.)}
181     \hyperlink{openavb__types__base__pub_8h_a696390429f2f3b644bde8d0322a24124}{U32} transmitInterval = pTalkerData->\hyperlink{structtalker__data__t_a0bf28249cb23ce65c155693440118df5}{classRate};
182     \textcolor{keywordflow}{if} (pCfg->\hyperlink{structopenavb__tl__cfg__t_a0a631fd45cd5f56f47a927e435f21a38}{map\_cb}.\hyperlink{structopenavb__map__cb__t_a9928a7e0cddbaebed6cb1333e270acf3}{map\_transmit\_interval\_cb}(pTLState->
      \hyperlink{structtl__state__t_a19b6a37a9e1222c5c08444ea175d6a45}{pMediaQ})) \{
183         \textcolor{comment}{// Override the class observation interval with the one provided by the mapping module.}
184         transmitInterval = pCfg->\hyperlink{structopenavb__tl__cfg__t_a0a631fd45cd5f56f47a927e435f21a38}{map\_cb}.\hyperlink{structopenavb__map__cb__t_a9928a7e0cddbaebed6cb1333e270acf3}{map\_transmit\_interval\_cb}(pTLState->
      \hyperlink{structtl__state__t_a19b6a37a9e1222c5c08444ea175d6a45}{pMediaQ});
185     \}
186     \textcolor{keywordflow}{return} (\hyperlink{openavb__endpoint_8h_a8c99f67f773e32e1bfe3c532a6571751}{openavbEptClntRegisterStream}(pTLState->
      \hyperlink{structtl__state__t_ab3ab35067245073649b909ddc82c2807}{endpointHandle},
187             &streamID,
188             pCfg->\hyperlink{structopenavb__tl__cfg__t_adafdd018fad617237267247e6680f87a}{dest\_addr}.\hyperlink{structcfg__mac__t_af2bc5d41ceefb37a387542f87c90ccb8}{mac}->ether\_addr\_octet,
189             pCfg->\hyperlink{structopenavb__tl__cfg__t_a34a2e8da45008a86cef126647be52472}{backup\_dest\_addr\_valid}, \textcolor{comment}{// If we have a backup dest\_addr, then the
       current one was forced and MAAP should not be used.}
190             &pTalkerData->\hyperlink{structtalker__data__t_ab928eca0e7b010a8cc3a80be5bc8adcc}{tSpec},
191             pCfg->\hyperlink{structopenavb__tl__cfg__t_a39d4e73b306d801de38536c43ef7a5e8}{sr\_class},
192             pCfg->\hyperlink{structopenavb__tl__cfg__t_aec168f739a62e7d1167959b587d0a50b}{sr\_rank},
193             pCfg->\hyperlink{structopenavb__tl__cfg__t_a770b9a7e3ef496ca3269c2005f12fa81}{internal\_latency},
194             transmitInterval));
195 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{openavb__talker__endpoint_8c_a8a14b94cdaf2df77758c0ff8466137db_cgraph}
\end{center}
\end{figure}


