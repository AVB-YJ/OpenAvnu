\hypertarget{struct_memory_leak_detector_table}{}\section{Memory\+Leak\+Detector\+Table 구조체 참조}
\label{struct_memory_leak_detector_table}\index{Memory\+Leak\+Detector\+Table@{Memory\+Leak\+Detector\+Table}}


{\ttfamily \#include $<$Memory\+Leak\+Detector.\+h$>$}



Memory\+Leak\+Detector\+Table에 대한 협력 다이어그램\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=550pt]{struct_memory_leak_detector_table__coll__graph}
\end{center}
\end{figure}
\subsection*{Public 멤버 함수}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{struct_memory_leak_detector_table_a6c18f981e1c2139528a10aa573ffeaa9}{clear\+All\+Accounting} (\hyperlink{_memory_leak_detector_8h_ab248e6cc6c6699b88b002286d8a3ed76}{Mem\+Leak\+Period} period)
\item 
void \hyperlink{struct_memory_leak_detector_table_a78f2e89c0db3e4216dcd2061d70dea84}{add\+New\+Node} (\hyperlink{struct_memory_leak_detector_node}{Memory\+Leak\+Detector\+Node} $\ast$node)
\item 
\hyperlink{struct_memory_leak_detector_node}{Memory\+Leak\+Detector\+Node} $\ast$ \hyperlink{struct_memory_leak_detector_table_aa1655267a6cde38557847aca1e545a77}{retrieve\+Node} (char $\ast$memory)
\item 
\hyperlink{struct_memory_leak_detector_node}{Memory\+Leak\+Detector\+Node} $\ast$ \hyperlink{struct_memory_leak_detector_table_aaa0452383ce806d8a7248cb567813f84}{remove\+Node} (char $\ast$memory)
\item 
int \hyperlink{struct_memory_leak_detector_table_ae203c76563a188474a816e4ef8d8aa06}{get\+Total\+Leaks} (\hyperlink{_memory_leak_detector_8h_ab248e6cc6c6699b88b002286d8a3ed76}{Mem\+Leak\+Period} period)
\item 
\hyperlink{struct_memory_leak_detector_node}{Memory\+Leak\+Detector\+Node} $\ast$ \hyperlink{struct_memory_leak_detector_table_a1b95cd1a5e8372a8f795f2d3387ae065}{get\+First\+Leak} (\hyperlink{_memory_leak_detector_8h_ab248e6cc6c6699b88b002286d8a3ed76}{Mem\+Leak\+Period} period)
\item 
\hyperlink{struct_memory_leak_detector_node}{Memory\+Leak\+Detector\+Node} $\ast$ \hyperlink{struct_memory_leak_detector_table_a4aafc8945d8152ee287b651ffd2ede97}{get\+Next\+Leak} (\hyperlink{struct_memory_leak_detector_node}{Memory\+Leak\+Detector\+Node} $\ast$leak, \hyperlink{_memory_leak_detector_8h_ab248e6cc6c6699b88b002286d8a3ed76}{Mem\+Leak\+Period} period)
\end{DoxyCompactItemize}
\subsection*{Private 타입}
\begin{DoxyCompactItemize}
\item 
enum \{ \hyperlink{struct_memory_leak_detector_table_a34df7cc7f69a8ec535eec8a524dcbaf9af69a0171f9288f3c7d098803381facbf}{hash\+\_\+prime} = M\+E\+M\+O\+R\+Y\+\_\+\+L\+E\+A\+K\+\_\+\+H\+A\+S\+H\+\_\+\+T\+A\+B\+L\+E\+\_\+\+S\+I\+ZE
 \}
\end{DoxyCompactItemize}
\subsection*{Private 멤버 함수}
\begin{DoxyCompactItemize}
\item 
unsigned long \hyperlink{struct_memory_leak_detector_table_ac75f34a5bb665fa98b7c96fbbee761ba}{hash} (char $\ast$memory)
\end{DoxyCompactItemize}
\subsection*{Private 속성}
\begin{DoxyCompactItemize}
\item 
\hyperlink{struct_memory_leak_detector_list}{Memory\+Leak\+Detector\+List} \hyperlink{struct_memory_leak_detector_table_acc85a6c3d987233f1bf24811ba473b8d}{table\+\_\+} \mbox{[}\hyperlink{struct_memory_leak_detector_table_a34df7cc7f69a8ec535eec8a524dcbaf9af69a0171f9288f3c7d098803381facbf}{hash\+\_\+prime}\mbox{]}
\end{DoxyCompactItemize}


\subsection{상세한 설명}


Memory\+Leak\+Detector.\+h 파일의 164 번째 라인에서 정의되었습니다.



\subsection{멤버 열거형 문서화}
\subsubsection[{\texorpdfstring{anonymous enum}{anonymous enum}}]{\setlength{\rightskip}{0pt plus 5cm}anonymous enum\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{struct_memory_leak_detector_table_a34df7cc7f69a8ec535eec8a524dcbaf9}{}\label{struct_memory_leak_detector_table_a34df7cc7f69a8ec535eec8a524dcbaf9}
\begin{Desc}
\item[열거형 멤버]\par
\begin{description}
\index{hash\+\_\+prime@{hash\+\_\+prime}!Memory\+Leak\+Detector\+Table@{Memory\+Leak\+Detector\+Table}}\index{Memory\+Leak\+Detector\+Table@{Memory\+Leak\+Detector\+Table}!hash\+\_\+prime@{hash\+\_\+prime}}\item[{\em 
hash\+\_\+prime\hypertarget{struct_memory_leak_detector_table_a34df7cc7f69a8ec535eec8a524dcbaf9af69a0171f9288f3c7d098803381facbf}{}\label{struct_memory_leak_detector_table_a34df7cc7f69a8ec535eec8a524dcbaf9af69a0171f9288f3c7d098803381facbf}
}]\end{description}
\end{Desc}


Memory\+Leak\+Detector.\+h 파일의 181 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
182     \{
183         \hyperlink{struct_memory_leak_detector_table_a34df7cc7f69a8ec535eec8a524dcbaf9af69a0171f9288f3c7d098803381facbf}{hash\_prime} = \hyperlink{_test_harness_8h_a068c5404dfbd21c87f6cc4894fc7de8b}{MEMORY\_LEAK\_HASH\_TABLE\_SIZE}
184     \};
\end{DoxyCode}


\subsection{멤버 함수 문서화}
\index{Memory\+Leak\+Detector\+Table@{Memory\+Leak\+Detector\+Table}!add\+New\+Node@{add\+New\+Node}}
\index{add\+New\+Node@{add\+New\+Node}!Memory\+Leak\+Detector\+Table@{Memory\+Leak\+Detector\+Table}}
\subsubsection[{\texorpdfstring{add\+New\+Node(\+Memory\+Leak\+Detector\+Node $\ast$node)}{addNewNode(MemoryLeakDetectorNode *node)}}]{\setlength{\rightskip}{0pt plus 5cm}void add\+New\+Node (
\begin{DoxyParamCaption}
\item[{{\bf Memory\+Leak\+Detector\+Node} $\ast$}]{node}
\end{DoxyParamCaption}
)}\hypertarget{struct_memory_leak_detector_table_a78f2e89c0db3e4216dcd2061d70dea84}{}\label{struct_memory_leak_detector_table_a78f2e89c0db3e4216dcd2061d70dea84}


Memory\+Leak\+Detector.\+cpp 파일의 372 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
373 \{
374     \hyperlink{struct_memory_leak_detector_table_acc85a6c3d987233f1bf24811ba473b8d}{table\_}[\hyperlink{struct_memory_leak_detector_table_ac75f34a5bb665fa98b7c96fbbee761ba}{hash}(node->\hyperlink{struct_memory_leak_detector_node_a6cdb5ad30702010eaf86e4e5f26defce}{memory\_})].\hyperlink{struct_memory_leak_detector_list_a78f2e89c0db3e4216dcd2061d70dea84}{addNewNode}(node);
375 \}
\end{DoxyCode}
\index{Memory\+Leak\+Detector\+Table@{Memory\+Leak\+Detector\+Table}!clear\+All\+Accounting@{clear\+All\+Accounting}}
\index{clear\+All\+Accounting@{clear\+All\+Accounting}!Memory\+Leak\+Detector\+Table@{Memory\+Leak\+Detector\+Table}}
\subsubsection[{\texorpdfstring{clear\+All\+Accounting(\+Mem\+Leak\+Period period)}{clearAllAccounting(MemLeakPeriod period)}}]{\setlength{\rightskip}{0pt plus 5cm}void clear\+All\+Accounting (
\begin{DoxyParamCaption}
\item[{{\bf Mem\+Leak\+Period}}]{period}
\end{DoxyParamCaption}
)}\hypertarget{struct_memory_leak_detector_table_a6c18f981e1c2139528a10aa573ffeaa9}{}\label{struct_memory_leak_detector_table_a6c18f981e1c2139528a10aa573ffeaa9}


Memory\+Leak\+Detector.\+cpp 파일의 366 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
367 \{
368     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < \hyperlink{struct_memory_leak_detector_table_a34df7cc7f69a8ec535eec8a524dcbaf9af69a0171f9288f3c7d098803381facbf}{hash\_prime}; i++)
369         \hyperlink{struct_memory_leak_detector_table_acc85a6c3d987233f1bf24811ba473b8d}{table\_}[i].\hyperlink{struct_memory_leak_detector_table_a6c18f981e1c2139528a10aa573ffeaa9}{clearAllAccounting}(period);
370 \}
\end{DoxyCode}
\index{Memory\+Leak\+Detector\+Table@{Memory\+Leak\+Detector\+Table}!get\+First\+Leak@{get\+First\+Leak}}
\index{get\+First\+Leak@{get\+First\+Leak}!Memory\+Leak\+Detector\+Table@{Memory\+Leak\+Detector\+Table}}
\subsubsection[{\texorpdfstring{get\+First\+Leak(\+Mem\+Leak\+Period period)}{getFirstLeak(MemLeakPeriod period)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Memory\+Leak\+Detector\+Node} $\ast$ get\+First\+Leak (
\begin{DoxyParamCaption}
\item[{{\bf Mem\+Leak\+Period}}]{period}
\end{DoxyParamCaption}
)}\hypertarget{struct_memory_leak_detector_table_a1b95cd1a5e8372a8f795f2d3387ae065}{}\label{struct_memory_leak_detector_table_a1b95cd1a5e8372a8f795f2d3387ae065}


Memory\+Leak\+Detector.\+cpp 파일의 395 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
396 \{
397     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < \hyperlink{struct_memory_leak_detector_table_a34df7cc7f69a8ec535eec8a524dcbaf9af69a0171f9288f3c7d098803381facbf}{hash\_prime}; i++) \{
398         \hyperlink{struct_memory_leak_detector_node}{MemoryLeakDetectorNode}* node = \hyperlink{struct_memory_leak_detector_table_acc85a6c3d987233f1bf24811ba473b8d}{table\_}[i].
      \hyperlink{struct_memory_leak_detector_list_a1b95cd1a5e8372a8f795f2d3387ae065}{getFirstLeak}(period);
399         \textcolor{keywordflow}{if} (node) \textcolor{keywordflow}{return} node;
400     \}
401     \textcolor{keywordflow}{return} 0;
402 \}
\end{DoxyCode}
\index{Memory\+Leak\+Detector\+Table@{Memory\+Leak\+Detector\+Table}!get\+Next\+Leak@{get\+Next\+Leak}}
\index{get\+Next\+Leak@{get\+Next\+Leak}!Memory\+Leak\+Detector\+Table@{Memory\+Leak\+Detector\+Table}}
\subsubsection[{\texorpdfstring{get\+Next\+Leak(\+Memory\+Leak\+Detector\+Node $\ast$leak, Mem\+Leak\+Period period)}{getNextLeak(MemoryLeakDetectorNode *leak, MemLeakPeriod period)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Memory\+Leak\+Detector\+Node} $\ast$ get\+Next\+Leak (
\begin{DoxyParamCaption}
\item[{{\bf Memory\+Leak\+Detector\+Node} $\ast$}]{leak, }
\item[{{\bf Mem\+Leak\+Period}}]{period}
\end{DoxyParamCaption}
)}\hypertarget{struct_memory_leak_detector_table_a4aafc8945d8152ee287b651ffd2ede97}{}\label{struct_memory_leak_detector_table_a4aafc8945d8152ee287b651ffd2ede97}


Memory\+Leak\+Detector.\+cpp 파일의 404 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
405 \{
406     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} i = \hyperlink{struct_memory_leak_detector_table_ac75f34a5bb665fa98b7c96fbbee761ba}{hash}(leak->\hyperlink{struct_memory_leak_detector_node_a6cdb5ad30702010eaf86e4e5f26defce}{memory\_});
407     \hyperlink{struct_memory_leak_detector_node}{MemoryLeakDetectorNode}* node = \hyperlink{struct_memory_leak_detector_table_acc85a6c3d987233f1bf24811ba473b8d}{table\_}[i].
      \hyperlink{struct_memory_leak_detector_list_a7dc392fbd7a84bba7ce02a5586939537}{getNextLeak}(leak, period);
408     \textcolor{keywordflow}{if} (node) \textcolor{keywordflow}{return} node;
409 
410     \textcolor{keywordflow}{for} (++i; i < \hyperlink{struct_memory_leak_detector_table_a34df7cc7f69a8ec535eec8a524dcbaf9af69a0171f9288f3c7d098803381facbf}{hash\_prime}; i++) \{
411         node = \hyperlink{struct_memory_leak_detector_table_acc85a6c3d987233f1bf24811ba473b8d}{table\_}[i].\hyperlink{struct_memory_leak_detector_list_a1b95cd1a5e8372a8f795f2d3387ae065}{getFirstLeak}(period);
412         \textcolor{keywordflow}{if} (node) \textcolor{keywordflow}{return} node;
413     \}
414     \textcolor{keywordflow}{return} 0;
415 \}
\end{DoxyCode}
\index{Memory\+Leak\+Detector\+Table@{Memory\+Leak\+Detector\+Table}!get\+Total\+Leaks@{get\+Total\+Leaks}}
\index{get\+Total\+Leaks@{get\+Total\+Leaks}!Memory\+Leak\+Detector\+Table@{Memory\+Leak\+Detector\+Table}}
\subsubsection[{\texorpdfstring{get\+Total\+Leaks(\+Mem\+Leak\+Period period)}{getTotalLeaks(MemLeakPeriod period)}}]{\setlength{\rightskip}{0pt plus 5cm}int get\+Total\+Leaks (
\begin{DoxyParamCaption}
\item[{{\bf Mem\+Leak\+Period}}]{period}
\end{DoxyParamCaption}
)}\hypertarget{struct_memory_leak_detector_table_ae203c76563a188474a816e4ef8d8aa06}{}\label{struct_memory_leak_detector_table_ae203c76563a188474a816e4ef8d8aa06}


Memory\+Leak\+Detector.\+cpp 파일의 387 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
388 \{
389     \textcolor{keywordtype}{int} total\_leaks = 0;
390     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < \hyperlink{struct_memory_leak_detector_table_a34df7cc7f69a8ec535eec8a524dcbaf9af69a0171f9288f3c7d098803381facbf}{hash\_prime}; i++)
391         total\_leaks += \hyperlink{struct_memory_leak_detector_table_acc85a6c3d987233f1bf24811ba473b8d}{table\_}[i].\hyperlink{struct_memory_leak_detector_table_ae203c76563a188474a816e4ef8d8aa06}{getTotalLeaks}(period);
392     \textcolor{keywordflow}{return} total\_leaks;
393 \}
\end{DoxyCode}
\index{Memory\+Leak\+Detector\+Table@{Memory\+Leak\+Detector\+Table}!hash@{hash}}
\index{hash@{hash}!Memory\+Leak\+Detector\+Table@{Memory\+Leak\+Detector\+Table}}
\subsubsection[{\texorpdfstring{hash(char $\ast$memory)}{hash(char *memory)}}]{\setlength{\rightskip}{0pt plus 5cm}unsigned long hash (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{memory}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{struct_memory_leak_detector_table_ac75f34a5bb665fa98b7c96fbbee761ba}{}\label{struct_memory_leak_detector_table_ac75f34a5bb665fa98b7c96fbbee761ba}


Memory\+Leak\+Detector.\+cpp 파일의 361 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
362 \{
363     \textcolor{keywordflow}{return} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long})((size\_t)memory % \hyperlink{struct_memory_leak_detector_table_a34df7cc7f69a8ec535eec8a524dcbaf9af69a0171f9288f3c7d098803381facbf}{hash\_prime});
364 \}
\end{DoxyCode}
\index{Memory\+Leak\+Detector\+Table@{Memory\+Leak\+Detector\+Table}!remove\+Node@{remove\+Node}}
\index{remove\+Node@{remove\+Node}!Memory\+Leak\+Detector\+Table@{Memory\+Leak\+Detector\+Table}}
\subsubsection[{\texorpdfstring{remove\+Node(char $\ast$memory)}{removeNode(char *memory)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Memory\+Leak\+Detector\+Node} $\ast$ remove\+Node (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{memory}
\end{DoxyParamCaption}
)}\hypertarget{struct_memory_leak_detector_table_aaa0452383ce806d8a7248cb567813f84}{}\label{struct_memory_leak_detector_table_aaa0452383ce806d8a7248cb567813f84}


Memory\+Leak\+Detector.\+cpp 파일의 377 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
378 \{
379     \textcolor{keywordflow}{return} \hyperlink{struct_memory_leak_detector_table_acc85a6c3d987233f1bf24811ba473b8d}{table\_}[\hyperlink{struct_memory_leak_detector_table_ac75f34a5bb665fa98b7c96fbbee761ba}{hash}(memory)].\hyperlink{struct_memory_leak_detector_list_aaa0452383ce806d8a7248cb567813f84}{removeNode}(memory);
380 \}
\end{DoxyCode}
\index{Memory\+Leak\+Detector\+Table@{Memory\+Leak\+Detector\+Table}!retrieve\+Node@{retrieve\+Node}}
\index{retrieve\+Node@{retrieve\+Node}!Memory\+Leak\+Detector\+Table@{Memory\+Leak\+Detector\+Table}}
\subsubsection[{\texorpdfstring{retrieve\+Node(char $\ast$memory)}{retrieveNode(char *memory)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Memory\+Leak\+Detector\+Node} $\ast$ retrieve\+Node (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{memory}
\end{DoxyParamCaption}
)}\hypertarget{struct_memory_leak_detector_table_aa1655267a6cde38557847aca1e545a77}{}\label{struct_memory_leak_detector_table_aa1655267a6cde38557847aca1e545a77}


Memory\+Leak\+Detector.\+cpp 파일의 382 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
383 \{
384   \textcolor{keywordflow}{return} \hyperlink{struct_memory_leak_detector_table_acc85a6c3d987233f1bf24811ba473b8d}{table\_}[\hyperlink{struct_memory_leak_detector_table_ac75f34a5bb665fa98b7c96fbbee761ba}{hash}(memory)].\hyperlink{struct_memory_leak_detector_list_aa1655267a6cde38557847aca1e545a77}{retrieveNode}(memory);
385 \}
\end{DoxyCode}


\subsection{필드 문서화}
\index{Memory\+Leak\+Detector\+Table@{Memory\+Leak\+Detector\+Table}!table\+\_\+@{table\+\_\+}}
\index{table\+\_\+@{table\+\_\+}!Memory\+Leak\+Detector\+Table@{Memory\+Leak\+Detector\+Table}}
\subsubsection[{\texorpdfstring{table\+\_\+}{table_}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Memory\+Leak\+Detector\+List} table\+\_\+\mbox{[}{\bf hash\+\_\+prime}\mbox{]}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{struct_memory_leak_detector_table_acc85a6c3d987233f1bf24811ba473b8d}{}\label{struct_memory_leak_detector_table_acc85a6c3d987233f1bf24811ba473b8d}


Memory\+Leak\+Detector.\+h 파일의 185 번째 라인에서 정의되었습니다.



이 구조체에 대한 문서화 페이지는 다음의 파일들로부터 생성되었습니다.\+:\begin{DoxyCompactItemize}
\item 
thirdparty/cpputest/include/\+Cpp\+U\+Test/\hyperlink{_memory_leak_detector_8h}{Memory\+Leak\+Detector.\+h}\item 
thirdparty/cpputest/src/\+Cpp\+U\+Test/\hyperlink{_memory_leak_detector_8cpp}{Memory\+Leak\+Detector.\+cpp}\end{DoxyCompactItemize}
