\hypertarget{parse_8c}{}\section{daemons/common/parse.c 파일 참조}
\label{parse_8c}\index{daemons/common/parse.\+c@{daemons/common/parse.\+c}}
{\ttfamily \#include $<$stdio.\+h$>$}\\*
{\ttfamily \#include $<$string.\+h$>$}\\*
{\ttfamily \#include $<$stdint.\+h$>$}\\*
{\ttfamily \#include \char`\"{}parse.\+h\char`\"{}}\\*
parse.\+c에 대한 include 의존 그래프
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=346pt]{parse_8c__incl}
\end{center}
\end{figure}
\subsection*{매크로}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{parse_8c_af085b9f73207a4b3b4a133ab05fd7eef}{S\+C\+Nu64}~\char`\"{}I64u\char`\"{}
\item 
\#define \hyperlink{parse_8c_a4c454faacb996aa020efeb312379af4e}{S\+C\+Nx64}~\char`\"{}I64x\char`\"{}
\item 
\#define \hyperlink{parse_8c_a9c6cde6e32066eac6c2be378c14b6c31}{parse\+\_\+log}(a,  b)
\end{DoxyCompactItemize}
\subsection*{타입정의}
\begin{DoxyCompactItemize}
\item 
typedef \+\_\+\+\_\+int32 \hyperlink{parse_8c_a37994e3b11c72957c6f454c6ec96d43d}{int32\+\_\+t}
\item 
typedef unsigned \+\_\+\+\_\+int32 \hyperlink{parse_8c_a6eb1e68cc391dd753bc8ce896dbb8315}{uint32\+\_\+t}
\item 
typedef \+\_\+\+\_\+int64 \hyperlink{parse_8c_a67a9885ef4908cb72ce26d75b694386c}{int64\+\_\+t}
\item 
typedef unsigned \+\_\+\+\_\+int64 \hyperlink{parse_8c_aec6fcb673ff035718c238c8c9d544c47}{uint64\+\_\+t}
\end{DoxyCompactItemize}
\subsection*{함수}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{parse_8c_a2f6a69a9fef60eee9fc83d6f16367302}{parse} (const char $\ast$s, int len, struct \hyperlink{structparse__param}{parse\+\_\+param} $\ast$specs, int $\ast$err\+\_\+index)
\end{DoxyCompactItemize}


\subsection{매크로 문서화}
\index{parse.\+c@{parse.\+c}!parse\+\_\+log@{parse\+\_\+log}}
\index{parse\+\_\+log@{parse\+\_\+log}!parse.\+c@{parse.\+c}}
\subsubsection[{\texorpdfstring{parse\+\_\+log}{parse_log}}]{\setlength{\rightskip}{0pt plus 5cm}\#define parse\+\_\+log(
\begin{DoxyParamCaption}
\item[{}]{a, }
\item[{}]{b}
\end{DoxyParamCaption}
)}\hypertarget{parse_8c_a9c6cde6e32066eac6c2be378c14b6c31}{}\label{parse_8c_a9c6cde6e32066eac6c2be378c14b6c31}


parse.\+c 파일의 54 번째 라인에서 정의되었습니다.

\index{parse.\+c@{parse.\+c}!S\+C\+Nu64@{S\+C\+Nu64}}
\index{S\+C\+Nu64@{S\+C\+Nu64}!parse.\+c@{parse.\+c}}
\subsubsection[{\texorpdfstring{S\+C\+Nu64}{SCNu64}}]{\setlength{\rightskip}{0pt plus 5cm}\#define S\+C\+Nu64~\char`\"{}I64u\char`\"{}}\hypertarget{parse_8c_af085b9f73207a4b3b4a133ab05fd7eef}{}\label{parse_8c_af085b9f73207a4b3b4a133ab05fd7eef}


parse.\+c 파일의 45 번째 라인에서 정의되었습니다.

\index{parse.\+c@{parse.\+c}!S\+C\+Nx64@{S\+C\+Nx64}}
\index{S\+C\+Nx64@{S\+C\+Nx64}!parse.\+c@{parse.\+c}}
\subsubsection[{\texorpdfstring{S\+C\+Nx64}{SCNx64}}]{\setlength{\rightskip}{0pt plus 5cm}\#define S\+C\+Nx64~\char`\"{}I64x\char`\"{}}\hypertarget{parse_8c_a4c454faacb996aa020efeb312379af4e}{}\label{parse_8c_a4c454faacb996aa020efeb312379af4e}


parse.\+c 파일의 46 번째 라인에서 정의되었습니다.



\subsection{타입정의 문서화}
\index{parse.\+c@{parse.\+c}!int32\+\_\+t@{int32\+\_\+t}}
\index{int32\+\_\+t@{int32\+\_\+t}!parse.\+c@{parse.\+c}}
\subsubsection[{\texorpdfstring{int32\+\_\+t}{int32_t}}]{\setlength{\rightskip}{0pt plus 5cm}typedef \+\_\+\+\_\+int32 {\bf int32\+\_\+t}}\hypertarget{parse_8c_a37994e3b11c72957c6f454c6ec96d43d}{}\label{parse_8c_a37994e3b11c72957c6f454c6ec96d43d}


parse.\+c 파일의 40 번째 라인에서 정의되었습니다.

\index{parse.\+c@{parse.\+c}!int64\+\_\+t@{int64\+\_\+t}}
\index{int64\+\_\+t@{int64\+\_\+t}!parse.\+c@{parse.\+c}}
\subsubsection[{\texorpdfstring{int64\+\_\+t}{int64_t}}]{\setlength{\rightskip}{0pt plus 5cm}typedef \+\_\+\+\_\+int64 {\bf int64\+\_\+t}}\hypertarget{parse_8c_a67a9885ef4908cb72ce26d75b694386c}{}\label{parse_8c_a67a9885ef4908cb72ce26d75b694386c}


parse.\+c 파일의 42 번째 라인에서 정의되었습니다.

\index{parse.\+c@{parse.\+c}!uint32\+\_\+t@{uint32\+\_\+t}}
\index{uint32\+\_\+t@{uint32\+\_\+t}!parse.\+c@{parse.\+c}}
\subsubsection[{\texorpdfstring{uint32\+\_\+t}{uint32_t}}]{\setlength{\rightskip}{0pt plus 5cm}typedef unsigned \+\_\+\+\_\+int32 {\bf uint32\+\_\+t}}\hypertarget{parse_8c_a6eb1e68cc391dd753bc8ce896dbb8315}{}\label{parse_8c_a6eb1e68cc391dd753bc8ce896dbb8315}


parse.\+c 파일의 41 번째 라인에서 정의되었습니다.

\index{parse.\+c@{parse.\+c}!uint64\+\_\+t@{uint64\+\_\+t}}
\index{uint64\+\_\+t@{uint64\+\_\+t}!parse.\+c@{parse.\+c}}
\subsubsection[{\texorpdfstring{uint64\+\_\+t}{uint64_t}}]{\setlength{\rightskip}{0pt plus 5cm}typedef unsigned \+\_\+\+\_\+int64 {\bf uint64\+\_\+t}}\hypertarget{parse_8c_aec6fcb673ff035718c238c8c9d544c47}{}\label{parse_8c_aec6fcb673ff035718c238c8c9d544c47}


parse.\+c 파일의 43 번째 라인에서 정의되었습니다.



\subsection{함수 문서화}
\index{parse.\+c@{parse.\+c}!parse@{parse}}
\index{parse@{parse}!parse.\+c@{parse.\+c}}
\subsubsection[{\texorpdfstring{parse(const char $\ast$s, int len, struct parse\+\_\+param $\ast$specs, int $\ast$err\+\_\+index)}{parse(const char *s, int len, struct parse_param *specs, int *err_index)}}]{\setlength{\rightskip}{0pt plus 5cm}int parse (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{s, }
\item[{int}]{len, }
\item[{struct {\bf parse\+\_\+param} $\ast$}]{specs, }
\item[{int $\ast$}]{err\+\_\+index}
\end{DoxyParamCaption}
)}\hypertarget{parse_8c_a2f6a69a9fef60eee9fc83d6f16367302}{}\label{parse_8c_a2f6a69a9fef60eee9fc83d6f16367302}
Parse a string of parameters into specified types. 
\begin{DoxyParams}{매개변수}
{\em s} & a null terminated string to be parsed \\
\hline
{\em len} & the length of buffer containing the string to be parsed. This is not strlen(s)!. \\
\hline
{\em specs} & a pointer to an array of parsing specificaions \\
\hline
{\em the} & parameter index at which a parsing error occured \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{반환값}
0 on success 
\end{DoxyReturn}


parse.\+c 파일의 57 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
58 \{
59     \textcolor{keywordtype}{int} \hyperlink{gst__avb__playbin_8c_a6ce68847c12434f60d1b2654a3dc3409}{err} = 0;
60     \textcolor{keywordtype}{char} *param;
61     \textcolor{keywordtype}{char} *data;
62     \textcolor{keywordtype}{char} *delimiter;
63     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *guard;
64     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} v\_uint;
65     \hyperlink{parse_8c_aec6fcb673ff035718c238c8c9d544c47}{uint64\_t} v\_uint64;
66     \textcolor{keywordtype}{int} result = 0;
67     \textcolor{keywordtype}{int} count = 0;
68     \textcolor{keywordtype}{int} i;
69     
70     \textcolor{comment}{/* look for a null starting at the end of the buffer until}
71 \textcolor{comment}{    we find one or hit the beginning of the buffer */}
72     \textcolor{keywordflow}{for} (i = len - 1; s[i] != 0 && i >= 0; --i) \{\}
73 
74     \textcolor{comment}{/* If a null wasn't found before the element at offset 0, counter will be negative */}
75     \textcolor{keywordflow}{if} (i < 0)
76         \textcolor{keywordflow}{return} -1;
77 
78     guard = s + strlen(s);
79 
80     \hyperlink{parse_8c_a9c6cde6e32066eac6c2be378c14b6c31}{parse\_log}(\textcolor{stringliteral}{"PARSE: %s\(\backslash\)n"}, s);
81 
82     \textcolor{keywordflow}{while} (specs->\hyperlink{structparse__param_a5ac083a645d964373f022d03df4849c8}{name} && !err) \{
83         param = strstr(s, specs->\hyperlink{structparse__param_a5ac083a645d964373f022d03df4849c8}{name});
84         \textcolor{keywordflow}{if} (\hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} == param) \{
85             *err\_index = count + 1;
86             \hyperlink{parse_8c_a9c6cde6e32066eac6c2be378c14b6c31}{parse\_log}(\textcolor{stringliteral}{"PARSE: ERROR - could not find %s\(\backslash\)n"},
87                   specs->\hyperlink{structparse__param_a5ac083a645d964373f022d03df4849c8}{name});
88             \textcolor{keywordflow}{return} -1;
89         \}
90         data = param + strlen(specs->\hyperlink{structparse__param_a5ac083a645d964373f022d03df4849c8}{name});
91 
92         \textcolor{comment}{/* temporarily terminate string at next delimiter */}
93         delimiter = data;
94         \textcolor{keywordflow}{while} ((*delimiter != \hyperlink{parse_8h_a951bb068f84030df2b096f5afdeec2ce}{PARSE\_DELIMITER}) && (delimiter < guard))
95             delimiter++;
96         \textcolor{keywordflow}{if} (delimiter < guard)
97             *delimiter = 0;
98 
99         \textcolor{keywordflow}{switch} (specs->\hyperlink{structparse__param_a0a166059b44f584dc5dbec3ef5690c76}{type}) \{
100         \textcolor{keywordflow}{case} \hyperlink{parse_8h_a93f84b99386e130a55f8403e259db5d1ae39724d02c4758b719cf742a740a7dc0}{parse\_null}:
101             \textcolor{keywordflow}{break};
102         \textcolor{keywordflow}{case} \hyperlink{parse_8h_a93f84b99386e130a55f8403e259db5d1ad8e70adbd665b392e08d67b77839e326}{parse\_u8}:
103             result = sscanf(data, \textcolor{stringliteral}{"%u"}, &v\_uint);
104             \textcolor{keywordflow}{if} (result == 1) \{
105                 *(\hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t} *) specs->\hyperlink{structparse__param_a67806b49e20fb1170422969965db6ecb}{v} = (\hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t}) v\_uint;
106             \} \textcolor{keywordflow}{else} \{
107                 \hyperlink{parse_8c_a9c6cde6e32066eac6c2be378c14b6c31}{parse\_log}(\textcolor{stringliteral}{"PARSE: ERROR - parse\_u8 %s\(\backslash\)n"}, data);
108             \}
109             \textcolor{keywordflow}{break};
110         \textcolor{keywordflow}{case} \hyperlink{parse_8h_a93f84b99386e130a55f8403e259db5d1a65e22877b9a545a9077c70e8e7092694}{parse\_u16\_04x}:
111             result = sscanf(data, \textcolor{stringliteral}{"%04x"}, &v\_uint);
112             \textcolor{keywordflow}{if} (result == 1) \{
113                 *(uint16\_t *) specs->\hyperlink{structparse__param_a67806b49e20fb1170422969965db6ecb}{v} = (uint16\_t) v\_uint;
114             \} \textcolor{keywordflow}{else} \{
115                 \hyperlink{parse_8c_a9c6cde6e32066eac6c2be378c14b6c31}{parse\_log}(\textcolor{stringliteral}{"PARSE: ERROR - parse\_u16\_04x %s\(\backslash\)n"},
116                       data);
117             \}
118             \textcolor{keywordflow}{break};
119         \textcolor{keywordflow}{case} \hyperlink{parse_8h_a93f84b99386e130a55f8403e259db5d1ae073ce25a75fd9e9495aa67103e7f5fa}{parse\_u16}:
120             result = sscanf(data, \textcolor{stringliteral}{"%u"}, &v\_uint);
121             \textcolor{keywordflow}{if} (result == 1) \{
122                 *(uint16\_t *) specs->\hyperlink{structparse__param_a67806b49e20fb1170422969965db6ecb}{v} = (uint16\_t) v\_uint;
123             \} \textcolor{keywordflow}{else} \{
124                 \hyperlink{parse_8c_a9c6cde6e32066eac6c2be378c14b6c31}{parse\_log}(\textcolor{stringliteral}{"PARSE: ERROR - parse\_u16 %s\(\backslash\)n"},
125                       data);
126             \}
127             \textcolor{keywordflow}{break};
128         \textcolor{keywordflow}{case} \hyperlink{parse_8h_a93f84b99386e130a55f8403e259db5d1a56c3953bf6fdc050c04724a967d4ab9d}{parse\_u32}:
129             result = sscanf(data, \textcolor{stringliteral}{"%u"}, &v\_uint);
130             \textcolor{keywordflow}{if} (result == 1) \{
131                 *(\hyperlink{parse_8c_a6eb1e68cc391dd753bc8ce896dbb8315}{uint32\_t} *) specs->\hyperlink{structparse__param_a67806b49e20fb1170422969965db6ecb}{v} = v\_uint;
132             \} \textcolor{keywordflow}{else} \{
133                 \hyperlink{parse_8c_a9c6cde6e32066eac6c2be378c14b6c31}{parse\_log}(\textcolor{stringliteral}{"PARSE: ERROR - parse\_u32 %s\(\backslash\)n"},
134                       data);
135             \}
136             \textcolor{keywordflow}{break};
137         \textcolor{keywordflow}{case} \hyperlink{parse_8h_a93f84b99386e130a55f8403e259db5d1a1e34d61e7a5337ed3c35d4b9c4586a13}{parse\_u64}:
138             result = sscanf(data, \textcolor{stringliteral}{"%"} \hyperlink{parse_8c_af085b9f73207a4b3b4a133ab05fd7eef}{SCNu64}, &v\_uint64);
139             \textcolor{keywordflow}{if} (result == 1) \{
140                 *(\hyperlink{parse_8c_aec6fcb673ff035718c238c8c9d544c47}{uint64\_t} *) specs->\hyperlink{structparse__param_a67806b49e20fb1170422969965db6ecb}{v} = v\_uint64;
141             \} \textcolor{keywordflow}{else} \{
142                 \hyperlink{parse_8c_a9c6cde6e32066eac6c2be378c14b6c31}{parse\_log}(\textcolor{stringliteral}{"PARSE: ERROR - parse\_h64 %s\(\backslash\)n"},
143                       data);
144             \}
145             \textcolor{keywordflow}{break};
146         \textcolor{keywordflow}{case} \hyperlink{parse_8h_a93f84b99386e130a55f8403e259db5d1a51f79f871eba98e1f7e0d6184c9dfff8}{parse\_h64}:
147             result = sscanf(data, \textcolor{stringliteral}{"%"} \hyperlink{parse_8c_a4c454faacb996aa020efeb312379af4e}{SCNx64}, &v\_uint64);
148             \textcolor{keywordflow}{if} (result == 1) \{
149                 *(\hyperlink{parse_8c_aec6fcb673ff035718c238c8c9d544c47}{uint64\_t} *) specs->\hyperlink{structparse__param_a67806b49e20fb1170422969965db6ecb}{v} = v\_uint64;
150             \} \textcolor{keywordflow}{else} \{
151                 \hyperlink{parse_8c_a9c6cde6e32066eac6c2be378c14b6c31}{parse\_log}(\textcolor{stringliteral}{"PARSE: ERROR - parse\_h64 %s\(\backslash\)n"},
152                       data);
153             \}
154             \textcolor{keywordflow}{break};
155         \textcolor{keywordflow}{case} \hyperlink{parse_8h_a93f84b99386e130a55f8403e259db5d1aa40371707c2e44042057d29277a0dc69}{parse\_c64}:
156             \textcolor{comment}{/* read as uint64\_t, then unpack to array */}
157             result = sscanf(data, \textcolor{stringliteral}{"%"} \hyperlink{parse_8c_a4c454faacb996aa020efeb312379af4e}{SCNx64}, &v\_uint64);
158             \textcolor{keywordflow}{if} (result == 1) \{
159                 \textcolor{keywordtype}{int} i;
160                 \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t} *\hyperlink{structeui64set__entry_a117104b82864d3b23ec174af6d392709}{p} = (\hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t} *) specs->\hyperlink{structparse__param_a67806b49e20fb1170422969965db6ecb}{v};
161                 for (i = 0; i < 8; i++) \{
162                     \textcolor{keywordtype}{int} shift = (7 - i) * 8;
163                     p[i] = (\hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t}) (v\_uint64 >> shift);
164                 \}
165             \} \textcolor{keywordflow}{else} \{
166                 \hyperlink{parse_8c_a9c6cde6e32066eac6c2be378c14b6c31}{parse\_log}(\textcolor{stringliteral}{"PARSE: ERROR - parse\_c64 %s\(\backslash\)n"},
167                       data);
168             \}
169             \textcolor{keywordflow}{break};
170         \textcolor{keywordflow}{case} \hyperlink{parse_8h_a93f84b99386e130a55f8403e259db5d1a8704dcea9d4223b804f7a4a8a1e28421}{parse\_mac}:
171             \textcolor{comment}{/* read as uint64\_t, then unpack to array */}
172             result = sscanf(data, \textcolor{stringliteral}{"%"} \hyperlink{parse_8c_a4c454faacb996aa020efeb312379af4e}{SCNx64}, &v\_uint64);
173             \textcolor{keywordflow}{if} (result == 1) \{
174                 \textcolor{keywordtype}{int} i;
175                 \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t} *p = (\hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t} *) specs->\hyperlink{structparse__param_a67806b49e20fb1170422969965db6ecb}{v};
176                 for (i = 0; i < 6; i++) \{
177                     \textcolor{keywordtype}{int} shift = (5 - i) * 8;
178                     p[i] = (\hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t}) (v\_uint64 >> shift);
179                 \}
180             \} \textcolor{keywordflow}{else} \{
181                 \hyperlink{parse_8c_a9c6cde6e32066eac6c2be378c14b6c31}{parse\_log}(\textcolor{stringliteral}{"PARSE: ERROR - parse\_mac %s\(\backslash\)n"},
182                       data);
183             \}
184             \textcolor{keywordflow}{break};
185         \}
186         \textcolor{keywordflow}{if} (result != 1) \{
187             *err\_index = count + 1;
188             \textcolor{keywordflow}{return} -1;
189         \}
190 
191         \textcolor{keywordflow}{if} (delimiter < guard) \{
192             *delimiter = \hyperlink{parse_8h_a951bb068f84030df2b096f5afdeec2ce}{PARSE\_DELIMITER};
193             s = delimiter + 1;
194         \}
195         specs++;
196         count++;
197     \}
198     *err\_index = 0;
199     \textcolor{keywordflow}{return} 0;
200 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{parse_8c_a2f6a69a9fef60eee9fc83d6f16367302_icgraph}
\end{center}
\end{figure}


