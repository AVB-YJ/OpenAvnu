\hypertarget{class_code_memory_report_formatter}{}\section{Code\+Memory\+Report\+Formatter 클래스 참조}
\label{class_code_memory_report_formatter}\index{Code\+Memory\+Report\+Formatter@{Code\+Memory\+Report\+Formatter}}


{\ttfamily \#include $<$Code\+Memory\+Report\+Formatter.\+h$>$}



Code\+Memory\+Report\+Formatter에 대한 상속 다이어그램 \+: 
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=247pt]{class_code_memory_report_formatter__inherit__graph}
\end{center}
\end{figure}


Code\+Memory\+Report\+Formatter에 대한 협력 다이어그램\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_code_memory_report_formatter__coll__graph}
\end{center}
\end{figure}
\subsection*{Public 멤버 함수}
\begin{DoxyCompactItemize}
\item 
\hyperlink{class_code_memory_report_formatter_a91ded3a4619f7c76ea870067e3c8037c}{Code\+Memory\+Report\+Formatter} (\hyperlink{class_test_memory_allocator}{Test\+Memory\+Allocator} $\ast$internal\+Allocator)
\item 
virtual \hyperlink{class_code_memory_report_formatter_ae2c822376c389d96ab99f662ecb9bcf3}{$\sim$\+Code\+Memory\+Report\+Formatter} ()
\item 
virtual void \hyperlink{class_code_memory_report_formatter_a5752211789cc4a3478f07498cf8e3006}{report\+\_\+testgroup\+\_\+start} (\hyperlink{class_test_result}{Test\+Result} $\ast$result, \hyperlink{class_utest_shell}{Utest\+Shell} \&test) \hyperlink{_cpp_u_test_config_8h_a049bea15dd750e15869863c94c1efc3b}{\+\_\+override}
\item 
virtual void \hyperlink{class_code_memory_report_formatter_a654fe66c6d74e1276278ad0fbf6af3aa}{report\+\_\+testgroup\+\_\+end} (\hyperlink{class_test_result}{Test\+Result} $\ast$, \hyperlink{class_utest_shell}{Utest\+Shell} \&) \hyperlink{_cpp_u_test_config_8h_a049bea15dd750e15869863c94c1efc3b}{\+\_\+override}
\item 
virtual void \hyperlink{class_code_memory_report_formatter_ab6b7ea5f2e0c5bdad43b71b76881f362}{report\+\_\+test\+\_\+start} (\hyperlink{class_test_result}{Test\+Result} $\ast$result, \hyperlink{class_utest_shell}{Utest\+Shell} \&test) \hyperlink{_cpp_u_test_config_8h_a049bea15dd750e15869863c94c1efc3b}{\+\_\+override}
\item 
virtual void \hyperlink{class_code_memory_report_formatter_a2b191434b124b93d8c0ed5a05e084e02}{report\+\_\+test\+\_\+end} (\hyperlink{class_test_result}{Test\+Result} $\ast$result, \hyperlink{class_utest_shell}{Utest\+Shell} \&test) \hyperlink{_cpp_u_test_config_8h_a049bea15dd750e15869863c94c1efc3b}{\+\_\+override}
\item 
virtual void \hyperlink{class_code_memory_report_formatter_a662fcaf995e9e0137c8debfc33530366}{report\+\_\+alloc\+\_\+memory} (\hyperlink{class_test_result}{Test\+Result} $\ast$result, \hyperlink{class_test_memory_allocator}{Test\+Memory\+Allocator} $\ast$\hyperlink{_memory_leak_warning_test_8cpp_a83fc2e9b9142613f7df2bcc3ff8292bc}{allocator}, size\+\_\+t \hyperlink{gst__avb__playbin_8c_a439227feff9d7f55384e8780cfc2eb82}{size}, char $\ast$memory, const char $\ast$file, int line) \hyperlink{_cpp_u_test_config_8h_a049bea15dd750e15869863c94c1efc3b}{\+\_\+override}
\item 
virtual void \hyperlink{class_code_memory_report_formatter_ae5e392cdf5fece2cbd2eeb25e8478c8f}{report\+\_\+free\+\_\+memory} (\hyperlink{class_test_result}{Test\+Result} $\ast$result, \hyperlink{class_test_memory_allocator}{Test\+Memory\+Allocator} $\ast$\hyperlink{_memory_leak_warning_test_8cpp_a83fc2e9b9142613f7df2bcc3ff8292bc}{allocator}, char $\ast$memory, const char $\ast$file, int line) \hyperlink{_cpp_u_test_config_8h_a049bea15dd750e15869863c94c1efc3b}{\+\_\+override}
\end{DoxyCompactItemize}
\subsection*{Private 멤버 함수}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{class_code_memory_report_formatter_a52af7af383a8ca9f00412be8cf31fb52}{add\+Node\+To\+List} (const char $\ast$variable\+Name, void $\ast$memory, \hyperlink{struct_code_reporting_allocation_node}{Code\+Reporting\+Allocation\+Node} $\ast$next)
\item 
\hyperlink{struct_code_reporting_allocation_node}{Code\+Reporting\+Allocation\+Node} $\ast$ \hyperlink{class_code_memory_report_formatter_ab3bdf37ad56ffc1f06245f495afad613}{find\+Node} (void $\ast$memory)
\item 
\hyperlink{avb__gptp_8h_af6a258d8f3ee5206d682d799316314b1}{bool} \hyperlink{class_code_memory_report_formatter_aebb4bb2cfdbdeca9666a6b426fc126cb}{variable\+Exists} (const \hyperlink{class_simple_string}{Simple\+String} \&variable\+Name)
\item 
void \hyperlink{class_code_memory_report_formatter_a8bdb7334ae0af7865a368903e7e9c3b3}{clear\+Reporting} ()
\item 
\hyperlink{avb__gptp_8h_af6a258d8f3ee5206d682d799316314b1}{bool} \hyperlink{class_code_memory_report_formatter_a33b96e0ded7b181daf75a9aab9a8f370}{is\+New\+Allocator} (\hyperlink{class_test_memory_allocator}{Test\+Memory\+Allocator} $\ast$\hyperlink{_memory_leak_warning_test_8cpp_a83fc2e9b9142613f7df2bcc3ff8292bc}{allocator})
\item 
\hyperlink{class_simple_string}{Simple\+String} \hyperlink{class_code_memory_report_formatter_a2501cae5156eeee3e38c94c5b0304240}{create\+Variable\+Name\+From\+File\+Line\+Info} (const char $\ast$file, int line)
\item 
\hyperlink{class_simple_string}{Simple\+String} \hyperlink{class_code_memory_report_formatter_a184180e6760987bc2c4acfd59ad34fa5}{get\+Allocation\+String} (\hyperlink{class_test_memory_allocator}{Test\+Memory\+Allocator} $\ast$\hyperlink{_memory_leak_warning_test_8cpp_a83fc2e9b9142613f7df2bcc3ff8292bc}{allocator}, const \hyperlink{class_simple_string}{Simple\+String} \&variable\+Name, size\+\_\+t \hyperlink{gst__avb__playbin_8c_a439227feff9d7f55384e8780cfc2eb82}{size})
\item 
\hyperlink{class_simple_string}{Simple\+String} \hyperlink{class_code_memory_report_formatter_a32fb96533a756602b0f707abdb20fe14}{get\+Deallocation\+String} (\hyperlink{class_test_memory_allocator}{Test\+Memory\+Allocator} $\ast$\hyperlink{_memory_leak_warning_test_8cpp_a83fc2e9b9142613f7df2bcc3ff8292bc}{allocator}, const \hyperlink{class_simple_string}{Simple\+String} \&variable\+Name, const char $\ast$file, int line)
\end{DoxyCompactItemize}
\subsection*{Private 속성}
\begin{DoxyCompactItemize}
\item 
\hyperlink{struct_code_reporting_allocation_node}{Code\+Reporting\+Allocation\+Node} $\ast$ \hyperlink{class_code_memory_report_formatter_a7256d2e6da45bdd7eaa77637be299e56}{code\+Reporting\+List\+\_\+}
\item 
\hyperlink{class_test_memory_allocator}{Test\+Memory\+Allocator} $\ast$ \hyperlink{class_code_memory_report_formatter_a5177d1223b6c18bfc2ddfb40e8400d84}{internal\+Allocator\+\_\+}
\end{DoxyCompactItemize}


\subsection{상세한 설명}


Code\+Memory\+Report\+Formatter.\+h 파일의 34 번째 라인에서 정의되었습니다.



\subsection{생성자 \& 소멸자 문서화}
\index{Code\+Memory\+Report\+Formatter@{Code\+Memory\+Report\+Formatter}!Code\+Memory\+Report\+Formatter@{Code\+Memory\+Report\+Formatter}}
\index{Code\+Memory\+Report\+Formatter@{Code\+Memory\+Report\+Formatter}!Code\+Memory\+Report\+Formatter@{Code\+Memory\+Report\+Formatter}}
\subsubsection[{\texorpdfstring{Code\+Memory\+Report\+Formatter(\+Test\+Memory\+Allocator $\ast$internal\+Allocator)}{CodeMemoryReportFormatter(TestMemoryAllocator *internalAllocator)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Code\+Memory\+Report\+Formatter} (
\begin{DoxyParamCaption}
\item[{{\bf Test\+Memory\+Allocator} $\ast$}]{internal\+Allocator}
\end{DoxyParamCaption}
)}\hypertarget{class_code_memory_report_formatter_a91ded3a4619f7c76ea870067e3c8037c}{}\label{class_code_memory_report_formatter_a91ded3a4619f7c76ea870067e3c8037c}


Code\+Memory\+Report\+Formatter.\+cpp 파일의 46 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
47     : \hyperlink{class_code_memory_report_formatter_a7256d2e6da45bdd7eaa77637be299e56}{codeReportingList\_}(\hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}), \hyperlink{class_code_memory_report_formatter_a5177d1223b6c18bfc2ddfb40e8400d84}{internalAllocator\_}(
      internalAllocator)
48 \{
49 \}
\end{DoxyCode}
\index{Code\+Memory\+Report\+Formatter@{Code\+Memory\+Report\+Formatter}!````~Code\+Memory\+Report\+Formatter@{$\sim$\+Code\+Memory\+Report\+Formatter}}
\index{````~Code\+Memory\+Report\+Formatter@{$\sim$\+Code\+Memory\+Report\+Formatter}!Code\+Memory\+Report\+Formatter@{Code\+Memory\+Report\+Formatter}}
\subsubsection[{\texorpdfstring{$\sim$\+Code\+Memory\+Report\+Formatter()}{~CodeMemoryReportFormatter()}}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf Code\+Memory\+Report\+Formatter} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{class_code_memory_report_formatter_ae2c822376c389d96ab99f662ecb9bcf3}{}\label{class_code_memory_report_formatter_ae2c822376c389d96ab99f662ecb9bcf3}


Code\+Memory\+Report\+Formatter.\+cpp 파일의 51 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
52 \{
53     \hyperlink{class_code_memory_report_formatter_a8bdb7334ae0af7865a368903e7e9c3b3}{clearReporting}();
54 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_code_memory_report_formatter_ae2c822376c389d96ab99f662ecb9bcf3_cgraph}
\end{center}
\end{figure}




\subsection{멤버 함수 문서화}
\index{Code\+Memory\+Report\+Formatter@{Code\+Memory\+Report\+Formatter}!add\+Node\+To\+List@{add\+Node\+To\+List}}
\index{add\+Node\+To\+List@{add\+Node\+To\+List}!Code\+Memory\+Report\+Formatter@{Code\+Memory\+Report\+Formatter}}
\subsubsection[{\texorpdfstring{add\+Node\+To\+List(const char $\ast$variable\+Name, void $\ast$memory, Code\+Reporting\+Allocation\+Node $\ast$next)}{addNodeToList(const char *variableName, void *memory, CodeReportingAllocationNode *next)}}]{\setlength{\rightskip}{0pt plus 5cm}void add\+Node\+To\+List (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{variable\+Name, }
\item[{void $\ast$}]{memory, }
\item[{{\bf Code\+Reporting\+Allocation\+Node} $\ast$}]{next}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_code_memory_report_formatter_a52af7af383a8ca9f00412be8cf31fb52}{}\label{class_code_memory_report_formatter_a52af7af383a8ca9f00412be8cf31fb52}


Code\+Memory\+Report\+Formatter.\+cpp 파일의 65 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
66 \{
67     \hyperlink{struct_code_reporting_allocation_node}{CodeReportingAllocationNode}* newNode = (
      \hyperlink{struct_code_reporting_allocation_node}{CodeReportingAllocationNode}*) (\textcolor{keywordtype}{void}*) 
      \hyperlink{class_code_memory_report_formatter_a5177d1223b6c18bfc2ddfb40e8400d84}{internalAllocator\_}->\hyperlink{class_test_memory_allocator_a2ebbde51a1d514c74e9e2a09a21b0624}{alloc\_memory}(\textcolor{keyword}{sizeof}(
      \hyperlink{struct_code_reporting_allocation_node}{CodeReportingAllocationNode}), \_\_FILE\_\_, \_\_LINE\_\_);
68     newNode->\hyperlink{struct_code_reporting_allocation_node_a2873ecb79916c84dc21bb9a27876a46c}{memory\_} = memory;
69     newNode->\hyperlink{struct_code_reporting_allocation_node_a8f0c58c5a02860822d947c32e435bd3c}{next\_} = next;
70     \hyperlink{class_simple_string_a441975b120170a5cf9662de1330e2bf4}{SimpleString::StrNCpy}(newNode->\hyperlink{struct_code_reporting_allocation_node_ac6f8a20a992369f629ef7f014c8a884e}{variableName\_}, variableName, 
      \hyperlink{_code_memory_report_formatter_8cpp_a390a261795a09db8b3cf37b5942f00bd}{MAX\_VARIABLE\_NAME\_LENGTH});
71     \hyperlink{class_code_memory_report_formatter_a7256d2e6da45bdd7eaa77637be299e56}{codeReportingList\_} = newNode;
72 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_code_memory_report_formatter_a52af7af383a8ca9f00412be8cf31fb52_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_code_memory_report_formatter_a52af7af383a8ca9f00412be8cf31fb52_icgraph}
\end{center}
\end{figure}


\index{Code\+Memory\+Report\+Formatter@{Code\+Memory\+Report\+Formatter}!clear\+Reporting@{clear\+Reporting}}
\index{clear\+Reporting@{clear\+Reporting}!Code\+Memory\+Report\+Formatter@{Code\+Memory\+Report\+Formatter}}
\subsubsection[{\texorpdfstring{clear\+Reporting()}{clearReporting()}}]{\setlength{\rightskip}{0pt plus 5cm}void clear\+Reporting (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_code_memory_report_formatter_a8bdb7334ae0af7865a368903e7e9c3b3}{}\label{class_code_memory_report_formatter_a8bdb7334ae0af7865a368903e7e9c3b3}


Code\+Memory\+Report\+Formatter.\+cpp 파일의 56 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
57 \{
58     \textcolor{keywordflow}{while} (\hyperlink{class_code_memory_report_formatter_a7256d2e6da45bdd7eaa77637be299e56}{codeReportingList\_}) \{
59         \hyperlink{struct_code_reporting_allocation_node}{CodeReportingAllocationNode}* oldNode = 
      \hyperlink{class_code_memory_report_formatter_a7256d2e6da45bdd7eaa77637be299e56}{codeReportingList\_};
60         \hyperlink{class_code_memory_report_formatter_a7256d2e6da45bdd7eaa77637be299e56}{codeReportingList\_} = \hyperlink{class_code_memory_report_formatter_a7256d2e6da45bdd7eaa77637be299e56}{codeReportingList\_}->
      \hyperlink{struct_code_reporting_allocation_node_a8f0c58c5a02860822d947c32e435bd3c}{next\_};
61         \hyperlink{class_code_memory_report_formatter_a5177d1223b6c18bfc2ddfb40e8400d84}{internalAllocator\_}->\hyperlink{class_test_memory_allocator_a529ac9813d3b0836ce0b964449942534}{free\_memory}((\textcolor{keywordtype}{char}*) oldNode, \_\_FILE\_\_, \_\_LINE\_\_);
62     \}
63 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=306pt]{class_code_memory_report_formatter_a8bdb7334ae0af7865a368903e7e9c3b3_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_code_memory_report_formatter_a8bdb7334ae0af7865a368903e7e9c3b3_icgraph}
\end{center}
\end{figure}


\index{Code\+Memory\+Report\+Formatter@{Code\+Memory\+Report\+Formatter}!create\+Variable\+Name\+From\+File\+Line\+Info@{create\+Variable\+Name\+From\+File\+Line\+Info}}
\index{create\+Variable\+Name\+From\+File\+Line\+Info@{create\+Variable\+Name\+From\+File\+Line\+Info}!Code\+Memory\+Report\+Formatter@{Code\+Memory\+Report\+Formatter}}
\subsubsection[{\texorpdfstring{create\+Variable\+Name\+From\+File\+Line\+Info(const char $\ast$file, int line)}{createVariableNameFromFileLineInfo(const char *file, int line)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Simple\+String} create\+Variable\+Name\+From\+File\+Line\+Info (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{file, }
\item[{int}]{line}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_code_memory_report_formatter_a2501cae5156eeee3e38c94c5b0304240}{}\label{class_code_memory_report_formatter_a2501cae5156eeee3e38c94c5b0304240}


Code\+Memory\+Report\+Formatter.\+cpp 파일의 93 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
94 \{
95     \hyperlink{class_simple_string}{SimpleString} fileNameOnly = \hyperlink{_code_memory_report_formatter_8cpp_a15549f21e6fbd249c1758ba595a4ce01}{extractFileNameFromPath}(file);
96     fileNameOnly.\hyperlink{class_simple_string_a432bd98f2897a79d54b8dd64de48247e}{replace}(\textcolor{stringliteral}{"."}, \textcolor{stringliteral}{"\_"});
97 
98     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 1; i < 100; i++) \{
99         \hyperlink{class_simple_string}{SimpleString} variableName = \hyperlink{_simple_string_8h_a0699d0e92f0abee2b3bdb9f254f90e51}{StringFromFormat}(\textcolor{stringliteral}{"%s\_%d\_%d"}, fileNameOnly.
      \hyperlink{class_simple_string_af7c0efaf31f42553f05719903c830be1}{asCharString}(), line, i);
100         \textcolor{keywordflow}{if} (!\hyperlink{class_code_memory_report_formatter_aebb4bb2cfdbdeca9666a6b426fc126cb}{variableExists}(variableName))
101             \textcolor{keywordflow}{return} variableName;
102     \}
103     \textcolor{keywordflow}{return} \textcolor{stringliteral}{""};
104 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_code_memory_report_formatter_a2501cae5156eeee3e38c94c5b0304240_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_code_memory_report_formatter_a2501cae5156eeee3e38c94c5b0304240_icgraph}
\end{center}
\end{figure}


\index{Code\+Memory\+Report\+Formatter@{Code\+Memory\+Report\+Formatter}!find\+Node@{find\+Node}}
\index{find\+Node@{find\+Node}!Code\+Memory\+Report\+Formatter@{Code\+Memory\+Report\+Formatter}}
\subsubsection[{\texorpdfstring{find\+Node(void $\ast$memory)}{findNode(void *memory)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Code\+Reporting\+Allocation\+Node} $\ast$ find\+Node (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{memory}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_code_memory_report_formatter_ab3bdf37ad56ffc1f06245f495afad613}{}\label{class_code_memory_report_formatter_ab3bdf37ad56ffc1f06245f495afad613}


Code\+Memory\+Report\+Formatter.\+cpp 파일의 74 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
75 \{
76 
77     \hyperlink{struct_code_reporting_allocation_node}{CodeReportingAllocationNode}* current = 
      \hyperlink{class_code_memory_report_formatter_a7256d2e6da45bdd7eaa77637be299e56}{codeReportingList\_};
78     \textcolor{keywordflow}{while} (current && current->\hyperlink{struct_code_reporting_allocation_node_a2873ecb79916c84dc21bb9a27876a46c}{memory\_} != memory) \{
79         current = current->\hyperlink{struct_code_reporting_allocation_node_a8f0c58c5a02860822d947c32e435bd3c}{next\_};
80     \}
81     \textcolor{keywordflow}{return} current;
82 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_code_memory_report_formatter_ab3bdf37ad56ffc1f06245f495afad613_icgraph}
\end{center}
\end{figure}


\index{Code\+Memory\+Report\+Formatter@{Code\+Memory\+Report\+Formatter}!get\+Allocation\+String@{get\+Allocation\+String}}
\index{get\+Allocation\+String@{get\+Allocation\+String}!Code\+Memory\+Report\+Formatter@{Code\+Memory\+Report\+Formatter}}
\subsubsection[{\texorpdfstring{get\+Allocation\+String(\+Test\+Memory\+Allocator $\ast$allocator, const Simple\+String \&variable\+Name, size\+\_\+t size)}{getAllocationString(TestMemoryAllocator *allocator, const SimpleString &variableName, size_t size)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Simple\+String} get\+Allocation\+String (
\begin{DoxyParamCaption}
\item[{{\bf Test\+Memory\+Allocator} $\ast$}]{allocator, }
\item[{const {\bf Simple\+String} \&}]{variable\+Name, }
\item[{size\+\_\+t}]{size}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_code_memory_report_formatter_a184180e6760987bc2c4acfd59ad34fa5}{}\label{class_code_memory_report_formatter_a184180e6760987bc2c4acfd59ad34fa5}


Code\+Memory\+Report\+Formatter.\+cpp 파일의 122 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
123 \{
124     \textcolor{keywordflow}{if} (\hyperlink{class_code_memory_report_formatter_a33b96e0ded7b181daf75a9aab9a8f370}{isNewAllocator}(allocator))
125         \textcolor{keywordflow}{return} \hyperlink{_simple_string_8h_a0699d0e92f0abee2b3bdb9f254f90e51}{StringFromFormat}(\textcolor{stringliteral}{"char* %s = new char[%lu]; /* using %s */"}, variableName.
      \hyperlink{class_simple_string_af7c0efaf31f42553f05719903c830be1}{asCharString}(), (\textcolor{keywordtype}{unsigned} long) \hyperlink{gst__avb__playbin_8c_a439227feff9d7f55384e8780cfc2eb82}{size}, allocator->\hyperlink{class_test_memory_allocator_afab6c44b5468c71a699c1efbd787e6e7}{alloc\_name}());
126     \textcolor{keywordflow}{else}
127         \textcolor{keywordflow}{return} \hyperlink{_simple_string_8h_a0699d0e92f0abee2b3bdb9f254f90e51}{StringFromFormat}(\textcolor{stringliteral}{"void* %s = malloc(%lu);"}, variableName.
      \hyperlink{class_simple_string_af7c0efaf31f42553f05719903c830be1}{asCharString}(), (\textcolor{keywordtype}{unsigned} long) \hyperlink{gst__avb__playbin_8c_a439227feff9d7f55384e8780cfc2eb82}{size});
128 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_code_memory_report_formatter_a184180e6760987bc2c4acfd59ad34fa5_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_code_memory_report_formatter_a184180e6760987bc2c4acfd59ad34fa5_icgraph}
\end{center}
\end{figure}


\index{Code\+Memory\+Report\+Formatter@{Code\+Memory\+Report\+Formatter}!get\+Deallocation\+String@{get\+Deallocation\+String}}
\index{get\+Deallocation\+String@{get\+Deallocation\+String}!Code\+Memory\+Report\+Formatter@{Code\+Memory\+Report\+Formatter}}
\subsubsection[{\texorpdfstring{get\+Deallocation\+String(\+Test\+Memory\+Allocator $\ast$allocator, const Simple\+String \&variable\+Name, const char $\ast$file, int line)}{getDeallocationString(TestMemoryAllocator *allocator, const SimpleString &variableName, const char *file, int line)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Simple\+String} get\+Deallocation\+String (
\begin{DoxyParamCaption}
\item[{{\bf Test\+Memory\+Allocator} $\ast$}]{allocator, }
\item[{const {\bf Simple\+String} \&}]{variable\+Name, }
\item[{const char $\ast$}]{file, }
\item[{int}]{line}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_code_memory_report_formatter_a32fb96533a756602b0f707abdb20fe14}{}\label{class_code_memory_report_formatter_a32fb96533a756602b0f707abdb20fe14}


Code\+Memory\+Report\+Formatter.\+cpp 파일의 130 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
131 \{
132     \textcolor{keywordflow}{if} (\hyperlink{class_code_memory_report_formatter_a33b96e0ded7b181daf75a9aab9a8f370}{isNewAllocator}(allocator))
133         \textcolor{keywordflow}{return} \hyperlink{_simple_string_8h_a0699d0e92f0abee2b3bdb9f254f90e51}{StringFromFormat}(\textcolor{stringliteral}{"delete [] %s; /* using %s at %s:%d */"}, variableName.
      \hyperlink{class_simple_string_af7c0efaf31f42553f05719903c830be1}{asCharString}(), allocator->\hyperlink{class_test_memory_allocator_aac134aac79b30bc5903d0b2b7cc55b74}{free\_name}(), file, line);
134     \textcolor{keywordflow}{else}
135         \textcolor{keywordflow}{return} \hyperlink{_simple_string_8h_a0699d0e92f0abee2b3bdb9f254f90e51}{StringFromFormat}(\textcolor{stringliteral}{"free(%s); /* at %s:%d */"}, variableName.
      \hyperlink{class_simple_string_af7c0efaf31f42553f05719903c830be1}{asCharString}(), file, line);
136 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_code_memory_report_formatter_a32fb96533a756602b0f707abdb20fe14_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_code_memory_report_formatter_a32fb96533a756602b0f707abdb20fe14_icgraph}
\end{center}
\end{figure}


\index{Code\+Memory\+Report\+Formatter@{Code\+Memory\+Report\+Formatter}!is\+New\+Allocator@{is\+New\+Allocator}}
\index{is\+New\+Allocator@{is\+New\+Allocator}!Code\+Memory\+Report\+Formatter@{Code\+Memory\+Report\+Formatter}}
\subsubsection[{\texorpdfstring{is\+New\+Allocator(\+Test\+Memory\+Allocator $\ast$allocator)}{isNewAllocator(TestMemoryAllocator *allocator)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf bool} is\+New\+Allocator (
\begin{DoxyParamCaption}
\item[{{\bf Test\+Memory\+Allocator} $\ast$}]{allocator}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_code_memory_report_formatter_a33b96e0ded7b181daf75a9aab9a8f370}{}\label{class_code_memory_report_formatter_a33b96e0ded7b181daf75a9aab9a8f370}


Code\+Memory\+Report\+Formatter.\+cpp 파일의 106 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
107 \{
108     \textcolor{keywordflow}{return} \hyperlink{class_simple_string_a0b7a8ae895cbde84a491b42c43de23a6}{SimpleString::StrCmp}(allocator->\hyperlink{class_test_memory_allocator_afab6c44b5468c71a699c1efbd787e6e7}{alloc\_name}(), 
      \hyperlink{_test_memory_allocator_8h_a867eb2c996371985be8d9828339fd3d5}{defaultNewAllocator}()->\hyperlink{class_test_memory_allocator_afab6c44b5468c71a699c1efbd787e6e7}{alloc\_name}()) == 0 || 
      \hyperlink{class_simple_string_a0b7a8ae895cbde84a491b42c43de23a6}{SimpleString::StrCmp}(allocator->\hyperlink{class_test_memory_allocator_afab6c44b5468c71a699c1efbd787e6e7}{alloc\_name}(), 
      \hyperlink{_test_memory_allocator_8h_aec876a911821b794424b0f77a186f2ab}{defaultNewArrayAllocator}()->\hyperlink{class_test_memory_allocator_afab6c44b5468c71a699c1efbd787e6e7}{alloc\_name}()) == 0;
109 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=327pt]{class_code_memory_report_formatter_a33b96e0ded7b181daf75a9aab9a8f370_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_code_memory_report_formatter_a33b96e0ded7b181daf75a9aab9a8f370_icgraph}
\end{center}
\end{figure}


\index{Code\+Memory\+Report\+Formatter@{Code\+Memory\+Report\+Formatter}!report\+\_\+alloc\+\_\+memory@{report\+\_\+alloc\+\_\+memory}}
\index{report\+\_\+alloc\+\_\+memory@{report\+\_\+alloc\+\_\+memory}!Code\+Memory\+Report\+Formatter@{Code\+Memory\+Report\+Formatter}}
\subsubsection[{\texorpdfstring{report\+\_\+alloc\+\_\+memory(\+Test\+Result $\ast$result, Test\+Memory\+Allocator $\ast$allocator, size\+\_\+t size, char $\ast$memory, const char $\ast$file, int line) \+\_\+override}{report_alloc_memory(TestResult *result, TestMemoryAllocator *allocator, size_t size, char *memory, const char *file, int line) _override}}]{\setlength{\rightskip}{0pt plus 5cm}void report\+\_\+alloc\+\_\+memory (
\begin{DoxyParamCaption}
\item[{{\bf Test\+Result} $\ast$}]{result, }
\item[{{\bf Test\+Memory\+Allocator} $\ast$}]{allocator, }
\item[{size\+\_\+t}]{size, }
\item[{char $\ast$}]{memory, }
\item[{const char $\ast$}]{file, }
\item[{int}]{line}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{class_code_memory_report_formatter_a662fcaf995e9e0137c8debfc33530366}{}\label{class_code_memory_report_formatter_a662fcaf995e9e0137c8debfc33530366}


\hyperlink{class_memory_report_formatter_a27f55ca9a929b13376410b3369450fb3}{Memory\+Report\+Formatter}를 구현.



Code\+Memory\+Report\+Formatter.\+cpp 파일의 156 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
157 \{
158     \hyperlink{class_simple_string}{SimpleString} variableName = \hyperlink{class_code_memory_report_formatter_a2501cae5156eeee3e38c94c5b0304240}{createVariableNameFromFileLineInfo}
      (file, line);
159     result->\hyperlink{class_test_result_aeee8b15298e1baa2d0ced78c1fcb4b90}{print}(\hyperlink{_simple_string_8h_a0699d0e92f0abee2b3bdb9f254f90e51}{StringFromFormat}(\textcolor{stringliteral}{"\(\backslash\)t%s\(\backslash\)n"}, 
      \hyperlink{class_code_memory_report_formatter_a184180e6760987bc2c4acfd59ad34fa5}{getAllocationString}(allocator, variableName, \hyperlink{gst__avb__playbin_8c_a439227feff9d7f55384e8780cfc2eb82}{size}).asCharString()).asCharString());
160     \hyperlink{class_code_memory_report_formatter_a52af7af383a8ca9f00412be8cf31fb52}{addNodeToList}(variableName.\hyperlink{class_simple_string_af7c0efaf31f42553f05719903c830be1}{asCharString}(), memory, 
      \hyperlink{class_code_memory_report_formatter_a7256d2e6da45bdd7eaa77637be299e56}{codeReportingList\_});
161 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_code_memory_report_formatter_a662fcaf995e9e0137c8debfc33530366_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=331pt]{class_code_memory_report_formatter_a662fcaf995e9e0137c8debfc33530366_icgraph}
\end{center}
\end{figure}


\index{Code\+Memory\+Report\+Formatter@{Code\+Memory\+Report\+Formatter}!report\+\_\+free\+\_\+memory@{report\+\_\+free\+\_\+memory}}
\index{report\+\_\+free\+\_\+memory@{report\+\_\+free\+\_\+memory}!Code\+Memory\+Report\+Formatter@{Code\+Memory\+Report\+Formatter}}
\subsubsection[{\texorpdfstring{report\+\_\+free\+\_\+memory(\+Test\+Result $\ast$result, Test\+Memory\+Allocator $\ast$allocator, char $\ast$memory, const char $\ast$file, int line) \+\_\+override}{report_free_memory(TestResult *result, TestMemoryAllocator *allocator, char *memory, const char *file, int line) _override}}]{\setlength{\rightskip}{0pt plus 5cm}void report\+\_\+free\+\_\+memory (
\begin{DoxyParamCaption}
\item[{{\bf Test\+Result} $\ast$}]{result, }
\item[{{\bf Test\+Memory\+Allocator} $\ast$}]{allocator, }
\item[{char $\ast$}]{memory, }
\item[{const char $\ast$}]{file, }
\item[{int}]{line}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{class_code_memory_report_formatter_ae5e392cdf5fece2cbd2eeb25e8478c8f}{}\label{class_code_memory_report_formatter_ae5e392cdf5fece2cbd2eeb25e8478c8f}


\hyperlink{class_memory_report_formatter_a57360da7f89ad25456d061955c7c77da}{Memory\+Report\+Formatter}를 구현.



Code\+Memory\+Report\+Formatter.\+cpp 파일의 163 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
164 \{
165     \hyperlink{class_simple_string}{SimpleString} variableName;
166     \hyperlink{struct_code_reporting_allocation_node}{CodeReportingAllocationNode}* node = \hyperlink{class_code_memory_report_formatter_ab3bdf37ad56ffc1f06245f495afad613}{findNode}(memory);
167 
168     \textcolor{keywordflow}{if} (memory == \hyperlink{openavb__types__base__pub_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}) variableName = \textcolor{stringliteral}{"NULL"};
169     \textcolor{keywordflow}{else} variableName = node->\hyperlink{struct_code_reporting_allocation_node_ac6f8a20a992369f629ef7f014c8a884e}{variableName\_};
170 
171     result->\hyperlink{class_test_result_aeee8b15298e1baa2d0ced78c1fcb4b90}{print}(\hyperlink{_simple_string_8h_a0699d0e92f0abee2b3bdb9f254f90e51}{StringFromFormat}(\textcolor{stringliteral}{"\(\backslash\)t%s\(\backslash\)n"}, 
      \hyperlink{class_code_memory_report_formatter_a32fb96533a756602b0f707abdb20fe14}{getDeallocationString}(allocator, variableName, file, line).asCharString()).
      asCharString());
172 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_code_memory_report_formatter_ae5e392cdf5fece2cbd2eeb25e8478c8f_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=328pt]{class_code_memory_report_formatter_ae5e392cdf5fece2cbd2eeb25e8478c8f_icgraph}
\end{center}
\end{figure}


\index{Code\+Memory\+Report\+Formatter@{Code\+Memory\+Report\+Formatter}!report\+\_\+test\+\_\+end@{report\+\_\+test\+\_\+end}}
\index{report\+\_\+test\+\_\+end@{report\+\_\+test\+\_\+end}!Code\+Memory\+Report\+Formatter@{Code\+Memory\+Report\+Formatter}}
\subsubsection[{\texorpdfstring{report\+\_\+test\+\_\+end(\+Test\+Result $\ast$result, Utest\+Shell \&test) \+\_\+override}{report_test_end(TestResult *result, UtestShell &test) _override}}]{\setlength{\rightskip}{0pt plus 5cm}void report\+\_\+test\+\_\+end (
\begin{DoxyParamCaption}
\item[{{\bf Test\+Result} $\ast$}]{result, }
\item[{{\bf Utest\+Shell} \&}]{test}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{class_code_memory_report_formatter_a2b191434b124b93d8c0ed5a05e084e02}{}\label{class_code_memory_report_formatter_a2b191434b124b93d8c0ed5a05e084e02}


\hyperlink{class_memory_report_formatter_ace6fc7f4a7c7cb5d702018d91d85ae62}{Memory\+Report\+Formatter}를 구현.



Code\+Memory\+Report\+Formatter.\+cpp 파일의 145 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
146 \{
147     result->\hyperlink{class_test_result_aeee8b15298e1baa2d0ced78c1fcb4b90}{print}(\textcolor{stringliteral}{"\}/*"});
148 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_code_memory_report_formatter_a2b191434b124b93d8c0ed5a05e084e02_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=308pt]{class_code_memory_report_formatter_a2b191434b124b93d8c0ed5a05e084e02_icgraph}
\end{center}
\end{figure}


\index{Code\+Memory\+Report\+Formatter@{Code\+Memory\+Report\+Formatter}!report\+\_\+test\+\_\+start@{report\+\_\+test\+\_\+start}}
\index{report\+\_\+test\+\_\+start@{report\+\_\+test\+\_\+start}!Code\+Memory\+Report\+Formatter@{Code\+Memory\+Report\+Formatter}}
\subsubsection[{\texorpdfstring{report\+\_\+test\+\_\+start(\+Test\+Result $\ast$result, Utest\+Shell \&test) \+\_\+override}{report_test_start(TestResult *result, UtestShell &test) _override}}]{\setlength{\rightskip}{0pt plus 5cm}void report\+\_\+test\+\_\+start (
\begin{DoxyParamCaption}
\item[{{\bf Test\+Result} $\ast$}]{result, }
\item[{{\bf Utest\+Shell} \&}]{test}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{class_code_memory_report_formatter_ab6b7ea5f2e0c5bdad43b71b76881f362}{}\label{class_code_memory_report_formatter_ab6b7ea5f2e0c5bdad43b71b76881f362}


\hyperlink{class_memory_report_formatter_a3e3c7a63454b6711cf890eddcaba0d6a}{Memory\+Report\+Formatter}를 구현.



Code\+Memory\+Report\+Formatter.\+cpp 파일의 138 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
139 \{
140     \hyperlink{class_code_memory_report_formatter_a8bdb7334ae0af7865a368903e7e9c3b3}{clearReporting}();
141     result->\hyperlink{class_test_result_aeee8b15298e1baa2d0ced78c1fcb4b90}{print}(\hyperlink{_simple_string_8h_a0699d0e92f0abee2b3bdb9f254f90e51}{StringFromFormat}(\textcolor{stringliteral}{"*/\(\backslash\)nTEST(%s\_memoryReport, %s)\(\backslash\)n\{ /* at %s:%d */\(\backslash\)n"}
      ,
142             test.\hyperlink{class_utest_shell_a9d203c5f3c7cb6d28b66189a20735dca}{getGroup}().\hyperlink{class_simple_string_af7c0efaf31f42553f05719903c830be1}{asCharString}(), test.\hyperlink{class_utest_shell_a454500e4f7023136a9a6a956323e3a77}{getName}().
      \hyperlink{class_simple_string_af7c0efaf31f42553f05719903c830be1}{asCharString}(), test.\hyperlink{class_utest_shell_ac086867db63bc447ebef78844034d289}{getFile}().\hyperlink{class_simple_string_af7c0efaf31f42553f05719903c830be1}{asCharString}(), test.
      \hyperlink{class_utest_shell_ae48a165945bebe01fd777069441e614e}{getLineNumber}()).asCharString());
143 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_code_memory_report_formatter_ab6b7ea5f2e0c5bdad43b71b76881f362_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=312pt]{class_code_memory_report_formatter_ab6b7ea5f2e0c5bdad43b71b76881f362_icgraph}
\end{center}
\end{figure}


\index{Code\+Memory\+Report\+Formatter@{Code\+Memory\+Report\+Formatter}!report\+\_\+testgroup\+\_\+end@{report\+\_\+testgroup\+\_\+end}}
\index{report\+\_\+testgroup\+\_\+end@{report\+\_\+testgroup\+\_\+end}!Code\+Memory\+Report\+Formatter@{Code\+Memory\+Report\+Formatter}}
\subsubsection[{\texorpdfstring{report\+\_\+testgroup\+\_\+end(\+Test\+Result $\ast$, Utest\+Shell \&) \+\_\+override}{report_testgroup_end(TestResult *, UtestShell &) _override}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void report\+\_\+testgroup\+\_\+end (
\begin{DoxyParamCaption}
\item[{{\bf Test\+Result} $\ast$}]{, }
\item[{{\bf Utest\+Shell} \&}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{class_code_memory_report_formatter_a654fe66c6d74e1276278ad0fbf6af3aa}{}\label{class_code_memory_report_formatter_a654fe66c6d74e1276278ad0fbf6af3aa}


\hyperlink{class_memory_report_formatter_aa6b20dc53db478226037eaac7ae7b49e}{Memory\+Report\+Formatter}를 구현.



Code\+Memory\+Report\+Formatter.\+h 파일의 45 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
45 \{\} \textcolor{comment}{// LCOV\_EXCL\_LINE}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_code_memory_report_formatter_a654fe66c6d74e1276278ad0fbf6af3aa_cgraph}
\end{center}
\end{figure}


\index{Code\+Memory\+Report\+Formatter@{Code\+Memory\+Report\+Formatter}!report\+\_\+testgroup\+\_\+start@{report\+\_\+testgroup\+\_\+start}}
\index{report\+\_\+testgroup\+\_\+start@{report\+\_\+testgroup\+\_\+start}!Code\+Memory\+Report\+Formatter@{Code\+Memory\+Report\+Formatter}}
\subsubsection[{\texorpdfstring{report\+\_\+testgroup\+\_\+start(\+Test\+Result $\ast$result, Utest\+Shell \&test) \+\_\+override}{report_testgroup_start(TestResult *result, UtestShell &test) _override}}]{\setlength{\rightskip}{0pt plus 5cm}void report\+\_\+testgroup\+\_\+start (
\begin{DoxyParamCaption}
\item[{{\bf Test\+Result} $\ast$}]{result, }
\item[{{\bf Utest\+Shell} \&}]{test}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{class_code_memory_report_formatter_a5752211789cc4a3478f07498cf8e3006}{}\label{class_code_memory_report_formatter_a5752211789cc4a3478f07498cf8e3006}


\hyperlink{class_memory_report_formatter_a8f75294451f71b616932a7a9c649caa0}{Memory\+Report\+Formatter}를 구현.



Code\+Memory\+Report\+Formatter.\+cpp 파일의 150 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
151 \{
152     result->\hyperlink{class_test_result_aeee8b15298e1baa2d0ced78c1fcb4b90}{print}(\hyperlink{_simple_string_8h_a0699d0e92f0abee2b3bdb9f254f90e51}{StringFromFormat}(\textcolor{stringliteral}{"*/TEST\_GROUP(%s\_memoryReport)\(\backslash\)n\{\(\backslash\)n\};\(\backslash\)n/*"},
153             test.\hyperlink{class_utest_shell_a9d203c5f3c7cb6d28b66189a20735dca}{getGroup}().\hyperlink{class_simple_string_af7c0efaf31f42553f05719903c830be1}{asCharString}()).asCharString());
154 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_code_memory_report_formatter_a5752211789cc4a3478f07498cf8e3006_cgraph}
\end{center}
\end{figure}


\index{Code\+Memory\+Report\+Formatter@{Code\+Memory\+Report\+Formatter}!variable\+Exists@{variable\+Exists}}
\index{variable\+Exists@{variable\+Exists}!Code\+Memory\+Report\+Formatter@{Code\+Memory\+Report\+Formatter}}
\subsubsection[{\texorpdfstring{variable\+Exists(const Simple\+String \&variable\+Name)}{variableExists(const SimpleString &variableName)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf bool} variable\+Exists (
\begin{DoxyParamCaption}
\item[{const {\bf Simple\+String} \&}]{variable\+Name}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_code_memory_report_formatter_aebb4bb2cfdbdeca9666a6b426fc126cb}{}\label{class_code_memory_report_formatter_aebb4bb2cfdbdeca9666a6b426fc126cb}


Code\+Memory\+Report\+Formatter.\+cpp 파일의 111 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
112 \{
113     \hyperlink{struct_code_reporting_allocation_node}{CodeReportingAllocationNode}* current = 
      \hyperlink{class_code_memory_report_formatter_a7256d2e6da45bdd7eaa77637be299e56}{codeReportingList\_};
114     \textcolor{keywordflow}{while} (current) \{
115         \textcolor{keywordflow}{if} (variableName == current->\hyperlink{struct_code_reporting_allocation_node_ac6f8a20a992369f629ef7f014c8a884e}{variableName\_})
116             \textcolor{keywordflow}{return} \textcolor{keyword}{true};
117         current = current->\hyperlink{struct_code_reporting_allocation_node_a8f0c58c5a02860822d947c32e435bd3c}{next\_};
118     \}
119     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
120 \}
\end{DoxyCode}


이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_code_memory_report_formatter_aebb4bb2cfdbdeca9666a6b426fc126cb_icgraph}
\end{center}
\end{figure}




\subsection{필드 문서화}
\index{Code\+Memory\+Report\+Formatter@{Code\+Memory\+Report\+Formatter}!code\+Reporting\+List\+\_\+@{code\+Reporting\+List\+\_\+}}
\index{code\+Reporting\+List\+\_\+@{code\+Reporting\+List\+\_\+}!Code\+Memory\+Report\+Formatter@{Code\+Memory\+Report\+Formatter}}
\subsubsection[{\texorpdfstring{code\+Reporting\+List\+\_\+}{codeReportingList_}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Code\+Reporting\+Allocation\+Node}$\ast$ code\+Reporting\+List\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_code_memory_report_formatter_a7256d2e6da45bdd7eaa77637be299e56}{}\label{class_code_memory_report_formatter_a7256d2e6da45bdd7eaa77637be299e56}


Code\+Memory\+Report\+Formatter.\+h 파일의 37 번째 라인에서 정의되었습니다.

\index{Code\+Memory\+Report\+Formatter@{Code\+Memory\+Report\+Formatter}!internal\+Allocator\+\_\+@{internal\+Allocator\+\_\+}}
\index{internal\+Allocator\+\_\+@{internal\+Allocator\+\_\+}!Code\+Memory\+Report\+Formatter@{Code\+Memory\+Report\+Formatter}}
\subsubsection[{\texorpdfstring{internal\+Allocator\+\_\+}{internalAllocator_}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Test\+Memory\+Allocator}$\ast$ internal\+Allocator\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_code_memory_report_formatter_a5177d1223b6c18bfc2ddfb40e8400d84}{}\label{class_code_memory_report_formatter_a5177d1223b6c18bfc2ddfb40e8400d84}


Code\+Memory\+Report\+Formatter.\+h 파일의 38 번째 라인에서 정의되었습니다.



이 클래스에 대한 문서화 페이지는 다음의 파일들로부터 생성되었습니다.\+:\begin{DoxyCompactItemize}
\item 
thirdparty/cpputest/include/\+Cpp\+U\+Test\+Ext/\hyperlink{_code_memory_report_formatter_8h}{Code\+Memory\+Report\+Formatter.\+h}\item 
thirdparty/cpputest/src/\+Cpp\+U\+Test\+Ext/\hyperlink{_code_memory_report_formatter_8cpp}{Code\+Memory\+Report\+Formatter.\+cpp}\end{DoxyCompactItemize}
