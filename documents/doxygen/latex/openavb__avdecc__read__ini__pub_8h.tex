\hypertarget{openavb__avdecc__read__ini__pub_8h}{}\section{lib/avtp\+\_\+pipeline/avdecc/openavb\+\_\+avdecc\+\_\+read\+\_\+ini\+\_\+pub.h 파일 참조}
\label{openavb__avdecc__read__ini__pub_8h}\index{lib/avtp\+\_\+pipeline/avdecc/openavb\+\_\+avdecc\+\_\+read\+\_\+ini\+\_\+pub.\+h@{lib/avtp\+\_\+pipeline/avdecc/openavb\+\_\+avdecc\+\_\+read\+\_\+ini\+\_\+pub.\+h}}
{\ttfamily \#include \char`\"{}openavb\+\_\+types\+\_\+pub.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}openavb\+\_\+mediaq\+\_\+pub.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}openavb\+\_\+avtp\+\_\+time\+\_\+pub.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}openavb\+\_\+tl\+\_\+pub.\+h\char`\"{}}\\*
openavb\+\_\+avdecc\+\_\+read\+\_\+ini\+\_\+pub.\+h에 대한 include 의존 그래프
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{openavb__avdecc__read__ini__pub_8h__incl}
\end{center}
\end{figure}
이 그래프는 이 파일을 직/간접적으로 include 하는 파일들을 보여줍니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{openavb__avdecc__read__ini__pub_8h__dep__incl}
\end{center}
\end{figure}
\subsection*{데이타 구조}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structopenavb__tl__data__cfg}{openavb\+\_\+tl\+\_\+data\+\_\+cfg}
\begin{DoxyCompactList}\small\item\em Structure containing configuration of the host. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{매크로}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{openavb__avdecc__read__ini__pub_8h_abc74489af2084c5a3eb559c282fd16b8}{M\+A\+X\+\_\+\+S\+A\+M\+P\+L\+I\+N\+G\+\_\+\+R\+A\+T\+E\+S\+\_\+\+C\+O\+U\+NT}~91
\item 
\#define \hyperlink{openavb__avdecc__read__ini__pub_8h_a29d83e67ee30c78c6ed81c188a433c10}{F\+R\+I\+E\+N\+D\+L\+Y\+\_\+\+N\+A\+M\+E\+\_\+\+S\+I\+ZE}~64
\begin{DoxyCompactList}\small\item\em Maximum size of the friendly name. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{타입정의}
\begin{DoxyCompactItemize}
\item 
typedef struct \hyperlink{struct__avdecc__msg__state}{\+\_\+avdecc\+\_\+msg\+\_\+state} \hyperlink{openavb__avdecc__read__ini__pub_8h_a23083b48075a0359e894648e78de1e98}{avdecc\+\_\+msg\+\_\+state\+\_\+t}
\item 
typedef struct \hyperlink{structopenavb__tl__data__cfg}{openavb\+\_\+tl\+\_\+data\+\_\+cfg} \hyperlink{openavb__avdecc__read__ini__pub_8h_a2c6c3608b0b8c34af5fa95c11753cfc0}{openavb\+\_\+tl\+\_\+data\+\_\+cfg\+\_\+t}
\end{DoxyCompactItemize}
\subsection*{함수}
\begin{DoxyCompactItemize}
\item 
\hyperlink{avb__gptp_8h_af6a258d8f3ee5206d682d799316314b1}{bool} \hyperlink{openavb__avdecc__read__ini__pub_8h_aff613389c2d0e865c1977604e80c58cf}{openavb\+Read\+Tl\+Data\+Ini\+File} (const char $\ast$file\+Name, \hyperlink{openavb__avdecc__read__ini__pub_8h_a2c6c3608b0b8c34af5fa95c11753cfc0}{openavb\+\_\+tl\+\_\+data\+\_\+cfg\+\_\+t} $\ast$p\+Cfg)
\item 
\hyperlink{avb__gptp_8h_af6a258d8f3ee5206d682d799316314b1}{bool} \hyperlink{openavb__avdecc__read__ini__pub_8h_a9ea955859d4f0e9fa133b6a3665f12b6}{openavb\+Avdecc\+Save\+State} (const \hyperlink{openavb__avdecc__read__ini__pub_8h_a2c6c3608b0b8c34af5fa95c11753cfc0}{openavb\+\_\+tl\+\_\+data\+\_\+cfg\+\_\+t} $\ast$p\+Listener, \hyperlink{openavb__types__base__pub_8h_a0a0a322d5fa4a546d293a77ba8b4a71f}{U16} flags, \hyperlink{openavb__types__base__pub_8h_a0a0a322d5fa4a546d293a77ba8b4a71f}{U16} talker\+\_\+unique\+\_\+id, const \hyperlink{openavb__types__base__pub_8h_aa63ef7b996d5487ce35a5a66601f3e73}{U8} talker\+\_\+entity\+\_\+id\mbox{[}8\mbox{]}, const \hyperlink{openavb__types__base__pub_8h_aa63ef7b996d5487ce35a5a66601f3e73}{U8} controller\+\_\+entity\+\_\+id\mbox{[}8\mbox{]})
\item 
\hyperlink{avb__gptp_8h_af6a258d8f3ee5206d682d799316314b1}{bool} \hyperlink{openavb__avdecc__read__ini__pub_8h_a795a38bd974e979fd6b8709e941badf3}{openavb\+Avdecc\+Clear\+Saved\+State} (const \hyperlink{openavb__avdecc__read__ini__pub_8h_a2c6c3608b0b8c34af5fa95c11753cfc0}{openavb\+\_\+tl\+\_\+data\+\_\+cfg\+\_\+t} $\ast$p\+Listener)
\item 
\hyperlink{avb__gptp_8h_af6a258d8f3ee5206d682d799316314b1}{bool} \hyperlink{openavb__avdecc__read__ini__pub_8h_a3a59dfcc244d7c0644380666afedeb19}{openavb\+Avdecc\+Get\+Save\+State\+Info} (const \hyperlink{openavb__avdecc__read__ini__pub_8h_a2c6c3608b0b8c34af5fa95c11753cfc0}{openavb\+\_\+tl\+\_\+data\+\_\+cfg\+\_\+t} $\ast$p\+Listener, \hyperlink{openavb__types__base__pub_8h_a0a0a322d5fa4a546d293a77ba8b4a71f}{U16} $\ast$p\+\_\+flags, \hyperlink{openavb__types__base__pub_8h_a0a0a322d5fa4a546d293a77ba8b4a71f}{U16} $\ast$p\+\_\+talker\+\_\+unique\+\_\+id, \hyperlink{openavb__types__base__pub_8h_aa63ef7b996d5487ce35a5a66601f3e73}{U8}($\ast$p\+\_\+talker\+\_\+entity\+\_\+id)\mbox{[}8\mbox{]}, \hyperlink{openavb__types__base__pub_8h_aa63ef7b996d5487ce35a5a66601f3e73}{U8}($\ast$p\+\_\+controller\+\_\+entity\+\_\+id)\mbox{[}8\mbox{]})
\end{DoxyCompactItemize}


\subsection{상세한 설명}
A\+V\+D\+E\+CC Read I\+NI Public Interface. 

\subsection{매크로 문서화}
\index{openavb\+\_\+avdecc\+\_\+read\+\_\+ini\+\_\+pub.\+h@{openavb\+\_\+avdecc\+\_\+read\+\_\+ini\+\_\+pub.\+h}!F\+R\+I\+E\+N\+D\+L\+Y\+\_\+\+N\+A\+M\+E\+\_\+\+S\+I\+ZE@{F\+R\+I\+E\+N\+D\+L\+Y\+\_\+\+N\+A\+M\+E\+\_\+\+S\+I\+ZE}}
\index{F\+R\+I\+E\+N\+D\+L\+Y\+\_\+\+N\+A\+M\+E\+\_\+\+S\+I\+ZE@{F\+R\+I\+E\+N\+D\+L\+Y\+\_\+\+N\+A\+M\+E\+\_\+\+S\+I\+ZE}!openavb\+\_\+avdecc\+\_\+read\+\_\+ini\+\_\+pub.\+h@{openavb\+\_\+avdecc\+\_\+read\+\_\+ini\+\_\+pub.\+h}}
\subsubsection[{\texorpdfstring{F\+R\+I\+E\+N\+D\+L\+Y\+\_\+\+N\+A\+M\+E\+\_\+\+S\+I\+ZE}{FRIENDLY_NAME_SIZE}}]{\setlength{\rightskip}{0pt plus 5cm}\#define F\+R\+I\+E\+N\+D\+L\+Y\+\_\+\+N\+A\+M\+E\+\_\+\+S\+I\+ZE~64}\hypertarget{openavb__avdecc__read__ini__pub_8h_a29d83e67ee30c78c6ed81c188a433c10}{}\label{openavb__avdecc__read__ini__pub_8h_a29d83e67ee30c78c6ed81c188a433c10}


Maximum size of the friendly name. 



openavb\+\_\+avdecc\+\_\+read\+\_\+ini\+\_\+pub.\+h 파일의 54 번째 라인에서 정의되었습니다.

\index{openavb\+\_\+avdecc\+\_\+read\+\_\+ini\+\_\+pub.\+h@{openavb\+\_\+avdecc\+\_\+read\+\_\+ini\+\_\+pub.\+h}!M\+A\+X\+\_\+\+S\+A\+M\+P\+L\+I\+N\+G\+\_\+\+R\+A\+T\+E\+S\+\_\+\+C\+O\+U\+NT@{M\+A\+X\+\_\+\+S\+A\+M\+P\+L\+I\+N\+G\+\_\+\+R\+A\+T\+E\+S\+\_\+\+C\+O\+U\+NT}}
\index{M\+A\+X\+\_\+\+S\+A\+M\+P\+L\+I\+N\+G\+\_\+\+R\+A\+T\+E\+S\+\_\+\+C\+O\+U\+NT@{M\+A\+X\+\_\+\+S\+A\+M\+P\+L\+I\+N\+G\+\_\+\+R\+A\+T\+E\+S\+\_\+\+C\+O\+U\+NT}!openavb\+\_\+avdecc\+\_\+read\+\_\+ini\+\_\+pub.\+h@{openavb\+\_\+avdecc\+\_\+read\+\_\+ini\+\_\+pub.\+h}}
\subsubsection[{\texorpdfstring{M\+A\+X\+\_\+\+S\+A\+M\+P\+L\+I\+N\+G\+\_\+\+R\+A\+T\+E\+S\+\_\+\+C\+O\+U\+NT}{MAX_SAMPLING_RATES_COUNT}}]{\setlength{\rightskip}{0pt plus 5cm}\#define M\+A\+X\+\_\+\+S\+A\+M\+P\+L\+I\+N\+G\+\_\+\+R\+A\+T\+E\+S\+\_\+\+C\+O\+U\+NT~91}\hypertarget{openavb__avdecc__read__ini__pub_8h_abc74489af2084c5a3eb559c282fd16b8}{}\label{openavb__avdecc__read__ini__pub_8h_abc74489af2084c5a3eb559c282fd16b8}


openavb\+\_\+avdecc\+\_\+read\+\_\+ini\+\_\+pub.\+h 파일의 44 번째 라인에서 정의되었습니다.



\subsection{타입정의 문서화}
\index{openavb\+\_\+avdecc\+\_\+read\+\_\+ini\+\_\+pub.\+h@{openavb\+\_\+avdecc\+\_\+read\+\_\+ini\+\_\+pub.\+h}!avdecc\+\_\+msg\+\_\+state\+\_\+t@{avdecc\+\_\+msg\+\_\+state\+\_\+t}}
\index{avdecc\+\_\+msg\+\_\+state\+\_\+t@{avdecc\+\_\+msg\+\_\+state\+\_\+t}!openavb\+\_\+avdecc\+\_\+read\+\_\+ini\+\_\+pub.\+h@{openavb\+\_\+avdecc\+\_\+read\+\_\+ini\+\_\+pub.\+h}}
\subsubsection[{\texorpdfstring{avdecc\+\_\+msg\+\_\+state\+\_\+t}{avdecc_msg_state_t}}]{\setlength{\rightskip}{0pt plus 5cm}typedef struct {\bf \+\_\+avdecc\+\_\+msg\+\_\+state} {\bf avdecc\+\_\+msg\+\_\+state\+\_\+t}}\hypertarget{openavb__avdecc__read__ini__pub_8h_a23083b48075a0359e894648e78de1e98}{}\label{openavb__avdecc__read__ini__pub_8h_a23083b48075a0359e894648e78de1e98}


openavb\+\_\+avdecc\+\_\+read\+\_\+ini\+\_\+pub.\+h 파일의 51 번째 라인에서 정의되었습니다.

\index{openavb\+\_\+avdecc\+\_\+read\+\_\+ini\+\_\+pub.\+h@{openavb\+\_\+avdecc\+\_\+read\+\_\+ini\+\_\+pub.\+h}!openavb\+\_\+tl\+\_\+data\+\_\+cfg\+\_\+t@{openavb\+\_\+tl\+\_\+data\+\_\+cfg\+\_\+t}}
\index{openavb\+\_\+tl\+\_\+data\+\_\+cfg\+\_\+t@{openavb\+\_\+tl\+\_\+data\+\_\+cfg\+\_\+t}!openavb\+\_\+avdecc\+\_\+read\+\_\+ini\+\_\+pub.\+h@{openavb\+\_\+avdecc\+\_\+read\+\_\+ini\+\_\+pub.\+h}}
\subsubsection[{\texorpdfstring{openavb\+\_\+tl\+\_\+data\+\_\+cfg\+\_\+t}{openavb_tl_data_cfg_t}}]{\setlength{\rightskip}{0pt plus 5cm}typedef struct {\bf openavb\+\_\+tl\+\_\+data\+\_\+cfg} {\bf openavb\+\_\+tl\+\_\+data\+\_\+cfg\+\_\+t}}\hypertarget{openavb__avdecc__read__ini__pub_8h_a2c6c3608b0b8c34af5fa95c11753cfc0}{}\label{openavb__avdecc__read__ini__pub_8h_a2c6c3608b0b8c34af5fa95c11753cfc0}


openavb\+\_\+avdecc\+\_\+read\+\_\+ini\+\_\+pub.\+h 파일의 135 번째 라인에서 정의되었습니다.



\subsection{함수 문서화}
\index{openavb\+\_\+avdecc\+\_\+read\+\_\+ini\+\_\+pub.\+h@{openavb\+\_\+avdecc\+\_\+read\+\_\+ini\+\_\+pub.\+h}!openavb\+Avdecc\+Clear\+Saved\+State@{openavb\+Avdecc\+Clear\+Saved\+State}}
\index{openavb\+Avdecc\+Clear\+Saved\+State@{openavb\+Avdecc\+Clear\+Saved\+State}!openavb\+\_\+avdecc\+\_\+read\+\_\+ini\+\_\+pub.\+h@{openavb\+\_\+avdecc\+\_\+read\+\_\+ini\+\_\+pub.\+h}}
\subsubsection[{\texorpdfstring{openavb\+Avdecc\+Clear\+Saved\+State(const openavb\+\_\+tl\+\_\+data\+\_\+cfg\+\_\+t $\ast$p\+Listener)}{openavbAvdeccClearSavedState(const openavb_tl_data_cfg_t *pListener)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf bool} openavb\+Avdecc\+Clear\+Saved\+State (
\begin{DoxyParamCaption}
\item[{const {\bf openavb\+\_\+tl\+\_\+data\+\_\+cfg\+\_\+t} $\ast$}]{p\+Listener}
\end{DoxyParamCaption}
)}\hypertarget{openavb__avdecc__read__ini__pub_8h_a795a38bd974e979fd6b8709e941badf3}{}\label{openavb__avdecc__read__ini__pub_8h_a795a38bd974e979fd6b8709e941badf3}
Delete a connection with saved state

If fast connect support is enabled, this function is used to clear previously saved state information (from a previous call to \hyperlink{openavb__avdecc__read__ini__pub_8h_a9ea955859d4f0e9fa133b6a3665f12b6}{openavb\+Avdecc\+Save\+State}). This function should be called from the Listener when a Talker/\+Listener connection is closed (and fast connects should no longer be attempted in the future).


\begin{DoxyParams}{매개변수}
{\em p\+Listener} & Pointer to configuration for the Listener\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{반환값}
T\+R\+UE on success or F\+A\+L\+SE on failure 
\end{DoxyReturn}


openavb\+\_\+avdecc\+\_\+read\+\_\+ini.\+c 파일의 543 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
544 \{
545     \hyperlink{build_2sdk__eavb_2openavb__trace__pub_8h_ab2bfc814f0447a6d975e8332be197b85}{AVB\_TRACE\_ENTRY}(\hyperlink{openavb__trace_8h_a160710781610431734a8aa068baf9fe2}{AVB\_TRACE\_AVDECC});
546 
547     \textcolor{keywordtype}{int} i;
548 
549     \textcolor{comment}{// Delete the saved state matching the supplied one.}
550     \textcolor{comment}{// If the supplied saved state does not match any of the ones already saved, do nothing and return.}
551     \textcolor{keywordflow}{for} (i = 0; i < 1000; ++i) \{
552         \textcolor{keyword}{const} \hyperlink{structopenavb__saved__state}{openavb\_saved\_state\_t} * pTest = 
      \hyperlink{openavb__avdecc__save__state_8c_a68f1147b5be612cc07767baa03f88767}{openavbAvdeccGetSavedState}(i);
553         \textcolor{keywordflow}{if} (!pTest) \{
554             \textcolor{keywordflow}{break};
555         \}
556 
557         \textcolor{keywordflow}{if} (strcmp(pTest->\hyperlink{structopenavb__saved__state_aeaaf1a5eb8e190e9385389bc81aadb39}{listener\_friendly\_name}, pListener->
      \hyperlink{structopenavb__tl__data__cfg_a25c82ac188182d72242fb10f0285a2bd}{friendly\_name}) == 0) \{
558             \textcolor{comment}{// We found the index for the item to delete.}
559             \textcolor{comment}{// Delete the item and save the updated file.}
560             \hyperlink{openavb__avdecc__save__state_8c_a99838adab78e8804d6b5db710a620202}{openavbAvdeccDeleteSavedState}(i);
561             \hyperlink{build_2sdk__eavb_2openavb__log__pub_8h_afcf1f0c1d10ae9efe3782eb6cae78355}{AVB\_LOGF\_DEBUG}(\textcolor{stringliteral}{"Cleared saved state:  listener\_id=\(\backslash\)"%s\(\backslash\)""}, pListener->
      \hyperlink{structopenavb__tl__data__cfg_a25c82ac188182d72242fb10f0285a2bd}{friendly\_name});
562 
563             \hyperlink{build_2sdk__eavb_2openavb__trace__pub_8h_a0906ddd9e84cc650a76634fe8ff766d7}{AVB\_TRACE\_EXIT}(\hyperlink{openavb__trace_8h_a160710781610431734a8aa068baf9fe2}{AVB\_TRACE\_AVDECC});
564             \textcolor{keywordflow}{return} \textcolor{keyword}{true};
565         \}
566     \}
567 
568     \hyperlink{build_2sdk__eavb_2openavb__log__pub_8h_a6b02336e691e2e0579d2a5bb06367296}{AVB\_LOGF\_WARNING}(\textcolor{stringliteral}{"Unable to find saved state to clear:  listener\_id=\(\backslash\)"%s\(\backslash\)""}, pListener
      ->\hyperlink{structopenavb__tl__data__cfg_a25c82ac188182d72242fb10f0285a2bd}{friendly\_name});
569     \hyperlink{build_2sdk__eavb_2openavb__trace__pub_8h_a0906ddd9e84cc650a76634fe8ff766d7}{AVB\_TRACE\_EXIT}(\hyperlink{openavb__trace_8h_a160710781610431734a8aa068baf9fe2}{AVB\_TRACE\_AVDECC});
570     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
571 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{openavb__avdecc__read__ini__pub_8h_a795a38bd974e979fd6b8709e941badf3_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{openavb__avdecc__read__ini__pub_8h_a795a38bd974e979fd6b8709e941badf3_icgraph}
\end{center}
\end{figure}


\index{openavb\+\_\+avdecc\+\_\+read\+\_\+ini\+\_\+pub.\+h@{openavb\+\_\+avdecc\+\_\+read\+\_\+ini\+\_\+pub.\+h}!openavb\+Avdecc\+Get\+Save\+State\+Info@{openavb\+Avdecc\+Get\+Save\+State\+Info}}
\index{openavb\+Avdecc\+Get\+Save\+State\+Info@{openavb\+Avdecc\+Get\+Save\+State\+Info}!openavb\+\_\+avdecc\+\_\+read\+\_\+ini\+\_\+pub.\+h@{openavb\+\_\+avdecc\+\_\+read\+\_\+ini\+\_\+pub.\+h}}
\subsubsection[{\texorpdfstring{openavb\+Avdecc\+Get\+Save\+State\+Info(const openavb\+\_\+tl\+\_\+data\+\_\+cfg\+\_\+t $\ast$p\+Listener, U16 $\ast$p\+\_\+flags, U16 $\ast$p\+\_\+talker\+\_\+unique\+\_\+id, U8($\ast$p\+\_\+talker\+\_\+entity\+\_\+id)[8], U8($\ast$p\+\_\+controller\+\_\+entity\+\_\+id)[8])}{openavbAvdeccGetSaveStateInfo(const openavb_tl_data_cfg_t *pListener, U16 *p_flags, U16 *p_talker_unique_id, U8(*p_talker_entity_id)[8], U8(*p_controller_entity_id)[8])}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf bool} openavb\+Avdecc\+Get\+Save\+State\+Info (
\begin{DoxyParamCaption}
\item[{const {\bf openavb\+\_\+tl\+\_\+data\+\_\+cfg\+\_\+t} $\ast$}]{p\+Listener, }
\item[{{\bf U16} $\ast$}]{p\+\_\+flags, }
\item[{{\bf U16} $\ast$}]{p\+\_\+talker\+\_\+unique\+\_\+id, }
\item[{{\bf U8}($\ast$)}]{p\+\_\+talker\+\_\+entity\+\_\+id\mbox{[}8\mbox{]}, }
\item[{{\bf U8}($\ast$)}]{p\+\_\+controller\+\_\+entity\+\_\+id\mbox{[}8\mbox{]}}
\end{DoxyParamCaption}
)}\hypertarget{openavb__avdecc__read__ini__pub_8h_a3a59dfcc244d7c0644380666afedeb19}{}\label{openavb__avdecc__read__ini__pub_8h_a3a59dfcc244d7c0644380666afedeb19}
Determine if the connection has a saved state

If fast connect support is enabled, this function is used to get the last saved state (from a call to \hyperlink{openavb__avdecc__read__ini__pub_8h_a9ea955859d4f0e9fa133b6a3665f12b6}{openavb\+Avdecc\+Save\+State}) for a Listener, if any.


\begin{DoxyParams}{매개변수}
{\em p\+Listener} & Pointer to configuration for the Listener \\
\hline
{\em p\+\_\+flags} & Optional pointer to the flags used for the connection (C\+L\+A\+S\+S\+\_\+B, S\+U\+P\+P\+O\+R\+T\+S\+\_\+\+E\+N\+C\+R\+Y\+P\+T\+ED, E\+N\+C\+R\+Y\+P\+T\+E\+D\+\_\+\+P\+DU) \\
\hline
{\em p\+\_\+talker\+\_\+unique\+\_\+id} & Optional pointer to the unique id for the Talker \\
\hline
{\em p\+\_\+talker\+\_\+entity\+\_\+id} & Optional pointer to the buffer to fill in the binary entity id for the Talker \\
\hline
{\em p\+\_\+controller\+\_\+entity\+\_\+id} & Optional pointer to the buffer to fill in the binary entity id for the Controller that initiated the connection\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{반환값}
T\+R\+UE if there is a saved state, or F\+A\+L\+SE otherwise 
\end{DoxyReturn}


openavb\+\_\+avdecc\+\_\+read\+\_\+ini.\+c 파일의 575 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
576 \{
577     \hyperlink{build_2sdk__eavb_2openavb__trace__pub_8h_ab2bfc814f0447a6d975e8332be197b85}{AVB\_TRACE\_ENTRY}(\hyperlink{openavb__trace_8h_a160710781610431734a8aa068baf9fe2}{AVB\_TRACE\_AVDECC});
578 
579     \textcolor{keywordtype}{int} i;
580 
581     \textcolor{comment}{// Don't return anything from the saved state list if fast connect support is not enabled.}
582     \textcolor{keywordflow}{if} (!\hyperlink{openavb__avdecc__read__ini_8c_a142e959837c765cd9a1767b886421315}{gAvdeccCfg}.\hyperlink{structopenavb__avdecc__cfg__t_af2d13c6414749c36d13faf34d3bbbd40}{bFastConnectSupported}) \{
583         \hyperlink{build_2sdk__eavb_2openavb__trace__pub_8h_a0906ddd9e84cc650a76634fe8ff766d7}{AVB\_TRACE\_EXIT}(\hyperlink{openavb__trace_8h_a160710781610431734a8aa068baf9fe2}{AVB\_TRACE\_AVDECC});
584         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
585     \}
586 
587     \textcolor{comment}{// If the loaded saved state information matches the Listener supplied, return the information for it.}
588     \textcolor{keywordflow}{for} (i = 0; i < 1000; ++i) \{
589         \textcolor{keyword}{const} \hyperlink{structopenavb__saved__state}{openavb\_saved\_state\_t} * pTest = 
      \hyperlink{openavb__avdecc__save__state_8c_a68f1147b5be612cc07767baa03f88767}{openavbAvdeccGetSavedState}(i);
590         \textcolor{keywordflow}{if} (!pTest) \{
591             \textcolor{keywordflow}{break};
592         \}
593 
594         \textcolor{keywordflow}{if} (strcmp(pTest->\hyperlink{structopenavb__saved__state_aeaaf1a5eb8e190e9385389bc81aadb39}{listener\_friendly\_name}, pListener->
      \hyperlink{structopenavb__tl__data__cfg_a25c82ac188182d72242fb10f0285a2bd}{friendly\_name}) == 0) \{
595             \hyperlink{build_2sdk__eavb_2openavb__log__pub_8h_afcf1f0c1d10ae9efe3782eb6cae78355}{AVB\_LOGF\_DEBUG}(\textcolor{stringliteral}{"Saved state available for listener\_id=%s, flags=0x%04x,
       talker\_unique\_id=0x%04x, talker\_entity\_id="} \hyperlink{build_2sdk__eavb_2openavb__log__pub_8h_a2a3dc3ce1982b3a859b968268f2945ef}{ENTITYID\_FORMAT} \textcolor{stringliteral}{", controller\_entity\_id="} 
      \hyperlink{build_2sdk__eavb_2openavb__log__pub_8h_a2a3dc3ce1982b3a859b968268f2945ef}{ENTITYID\_FORMAT},
596                     pListener->\hyperlink{structopenavb__tl__data__cfg_a25c82ac188182d72242fb10f0285a2bd}{friendly\_name},
597                     pTest->\hyperlink{structopenavb__saved__state_a492b33861e809623846e5256d271bc78}{flags},
598                     pTest->\hyperlink{structopenavb__saved__state_a545e994bde6218210bb41265ac298837}{talker\_unique\_id},
599                     \hyperlink{build_2sdk__eavb_2openavb__log__pub_8h_af361c6d79888b72d21c410bd60035121}{ENTITYID\_ARGS}(pTest->\hyperlink{structopenavb__saved__state_a9a599b9c25c2171c3e76f269d9a04f51}{talker\_entity\_id}),
600                     \hyperlink{build_2sdk__eavb_2openavb__log__pub_8h_af361c6d79888b72d21c410bd60035121}{ENTITYID\_ARGS}(pTest->\hyperlink{structopenavb__saved__state_a8b74ba582b9c19e1f2e475925f7cfb2f}{controller\_entity\_id}));
601             \textcolor{keywordflow}{if} (p\_flags) \{
602                 *p\_flags = pTest->\hyperlink{structopenavb__saved__state_a492b33861e809623846e5256d271bc78}{flags};
603             \}
604             \textcolor{keywordflow}{if} (p\_talker\_unique\_id) \{
605                 *p\_talker\_unique\_id = pTest->\hyperlink{structopenavb__saved__state_a545e994bde6218210bb41265ac298837}{talker\_unique\_id};
606             \}
607             \textcolor{keywordflow}{if} (p\_talker\_entity\_id) \{
608                 memcpy(*p\_talker\_entity\_id, pTest->\hyperlink{structopenavb__saved__state_a9a599b9c25c2171c3e76f269d9a04f51}{talker\_entity\_id}, 8);
609             \}
610             \textcolor{keywordflow}{if} (p\_controller\_entity\_id) \{
611                 memcpy(*p\_controller\_entity\_id, pTest->\hyperlink{structopenavb__saved__state_a8b74ba582b9c19e1f2e475925f7cfb2f}{controller\_entity\_id}, 8);
612             \}
613             \hyperlink{build_2sdk__eavb_2openavb__trace__pub_8h_a0906ddd9e84cc650a76634fe8ff766d7}{AVB\_TRACE\_EXIT}(\hyperlink{openavb__trace_8h_a160710781610431734a8aa068baf9fe2}{AVB\_TRACE\_AVDECC});
614             \textcolor{keywordflow}{return} \textcolor{keyword}{true};
615         \}
616     \}
617 
618     \hyperlink{build_2sdk__eavb_2openavb__trace__pub_8h_a0906ddd9e84cc650a76634fe8ff766d7}{AVB\_TRACE\_EXIT}(\hyperlink{openavb__trace_8h_a160710781610431734a8aa068baf9fe2}{AVB\_TRACE\_AVDECC});
619     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
620 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{openavb__avdecc__read__ini__pub_8h_a3a59dfcc244d7c0644380666afedeb19_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{openavb__avdecc__read__ini__pub_8h_a3a59dfcc244d7c0644380666afedeb19_icgraph}
\end{center}
\end{figure}


\index{openavb\+\_\+avdecc\+\_\+read\+\_\+ini\+\_\+pub.\+h@{openavb\+\_\+avdecc\+\_\+read\+\_\+ini\+\_\+pub.\+h}!openavb\+Avdecc\+Save\+State@{openavb\+Avdecc\+Save\+State}}
\index{openavb\+Avdecc\+Save\+State@{openavb\+Avdecc\+Save\+State}!openavb\+\_\+avdecc\+\_\+read\+\_\+ini\+\_\+pub.\+h@{openavb\+\_\+avdecc\+\_\+read\+\_\+ini\+\_\+pub.\+h}}
\subsubsection[{\texorpdfstring{openavb\+Avdecc\+Save\+State(const openavb\+\_\+tl\+\_\+data\+\_\+cfg\+\_\+t $\ast$p\+Listener, U16 flags, U16 talker\+\_\+unique\+\_\+id, const U8 talker\+\_\+entity\+\_\+id[8], const U8 controller\+\_\+entity\+\_\+id[8])}{openavbAvdeccSaveState(const openavb_tl_data_cfg_t *pListener, U16 flags, U16 talker_unique_id, const U8 talker_entity_id[8], const U8 controller_entity_id[8])}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf bool} openavb\+Avdecc\+Save\+State (
\begin{DoxyParamCaption}
\item[{const {\bf openavb\+\_\+tl\+\_\+data\+\_\+cfg\+\_\+t} $\ast$}]{p\+Listener, }
\item[{{\bf U16}}]{flags, }
\item[{{\bf U16}}]{talker\+\_\+unique\+\_\+id, }
\item[{const {\bf U8}}]{talker\+\_\+entity\+\_\+id\mbox{[}8\mbox{]}, }
\item[{const {\bf U8}}]{controller\+\_\+entity\+\_\+id\mbox{[}8\mbox{]}}
\end{DoxyParamCaption}
)}\hypertarget{openavb__avdecc__read__ini__pub_8h_a9ea955859d4f0e9fa133b6a3665f12b6}{}\label{openavb__avdecc__read__ini__pub_8h_a9ea955859d4f0e9fa133b6a3665f12b6}
Save the connection to the saved state

If fast connect support is enabled, this function is used to save the state of the connection by a Listener when a connection is successfully made to a Talker for possible fast connect support later. \hyperlink{openavb__avdecc__read__ini__pub_8h_a795a38bd974e979fd6b8709e941badf3}{openavb\+Avdecc\+Clear\+Saved\+State()} should be called when the connection is closed.


\begin{DoxyParams}{매개변수}
{\em p\+Listener} & Pointer to configuration for the Listener \\
\hline
{\em flags} & The flags used for the connection (C\+L\+A\+S\+S\+\_\+B, S\+U\+P\+P\+O\+R\+T\+S\+\_\+\+E\+N\+C\+R\+Y\+P\+T\+ED, E\+N\+C\+R\+Y\+P\+T\+E\+D\+\_\+\+P\+DU) \\
\hline
{\em talker\+\_\+unique\+\_\+id} & The unique id for the Talker \\
\hline
{\em talker\+\_\+entity\+\_\+id} & The binary entity id for the Talker \\
\hline
{\em controller\+\_\+entity\+\_\+id} & The binary entity id for the Controller that initiated the connection\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{반환값}
T\+R\+UE on success or F\+A\+L\+SE on failure 
\end{DoxyReturn}


openavb\+\_\+avdecc\+\_\+read\+\_\+ini.\+c 파일의 491 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
492 \{
493     \hyperlink{build_2sdk__eavb_2openavb__trace__pub_8h_ab2bfc814f0447a6d975e8332be197b85}{AVB\_TRACE\_ENTRY}(\hyperlink{openavb__trace_8h_a160710781610431734a8aa068baf9fe2}{AVB\_TRACE\_AVDECC});
494 
495     \textcolor{keywordtype}{int} i;
496 
497     \textcolor{comment}{// Don't add to the saved state list if fast connect support is not enabled.}
498     \textcolor{keywordflow}{if} (!\hyperlink{openavb__avdecc__read__ini_8c_a142e959837c765cd9a1767b886421315}{gAvdeccCfg}.\hyperlink{structopenavb__avdecc__cfg__t_af2d13c6414749c36d13faf34d3bbbd40}{bFastConnectSupported}) \{
499         \hyperlink{build_2sdk__eavb_2openavb__trace__pub_8h_a0906ddd9e84cc650a76634fe8ff766d7}{AVB\_TRACE\_EXIT}(\hyperlink{openavb__trace_8h_a160710781610431734a8aa068baf9fe2}{AVB\_TRACE\_AVDECC});
500         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
501     \}
502 
503     \textcolor{comment}{// If the supplied saved state matches one of the ones already saved, do nothing and return.}
504     \textcolor{comment}{// If the Talker or Controller has changed, delete the old information.}
505     \textcolor{keywordflow}{for} (i = 0; i < 1000; ++i) \{
506         \textcolor{keyword}{const} \hyperlink{structopenavb__saved__state}{openavb\_saved\_state\_t} * pTest = 
      \hyperlink{openavb__avdecc__save__state_8c_a68f1147b5be612cc07767baa03f88767}{openavbAvdeccGetSavedState}(i);
507         \textcolor{keywordflow}{if} (!pTest) \{
508             \textcolor{keywordflow}{break};
509         \}
510 
511         \textcolor{keywordflow}{if} (strcmp(pTest->\hyperlink{structopenavb__saved__state_aeaaf1a5eb8e190e9385389bc81aadb39}{listener\_friendly\_name}, pListener->
      \hyperlink{structopenavb__tl__data__cfg_a25c82ac188182d72242fb10f0285a2bd}{friendly\_name}) == 0) \{
512             \textcolor{keywordflow}{if} (pTest->\hyperlink{structopenavb__saved__state_a492b33861e809623846e5256d271bc78}{flags} == \hyperlink{namespaceavdecc__lib_ab6b306ef981f5e21bb41ea2c2dbe8cd9}{flags} &&
513                     pTest->\hyperlink{structopenavb__saved__state_a545e994bde6218210bb41265ac298837}{talker\_unique\_id} == talker\_unique\_id &&
514                     memcmp(pTest->\hyperlink{structopenavb__saved__state_a9a599b9c25c2171c3e76f269d9a04f51}{talker\_entity\_id}, talker\_entity\_id, 8) == 0 &&
515                     memcmp(pTest->\hyperlink{structopenavb__saved__state_a8b74ba582b9c19e1f2e475925f7cfb2f}{controller\_entity\_id}, controller\_entity\_id, 8) == 0) 
      \{
516                 \textcolor{comment}{// The supplied data is a match for the existing item.  Do nothing.}
517                 \hyperlink{build_2sdk__eavb_2openavb__trace__pub_8h_a0906ddd9e84cc650a76634fe8ff766d7}{AVB\_TRACE\_EXIT}(\hyperlink{openavb__trace_8h_a160710781610431734a8aa068baf9fe2}{AVB\_TRACE\_AVDECC});
518                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};
519             \}
520 
521             \textcolor{comment}{// Delete this item.  We will create a new item with the updated information.}
522             \hyperlink{openavb__avdecc__save__state_8c_a99838adab78e8804d6b5db710a620202}{openavbAvdeccDeleteSavedState}(i);
523             \textcolor{keywordflow}{break};
524         \}
525     \}
526 
527     \textcolor{comment}{// Add the supplied state to the list of states.}
528     \hyperlink{openavb__avdecc__save__state_8c_a2804d64e1af98771b8599596e26e239f}{openavbAvdeccAddSavedState}(pListener->
      \hyperlink{structopenavb__tl__data__cfg_a25c82ac188182d72242fb10f0285a2bd}{friendly\_name}, \hyperlink{namespaceavdecc__lib_ab6b306ef981f5e21bb41ea2c2dbe8cd9}{flags}, talker\_unique\_id, talker\_entity\_id, controller\_entity\_id);
529 
530     \hyperlink{build_2sdk__eavb_2openavb__log__pub_8h_afcf1f0c1d10ae9efe3782eb6cae78355}{AVB\_LOGF\_DEBUG}(\textcolor{stringliteral}{"New saved state:  listener\_id=%s, flags=0x%04x, talker\_unique\_id=0x%04x,
       talker\_entity\_id="} \hyperlink{build_2sdk__eavb_2openavb__log__pub_8h_a2a3dc3ce1982b3a859b968268f2945ef}{ENTITYID\_FORMAT} \textcolor{stringliteral}{", controller\_entity\_id="} 
      \hyperlink{build_2sdk__eavb_2openavb__log__pub_8h_a2a3dc3ce1982b3a859b968268f2945ef}{ENTITYID\_FORMAT},
531         pListener->\hyperlink{structopenavb__tl__data__cfg_a25c82ac188182d72242fb10f0285a2bd}{friendly\_name},
532         \hyperlink{namespaceavdecc__lib_ab6b306ef981f5e21bb41ea2c2dbe8cd9}{flags},
533         talker\_unique\_id,
534         \hyperlink{build_2sdk__eavb_2openavb__log__pub_8h_af361c6d79888b72d21c410bd60035121}{ENTITYID\_ARGS}(talker\_entity\_id),
535         \hyperlink{build_2sdk__eavb_2openavb__log__pub_8h_af361c6d79888b72d21c410bd60035121}{ENTITYID\_ARGS}(controller\_entity\_id));
536 
537     \hyperlink{build_2sdk__eavb_2openavb__trace__pub_8h_a0906ddd9e84cc650a76634fe8ff766d7}{AVB\_TRACE\_EXIT}(\hyperlink{openavb__trace_8h_a160710781610431734a8aa068baf9fe2}{AVB\_TRACE\_AVDECC});
538     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
539 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{openavb__avdecc__read__ini__pub_8h_a9ea955859d4f0e9fa133b6a3665f12b6_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{openavb__avdecc__read__ini__pub_8h_a9ea955859d4f0e9fa133b6a3665f12b6_icgraph}
\end{center}
\end{figure}


\index{openavb\+\_\+avdecc\+\_\+read\+\_\+ini\+\_\+pub.\+h@{openavb\+\_\+avdecc\+\_\+read\+\_\+ini\+\_\+pub.\+h}!openavb\+Read\+Tl\+Data\+Ini\+File@{openavb\+Read\+Tl\+Data\+Ini\+File}}
\index{openavb\+Read\+Tl\+Data\+Ini\+File@{openavb\+Read\+Tl\+Data\+Ini\+File}!openavb\+\_\+avdecc\+\_\+read\+\_\+ini\+\_\+pub.\+h@{openavb\+\_\+avdecc\+\_\+read\+\_\+ini\+\_\+pub.\+h}}
\subsubsection[{\texorpdfstring{openavb\+Read\+Tl\+Data\+Ini\+File(const char $\ast$file\+Name, openavb\+\_\+tl\+\_\+data\+\_\+cfg\+\_\+t $\ast$p\+Cfg)}{openavbReadTlDataIniFile(const char *fileName, openavb_tl_data_cfg_t *pCfg)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf bool} openavb\+Read\+Tl\+Data\+Ini\+File (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{file\+Name, }
\item[{{\bf openavb\+\_\+tl\+\_\+data\+\_\+cfg\+\_\+t} $\ast$}]{p\+Cfg}
\end{DoxyParamCaption}
)}\hypertarget{openavb__avdecc__read__ini__pub_8h_aff613389c2d0e865c1977604e80c58cf}{}\label{openavb__avdecc__read__ini__pub_8h_aff613389c2d0e865c1977604e80c58cf}
Read an ini file.

Parses an input configuration file to populate configuration structures, and name value pairs. Only used in Operating Systems that have a file system


\begin{DoxyParams}{매개변수}
{\em file\+Name} & Pointer to configuration file name \\
\hline
{\em p\+Cfg} & Pointer to configuration structure \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{반환값}
T\+R\+UE on success or F\+A\+L\+SE on failure
\end{DoxyReturn}
\begin{DoxyWarning}{경고}
Not available on all platforms 
\end{DoxyWarning}


openavb\+\_\+avdecc\+\_\+read\+\_\+ini.\+c 파일의 410 번째 라인에서 정의되었습니다.


\begin{DoxyCode}
411 \{
412     \hyperlink{build_2sdk__eavb_2openavb__trace__pub_8h_ab2bfc814f0447a6d975e8332be197b85}{AVB\_TRACE\_ENTRY}(\hyperlink{openavb__trace_8h_a160710781610431734a8aa068baf9fe2}{AVB\_TRACE\_AVDECC});
413 
414     \hyperlink{openavb__avdecc__read__ini_8c_ad2a08504d0f44a37ea14a154d231412f}{openavbIniCfgInit}(pCfg);
415 
416     \textcolor{comment}{// Use the .INI file name as the default friendly name.}
417     strncpy(pCfg->\hyperlink{structopenavb__tl__data__cfg_a25c82ac188182d72242fb10f0285a2bd}{friendly\_name}, fileName, \hyperlink{openavb__avdecc__read__ini__pub_8h_a29d83e67ee30c78c6ed81c188a433c10}{FRIENDLY\_NAME\_SIZE} - 1);
418     \textcolor{keywordtype}{char} * pszComma = strchr(pCfg->\hyperlink{structopenavb__tl__data__cfg_a25c82ac188182d72242fb10f0285a2bd}{friendly\_name}, \textcolor{charliteral}{','});
419     \textcolor{keywordflow}{if} (pszComma) \{
420         \textcolor{comment}{// Get rid of anything following the file name.}
421         *pszComma = \textcolor{charliteral}{'\(\backslash\)0'};
422     \}
423     \textcolor{keywordtype}{char} * pszExtension = strrchr(pCfg->\hyperlink{structopenavb__tl__data__cfg_a25c82ac188182d72242fb10f0285a2bd}{friendly\_name}, \textcolor{charliteral}{'.'});
424     \textcolor{keywordflow}{if} (pszExtension && strcasecmp(pszExtension, \textcolor{stringliteral}{".ini"}) == 0) \{
425         \textcolor{comment}{// Get rid of the .INI file extension.}
426         *pszExtension = \textcolor{charliteral}{'\(\backslash\)0'};
427     \}
428 
429     \textcolor{keywordtype}{int} result = \hyperlink{daemons_2gptp_2common_2ini_8c_ad285e522c65745f50f01ba650b563dd7}{ini\_parse}(fileName, \hyperlink{openavb__avdecc__read__ini_8c_a830de25c58fb8731951494de81c751af}{openavbIniCfgCallback}, pCfg);
430     \textcolor{keywordflow}{if} (result < 0) \{
431         \hyperlink{build_2sdk__eavb_2openavb__log__pub_8h_a7965828e6f132ce789a962b917519e24}{AVB\_LOGF\_ERROR}(\textcolor{stringliteral}{"Couldn't parse INI file: %s"}, fileName);
432         \hyperlink{build_2sdk__eavb_2openavb__trace__pub_8h_a0906ddd9e84cc650a76634fe8ff766d7}{AVB\_TRACE\_EXIT}(\hyperlink{openavb__trace_8h_a160710781610431734a8aa068baf9fe2}{AVB\_TRACE\_AVDECC});
433         \textcolor{keywordflow}{return} \hyperlink{maap__log_8h_aa93f0eb578d23995850d61f7d61c55c1}{FALSE};
434     \}
435     \textcolor{keywordflow}{if} (result > 0) \{
436         \hyperlink{build_2sdk__eavb_2openavb__log__pub_8h_a7965828e6f132ce789a962b917519e24}{AVB\_LOGF\_ERROR}(\textcolor{stringliteral}{"Error in INI file: %s, line %d"}, fileName, result);
437         \hyperlink{build_2sdk__eavb_2openavb__trace__pub_8h_a0906ddd9e84cc650a76634fe8ff766d7}{AVB\_TRACE\_EXIT}(\hyperlink{openavb__trace_8h_a160710781610431734a8aa068baf9fe2}{AVB\_TRACE\_AVDECC});
438         \textcolor{keywordflow}{return} \hyperlink{maap__log_8h_aa93f0eb578d23995850d61f7d61c55c1}{FALSE};
439     \}
440 
441     \textcolor{keywordflow}{if} (pCfg->\hyperlink{structopenavb__tl__data__cfg_aa2a20a90661f499e91e4a4eb8aea4666}{current\_sampling\_rate} != 0 && pCfg->\hyperlink{structopenavb__tl__data__cfg_a011c2e9be501a618cccfc772e016a5c7}{audioRate} != 0 &&
442         pCfg->\hyperlink{structopenavb__tl__data__cfg_aa2a20a90661f499e91e4a4eb8aea4666}{current\_sampling\_rate} != pCfg->\hyperlink{structopenavb__tl__data__cfg_a011c2e9be501a618cccfc772e016a5c7}{audioRate})
443     \{
444         \hyperlink{build_2sdk__eavb_2openavb__log__pub_8h_a7965828e6f132ce789a962b917519e24}{AVB\_LOGF\_ERROR}(\textcolor{stringliteral}{"current\_sampling\_rate(%u) and intf\_nv\_audio\_rate(%u) do not match."}, 
      pCfg->\hyperlink{structopenavb__tl__data__cfg_aa2a20a90661f499e91e4a4eb8aea4666}{current\_sampling\_rate}, pCfg->\hyperlink{structopenavb__tl__data__cfg_a011c2e9be501a618cccfc772e016a5c7}{audioRate});
445         \hyperlink{build_2sdk__eavb_2openavb__trace__pub_8h_a0906ddd9e84cc650a76634fe8ff766d7}{AVB\_TRACE\_EXIT}(\hyperlink{openavb__trace_8h_a160710781610431734a8aa068baf9fe2}{AVB\_TRACE\_AVDECC});
446         \textcolor{keywordflow}{return} \hyperlink{maap__log_8h_aa93f0eb578d23995850d61f7d61c55c1}{FALSE};
447     \}
448 
449     \textcolor{keywordflow}{if} (pCfg->\hyperlink{structopenavb__tl__data__cfg_aa2a20a90661f499e91e4a4eb8aea4666}{current\_sampling\_rate} == 0)
450     \{
451         \textcolor{comment}{/* Make sure we have a default sampling rate. */}
452         \textcolor{keywordflow}{if} (pCfg->\hyperlink{structopenavb__tl__data__cfg_a011c2e9be501a618cccfc772e016a5c7}{audioRate} != 0) \{
453             pCfg->\hyperlink{structopenavb__tl__data__cfg_aa2a20a90661f499e91e4a4eb8aea4666}{current\_sampling\_rate} = pCfg->\hyperlink{structopenavb__tl__data__cfg_a011c2e9be501a618cccfc772e016a5c7}{audioRate};
454         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (pCfg->\hyperlink{structopenavb__tl__data__cfg_a4d629576141d6cb141a196f015fcd6ad}{sampling\_rates}[0] != 0) \{
455             pCfg->\hyperlink{structopenavb__tl__data__cfg_aa2a20a90661f499e91e4a4eb8aea4666}{current\_sampling\_rate} = pCfg->
      \hyperlink{structopenavb__tl__data__cfg_a4d629576141d6cb141a196f015fcd6ad}{sampling\_rates}[0];
456         \} \textcolor{keywordflow}{else} \{
457             pCfg->\hyperlink{structopenavb__tl__data__cfg_aa2a20a90661f499e91e4a4eb8aea4666}{current\_sampling\_rate} = 
      \hyperlink{openavb__audio__pub_8h_a6070f1cfbb6824de6f0b2524cd306903a3a14e34aa46b5b2055c1ea8a33799033}{AVB\_AUDIO\_RATE\_48KHZ};
458         \}
459         \textcolor{keywordflow}{if} (pCfg->\hyperlink{structopenavb__tl__data__cfg_a011c2e9be501a618cccfc772e016a5c7}{audioRate} == 0) \{
460             \hyperlink{build_2sdk__eavb_2openavb__log__pub_8h_a6b02336e691e2e0579d2a5bb06367296}{AVB\_LOGF\_WARNING}(\textcolor{stringliteral}{"current\_sampling\_rate not specified in %s. Defaulting to %u"},
       fileName, pCfg->\hyperlink{structopenavb__tl__data__cfg_aa2a20a90661f499e91e4a4eb8aea4666}{current\_sampling\_rate});
461         \}
462     \}
463     \textcolor{keywordflow}{if} (pCfg->\hyperlink{structopenavb__tl__data__cfg_a75b9a3bf65c881bc71b05d983793aa62}{sampling\_rates\_count} == 0)
464     \{
465         \textcolor{comment}{/* Set the list of sampling rates to the current sampling rate. */}
466         pCfg->\hyperlink{structopenavb__tl__data__cfg_a4d629576141d6cb141a196f015fcd6ad}{sampling\_rates}[0] = pCfg->\hyperlink{structopenavb__tl__data__cfg_aa2a20a90661f499e91e4a4eb8aea4666}{current\_sampling\_rate};
467         pCfg->\hyperlink{structopenavb__tl__data__cfg_a75b9a3bf65c881bc71b05d983793aa62}{sampling\_rates\_count} = 1;
468         \textcolor{keywordflow}{if} (pCfg->\hyperlink{structopenavb__tl__data__cfg_a011c2e9be501a618cccfc772e016a5c7}{audioRate} == 0) \{
469             \hyperlink{build_2sdk__eavb_2openavb__log__pub_8h_a6b02336e691e2e0579d2a5bb06367296}{AVB\_LOGF\_WARNING}(\textcolor{stringliteral}{"sampling\_rates not specified in %s. Defaulting to %u"}, 
      fileName, pCfg->\hyperlink{structopenavb__tl__data__cfg_aa2a20a90661f499e91e4a4eb8aea4666}{current\_sampling\_rate});
470         \}
471     \} \textcolor{keywordflow}{else} \{
472         \textcolor{comment}{/* Make sure the current sampling rate is in the list of sampling rates. */}
473         \hyperlink{openavb__types__base__pub_8h_a0a0a322d5fa4a546d293a77ba8b4a71f}{U16} i;
474         \textcolor{keywordflow}{for} (i = 0; i < pCfg->\hyperlink{structopenavb__tl__data__cfg_a75b9a3bf65c881bc71b05d983793aa62}{sampling\_rates\_count}; ++i) \{
475             \textcolor{keywordflow}{if} (pCfg->\hyperlink{structopenavb__tl__data__cfg_a4d629576141d6cb141a196f015fcd6ad}{sampling\_rates}[i] == pCfg->
      \hyperlink{structopenavb__tl__data__cfg_aa2a20a90661f499e91e4a4eb8aea4666}{current\_sampling\_rate}) \textcolor{keywordflow}{break};
476         \}
477         \textcolor{keywordflow}{if} (i >= pCfg->\hyperlink{structopenavb__tl__data__cfg_a75b9a3bf65c881bc71b05d983793aa62}{sampling\_rates\_count}) \{
478             \hyperlink{build_2sdk__eavb_2openavb__log__pub_8h_a7965828e6f132ce789a962b917519e24}{AVB\_LOGF\_ERROR}(\textcolor{stringliteral}{"current\_sampling\_rate(%u) not in list of sampling\_rates."}, pCfg->
      \hyperlink{structopenavb__tl__data__cfg_aa2a20a90661f499e91e4a4eb8aea4666}{current\_sampling\_rate});
479             \hyperlink{build_2sdk__eavb_2openavb__trace__pub_8h_a0906ddd9e84cc650a76634fe8ff766d7}{AVB\_TRACE\_EXIT}(\hyperlink{openavb__trace_8h_a160710781610431734a8aa068baf9fe2}{AVB\_TRACE\_AVDECC});
480             \textcolor{keywordflow}{return} \hyperlink{maap__log_8h_aa93f0eb578d23995850d61f7d61c55c1}{FALSE};
481         \}
482     \}
483 
484     \hyperlink{build_2sdk__eavb_2openavb__trace__pub_8h_a0906ddd9e84cc650a76634fe8ff766d7}{AVB\_TRACE\_EXIT}(\hyperlink{openavb__trace_8h_a160710781610431734a8aa068baf9fe2}{AVB\_TRACE\_AVDECC});
485     \textcolor{keywordflow}{return} \hyperlink{maap__log_8h_aa8cecfc5c5c054d2875c03e77b7be15d}{TRUE};
486 \}
\end{DoxyCode}


이 함수 내부에서 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{openavb__avdecc__read__ini__pub_8h_aff613389c2d0e865c1977604e80c58cf_cgraph}
\end{center}
\end{figure}




이 함수를 호출하는 함수들에 대한 그래프입니다.\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{openavb__avdecc__read__ini__pub_8h_aff613389c2d0e865c1977604e80c58cf_icgraph}
\end{center}
\end{figure}


