<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OpenAvnu: avdecc-lib</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenAvnu
   &#160;<span id="projectnumber">0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 다음에 의해 생성됨 :  Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'검색');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>메인&#160;페이지</span></a></li>
      <li class="current"><a href="pages.html"><span>관련된&#160;페이지</span></a></li>
      <li><a href="modules.html"><span>모듈</span></a></li>
      <li><a href="namespaces.html"><span>네임스페이스</span></a></li>
      <li><a href="annotated.html"><span>데이타&#160;구조</span></a></li>
      <li><a href="files.html"><span>파일들</span></a></li>
      <li><a href="examples.html"><span>예제</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="검색" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_avdecc-lib_controller_lib_doc_design.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">avdecc-lib </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Simple C++ library for implementing IEEE1722.1 (AVB Device Enumeration, Discovery and Control)</p>
<h2>Introduction </h2>
<p>This library aims to simplify development of an AVDECC controller based on the IEEE1722.1 specification. It provides a simple c++ object interface to 1722.1 objects and implements device discovery and enumeration as a background process.</p>
<p>The repository contains source to build a Windows DLL or a Linux library and a command line application for exercising the library.</p>
<p>The overall philosophy of AVDECC LIB is to implement a thin layer of commands that allow an application to discover and and control AVDECC capable endpoints. The internal operations of the library are designed to be single threaded, although multiple threads are used to queue operations to be performed by the single threaded "engine" portion of the library. The library supports notification events (callbacks) that are triggered on the success (or failure) of a command. It is up to the application to process the notifications in a useful manner. Asynchronously control updates from an endpoint are also supported. A control notification does not have data about the updated descriptor values embedded in it. Instead the AVDECC application should query the control class to obtain the updated values.</p>
<h2>Directory layout </h2>
<pre class="fragment">lib\
  bin\
  doc\
  binding\
    python\
  build\
    linux\
    msvc\
  binding\
  include\ (contains public header files)
  src\ (contains private header files and c++ source code)
  linux\ (linux specific files)
    msvc\ (Microsoft Visual Studio specific files)
app\
  bin\
  doc\
  build\
    linux\
    msvc\
  cmdline\
    src\
  test\
    strings\
    adp\
    logging\ 
    notify\
</pre><h2>Object hierarchy </h2>
<pre class="fragment">AVDECC System
  Endpoint[1..N]
    Entity[1..N]
        Configuration[1..N]
            Audio Unit[0..N]
            Stream Input[0..N]
            Stream Output[0..N]
            AVB Interface[0..N]
            Clock Source[0..N]
            Jack Input[0..N]
            Jack Output[0..N]
            Clock Domain[0..N]
</pre><p><b>association_id</b></p>
<p>If ASSOCIATION_ID_SUPPORTED and ASSOCIATION_ID_VALID flags are set in the ADP entity_capabilities field, then multiple entites will be represented as a single logical entity in the hierarchy. <em>AL: How closely do we want to stick to 1722.1 terminology here e.g. The term for endpoint in the standard is 'end station'. Should this be reflected here?</em> <em>AGE: will change to use endstation terminology</em></p>
<h2>Building </h2>
<p><b>Windows</b></p>
<p>Prerequisites</p>
<ol type="1">
<li>MSVC 2010 or later</li>
</ol>
<ol type="1">
<li>jdksavdecc-c git repository from <a href="https://github.com/jdkoftinoff/jdksavdecc-c">https://github.com/jdkoftinoff/jdksavdecc-c</a></li>
</ol>
<ol type="1">
<li>winpcap from <a href="http://www.winpcap.org/">http://www.winpcap.org/</a></li>
</ol>
<p>The following environment variables must be defined:</p><ul>
<li>WINPCAP_DIR the directory where WinPcap is installed</li>
<li>JDKAVDECC_DIR the directory where JDKSAVDECC-C git 1722.1 C library is installed</li>
</ul>
<p><b>Linux</b></p>
<p>ToDo</p>
<h1>Operations </h1>
<h2>AVDECC Endpoint Discovery </h2>
<p>When the AVDECC system receives a AVDECC advertise message from an endpoint, it proceeds to enumerate the endpoint's complete object model if it hasn't done so already and the following hold true:</p>
<ul>
<li>The AEM_SUPPORTED flag in the ADP entity_capabilities field is set</li>
<li>The GENERAL_CONTROLLER_IGNORE flag in the ADP entity_capabilities field is not set</li>
<li>The ENTITY_NOT_READY flag in the ADP entity_capabilities field is not set</li>
</ul>
<p>When an end station is discovered, a notification message is sent to the application. Additionally, upon completion of the enumeration process, a second notification message is sent to the application.</p>
<p><em>AL: Is there a case for separating the discovery and enumeration notifications? The user may want to connect entities that do not support AEM</em> <em>AGE: changed - see above</em></p>
<h2>AVDECC descriptor reads </h2>
<p>A descriptor read by referencing the object the object of interest. Since the AVDECC system has already read all descriptors, the read operation is completed without producing any network traffic.</p>
<p>To read the name of the first input jack, one would go:: </p><pre class="fragment">avdeccsys-&gt;endpoint(0)-&gt;entity(0)-&gt;configuration(0)-&gt;stream_input(0)-&gt;get_name(name) 
</pre><p><em>AL: This example might be a bit confusing, as there is also a GET_NAME command. I'd expect the above to issue an AECP GET_NAME command rather than just read the string from the descriptor. I presume the fields in the descriptor could just be accessed like:</em></p>
<p><em>AGE: agreed - I'll change it</em> </p><pre class="fragment">avdeccsys-&gt;endpoint(0)-&gt;entity(0)-&gt;configuration(0)-&gt;stream_input(0)-&gt;object_name
</pre><p><em>However, should the following return the actual contents of the descriptor, or return the correct string from the STRING descriptor?</em> </p><pre class="fragment">avdeccsys-&gt;endpoint(0)-&gt;entity(0)-&gt;configuration(0)-&gt;stream_input(0)-&gt;localized_description
</pre><p>A thought: </p><pre class="fragment">avdeccsys-&gt;get_entity(0x0022970102030000)-&gt;configuration(0)-&gt;stream_input(0)-&gt;localized_description
</pre><p><em>AGE we are having internal discussions about "flattening" the API.</em> <em>The controller would have a method something like</em> <em>root-&gt;in_stream_set_format(end station GUID, entity index, config index, in_stream_index, parameters)</em></p>
<h2>AVDECC commands </h2>
<p>An AVDECC command is sent to the target object, ie </p><pre class="fragment">istream = avdeccsys-&gt;endpoint(0)-&gt;entity(0)-&gt;configuration(0)-&gt;stream_input(0);
if (istream) {
    istream-&gt;set_format(unsigned int *id,format,...);
}
</pre><p>Completion results in a notification message of success or failure via the callback mechanism.</p>
<p><b>Relative Implementation Priorities</b></p>
<table class="doxtable">
<tr>
<th>Command/Response </th><th>Priority  </th></tr>
<tr>
<td>ACQUIRE_ENTITY </td><td>P1 </td></tr>
<tr>
<td>LOCK_ENTITY </td><td>P1 </td></tr>
<tr>
<td>ENTITY_AVAILABLE </td><td>P1 </td></tr>
<tr>
<td>CONTROLLER_AVAILABLE </td><td>P1 </td></tr>
<tr>
<td>READ_DESCRIPTOR </td><td>P1 </td></tr>
<tr>
<td>WRITE_DESCRIPTOR </td><td>P3 </td></tr>
<tr>
<td>SET_CONFIGURATION </td><td>P2 </td></tr>
<tr>
<td>GET_CONFIGURATION </td><td>P2 </td></tr>
<tr>
<td>SET_STREAM_FORMAT </td><td>P1 </td></tr>
<tr>
<td>GET_STREAM_FORMAT </td><td>P1 </td></tr>
<tr>
<td>SET_VIDEO_FORMAT </td><td>P4 </td></tr>
<tr>
<td>GET_VIDEO_FORMAT </td><td>P4 </td></tr>
<tr>
<td>SET_SENSOR_FORMAT </td><td>P4 </td></tr>
<tr>
<td>GET_SENSOR_FORMAT </td><td>P4 </td></tr>
<tr>
<td>SET_STREAM_INFO </td><td>P1 </td></tr>
<tr>
<td>GET_STREAM_INFO </td><td>P1 </td></tr>
<tr>
<td>SET_NAME </td><td>P2 </td></tr>
<tr>
<td>GET_NAME </td><td>P2 </td></tr>
<tr>
<td>SET_ASSOCIATION_ID </td><td>P3 </td></tr>
<tr>
<td>GET_ASSOCIATION_ID </td><td>P3 </td></tr>
<tr>
<td>SET_SAMPLING_RATE </td><td>P1 </td></tr>
<tr>
<td>GET_SAMPLING_RATE </td><td>P1 </td></tr>
<tr>
<td>SET_CLOCK_SOURCE </td><td>P1 </td></tr>
<tr>
<td>GET_CLOCK_SOURCE </td><td>P1 </td></tr>
<tr>
<td>SET_CONTROL </td><td>P2 </td></tr>
<tr>
<td>GET_CONTROL </td><td>P2 </td></tr>
<tr>
<td>INCREMENT_CONTROL </td><td>P3 </td></tr>
<tr>
<td>DECREMENT_CONTROL </td><td>P3 </td></tr>
<tr>
<td>SET_SIGNAL_SELECTOR </td><td>P3 </td></tr>
<tr>
<td>GET_SIGNAL_SELECTOR </td><td>P3 </td></tr>
<tr>
<td>SET_MIXER </td><td>P2 </td></tr>
<tr>
<td>GET_MIXER </td><td>P2 </td></tr>
<tr>
<td>SET_MATRIX </td><td>P3 </td></tr>
<tr>
<td>GET_MATRIX </td><td>P3 </td></tr>
<tr>
<td>START_STREAMING </td><td>P1 </td></tr>
<tr>
<td>STOP_STREAMING </td><td>P1 </td></tr>
<tr>
<td>REGISTER_UNSOLICITED_NOTIFICATION </td><td>P2 </td></tr>
<tr>
<td>DEREGISTER_UNSOLICITED_NOTIFICATION </td><td>P2 </td></tr>
<tr>
<td>IDENTIFY_NOTIFICATION</td><td>P2 </td></tr>
<tr>
<td>GET_AVB_INFO </td><td>P2 </td></tr>
<tr>
<td>GET_AS_PATH </td><td>P2 </td></tr>
<tr>
<td>GET_COUNTERS </td><td>P3 </td></tr>
<tr>
<td>REBOOT </td><td>P2 </td></tr>
<tr>
<td>GET_AUDIO_MAP </td><td>P3 </td></tr>
<tr>
<td>ADD_AUDIO_MAPPINGS </td><td>P3 </td></tr>
<tr>
<td>REMOVE_AUDIO_MAPPINGS </td><td>P3 </td></tr>
<tr>
<td>GET_VIDEO_MAP </td><td>P4 </td></tr>
<tr>
<td>ADD_VIDEO_MAPPINGS </td><td>P4 </td></tr>
<tr>
<td>REMOVE_VIDEO_MAPPINGS </td><td>P4 </td></tr>
<tr>
<td>GET_SENSOR_MAP </td><td>P4 </td></tr>
<tr>
<td>ADD_SENSOR_MAPPINGS </td><td>P4 </td></tr>
<tr>
<td>REMOVE_SENSOR_MAPPINGS </td><td>P4 </td></tr>
<tr>
<td>START_OPERATION </td><td>P3 </td></tr>
<tr>
<td>ABORT_OPERATION </td><td>P3 </td></tr>
<tr>
<td>OPERATION_STATUS </td><td>P3 </td></tr>
</table>
<h2>Callbacks </h2>
<p>The following callback functions should be supplied. </p><pre class="fragment">void avdecc_log_fn(void *user_obj, int32_t log_level, char msg[256], uint32_t time_stamp_ms);
void avdecc_notify(void *user_obj, int32_t notification, int32_t endpoint_index, int32_t obj, int32_t index, int32_t cmd, int32_t id); 
</pre><p>With notifications of:</p><ul>
<li>No Match Found</li>
<li>Endpoint Discovered</li>
<li>Endpoint Connected</li>
<li>Endpoint Disconnected</li>
<li>Invalid Command</li>
<li>Command Timeout</li>
<li>Command Resent</li>
<li>Command Success </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">다음에 의해 생성됨 : 
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
