<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OpenAvnu: lib/avtp_pipeline/documents/sdk_avtp_stream_cfg.md 소스 파일</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenAvnu
   &#160;<span id="projectnumber">0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 다음에 의해 생성됨 :  Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'검색');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>메인&#160;페이지</span></a></li>
      <li><a href="pages.html"><span>관련된&#160;페이지</span></a></li>
      <li><a href="modules.html"><span>모듈</span></a></li>
      <li><a href="namespaces.html"><span>네임스페이스</span></a></li>
      <li><a href="annotated.html"><span>데이타&#160;구조</span></a></li>
      <li class="current"><a href="files.html"><span>파일들</span></a></li>
      <li><a href="examples.html"><span>예제</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="검색" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>파일&#160;목록</span></a></li>
      <li><a href="globals.html"><span>전역</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('sdk__avtp__stream__cfg_8md.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">lib/avtp_pipeline/documents/sdk_avtp_stream_cfg.md</div>  </div>
</div><!--header-->
<div class="contents">
<a href="sdk__avtp__stream__cfg_8md.html">이 파일의 문서화 페이지로 가기</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;AVTP Stream (Talker/Listener) Configuration {#sdk_avtp_stream_cfg}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;===========================================</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;Overview {#sdk_avtp_stream_cfg_overview}</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;========</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;The configuration of streams (talkers and listeners) is controlled via the </div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;structure @ref openavb_tl_cfg_t that is passed to the @ref openavbTLConfigure function. </div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;There are 3 major sections within the configuration structure. The general </div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;talker / listener (AVTP stream) section, the mapping module section and the </div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;interface module section. The general section has settings used by the </div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;talker/listener module directly. The mapping module section has settings </div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;specific to the mapping module being used for the stream and the interface </div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;module section has settings specific to the interface module being used for the </div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;stream. </div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;How the @ref openavb_tl_cfg_t structure gets set is platform dependent. For the </div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;Linux reference implementation reading from .ini files is supported which in </div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;turn fills this structure. For RTOSes the stream configuration structure is </div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;usually set directly via code in the AVB host application module. Therefore the </div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;use of .ini files is a layer above the what the core AVB stack uses. The Release </div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;Notes for the AVB port should be referenced with regards to where the </div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;configuration values can be set. </div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;Here is a sample configuration structure initialization for a H.264 listener.</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;void h264_SampleListenerCfg(openavb_tl_cfg_t *cfg)</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;{</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;   // Clear our the configuration structure to ensure defaults (0)</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;   memset(cfg, 0, sizeof(openavb_tl_cfg_t));</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;   // This must be set to the multicast address that is used </div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;   U8 multicastStrmAddr[] = { 0x91, 0xE0, 0xF0, 0x00, 0xFE, 0x00 };</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;   ///////////////////</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;   // TL (Talker / Listener) Configuration</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;   ///////////////////</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;   // Identify the role of the stream (talker or listener)</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;   // must be set to AVB_ROLE_LISTENER or AVB_ROLE_TALKER</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;   cfg-&gt;role = AVB_ROLE_LISTENER;</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;   memcpy(cfg-&gt;stream_addr.buffer.ether_addr_octet, multicastStrmAddr, ETH_ALEN);</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;   cfg-&gt;stream_addr.mac = &amp;cfg-&gt;stream_addr.buffer;</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;   // max_interval_frames: The maximum number of packets that will be sent during </div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;   // an observation interval. This is only used on the talker.</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;   // cfg-&gt;max_interval_frames = 1;</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;   // max_transit_usec: Allows manually specifying a maximum transit time. </div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;   // On the talker this value is added to the PTP walltime to create the AVTP Timestamp.</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;   // On the listener this value is used to validate an expected valid timestamp range.</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;   // Note: For the listener the map_nv_item_count value must be set large enough to </div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;   // allow buffering at least as many AVTP packets that can be transmitted during this </div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;   // max transit time.</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;   cfg-&gt;max_transit_usec = 2000;</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;   // max_transmit_deficit_usec: Allows setting the maximum packet transmit rate deficit that will</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;   // be recovered when a talker falls behind. This is only used on a talker side. When a talker</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;   // can not keep up with the specified transmit rate it builds up a deficit and will attempt to </div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;   // make up for this deficit by sending more packets. There is normally some variability in the </div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;   // transmit rate because of other demands on the system so this is expected. However, without this</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;   // bounding value the deficit could grew too large in cases such where more streams are started </div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;   // than the system can support and when the number of streams is reduced the remaining streams </div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;   // will attempt to recover this deficit by sending packets at a higher rate. This can cause a problem</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;   // at the listener side and significantly delay the recovery time before media playback will return </div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;   // to normal. Typically this value can be set to the expected buffer size (in usec) that listeners are </div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;   // expected to be buffering. For low latency solutions this is normally a small value. For non-live </div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;   // media playback such as video playback the listener side buffers can often be large enough to held many</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;   // seconds of data.</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;   // cfg-&gt;max_transmit_deficit_usec = 2000;</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;   // internal_latency: Allows mannually specifying an internal latency time. This is used</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;   // only on the talker.</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;   //  cfg-&gt;internal_latency = 0;</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;   // The number of microseconds a media queue items can be passed the presentation time at which</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;   // point it will be purged.</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;   cfg-&gt;max_stale = 500;</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;   // number of intervals to handle at once (talker)</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;   // cfg-&gt;batch_factor = 1;</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;   // report_seconds: How often to output stats. Defaults to 10 seconds. 0 turns off the stats. </div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;   cfg-&gt;report_seconds = 0;</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;   // sr_class: A talker only setting. Values are either SR_CLASS_A or SR_CLASS_B.</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;   // cfg-&gt;sr_class = SR_CLASS_A;</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;   // raw_tx_buffers: The number of raw socket transmit buffers.</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;   // cfg-&gt;raw_tx_buffers = 40;</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;   // raw_rx_buffers: The number of raw socket receive buffers.</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;   cfg-&gt;raw_rx_buffers = 40;</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;   // tx_blocking_in_intf : A talker only option. When set packet pacing is expected to be handled in the interface module.</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;   // Commonly there will be a matching interface module configuration item that needs to be set.</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;   // cfg-&gt;tx_blocking_in_intf = FALSE;</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;   ///////////////////</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;   // The remaining configuration items vary depending on the mapping module and interface module being used.</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;   // These configuration values are populated as name value pairs.</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;   ///////////////////</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;   // Configuration index counter.</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;   int cfgIdx = 0;</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;   ///////////////////</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;   // Mapping module</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;   ///////////////////</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;   // map_nv_item_count: The number of media queue elements to hold.</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;   cfg-&gt;libCfgNames[cfgIdx] = &quot;map_nv_item_count&quot;;</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;   cfg-&gt;libCfgValues[cfgIdx++] = &quot;10&quot;;</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;   // map_nv_tx_rate: Transmit rate. Typically this is set to match the SR Class. 8000 for A and 4000 for B</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;   // cfg-&gt;libCfgNames[cfgIdx] = &quot;map_nv_tx_rate&quot;;</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;   // cfg-&gt;libCfgValues[cfgIdx++] = &quot;8000&quot;;</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;   // map_nv_max_payload_size: This is the max RTP payload size. See RFC 6184 for details,</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;   // 1412 is the default size</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;   cfg-&gt;libCfgNames[cfgIdx] = &quot;map_nv_max_payload_size&quot;;</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;   cfg-&gt;libCfgValues[cfgIdx++] = &quot;1412&quot;;</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;   </div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;   ///////////////////</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;   // Interface module</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;   ///////////////////</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;   // intf_nv_blocking_tx_callback : A talker only option. When set packet pacing is expected to be handled in the interface module.</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;   // Commonly the TL configuration option tx_blocking_in_intf needs to be set to match this.</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;   // cfg-&gt;libCfgNames[cfgIdx] = &quot;intf_nv_blocking_tx_callback&quot;;</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;   // cfg-&gt;libCfgValues[cfgIdx++] = &quot;1&quot;;</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;   // intf_nv_ignore_timestamp : If set the listener will ignore the timestamp on media queue items.</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;   cfg-&gt;libCfgNames[cfgIdx] = &quot;intf_nv_ignore_timestamp&quot;;</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;   cfg-&gt;libCfgValues[cfgIdx++] = &quot;0&quot;;</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;   cfg-&gt;nLibCfgItems = cfgIdx;</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;   ///////////////////</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;   // Mapping and interface modules main initialization entry points</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;   ///////////////////</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;   // pMapInitFn : Mapping module initialization function. (openavb_map_initialize_fn_t)</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;   cfg-&gt;osalCfg.pMapInitFn = openavbMapH264Initialize;</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;   // pIntfInitFn : Interface module initialization function. (openavb_intf_initialize_fn_t)</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;   cfg-&gt;osalCfg.pIntfInitFn = openavbIntfJ6Video;</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;} </div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;&lt;br&gt;</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;Common Stream Configuration {#sdk_avtp_stream_cfg_common}</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;===========================</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;These are common stream configuration values. </div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;Name                | Description</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;--------------------|------------</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;role                |Sets the process as a talker or listener. Valid values are *talker* or *listener*.</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;stream_addr         |Used on the listener and should be set to the mac address of the talker.  If not specified on the talker, the talker&#39;s detected mac address will be used.&lt;br&gt;If AVDECC is being used, this does not need to be specified for the listener, as AVDECC will tell the listener which value to use.</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;stream_uid          |The unique stream ID. The talker and listener must both have this set the same.&lt;br&gt;If AVDECC is being used, this does not need to be specified for the listener, as AVDECC will tell the listener which value to use.</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;dest_addr           |Destination multicast address for the stream.&lt;br&gt;If using&lt;ul&gt;&lt;li&gt;&lt;b&gt;with MAAP&lt;/b&gt; - dynamic destination addresses are generated automatically by the talker and passed to the listener, and don&#39;t need to be configured.&lt;br&gt;However, it is recommended that a locally administered (static) address still be configured, as the dest_addr will be used if the MAAP daemon is not available.&lt;/li&gt;&lt;li&gt;&lt;b&gt;without MAAP&lt;/b&gt;, locally administered (static) addresses must be configured. Those addresses are in the range of: 91:E0:F0:00:FE:00 - 91:E0:F0:00:FE:FF. Typically use :00 for the first stream, :01 for the second, etc. &lt;/li&gt;&lt;/ul&gt; If &lt;b&gt;SRP&lt;/b&gt; &lt;ul&gt;&lt;li&gt;&lt;b&gt;is being&lt;/b&gt; used the static destination address only needs to be set in the talker;&lt;/li&gt; &lt;li&gt;&lt;b&gt;is not being&lt;/b&gt; used the destination address need to be set (to the same value) in both the talker and listener.&lt;/li&gt;&lt;/ul&gt; The destination is a multicast address, not a real MAC address, so it does not match the talker or listener&#39;s interface MAC. There are several pools of those addresses for use by AVTP defined in 1722.</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;max_interval_frames |The maximum number of packets that will be sent during an observation interval. This is only used on the talker.</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;max_frame_size      |Maximum size of the frame</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;sr_class            |A talker only setting. Values are either A or B. If not set an internal default is used.</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;sr_rank             |A talker only setting. If not set an internal default is used.</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;max_transit_usec    |Allows manually specifying a maximum transit time. &lt;ul&gt;&lt;li&gt;&lt;b&gt;On the talker&lt;/b&gt; this value is added to the PTP walltime to create the AVTP Timestamp.&lt;/li&gt;&lt;li&gt;&lt;b&gt;On the listener&lt;/b&gt; this value is used to validate an expected valid timestamp range.&lt;/li&gt;&lt;/ul&gt;&lt;b&gt;Note:&lt;/b&gt; For the listener the map_nv_item_count value must be set large enough to allow buffering at least as many AVTP packets that can be transmitted during this max transit time.</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;max_transmit_deficit_usec |Allows setting the maximum packet transmit rate deficit that will be recovered when a talker falls behind. &lt;p&gt;When a talker can not keep up with the specified transmit rate it builds up a deficit and will attempt to make up for this deficit by sending more packets. There is normally some variability in the transmit rate because of other demands on the system so this is expected. However, without this bounding value the deficit could grew too large in cases such where more streams are started than the system can support and when the number of streams is reduced the remaining streams will attempt to recover this deficit by sending packets at a higher rate. This can cause a problem at the listener side and significantly delay the recovery time before media playback will return to normal.&lt;/p&gt;&lt;p&gt;Typically this value can be set to the expected buffer size (in usec) that listeners are expected to be buffering.&lt;br&gt;For low latency solutions this is normally a small value. For non-live media playback such as video playback the listener side buffers can often be large enough to held many seconds of data.&lt;/p&gt;&lt;b&gt;Note:&lt;/b&gt; This is only used on a talker side.</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;internal_latency    |Allows manually specifying an internal latency time. This is used only on the talker.</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;max_stale           |The number of microseconds beyond the presentation time that media queue items will be purged because they are too old (past the presentation time).&lt;br&gt;This is only used on listener end stations.&lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; needing to purge old media queue items is often a sign of some other problem.&lt;br&gt;For example: a delay at stream startup before incoming packets are ready to be processed by the media sink.&lt;br&gt;If this deficit in processing or purging the old (stale) packets is not handled, syncing multiple listeners will be problematic.&lt;/p&gt;</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;raw_tx_buffers      |The number of raw socket transmit buffers. Typically 4 - 8 are good values. This is only used by the talker. If not set internal defaults are used.</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;raw_rx_buffers      |The number of raw socket receive buffers. Typically 50 - 100 are good values. This is only used by the listener. If not set internal defaults are used.</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;report_seconds      |How often to output stats. Defaults to 10 seconds. 0 turns off the stats.</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;tx_blocking_in_intf |The interface module will block until data is available. This is a talker only configuration value and not all interface modules support it.</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;pMapInitFn          |Pointer to the mapping module initialization function. Since this is a pointer to a function address is it not directly set in platforms that use a .ini file. </div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;IntfInitFn          |Pointer to the interface module initialization function. Since this is a pointer to a function address is it not directly set in platforms that use a .ini file. </div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;&lt;br&gt;</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;# Platform Specific Stream Configuration Values</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;Some platform ports have unique configuration values. </div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;## Linux</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;Name                      | Description</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;--------------------------|---------------------------</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;map_lib                   |The name of the library file (commonly a .so file) that implements the Initialize function.&lt;br&gt;Comment out the map_lib name and link in the .c file to the openavb_tl executable to embed the mapper directly into the executable unit. There is no need to change anything else. The Initialize function will still be dynamically linked in.</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;map_fn                    |The name of the initialize function in the mapper</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;intf_lib                  | The name of the library file (commonly a .so file) that implements the Initialize function.&lt;br&gt;Comment out the intf_lib name and link in the .c file to the openavb_tl executable to embed the interface directly into the executable unit.&lt;br&gt;There is no need to change anything else. The Initialize function will still be dynamically linked in</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;intf_fn                   | The name of the initialize function in the interface</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;&lt;br&gt;</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;Example Interface / Mapping Combinations {#sdk_avtp_stream_cfg_combinations}</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;========================================</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;Below are a few interface / mapping module combinations. Notice that a single </div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;interface module may work with mutliple mapping modules. Additionally some </div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;mappings may work with multiple interface modules. </div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;interface module            | mapping module        | description</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;----------------------------|-----------------------|------------</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;[echo](@ref echo_host_intf) |[pipe](@ref pipe_map)  |Demonstration interface used mostly for verification and testing purposes.</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;[alsa](@ref alsa_intf)      |[uncmp_audio](@ref uncmp_audio_map)|Audio interface created for demonstration on Linux. Can be used to play captured (line in, mic) audio stream via EAVB</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;[alsa](@ref alsa_intf)      |[aaf_audio](@ref aaf_audio_map)|Audio interface created for demonstration on Linux. Can be used to play captured (line in, mic) audio stream via EAVB</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;[wav_file](@ref wav_file_intf)|[uncmp_audio](@ref uncmp_audio_map)|Configuration for playing wave file via EAVB</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;&lt;br&gt;</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;Interface and Mapping Module Configuration {#sdk_avtp_stream_cfg_intf_map}</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;==========================================</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;Each interface module and mapping module has unique configuration values. </div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;Details of these configuration values can be found in the reference pages for </div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;each module. </div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;- Reference: AVTP Mapping Modules </div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;   - [1722 AAF (aaf_audio)](@ref aaf_audio_map)</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;   - [Control (ctrl)](@ref ctrl_map)</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;   - [Motion JPEG (mjpeg)](@ref mjpeg_map)</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;   - [MPEG2 TS (mpeg2ts)](@ref mpeg2ts_map)</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;   - [NULL (null)](@ref null_map)</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;   - [PIPE (pipe)](@ref pipe_map)</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;   - [61883-6 (uncmp_audio)](@ref uncmp_audio_map)</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;- Reference: AVTP Interface Module</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;   - [Control (ctrl)](@ref ctrl_intf)</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;   - [Echo (echo)](@ref echo_host_intf)</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;   - [Null (null)](@ref null_host_intf)</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;   - [Viewer (viewer)](@ref viewer_intf)</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;- Reference: AVTP Interface Module Linux Specific</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;   - [ALSA (alsa)](@ref alsa_intf)</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;   - [MJPEG GST (mjpeg_gstreamer)](@ref mjpeg_gst_intf)</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;   - [MPEG2 TS File (mpeg2ts_file)](@ref mpeg2ts_file_intf)</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;   - [MPEG2 TS GST (mpeg2ts_gstreamer)](@ref mpeg2ts_gst_intf)</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;   - [WAV File (wav_file)](@ref wav_file_intf)</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;</div></div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="sdk__avtp__stream__cfg_8md.html">sdk_avtp_stream_cfg.md</a></li>
    <li class="footer">다음에 의해 생성됨 : 
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
