<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Open-AVB AVTP Pipeline SDK: openavb_intf_pub.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="stc_logo_small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Open-AVB AVTP Pipeline SDK
   &#160;<span id="projectnumber">1.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Table&#160;of&#160;Contents</span></a></li>
      <li><a href="pages.html"><span>Topics</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<div class="title">openavb_intf_pub.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Common interface module public header.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;openavb_types_pub.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="openavb__mediaq__pub_8h_source.html">openavb_mediaq_pub.h</a>&quot;</code><br/>
</div>
<p><a href="openavb__intf__pub_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenavb__intf__cb__t.html">openavb_intf_cb_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface callbacks structure.  <a href="structopenavb__intf__cb__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ac68057221db3cde0c05117265aa4b669"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openavb__intf__pub_8h.html#ac68057221db3cde0c05117265aa4b669">openavb_intf_cfg_cb_t</a> )(<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ, const char *name, const char *value)</td></tr>
<tr class="memdesc:ac68057221db3cde0c05117265aa4b669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration callback into the interface module.  <a href="#ac68057221db3cde0c05117265aa4b669">More...</a><br/></td></tr>
<tr class="separator:ac68057221db3cde0c05117265aa4b669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af29488fb569dcc9085fb7c188318a557"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openavb__intf__pub_8h.html#af29488fb569dcc9085fb7c188318a557">openavb_intf_gen_init_cb_t</a> )(<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ)</td></tr>
<tr class="memdesc:af29488fb569dcc9085fb7c188318a557"><td class="mdescLeft">&#160;</td><td class="mdescRight">General initialize callback regardless if a talker or listener.  <a href="#af29488fb569dcc9085fb7c188318a557">More...</a><br/></td></tr>
<tr class="separator:af29488fb569dcc9085fb7c188318a557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4f0ffc9c0b2086c7838d0572423796"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openavb__intf__pub_8h.html#a7d4f0ffc9c0b2086c7838d0572423796">openavb_intf_avdecc_init_cb_t</a> )(<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ, <a class="el" href="openavb__types__base__pub_8h.html#a0a0a322d5fa4a546d293a77ba8b4a71f">U16</a> configIdx, <a class="el" href="openavb__types__base__pub_8h.html#a0a0a322d5fa4a546d293a77ba8b4a71f">U16</a> descriptorType, <a class="el" href="openavb__types__base__pub_8h.html#a0a0a322d5fa4a546d293a77ba8b4a71f">U16</a> descriptorIdx)</td></tr>
<tr class="memdesc:a7d4f0ffc9c0b2086c7838d0572423796"><td class="mdescLeft">&#160;</td><td class="mdescRight">AVDECC initialize callback for both a talker or listener.  <a href="#a7d4f0ffc9c0b2086c7838d0572423796">More...</a><br/></td></tr>
<tr class="separator:a7d4f0ffc9c0b2086c7838d0572423796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7115751b033b120c8a01b67450284b0b"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openavb__intf__pub_8h.html#a7115751b033b120c8a01b67450284b0b">openavb_intf_tx_init_cb_t</a> )(<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ)</td></tr>
<tr class="memdesc:a7115751b033b120c8a01b67450284b0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize transmit callback into the interface module.  <a href="#a7115751b033b120c8a01b67450284b0b">More...</a><br/></td></tr>
<tr class="separator:a7115751b033b120c8a01b67450284b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d9f29d7a240a53d562a519d9c9651d"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openavb__intf__pub_8h.html#a59d9f29d7a240a53d562a519d9c9651d">openavb_intf_tx_cb_t</a> )(<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ)</td></tr>
<tr class="memdesc:a59d9f29d7a240a53d562a519d9c9651d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit callback into the interface module.  <a href="#a59d9f29d7a240a53d562a519d9c9651d">More...</a><br/></td></tr>
<tr class="separator:a59d9f29d7a240a53d562a519d9c9651d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a8c777c7b7e27a8ce390ed1dba1cba3"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openavb__intf__pub_8h.html#a3a8c777c7b7e27a8ce390ed1dba1cba3">openavb_intf_rx_init_cb_t</a> )(<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ)</td></tr>
<tr class="memdesc:a3a8c777c7b7e27a8ce390ed1dba1cba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the receive callback into the interface module.  <a href="#a3a8c777c7b7e27a8ce390ed1dba1cba3">More...</a><br/></td></tr>
<tr class="separator:a3a8c777c7b7e27a8ce390ed1dba1cba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af15872adb66afc1673d19a35b8c6439a"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openavb__intf__pub_8h.html#af15872adb66afc1673d19a35b8c6439a">openavb_intf_rx_translate_cb_t</a> )(<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ, <a class="el" href="openavb__types__base__pub_8h.html#aa63ef7b996d5487ce35a5a66601f3e73">U8</a> *pPubData, <a class="el" href="openavb__types__base__pub_8h.html#a696390429f2f3b644bde8d0322a24124">U32</a> length)</td></tr>
<tr class="memdesc:af15872adb66afc1673d19a35b8c6439a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate RX data callback.  <a href="#af15872adb66afc1673d19a35b8c6439a">More...</a><br/></td></tr>
<tr class="separator:af15872adb66afc1673d19a35b8c6439a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c671f91d3113d7fa7ebe9c0d86654c2"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openavb__intf__pub_8h.html#a9c671f91d3113d7fa7ebe9c0d86654c2">openavb_intf_rx_cb_t</a> )(<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ)</td></tr>
<tr class="memdesc:a9c671f91d3113d7fa7ebe9c0d86654c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive callback into the interface module.  <a href="#a9c671f91d3113d7fa7ebe9c0d86654c2">More...</a><br/></td></tr>
<tr class="separator:a9c671f91d3113d7fa7ebe9c0d86654c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b69d51b5132ecef73dde5cc08d4e510"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openavb__intf__pub_8h.html#a9b69d51b5132ecef73dde5cc08d4e510">openavb_intf_end_cb_t</a> )(<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ)</td></tr>
<tr class="memdesc:a9b69d51b5132ecef73dde5cc08d4e510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback when the stream is ending.  <a href="#a9b69d51b5132ecef73dde5cc08d4e510">More...</a><br/></td></tr>
<tr class="separator:a9b69d51b5132ecef73dde5cc08d4e510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d2ab1f39e58099db52d976cb037908"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openavb__intf__pub_8h.html#a57d2ab1f39e58099db52d976cb037908">openavb_intf_gen_end_cb_t</a> )(<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ)</td></tr>
<tr class="memdesc:a57d2ab1f39e58099db52d976cb037908"><td class="mdescLeft">&#160;</td><td class="mdescRight">General shutdown callback into the interface module.  <a href="#a57d2ab1f39e58099db52d976cb037908">More...</a><br/></td></tr>
<tr class="separator:a57d2ab1f39e58099db52d976cb037908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67733ef9a1ae5729c6d4e0bd21c4903f"><td class="memItemLeft" align="right" valign="top">typedef unsigned int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openavb__intf__pub_8h.html#a67733ef9a1ae5729c6d4e0bd21c4903f">openavb_intf_get_src_bitrate_t</a> )(<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ)</td></tr>
<tr class="memdesc:a67733ef9a1ae5729c6d4e0bd21c4903f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the interface for source bitrate.  <a href="#a67733ef9a1ae5729c6d4e0bd21c4903f">More...</a><br/></td></tr>
<tr class="separator:a67733ef9a1ae5729c6d4e0bd21c4903f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b00afa0b3433e570fd0a282efdb54b"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openavb__intf__pub_8h.html#a44b00afa0b3433e570fd0a282efdb54b">openavb_intf_initialize_fn_t</a> )(<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ, <a class="el" href="structopenavb__intf__cb__t.html">openavb_intf_cb_t</a> *pIntfCB)</td></tr>
<tr class="memdesc:a44b00afa0b3433e570fd0a282efdb54b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main initialization entry point into the interface module.  <a href="#a44b00afa0b3433e570fd0a282efdb54b">More...</a><br/></td></tr>
<tr class="separator:a44b00afa0b3433e570fd0a282efdb54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Common interface module public header. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ac68057221db3cde0c05117265aa4b669"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* openavb_intf_cfg_cb_t)(<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ, const char *name, const char *value)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configuration callback into the interface module. </p>
<p>This callback function is called during the reading of the configuration file by the talker and listener for any named configuration item starting with "intf_nv". This is a convenient way to store new configuration name/value pairs that are needed in an interface module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMediaQ</td><td>A pointer to the media queue for this stream </td></tr>
    <tr><td class="paramname">name</td><td>The item name from the configuration file </td></tr>
    <tr><td class="paramname">value</td><td>The item value from the configuration file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af29488fb569dcc9085fb7c188318a557"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* openavb_intf_gen_init_cb_t)(<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>General initialize callback regardless if a talker or listener. </p>
<p>This callback function is called when the <a class="el" href="openavb__tl__pub_8h.html#a4952af6d10075781ffb320af2ff1665b" title="Open a talker or listener. ">openavbTLOpen()</a> function is called for the EAVB SDK API.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMediaQ</td><td>A pointer to the media queue for this stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7d4f0ffc9c0b2086c7838d0572423796"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* openavb_intf_avdecc_init_cb_t)(<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ, <a class="el" href="openavb__types__base__pub_8h.html#a0a0a322d5fa4a546d293a77ba8b4a71f">U16</a> configIdx, <a class="el" href="openavb__types__base__pub_8h.html#a0a0a322d5fa4a546d293a77ba8b4a71f">U16</a> descriptorType, <a class="el" href="openavb__types__base__pub_8h.html#a0a0a322d5fa4a546d293a77ba8b4a71f">U16</a> descriptorIdx)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AVDECC initialize callback for both a talker or listener. </p>
<p>Entity model based configuration can be processed at this time. This callback is optional and only executed when AVDECC is used to connect streams.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMediaQ</td><td>A pointer to the media queue for this stream </td></tr>
    <tr><td class="paramname">configIdx</td><td>current configuration descriptor index for the Entity Model </td></tr>
    <tr><td class="paramname">descriptorType</td><td>The descriptorType is expected to be of STREAM_INPUT for listeners and STREAM_OUTPUT for talkers. </td></tr>
    <tr><td class="paramname">descriptorIdx</td><td>descriptor index in the Entity Model </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7115751b033b120c8a01b67450284b0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* openavb_intf_tx_init_cb_t)(<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize transmit callback into the interface module. </p>
<p>This callback function is called anytime a stream reservation has completed successfully within a talker process. It does not get called when running within a listener process.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMediaQ</td><td>A pointer to the media queue for this stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a59d9f29d7a240a53d562a519d9c9651d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* openavb_intf_tx_cb_t)(<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmit callback into the interface module. </p>
<p>This is the transmit callback function for the interface module. This function will typically be called thousands of times per second depending the SR class type (A or B). This frequency may also be changed by the mapping module and at times configurable by mapping modules for example with the map_nv_tx_rate configuration value. If pacing is done in the interface module by: </p>
<pre class="fragment">cfg-&gt;tx_blocking_in_intf = FALSE;
</pre><p>Then this callback will suspend task execution until there is media data available for the mapping module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMediaQ</td><td>A pointer to the media queue for this stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3a8c777c7b7e27a8ce390ed1dba1cba3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* openavb_intf_rx_init_cb_t)(<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the receive callback into the interface module. </p>
<p>This callback function is called anytime a stream reservation has completed successfully within a listener process. It does not get called when running within a talker process.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMediaQ</td><td>A pointer to the media queue for this stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af15872adb66afc1673d19a35b8c6439a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* openavb_intf_rx_translate_cb_t)(<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ, <a class="el" href="openavb__types__base__pub_8h.html#aa63ef7b996d5487ce35a5a66601f3e73">U8</a> *pPubData, <a class="el" href="openavb__types__base__pub_8h.html#a696390429f2f3b644bde8d0322a24124">U32</a> length)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translate RX data callback. </p>
<p>This callback that may be used by mapping modules to allow interfaces to translate packet data as it arrives and before it gets packed into the media queue Item. Mapping modules MUST expose a function pointer var in their public data and the interface module must set it for the CB to be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMediaQ</td><td>A pointer to the media queue for this stream </td></tr>
    <tr><td class="paramname">pPubDataQ</td><td>A pointer to the data </td></tr>
    <tr><td class="paramname">length</td><td>Length of the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9c671f91d3113d7fa7ebe9c0d86654c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* openavb_intf_rx_cb_t)(<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive callback into the interface module. </p>
<p>This callback function is called when AVB packet data is received or when tail data item within the media queue has reached the presentation time</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMediaQ</td><td>A pointer to the media queue for this stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9b69d51b5132ecef73dde5cc08d4e510"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* openavb_intf_end_cb_t)(<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback when the stream is ending. </p>
<p>This callback function is called when a stream is closing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMediaQ</td><td>A pointer to the media queue for this stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a57d2ab1f39e58099db52d976cb037908"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* openavb_intf_gen_end_cb_t)(<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>General shutdown callback into the interface module. </p>
<p>This callback function is called when the <a class="el" href="openavb__tl__pub_8h.html#ae373dc0cd3617f44e3205bbc2f6d84f4" title="Close the talker or listener. ">openavbTLClose()</a> function is called for the EAVB SDK API</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMediaQ</td><td>A pointer to the media queue for this stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a67733ef9a1ae5729c6d4e0bd21c4903f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned int(* openavb_intf_get_src_bitrate_t)(<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the interface for source bitrate. </p>
<p>This callback is called to get the maximum bitrate of the source (in bits per second). For example for a mpeg2ts file interface this callback returns the maximum bitrate of the mpeg2ts file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMediaQ</td><td>A pointer to the media queue for this stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum bitrate of the source.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This callback is optional, does not need to be implemented in the interface module. </dd></dl>

</div>
</div>
<a class="anchor" id="a44b00afa0b3433e570fd0a282efdb54b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* openavb_intf_initialize_fn_t)(<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ, <a class="el" href="structopenavb__intf__cb__t.html">openavb_intf_cb_t</a> *pIntfCB)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main initialization entry point into the interface module. </p>
<p>This is the main entry point into the interface module. Every interface module must define this function. The talker process and listener process call this function directly while the configuration file it being read. The function address is discovered via the settings in the talker and listener configuration structure. For example: </p>
<pre class="fragment">osalCfg.pIntfInitFn = openavbIntfJ6Video;
</pre><p>Within this function the callbacks must all be set into the structure pointer parameter. Any interface module initialization can take place during this call such as setting default values into configuration settings. Private interface module should be allocated during this call. This can be used to hold configuration data as well as functional variable data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMediaQ</td><td>A pointer to the media queue for this stream </td></tr>
    <tr><td class="paramname">pIntfCB</td><td>Pointer to the callback structure. All the members of this structure must be set during this function call </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success or FALSE on failure </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Oct 30 2015 08:29:35 for Open-AVB AVTP Pipeline SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
