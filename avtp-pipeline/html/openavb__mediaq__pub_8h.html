<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Open-AVB AVTP Pipeline SDK: openavb_mediaq_pub.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="harman_logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Open-AVB AVTP Pipeline SDK
   &#160;<span id="projectnumber">1.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Table&#160;of&#160;Contents</span></a></li>
      <li><a href="pages.html"><span>Topics</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_b3958ddc7107bed6177f21619809a478.html">mediaq</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">openavb_mediaq_pub.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Media Queue.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;openavb_types_pub.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="openavb__avtp__time__pub_8h_source.html">openavb_avtp_time_pub.h</a>&quot;</code><br/>
</div>
<p><a href="openavb__mediaq__pub_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmedia__q__item__t.html">media_q_item_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Media Queue Item structure.  <a href="structmedia__q__item__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmedia__q__t.html">media_q_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Media Queue structure.  <a href="structmedia__q__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad9ac4896a82092d93fb4c21289497194"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmedia__q__t.html">media_q_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openavb__mediaq__pub_8h.html#ad9ac4896a82092d93fb4c21289497194">openavbMediaQCreate</a> ()</td></tr>
<tr class="memdesc:ad9ac4896a82092d93fb4c21289497194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a media queue.  <a href="#ad9ac4896a82092d93fb4c21289497194">More...</a><br/></td></tr>
<tr class="separator:ad9ac4896a82092d93fb4c21289497194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa052ae332aa31243056b46124bc9df71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openavb__mediaq__pub_8h.html#aa052ae332aa31243056b46124bc9df71">openavbMediaQThreadSafeOn</a> (<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ)</td></tr>
<tr class="memdesc:aa052ae332aa31243056b46124bc9df71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable thread safe access for this media queue.  <a href="#aa052ae332aa31243056b46124bc9df71">More...</a><br/></td></tr>
<tr class="separator:aa052ae332aa31243056b46124bc9df71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a392a15d51328fab65d754685450834de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openavb__mediaq__pub_8h.html#a392a15d51328fab65d754685450834de">openavbMediaQSetSize</a> (<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ, int itemCount, int itemSize)</td></tr>
<tr class="memdesc:a392a15d51328fab65d754685450834de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set size of media queue.  <a href="#a392a15d51328fab65d754685450834de">More...</a><br/></td></tr>
<tr class="separator:a392a15d51328fab65d754685450834de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc14a2759175d30dbf0663f937fe592"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openavb__mediaq__pub_8h.html#a3bc14a2759175d30dbf0663f937fe592">openavbMediaQAllocItemMapData</a> (<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ, int itemPubMapSize, int itemPvtMapSize)</td></tr>
<tr class="memdesc:a3bc14a2759175d30dbf0663f937fe592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alloc item map data.  <a href="#a3bc14a2759175d30dbf0663f937fe592">More...</a><br/></td></tr>
<tr class="separator:a3bc14a2759175d30dbf0663f937fe592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84c8ba28a68daf207204faa18e718110"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openavb__mediaq__pub_8h.html#a84c8ba28a68daf207204faa18e718110">openavbMediaQAllocItemIntfData</a> (<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ, int itemIntfSize)</td></tr>
<tr class="memdesc:a84c8ba28a68daf207204faa18e718110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alloc item interface data.  <a href="#a84c8ba28a68daf207204faa18e718110">More...</a><br/></td></tr>
<tr class="separator:a84c8ba28a68daf207204faa18e718110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adddaa9656fd7fcca39d54a3fdb8dc3a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openavb__mediaq__pub_8h.html#adddaa9656fd7fcca39d54a3fdb8dc3a9">openavbMediaQDelete</a> (<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ)</td></tr>
<tr class="memdesc:adddaa9656fd7fcca39d54a3fdb8dc3a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the queue.  <a href="#adddaa9656fd7fcca39d54a3fdb8dc3a9">More...</a><br/></td></tr>
<tr class="separator:adddaa9656fd7fcca39d54a3fdb8dc3a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb76a6274ad6626ee51a50174d7b9389"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openavb__mediaq__pub_8h.html#afb76a6274ad6626ee51a50174d7b9389">openavbMediaQSetMaxLatency</a> (<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ, <a class="el" href="openavb__types__base__pub_8h.html#a696390429f2f3b644bde8d0322a24124">U32</a> maxLatencyUsec)</td></tr>
<tr class="memdesc:afb76a6274ad6626ee51a50174d7b9389"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum latency expected.  <a href="#afb76a6274ad6626ee51a50174d7b9389">More...</a><br/></td></tr>
<tr class="separator:afb76a6274ad6626ee51a50174d7b9389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb41c6d762035f1d5e74c91b5ed44f06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openavb__mediaq__pub_8h.html#abb41c6d762035f1d5e74c91b5ed44f06">openavbMediaQSetMaxStaleTail</a> (<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ, <a class="el" href="openavb__types__base__pub_8h.html#a696390429f2f3b644bde8d0322a24124">U32</a> maxStaleTailUsec)</td></tr>
<tr class="memdesc:abb41c6d762035f1d5e74c91b5ed44f06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum stale tail.  <a href="#abb41c6d762035f1d5e74c91b5ed44f06">More...</a><br/></td></tr>
<tr class="separator:abb41c6d762035f1d5e74c91b5ed44f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ce807451447ec2dab9a4284ac61b99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmedia__q__item__t.html">media_q_item_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openavb__mediaq__pub_8h.html#ae2ce807451447ec2dab9a4284ac61b99">openavbMediaQHeadLock</a> (<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ)</td></tr>
<tr class="memdesc:ae2ce807451447ec2dab9a4284ac61b99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to the head item and lock it.  <a href="#ae2ce807451447ec2dab9a4284ac61b99">More...</a><br/></td></tr>
<tr class="separator:ae2ce807451447ec2dab9a4284ac61b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73b08d1568f13b634e2a0f1ef35e11a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openavb__mediaq__pub_8h.html#ac73b08d1568f13b634e2a0f1ef35e11a">openavbMediaQHeadUnlock</a> (<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ)</td></tr>
<tr class="memdesc:ac73b08d1568f13b634e2a0f1ef35e11a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the head item.  <a href="#ac73b08d1568f13b634e2a0f1ef35e11a">More...</a><br/></td></tr>
<tr class="separator:ac73b08d1568f13b634e2a0f1ef35e11a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a57c275ac213fdd14c944741c6e9250"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openavb__mediaq__pub_8h.html#a0a57c275ac213fdd14c944741c6e9250">openavbMediaQHeadPush</a> (<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ)</td></tr>
<tr class="memdesc:a0a57c275ac213fdd14c944741c6e9250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the head item and make it available.  <a href="#a0a57c275ac213fdd14c944741c6e9250">More...</a><br/></td></tr>
<tr class="separator:a0a57c275ac213fdd14c944741c6e9250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa1645c7e234bd011a70063d368b995"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmedia__q__item__t.html">media_q_item_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openavb__mediaq__pub_8h.html#aafa1645c7e234bd011a70063d368b995">openavbMediaQTailLock</a> (<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ, bool ignoreTimestamp)</td></tr>
<tr class="memdesc:aafa1645c7e234bd011a70063d368b995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to the tail item and lock it.  <a href="#aafa1645c7e234bd011a70063d368b995">More...</a><br/></td></tr>
<tr class="separator:aafa1645c7e234bd011a70063d368b995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b57c7a2cfb99521a7e460bd29b3b31a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openavb__mediaq__pub_8h.html#a9b57c7a2cfb99521a7e460bd29b3b31a">openavbMediaQTailUnlock</a> (<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ)</td></tr>
<tr class="memdesc:a9b57c7a2cfb99521a7e460bd29b3b31a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the tail item without removing it from the queue.  <a href="#a9b57c7a2cfb99521a7e460bd29b3b31a">More...</a><br/></td></tr>
<tr class="separator:a9b57c7a2cfb99521a7e460bd29b3b31a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0525761a2b45c4c14d4fdc80fa24c47"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openavb__mediaq__pub_8h.html#ab0525761a2b45c4c14d4fdc80fa24c47">openavbMediaQTailPull</a> (<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ)</td></tr>
<tr class="memdesc:ab0525761a2b45c4c14d4fdc80fa24c47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the tail item and remove it from the queue.  <a href="#ab0525761a2b45c4c14d4fdc80fa24c47">More...</a><br/></td></tr>
<tr class="separator:ab0525761a2b45c4c14d4fdc80fa24c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cba0078992041670a37d66dddb86072"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openavb__mediaq__pub_8h.html#a1cba0078992041670a37d66dddb86072">openavbMediaQTailItemTake</a> (<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ, <a class="el" href="structmedia__q__item__t.html">media_q_item_t</a> *pItem)</td></tr>
<tr class="memdesc:a1cba0078992041670a37d66dddb86072"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take ownership from the MediaQ of an item.  <a href="#a1cba0078992041670a37d66dddb86072">More...</a><br/></td></tr>
<tr class="separator:a1cba0078992041670a37d66dddb86072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81c13779e33c66b49ebe60e7565b1b2f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openavb__mediaq__pub_8h.html#a81c13779e33c66b49ebe60e7565b1b2f">openavbMediaQTailItemGive</a> (<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ, <a class="el" href="structmedia__q__item__t.html">media_q_item_t</a> *pItem)</td></tr>
<tr class="memdesc:a81c13779e33c66b49ebe60e7565b1b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give itme ownership back to the MediaQ.  <a href="#a81c13779e33c66b49ebe60e7565b1b2f">More...</a><br/></td></tr>
<tr class="separator:a81c13779e33c66b49ebe60e7565b1b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af040d551f94e83aaba3e3a7e105f6c41"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openavb__mediaq__pub_8h.html#af040d551f94e83aaba3e3a7e105f6c41">openavbMediaQUsecTillTail</a> (<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ, <a class="el" href="openavb__types__base__pub_8h.html#a696390429f2f3b644bde8d0322a24124">U32</a> *pUsecTill)</td></tr>
<tr class="memdesc:af040d551f94e83aaba3e3a7e105f6c41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get microseconds until tail is ready.  <a href="#af040d551f94e83aaba3e3a7e105f6c41">More...</a><br/></td></tr>
<tr class="separator:af040d551f94e83aaba3e3a7e105f6c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d02726069afc037940ef87f5893dfc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openavb__mediaq__pub_8h.html#ac1d02726069afc037940ef87f5893dfc">openavbMediaQIsAvailableBytes</a> (<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ, <a class="el" href="openavb__types__base__pub_8h.html#a696390429f2f3b644bde8d0322a24124">U32</a> bytes, bool ignoreTimestamp)</td></tr>
<tr class="memdesc:ac1d02726069afc037940ef87f5893dfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the number of bytes are available.  <a href="#ac1d02726069afc037940ef87f5893dfc">More...</a><br/></td></tr>
<tr class="separator:ac1d02726069afc037940ef87f5893dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c8943c2131c80107c137f5872effbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="openavb__types__base__pub_8h.html#a696390429f2f3b644bde8d0322a24124">U32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openavb__mediaq__pub_8h.html#aa3c8943c2131c80107c137f5872effbc">openavbMediaQCountItems</a> (<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ, bool ignoreTimestamp)</td></tr>
<tr class="memdesc:aa3c8943c2131c80107c137f5872effbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count number of available MediaQ items.  <a href="#aa3c8943c2131c80107c137f5872effbc">More...</a><br/></td></tr>
<tr class="separator:aa3c8943c2131c80107c137f5872effbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf06897fdf74f6607d1a24e474eae3c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openavb__mediaq__pub_8h.html#acbf06897fdf74f6607d1a24e474eae3c">openavbMediaQAnyReadyItems</a> (<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ, bool ignoreTimestamp)</td></tr>
<tr class="memdesc:acbf06897fdf74f6607d1a24e474eae3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if there are any ready MediaQ items.  <a href="#acbf06897fdf74f6607d1a24e474eae3c">More...</a><br/></td></tr>
<tr class="separator:acbf06897fdf74f6607d1a24e474eae3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Media Queue. </p>
<p>Circular queue for passing data between interfaces and mappers. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ad9ac4896a82092d93fb4c21289497194"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmedia__q__t.html">media_q_t</a>* openavbMediaQCreate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a media queue. </p>
<p>Allocate a media queue structure. Only mapping modules will use this call.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a media queue structure. NULL if the creation fails </dd></dl>

</div>
</div>
<a class="anchor" id="aa052ae332aa31243056b46124bc9df71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void openavbMediaQThreadSafeOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmedia__q__t.html">media_q_t</a> *&#160;</td>
          <td class="paramname"><em>pMediaQ</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable thread safe access for this media queue. </p>
<p>In the default case a media queue is only accessed from a single thread and therefore multi-threaded synchronication isn't needed. In situations where a media queue can be accessed from multiple threads calling this function will enable mutex protection on the head and tail related functions. Once enabled for a media queue it can not be disabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMediaQ</td><td>A pointer to the <a class="el" href="structmedia__q__t.html" title="Media Queue structure. ">media_q_t</a> structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a392a15d51328fab65d754685450834de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool openavbMediaQSetSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmedia__q__t.html">media_q_t</a> *&#160;</td>
          <td class="paramname"><em>pMediaQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>itemCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>itemSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set size of media queue. </p>
<p>Pre-allocate all the items for the media queue. Once allocated the item storage will be reused as items are added and removed from the queue. Only mapping modules will use this call. This must be called before using the MediaQ.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMediaQ</td><td>A pointer to the <a class="el" href="structmedia__q__t.html" title="Media Queue structure. ">media_q_t</a> structure </td></tr>
    <tr><td class="paramname">itemCount</td><td>Maximum number of items that the queue will hold. These are pre-allocated </td></tr>
    <tr><td class="paramname">itemSize</td><td>The pre-allocated size of a media queue item </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success or FALSE on failure</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This must be called before using the MediaQ </dd></dl>

</div>
</div>
<a class="anchor" id="a3bc14a2759175d30dbf0663f937fe592"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool openavbMediaQAllocItemMapData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmedia__q__t.html">media_q_t</a> *&#160;</td>
          <td class="paramname"><em>pMediaQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>itemPubMapSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>itemPvtMapSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alloc item map data. </p>
<p>Items in the media queue may also have per-item data that is managed by the mapping modules. This function allows mapping modules to specify this storage. Only mapping modules will use this call. This must be called before using the media queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMediaQ</td><td>A pointer to the <a class="el" href="structmedia__q__t.html" title="Media Queue structure. ">media_q_t</a> structure </td></tr>
    <tr><td class="paramname">itemPubMapSize</td><td>The size of the public (shared) per-items data that will be allocated. Typically this is the size of a structure that is declared in a public header file associated with the mapping module. </td></tr>
    <tr><td class="paramname">itemPvtMapSize</td><td>The size of the private per-items data that will be allocated. The structure of this area will not be shared outside of the mapping module </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success or FALSE on failure</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This must be called before using the MediaQ </dd></dl>

</div>
</div>
<a class="anchor" id="a84c8ba28a68daf207204faa18e718110"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool openavbMediaQAllocItemIntfData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmedia__q__t.html">media_q_t</a> *&#160;</td>
          <td class="paramname"><em>pMediaQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>itemIntfSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alloc item interface data. </p>
<p>Items in the media queue may also have per-item data that is managed by the interface modules. This function allows interface modules to specify this storage. This must be called before using the media queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMediaQ</td><td>A pointer to the <a class="el" href="structmedia__q__t.html" title="Media Queue structure. ">media_q_t</a> structure </td></tr>
    <tr><td class="paramname">itemIntfSize</td><td>The size of the per-items data to allocate for use by the interface module </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success or FALSE on failure</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This must be called before using the MediaQ </dd></dl>

</div>
</div>
<a class="anchor" id="adddaa9656fd7fcca39d54a3fdb8dc3a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool openavbMediaQDelete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmedia__q__t.html">media_q_t</a> *&#160;</td>
          <td class="paramname"><em>pMediaQ</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy the queue. </p>
<p>The media queue passed in will be deleted. This includes all allocated memory both for mapping modules and interface modules. Only mapping modules will use this call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMediaQ</td><td>A pointer to the <a class="el" href="structmedia__q__t.html" title="Media Queue structure. ">media_q_t</a> structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success or FALSE on failure </dd></dl>

</div>
</div>
<a class="anchor" id="afb76a6274ad6626ee51a50174d7b9389"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void openavbMediaQSetMaxLatency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmedia__q__t.html">media_q_t</a> *&#160;</td>
          <td class="paramname"><em>pMediaQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="openavb__types__base__pub_8h.html#a696390429f2f3b644bde8d0322a24124">U32</a>&#160;</td>
          <td class="paramname"><em>maxLatencyUsec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the maximum latency expected. </p>
<p>The maximum latency will be set. This value is used by the media queue to help determine if a media queue item is ready to be released to the listener interface module for presentation. Typically the mapping module will call this function with a max latency value derived from the max_latency configuration value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMediaQ</td><td>A pointer to the <a class="el" href="structmedia__q__t.html" title="Media Queue structure. ">media_q_t</a> structure </td></tr>
    <tr><td class="paramname">maxLatencyUsec</td><td>The maximum latency. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abb41c6d762035f1d5e74c91b5ed44f06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void openavbMediaQSetMaxStaleTail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmedia__q__t.html">media_q_t</a> *&#160;</td>
          <td class="paramname"><em>pMediaQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="openavb__types__base__pub_8h.html#a696390429f2f3b644bde8d0322a24124">U32</a>&#160;</td>
          <td class="paramname"><em>maxStaleTailUsec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the maximum stale tail. </p>
<p>Used to purge media queue items that are too old.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMediaQ</td><td>A pointer to the <a class="el" href="structmedia__q__t.html" title="Media Queue structure. ">media_q_t</a> structure </td></tr>
    <tr><td class="paramname">maxStaleTailUsec</td><td>tail element purge threshold in microseconds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae2ce807451447ec2dab9a4284ac61b99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmedia__q__item__t.html">media_q_item_t</a>* openavbMediaQHeadLock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmedia__q__t.html">media_q_t</a> *&#160;</td>
          <td class="paramname"><em>pMediaQ</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get pointer to the head item and lock it. </p>
<p>Get the storage location for the next item that can be added to the circle queue. Once the function is called the item will remained locked until unlocked or pushed. The lock remains valid across callbacks. An interface module will use this function when running as a talker to add a new media element to the queue thereby making it available to the mapping module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMediaQ</td><td>A pointer to the <a class="el" href="structmedia__q__t.html" title="Media Queue structure. ">media_q_t</a> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a media queue item. Returns NULL if head item storage isn't available. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="openavb_intf_echo_8c-example.html#a4">openavb_intf_echo.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ac73b08d1568f13b634e2a0f1ef35e11a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void openavbMediaQHeadUnlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmedia__q__t.html">media_q_t</a> *&#160;</td>
          <td class="paramname"><em>pMediaQ</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlock the head item. </p>
<p>Unlock a locked media queue item from the head of the queue. The item will not become available for use in the queue and the data will not be cleared. Subsequent calls to openavbMediaQHeadLock will return the same item storage with the same data values. An interface module will use this function when running as a talker when it must release a previously locked media queue head item.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMediaQ</td><td>A pointer to the <a class="el" href="structmedia__q__t.html" title="Media Queue structure. ">media_q_t</a> structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0a57c275ac213fdd14c944741c6e9250"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool openavbMediaQHeadPush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmedia__q__t.html">media_q_t</a> *&#160;</td>
          <td class="paramname"><em>pMediaQ</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlock the head item and make it available. </p>
<p>Unlock a locked media queue item from the head of the queue and make it available for use in the queue to be accessed with the tail function calls. An interface module will use this function when running as a talker after it has locked the head item and added data to the item storage area.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMediaQ</td><td>A pointer to the <a class="el" href="structmedia__q__t.html" title="Media Queue structure. ">media_q_t</a> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns TRUE on success or FALSE on failure. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="openavb_intf_echo_8c-example.html#a10">openavb_intf_echo.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="aafa1645c7e234bd011a70063d368b995"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmedia__q__item__t.html">media_q_item_t</a>* openavbMediaQTailLock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmedia__q__t.html">media_q_t</a> *&#160;</td>
          <td class="paramname"><em>pMediaQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreTimestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get pointer to the tail item and lock it. </p>
<p>Lock the next available tail item in the media queue. Available is based on the timestamp that is associated with the item when it was a placed into the media queue. The interface module running on a listener uses this function to access the data items place into the media queue by the mapping module. At some point after this function call the item must be unlocked with either openavbMediaQTailUnlockor openavbMediaQTailPull on the same callback or a subsequent callback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMediaQ</td><td>A pointer to the <a class="el" href="structmedia__q__t.html" title="Media Queue structure. ">media_q_t</a> structure. </td></tr>
    <tr><td class="paramname">ignoreTimestamp</td><td>If TRUE ignore the tail item timestamp making the tail item immediately available. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a media queue item. Returns NULL if a tail item isn't available. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="openavb_intf_echo_8c-example.html#a13">openavb_intf_echo.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a9b57c7a2cfb99521a7e460bd29b3b31a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void openavbMediaQTailUnlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmedia__q__t.html">media_q_t</a> *&#160;</td>
          <td class="paramname"><em>pMediaQ</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlock the tail item without removing it from the queue. </p>
<p>Unlock a media queue item that was previously locked with openavbMediaQTailLock. The item will not be removed from the tail of the media queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMediaQ</td><td>A pointer to the <a class="el" href="structmedia__q__t.html" title="Media Queue structure. ">media_q_t</a> structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab0525761a2b45c4c14d4fdc80fa24c47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool openavbMediaQTailPull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmedia__q__t.html">media_q_t</a> *&#160;</td>
          <td class="paramname"><em>pMediaQ</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlock the tail item and remove it from the queue. </p>
<p>Unlock a media queue item that was previously locked with openavbMediaQTailLock and remove it from the media queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMediaQ</td><td>A pointer to the <a class="el" href="structmedia__q__t.html" title="Media Queue structure. ">media_q_t</a> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns TRUE on success or FALSE on failure. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="openavb_intf_echo_8c-example.html#a14">openavb_intf_echo.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a1cba0078992041670a37d66dddb86072"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool openavbMediaQTailItemTake </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmedia__q__t.html">media_q_t</a> *&#160;</td>
          <td class="paramname"><em>pMediaQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmedia__q__item__t.html">media_q_item_t</a> *&#160;</td>
          <td class="paramname"><em>pItem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take ownership from the MediaQ of an item. </p>
<p>Take ownership from the MediaQ of an item previously locked with openavbMediaQTailLock. Will advance the tail. Used in place of <a class="el" href="openavb__mediaq__pub_8h.html#ab0525761a2b45c4c14d4fdc80fa24c47" title="Unlock the tail item and remove it from the queue. ">openavbMediaQTailPull()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMediaQ</td><td>A pointer to the <a class="el" href="structmedia__q__t.html" title="Media Queue structure. ">media_q_t</a> structure. </td></tr>
    <tr><td class="paramname">pItem</td><td>MediaQ item to take ownership of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns TRUE on success or FALSE on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a81c13779e33c66b49ebe60e7565b1b2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool openavbMediaQTailItemGive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmedia__q__t.html">media_q_t</a> *&#160;</td>
          <td class="paramname"><em>pMediaQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmedia__q__item__t.html">media_q_item_t</a> *&#160;</td>
          <td class="paramname"><em>pItem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Give itme ownership back to the MediaQ. </p>
<p>Give ownership back to the MediaQ of an item previously taken with <a class="el" href="openavb__mediaq__pub_8h.html#a1cba0078992041670a37d66dddb86072" title="Take ownership from the MediaQ of an item. ">openavbMediaQTailItemTake()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMediaQ</td><td>A pointer to the <a class="el" href="structmedia__q__t.html" title="Media Queue structure. ">media_q_t</a> structure. </td></tr>
    <tr><td class="paramname">pItem</td><td>MediaQ item to give back tot he MediaA. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns TRUE on success or FALSE on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="af040d551f94e83aaba3e3a7e105f6c41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool openavbMediaQUsecTillTail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmedia__q__t.html">media_q_t</a> *&#160;</td>
          <td class="paramname"><em>pMediaQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="openavb__types__base__pub_8h.html#a696390429f2f3b644bde8d0322a24124">U32</a> *&#160;</td>
          <td class="paramname"><em>pUsecTill</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get microseconds until tail is ready. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMediaQ</td><td>A pointer to the <a class="el" href="structmedia__q__t.html" title="Media Queue structure. ">media_q_t</a> structure. </td></tr>
    <tr><td class="paramname">pUsecTill</td><td>An output parameter that is set with the number of microseconds until the tail item will be available. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return FALSE if greater than 5 seconds otherwise TRUE. </dd></dl>

</div>
</div>
<a class="anchor" id="ac1d02726069afc037940ef87f5893dfc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool openavbMediaQIsAvailableBytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmedia__q__t.html">media_q_t</a> *&#160;</td>
          <td class="paramname"><em>pMediaQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="openavb__types__base__pub_8h.html#a696390429f2f3b644bde8d0322a24124">U32</a>&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreTimestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the number of bytes are available. </p>
<p>Checks were the given media queue contains bytes, returns true if it does false otherwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMediaQ</td><td>A pointer to the <a class="el" href="structmedia__q__t.html" title="Media Queue structure. ">media_q_t</a> structure. </td></tr>
    <tr><td class="paramname">bytes</td><td>Number of bytes expected in media queue </td></tr>
    <tr><td class="paramname">ignoreTimestamp</td><td>Ignore timestamp for byte accumulation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if bytes are available in pMediaQ; FALSE if bytes not available in pMediaQ. </dd></dl>

</div>
</div>
<a class="anchor" id="aa3c8943c2131c80107c137f5872effbc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="openavb__types__base__pub_8h.html#a696390429f2f3b644bde8d0322a24124">U32</a> openavbMediaQCountItems </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmedia__q__t.html">media_q_t</a> *&#160;</td>
          <td class="paramname"><em>pMediaQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreTimestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count number of available MediaQ items. </p>
<p>Count the number of available MediaQ items.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMediaQ</td><td>A pointer to the <a class="el" href="structmedia__q__t.html" title="Media Queue structure. ">media_q_t</a> structure. </td></tr>
    <tr><td class="paramname">ignoreTimestamp</td><td>Ignore timestamp for byte accumulation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of available MediaA items. </dd></dl>

</div>
</div>
<a class="anchor" id="acbf06897fdf74f6607d1a24e474eae3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool openavbMediaQAnyReadyItems </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmedia__q__t.html">media_q_t</a> *&#160;</td>
          <td class="paramname"><em>pMediaQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreTimestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if there are any ready MediaQ items. </p>
<p>Check if there are any ready MediaQ items.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMediaQ</td><td>A pointer to the <a class="el" href="structmedia__q__t.html" title="Media Queue structure. ">media_q_t</a> structure. </td></tr>
    <tr><td class="paramname">ignoreTimestamp</td><td>Ignore timestamp for checking </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if there is at least 1 MediaQ item available otherwise FALSE. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Oct 30 2015 08:29:35 for Open-AVB AVTP Pipeline SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
