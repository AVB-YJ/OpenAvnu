<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Open-AVB AVTP Pipeline SDK: openavb_map_pub.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="stc_logo_small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Open-AVB AVTP Pipeline SDK
   &#160;<span id="projectnumber">1.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Table&#160;of&#160;Contents</span></a></li>
      <li><a href="pages.html"><span>Topics</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">openavb_map_pub.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Common mapper module public interface.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;openavb_types_pub.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="openavb__mediaq__pub_8h_source.html">openavb_mediaq_pub.h</a>&quot;</code><br/>
</div>
<p><a href="openavb__map__pub_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenavb__map__cb__t.html">openavb_map_cb_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mapping callbacks structure.  <a href="structopenavb__map__cb__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a24182f6c44e8fe98db69924e21c9dd53"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24182f6c44e8fe98db69924e21c9dd53"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openavb__map__pub_8h.html#a24182f6c44e8fe98db69924e21c9dd53">MAP_NULL_OPENAVB_FORMAT</a>&#160;&#160;&#160;0x00</td></tr>
<tr class="memdesc:a24182f6c44e8fe98db69924e21c9dd53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vendor Specific format used in AVTP headers. <br/></td></tr>
<tr class="separator:a24182f6c44e8fe98db69924e21c9dd53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a179e3d454facb35ec8910b2e2428357e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a179e3d454facb35ec8910b2e2428357e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openavb__map__pub_8h.html#a179e3d454facb35ec8910b2e2428357e">MAP_PIPE_OPENAVB_FORMAT</a>&#160;&#160;&#160;0x01</td></tr>
<tr class="memdesc:a179e3d454facb35ec8910b2e2428357e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vendor Specific format used in AVTP headers. <br/></td></tr>
<tr class="separator:a179e3d454facb35ec8910b2e2428357e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bcbb040130c6a7b74855a7ee5b6cdf9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7bcbb040130c6a7b74855a7ee5b6cdf9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openavb__map__pub_8h.html#a7bcbb040130c6a7b74855a7ee5b6cdf9">MAP_CTRL_OPENAVB_FORMAT</a>&#160;&#160;&#160;0x00</td></tr>
<tr class="memdesc:a7bcbb040130c6a7b74855a7ee5b6cdf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vendor Specific CTRL format used in AVTP headers. <br/></td></tr>
<tr class="separator:a7bcbb040130c6a7b74855a7ee5b6cdf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aecd3b5a2f3996b94235edf2e69b2a943"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openavb__map__pub_8h.html#aecd3b5a2f3996b94235edf2e69b2a943">openavb_map_cfg_cb_t</a> )(<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ, const char *name, const char *value)</td></tr>
<tr class="memdesc:aecd3b5a2f3996b94235edf2e69b2a943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration callback.  <a href="#aecd3b5a2f3996b94235edf2e69b2a943">More...</a><br/></td></tr>
<tr class="separator:aecd3b5a2f3996b94235edf2e69b2a943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbdd1633ab3c9138c69f9114be800039"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="openavb__types__base__pub_8h.html#aa63ef7b996d5487ce35a5a66601f3e73">U8</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openavb__map__pub_8h.html#adbdd1633ab3c9138c69f9114be800039">openavb_map_subtype_cb_t</a> )()</td></tr>
<tr class="memdesc:adbdd1633ab3c9138c69f9114be800039"><td class="mdescLeft">&#160;</td><td class="mdescRight">AVB subtype callback.  <a href="#adbdd1633ab3c9138c69f9114be800039">More...</a><br/></td></tr>
<tr class="separator:adbdd1633ab3c9138c69f9114be800039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de3b82fc1aefe48ffbc65db755f5042"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="openavb__types__base__pub_8h.html#aa63ef7b996d5487ce35a5a66601f3e73">U8</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openavb__map__pub_8h.html#a4de3b82fc1aefe48ffbc65db755f5042">openavb_map_avtp_version_cb_t</a> )()</td></tr>
<tr class="memdesc:a4de3b82fc1aefe48ffbc65db755f5042"><td class="mdescLeft">&#160;</td><td class="mdescRight">AVTP version callback.  <a href="#a4de3b82fc1aefe48ffbc65db755f5042">More...</a><br/></td></tr>
<tr class="separator:a4de3b82fc1aefe48ffbc65db755f5042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afddfddd5a697c398c3c3712bec100eda"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="openavb__types__base__pub_8h.html#a0a0a322d5fa4a546d293a77ba8b4a71f">U16</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openavb__map__pub_8h.html#afddfddd5a697c398c3c3712bec100eda">openavb_map_max_data_size_cb_t</a> )(<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ)</td></tr>
<tr class="memdesc:afddfddd5a697c398c3c3712bec100eda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum data size callback.  <a href="#afddfddd5a697c398c3c3712bec100eda">More...</a><br/></td></tr>
<tr class="separator:afddfddd5a697c398c3c3712bec100eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa632528229a2ae8803b83241f01725d3"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="openavb__types__base__pub_8h.html#a696390429f2f3b644bde8d0322a24124">U32</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openavb__map__pub_8h.html#aa632528229a2ae8803b83241f01725d3">openavb_map_transmit_interval_cb_t</a> )(<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ)</td></tr>
<tr class="memdesc:aa632528229a2ae8803b83241f01725d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit interval callback.  <a href="#aa632528229a2ae8803b83241f01725d3">More...</a><br/></td></tr>
<tr class="separator:aa632528229a2ae8803b83241f01725d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95487a91318d100b069eb45067084b57"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openavb__map__pub_8h.html#a95487a91318d100b069eb45067084b57">openavb_map_gen_init_cb_t</a> )(<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ)</td></tr>
<tr class="memdesc:a95487a91318d100b069eb45067084b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">General initialize callback regardless if a talker or listener.  <a href="#a95487a91318d100b069eb45067084b57">More...</a><br/></td></tr>
<tr class="separator:a95487a91318d100b069eb45067084b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae48dac0e44bab1b54cb3672b8d01ed1"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openavb__map__pub_8h.html#aae48dac0e44bab1b54cb3672b8d01ed1">openavb_map_avdecc_init_cb_t</a> )(<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ, <a class="el" href="openavb__types__base__pub_8h.html#a0a0a322d5fa4a546d293a77ba8b4a71f">U16</a> configIdx, <a class="el" href="openavb__types__base__pub_8h.html#a0a0a322d5fa4a546d293a77ba8b4a71f">U16</a> descriptorType, <a class="el" href="openavb__types__base__pub_8h.html#a0a0a322d5fa4a546d293a77ba8b4a71f">U16</a> descriptorIdx)</td></tr>
<tr class="memdesc:aae48dac0e44bab1b54cb3672b8d01ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">AVDECC initialize callback for both a talker or listener.  <a href="#aae48dac0e44bab1b54cb3672b8d01ed1">More...</a><br/></td></tr>
<tr class="separator:aae48dac0e44bab1b54cb3672b8d01ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4722854577334c96ac70c007970eb00"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openavb__map__pub_8h.html#ab4722854577334c96ac70c007970eb00">openavb_map_tx_init_cb_t</a> )(<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ)</td></tr>
<tr class="memdesc:ab4722854577334c96ac70c007970eb00"><td class="mdescLeft">&#160;</td><td class="mdescRight">A call to this callback indicates that this mapping module will be a talker.  <a href="#ab4722854577334c96ac70c007970eb00">More...</a><br/></td></tr>
<tr class="separator:ab4722854577334c96ac70c007970eb00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a910d5316ace3c70d626e7605e6de837d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="openavb__map__pub_8h.html#adbd7b5e94070d12e84c8740e2027a843">tx_cb_ret_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openavb__map__pub_8h.html#a910d5316ace3c70d626e7605e6de837d">openavb_map_tx_cb_t</a> )(<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ, <a class="el" href="openavb__types__base__pub_8h.html#aa63ef7b996d5487ce35a5a66601f3e73">U8</a> *pData, <a class="el" href="openavb__types__base__pub_8h.html#a696390429f2f3b644bde8d0322a24124">U32</a> *datalen)</td></tr>
<tr class="memdesc:a910d5316ace3c70d626e7605e6de837d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This talker callback will be called for each AVB observation interval.  <a href="#a910d5316ace3c70d626e7605e6de837d">More...</a><br/></td></tr>
<tr class="separator:a910d5316ace3c70d626e7605e6de837d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c87a14c58f84d45f339b6f227f007c1"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openavb__map__pub_8h.html#a7c87a14c58f84d45f339b6f227f007c1">openavb_map_rx_init_cb_t</a> )(<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ)</td></tr>
<tr class="memdesc:a7c87a14c58f84d45f339b6f227f007c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A call to this callback indicates that this mapping module will be a listener.  <a href="#a7c87a14c58f84d45f339b6f227f007c1">More...</a><br/></td></tr>
<tr class="separator:a7c87a14c58f84d45f339b6f227f007c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2c199e0bac41040615def82b7f7904b"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openavb__map__pub_8h.html#aa2c199e0bac41040615def82b7f7904b">openavb_map_rx_cb_t</a> )(<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ, <a class="el" href="openavb__types__base__pub_8h.html#aa63ef7b996d5487ce35a5a66601f3e73">U8</a> *pData, <a class="el" href="openavb__types__base__pub_8h.html#a696390429f2f3b644bde8d0322a24124">U32</a> datalen)</td></tr>
<tr class="memdesc:aa2c199e0bac41040615def82b7f7904b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This callback occurs when running as a listener and data is available.  <a href="#aa2c199e0bac41040615def82b7f7904b">More...</a><br/></td></tr>
<tr class="separator:aa2c199e0bac41040615def82b7f7904b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e1a73cfdb308a3200197098d8be797"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openavb__map__pub_8h.html#ae0e1a73cfdb308a3200197098d8be797">openavb_map_end_cb_t</a> )(<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ)</td></tr>
<tr class="memdesc:ae0e1a73cfdb308a3200197098d8be797"><td class="mdescLeft">&#160;</td><td class="mdescRight">This callback will be called when the stream is closing.  <a href="#ae0e1a73cfdb308a3200197098d8be797">More...</a><br/></td></tr>
<tr class="separator:ae0e1a73cfdb308a3200197098d8be797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219ba596eec186efeca3a30f24469acd"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openavb__map__pub_8h.html#a219ba596eec186efeca3a30f24469acd">openavb_map_gen_end_cb_t</a> )(<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ)</td></tr>
<tr class="memdesc:a219ba596eec186efeca3a30f24469acd"><td class="mdescLeft">&#160;</td><td class="mdescRight">General shutdown callback regardless if a talker or listener.  <a href="#a219ba596eec186efeca3a30f24469acd">More...</a><br/></td></tr>
<tr class="separator:a219ba596eec186efeca3a30f24469acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a820507ca81240c1ccaec5566bacf2c74"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openavb__map__pub_8h.html#a820507ca81240c1ccaec5566bacf2c74">openavb_map_set_src_bitrate_cb_t</a> )(<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ, unsigned int bitrate)</td></tr>
<tr class="memdesc:a820507ca81240c1ccaec5566bacf2c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set source bitrate callback.  <a href="#a820507ca81240c1ccaec5566bacf2c74">More...</a><br/></td></tr>
<tr class="separator:a820507ca81240c1ccaec5566bacf2c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af59631bac0da5eab9a6ad16e86aa8196"><td class="memItemLeft" align="right" valign="top">typedef unsigned int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openavb__map__pub_8h.html#af59631bac0da5eab9a6ad16e86aa8196">openavb_map_get_max_interval_frames_cb_t</a> )(<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ, <a class="el" href="openavb__types__base__pub_8h.html#a4d8ccbeaf8ad040d8880e8971fc62752">SRClassIdx_t</a> sr_class)</td></tr>
<tr class="memdesc:af59631bac0da5eab9a6ad16e86aa8196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get max interval frames.  <a href="#af59631bac0da5eab9a6ad16e86aa8196">More...</a><br/></td></tr>
<tr class="separator:af59631bac0da5eab9a6ad16e86aa8196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d9c3d56d1eedc77fb2d50cc4e23bf4"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openavb__map__pub_8h.html#a31d9c3d56d1eedc77fb2d50cc4e23bf4">openavb_map_initialize_fn_t</a> )(<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ, <a class="el" href="structopenavb__map__cb__t.html">openavb_map_cb_t</a> *pMapCB, <a class="el" href="openavb__types__base__pub_8h.html#a696390429f2f3b644bde8d0322a24124">U32</a> inMaxTransitUsec)</td></tr>
<tr class="memdesc:a31d9c3d56d1eedc77fb2d50cc4e23bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main initialization entry point into the mapping module.  <a href="#a31d9c3d56d1eedc77fb2d50cc4e23bf4">More...</a><br/></td></tr>
<tr class="separator:a31d9c3d56d1eedc77fb2d50cc4e23bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:adbd7b5e94070d12e84c8740e2027a843"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openavb__map__pub_8h.html#adbd7b5e94070d12e84c8740e2027a843">tx_cb_ret_t</a> { <a class="el" href="openavb__map__pub_8h.html#adbd7b5e94070d12e84c8740e2027a843ab5479d73dceb1df51b92da5c5f69120c">TX_CB_RET_PACKET_NOT_READY</a> = 0, 
<a class="el" href="openavb__map__pub_8h.html#adbd7b5e94070d12e84c8740e2027a843a3ebc69a50dc698bf04baf68ad94c4f69">TX_CB_RET_PACKET_READY</a>, 
<a class="el" href="openavb__map__pub_8h.html#adbd7b5e94070d12e84c8740e2027a843a34800c6fe2237f3053802daae4b839ea">TX_CB_RET_MORE_PACKETS</a>
 }</td></tr>
<tr class="memdesc:adbd7b5e94070d12e84c8740e2027a843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return value of talker callback.  <a href="openavb__map__pub_8h.html#adbd7b5e94070d12e84c8740e2027a843">More...</a><br/></td></tr>
<tr class="separator:adbd7b5e94070d12e84c8740e2027a843"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Common mapper module public interface. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="aecd3b5a2f3996b94235edf2e69b2a943"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* openavb_map_cfg_cb_t)(<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ, const char *name, const char *value)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configuration callback. </p>
<p>Each configuration name value pair for this mapping will result in this callback being called. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMediaQ</td><td>A pointer to the media queue for this stream </td></tr>
    <tr><td class="paramname">name</td><td>configuration item name </td></tr>
    <tr><td class="paramname">value</td><td>configuration item value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adbdd1633ab3c9138c69f9114be800039"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="openavb__types__base__pub_8h.html#aa63ef7b996d5487ce35a5a66601f3e73">U8</a>(* openavb_map_subtype_cb_t)()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AVB subtype callback. </p>
<dl class="section return"><dt>Returns</dt><dd>The AVB subtype for this mapping. </dd></dl>

</div>
</div>
<a class="anchor" id="a4de3b82fc1aefe48ffbc65db755f5042"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="openavb__types__base__pub_8h.html#aa63ef7b996d5487ce35a5a66601f3e73">U8</a>(* openavb_map_avtp_version_cb_t)()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AVTP version callback. </p>
<dl class="section return"><dt>Returns</dt><dd>The AVTP version for this mapping. </dd></dl>

</div>
</div>
<a class="anchor" id="afddfddd5a697c398c3c3712bec100eda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="openavb__types__base__pub_8h.html#a0a0a322d5fa4a546d293a77ba8b4a71f">U16</a>(* openavb_map_max_data_size_cb_t)(<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum data size callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMediaQ</td><td>A pointer to the media queue for this stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum data size that will be used. </dd></dl>

</div>
</div>
<a class="anchor" id="aa632528229a2ae8803b83241f01725d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="openavb__types__base__pub_8h.html#a696390429f2f3b644bde8d0322a24124">U32</a>(* openavb_map_transmit_interval_cb_t)(<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmit interval callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMediaQ</td><td>A pointer to the media queue for this stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The intended transmit interval (in frames per second). 0 = default for talker / class. </dd></dl>

</div>
</div>
<a class="anchor" id="a95487a91318d100b069eb45067084b57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* openavb_map_gen_init_cb_t)(<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>General initialize callback regardless if a talker or listener. </p>
<p>Called once during <a class="el" href="openavb__tl__pub_8h.html#a4952af6d10075781ffb320af2ff1665b" title="Open a talker or listener. ">openavbTLOpen()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMediaQ</td><td>A pointer to the media queue for this stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aae48dac0e44bab1b54cb3672b8d01ed1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* openavb_map_avdecc_init_cb_t)(<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ, <a class="el" href="openavb__types__base__pub_8h.html#a0a0a322d5fa4a546d293a77ba8b4a71f">U16</a> configIdx, <a class="el" href="openavb__types__base__pub_8h.html#a0a0a322d5fa4a546d293a77ba8b4a71f">U16</a> descriptorType, <a class="el" href="openavb__types__base__pub_8h.html#a0a0a322d5fa4a546d293a77ba8b4a71f">U16</a> descriptorIdx)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AVDECC initialize callback for both a talker or listener. </p>
<p>Entity model based configuration can be processed at this time. This callback is optional and only executed when AVDECC is used to connect streams. The descriptorType is expected to be of STREAM_INPUT for listeners and STREAM_OUTPUT for talkers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMediaQ</td><td>A pointer to the media queue for this stream </td></tr>
    <tr><td class="paramname">configIdx</td><td>current configuration descriptor index for the Entity Model </td></tr>
    <tr><td class="paramname">descriptorType</td><td>The descriptorType is expected to be of STREAM_INPUT for listeners and STREAM_OUTPUT for talkers. </td></tr>
    <tr><td class="paramname">descriptorIdx</td><td>descriptor index in the Entity Model </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="openavb__intf__pub_8h.html#a7d4f0ffc9c0b2086c7838d0572423796" title="AVDECC initialize callback for both a talker or listener. ">openavb_intf_avdecc_init_cb_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab4722854577334c96ac70c007970eb00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* openavb_map_tx_init_cb_t)(<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A call to this callback indicates that this mapping module will be a talker. </p>
<p>Any talker initialization can be done in this function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMediaQ</td><td>A pointer to the media queue for this stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a910d5316ace3c70d626e7605e6de837d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="openavb__map__pub_8h.html#adbd7b5e94070d12e84c8740e2027a843">tx_cb_ret_t</a>(* openavb_map_tx_cb_t)(<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ, <a class="el" href="openavb__types__base__pub_8h.html#aa63ef7b996d5487ce35a5a66601f3e73">U8</a> *pData, <a class="el" href="openavb__types__base__pub_8h.html#a696390429f2f3b644bde8d0322a24124">U32</a> *datalen)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This talker callback will be called for each AVB observation interval. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMediaQ</td><td>A pointer to the media queue for this stream </td></tr>
    <tr><td class="paramname">pData</td><td>pointer to data </td></tr>
    <tr><td class="paramname">dataLen</td><td>length of data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of enum <a class="el" href="openavb__map__pub_8h.html#adbd7b5e94070d12e84c8740e2027a843">tx_cb_ret_t</a> values. </dd></dl>

</div>
</div>
<a class="anchor" id="a7c87a14c58f84d45f339b6f227f007c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* openavb_map_rx_init_cb_t)(<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A call to this callback indicates that this mapping module will be a listener. </p>
<p>Any listener initialization can be done in this function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMediaQ</td><td>A pointer to the media queue for this stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa2c199e0bac41040615def82b7f7904b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* openavb_map_rx_cb_t)(<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ, <a class="el" href="openavb__types__base__pub_8h.html#aa63ef7b996d5487ce35a5a66601f3e73">U8</a> *pData, <a class="el" href="openavb__types__base__pub_8h.html#a696390429f2f3b644bde8d0322a24124">U32</a> datalen)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This callback occurs when running as a listener and data is available. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMediaQ</td><td>A pointer to the media queue for this stream </td></tr>
    <tr><td class="paramname">pData</td><td>pointer to data </td></tr>
    <tr><td class="paramname">dataLen</td><td>length of data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae0e1a73cfdb308a3200197098d8be797"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* openavb_map_end_cb_t)(<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This callback will be called when the stream is closing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMediaQ</td><td>A pointer to the media queue for this stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a219ba596eec186efeca3a30f24469acd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* openavb_map_gen_end_cb_t)(<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>General shutdown callback regardless if a talker or listener. </p>
<p>Called once during <a class="el" href="openavb__tl__pub_8h.html#ae373dc0cd3617f44e3205bbc2f6d84f4" title="Close the talker or listener. ">openavbTLClose()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMediaQ</td><td>A pointer to the media queue for this stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a820507ca81240c1ccaec5566bacf2c74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* openavb_map_set_src_bitrate_cb_t)(<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ, unsigned int bitrate)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set source bitrate callback. </p>
<p>Used to inform mapping module on the bitrate of the data source (computed by the interface module). The reported bitrate is used by the <a class="el" href="openavb__map__pub_8h.html#af59631bac0da5eab9a6ad16e86aa8196" title="Get max interval frames. ">openavb_map_get_max_interval_frames_cb_t()</a> callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMediaQ</td><td>A pointer to the media queue for this stream </td></tr>
    <tr><td class="paramname">bitrate</td><td>Data source bitrate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This callback is optional, does not need to be implemented in the mapping module. </dd></dl>

</div>
</div>
<a class="anchor" id="af59631bac0da5eab9a6ad16e86aa8196"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned int(* openavb_map_get_max_interval_frames_cb_t)(<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ, <a class="el" href="openavb__types__base__pub_8h.html#a4d8ccbeaf8ad040d8880e8971fc62752">SRClassIdx_t</a> sr_class)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get max interval frames. </p>
<p>Called to get the maximum number of frames per interval for the talker. The calculation is based on the source bitrate provided in the call to <a class="el" href="openavb__map__pub_8h.html#a820507ca81240c1ccaec5566bacf2c74" title="Set source bitrate callback. ">openavb_map_set_src_bitrate_cb_t()</a>. Will override ini file "max_interval_frames" configuration option. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMediaQ</td><td>A pointer to the media queue for this stream </td></tr>
    <tr><td class="paramname">sr_class</td><td>Stream reservation class </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum number of frames per interval</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This callback is optional, does not need to be implemented in the mapping module. </dd></dl>

</div>
</div>
<a class="anchor" id="a31d9c3d56d1eedc77fb2d50cc4e23bf4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* openavb_map_initialize_fn_t)(<a class="el" href="structmedia__q__t.html">media_q_t</a> *pMediaQ, <a class="el" href="structopenavb__map__cb__t.html">openavb_map_cb_t</a> *pMapCB, <a class="el" href="openavb__types__base__pub_8h.html#a696390429f2f3b644bde8d0322a24124">U32</a> inMaxTransitUsec)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main initialization entry point into the mapping module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">pMediaQ</td><td>A pointer to the media queue for this stream </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pMapCB</td><td>Pointer to the callback structure. All the members of this structure must be set during this function call. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">inMaxTransitUsec</td><td>maximum expected latency. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="adbd7b5e94070d12e84c8740e2027a843"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="openavb__map__pub_8h.html#adbd7b5e94070d12e84c8740e2027a843">tx_cb_ret_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return value of talker callback. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="adbd7b5e94070d12e84c8740e2027a843ab5479d73dceb1df51b92da5c5f69120c"></a>TX_CB_RET_PACKET_NOT_READY</em>&#160;</td><td class="fielddoc">
<p>Packet will not be sent on this callback interval. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="adbd7b5e94070d12e84c8740e2027a843a3ebc69a50dc698bf04baf68ad94c4f69"></a>TX_CB_RET_PACKET_READY</em>&#160;</td><td class="fielddoc">
<p>Packet will be sent on this callback interal. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="adbd7b5e94070d12e84c8740e2027a843a34800c6fe2237f3053802daae4b839ea"></a>TX_CB_RET_MORE_PACKETS</em>&#160;</td><td class="fielddoc">
<p>Packet will be sent and the callback called immediately again. </p>
</td></tr>
</table>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Oct 30 2015 08:29:35 for Open-AVB AVTP Pipeline SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
