<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Open-AVB AVTP Pipeline SDK: Media Queue Usage</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="harman_logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Open-AVB AVTP Pipeline SDK
   &#160;<span id="projectnumber">1.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Table&#160;of&#160;Contents</span></a></li>
      <li class="current"><a href="pages.html"><span>Topics</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Media Queue Usage </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>Description</h1>
<p>This section presents the work flow required for working with the Media Queue. Please note that most of the described steps are performed inside the AVB stack and are hidden from interface module implemented. There are also some simplifications to make description as straightforward as possible.</p>
<p><br/>
 </p>
<h1>Workflow</h1>
<p>The following work flow steps will be described.</p>
<ul>
<li><a class="el" href="sdk_notes_media_queue_usage.html#media_queue_usage_start">Starting</a> - Initialization common for talker and listener streams</li>
<li><a class="el" href="sdk_notes_media_queue_usage.html#media_queue_usage_talker">Talker specific</a> - Talker specific usage</li>
<li><a class="el" href="sdk_notes_media_queue_usage.html#media_queue_usage_listener">Listener specific</a> - Listener specific usage</li>
<li><a class="el" href="sdk_notes_media_queue_usage.html#media_queue_usage_stop">Stopping</a> - Stopping procedure common for talker and listener streams</li>
<li><a class="el" href="sdk_notes_media_queue_usage.html#media_queue_usage_rules">Rules</a> - general rules to follow while using the Media Queue</li>
</ul>
<p><br/>
 </p>
<h1><a class="anchor" id="media_queue_usage_start"></a>
Starting </h1>
<p>First the Media Queue has to be created and initialized with correct data. Below are the function calls needed for proper creation and initialization. Note: these calls are initiated from the AVTP module.</p>
<ul>
<li><a class="el" href="openavb__mediaq__pub_8h.html#ad9ac4896a82092d93fb4c21289497194">openavbMediaQCreate</a> - data is allocated, queue is initialized, internal data structures are prepared</li>
<li><a class="el" href="openavb__mediaq__pub_8h.html#abb41c6d762035f1d5e74c91b5ed44f06">openavbMediaQSetMaxStaleTail</a> - sets maximum stale in microseconds before data is being purged</li>
<li>The Interface module initialization function for this media queue is called with media queue as a parameter, those functions<ul>
<li>Set internal interface module parameters</li>
<li>Initialize Media Queue<ul>
<li>Creates Media Queue Interface Module Private Data</li>
<li>Fills the private data structure with information needed by interface module</li>
</ul>
</li>
</ul>
</li>
<li>Stream configuration values are processed. This actually configuration data may come from .ini files or internally set within the AVB host application.</li>
<li>Mapping module init function <a class="el" href="structopenavb__map__cb__t.html#a4431f4da16672d5688dac608cc91471e" title="General initialize callback. ">openavb_map_cb_t::map_gen_init_cb</a> is being called during which several steps (media queue parameters <b>have to</b> be set)<ul>
<li>Media Queue Items count is set</li>
<li>Media Queue Items are allocated</li>
</ul>
</li>
<li>Interface module init function <a class="el" href="structopenavb__intf__cb__t.html#af01edd263b67945ace36cc888ab3d06e" title="General initialize callback. ">openavb_intf_cb_t::intf_gen_init_cb</a> function is called</li>
</ul>
<p>Now the listener/talker stream is running. See next steps below for details of Media Queue interaction for the talker and listener.</p>
<p><br/>
 </p>
<h1><a class="anchor" id="media_queue_usage_talker"></a>
Talker specific flow  </h1>
<p>As a talker, an interface module is responsible for writing data to Media Queue, so important steps are:</p>
<ul>
<li><a class="el" href="openavb__mediaq__pub_8h.html#ae2ce807451447ec2dab9a4284ac61b99">openavbMediaQHeadLock</a> function for getting the head of the media queue and marking it as locked</li>
<li><a class="el" href="openavb__mediaq__pub_8h.html#ac73b08d1568f13b634e2a0f1ef35e11a">openavbMediaQHeadUnlock</a> function which releases head. Any subsequent calls to <a class="el" href="openavb__mediaq__pub_8h.html#ae2ce807451447ec2dab9a4284ac61b99">openavbMediaQHeadLock</a> will return the same MediaQueueItem</li>
<li><a class="el" href="openavb__mediaq__pub_8h.html#a0a57c275ac213fdd14c944741c6e9250">openavbMediaQHeadPush</a> function unlocks head previously taken by the Lock function and informs that work on the current Item is finished so that next call to <a class="el" href="openavb__mediaq__pub_8h.html#ae2ce807451447ec2dab9a4284ac61b99">openavbMediaQHeadLock</a> will return next Media Queue Item. Call of this function makes the item accessible via the <a class="el" href="openavb__mediaq__pub_8h.html#aafa1645c7e234bd011a70063d368b995">openavbMediaQTailLock</a> function. This function additionally unlocks the head so the <a class="el" href="openavb__mediaq__pub_8h.html#ac73b08d1568f13b634e2a0f1ef35e11a">openavbMediaQHeadUnlock</a> call is not needed</li>
</ul>
<p><br/>
 </p>
<h1><a class="anchor" id="media_queue_usage_listener"></a>
Listener specific flow    </h1>
<p>As a listener, an interface module works on Media Queue tail elements. Data in those items is being written by the mapping module. These are the key Media Queue functions for the listener functionality in an interface module:</p>
<ul>
<li><a class="el" href="openavb__mediaq__pub_8h.html#aafa1645c7e234bd011a70063d368b995">openavbMediaQTailLock</a> gets an item from the tail and allows working on the current tail item of the Media Queue</li>
<li><a class="el" href="openavb__mediaq__pub_8h.html#a9b57c7a2cfb99521a7e460bd29b3b31a">openavbMediaQTailUnlock</a> unlocks the tail element in MediaQueue which means that interface module has stopped working on it for now but processing of current tail element will be continued later</li>
<li><a class="el" href="openavb__mediaq__pub_8h.html#ab0525761a2b45c4c14d4fdc80fa24c47">openavbMediaQTailPull</a> unlocks the tail element and removes it from the Media Queue. This means that the interface module has finished processing of current tail element and it can be rewritten again by new data. This function additionally unlocks tail, so it is not necessary to call <a class="el" href="openavb__mediaq__pub_8h.html#a9b57c7a2cfb99521a7e460bd29b3b31a">openavbMediaQTailUnlock</a>.</li>
</ul>
<p><br/>
 </p>
<h1><a class="anchor" id="media_queue_usage_stop"></a>
Stopping     </h1>
<p>During the stopping process following action are taken</p>
<ul>
<li><a class="el" href="structopenavb__intf__cb__t.html#ad91bda1289e1e751fe12453538504b96" title="General shutdown callback. ">openavb_intf_cb_t::intf_gen_end_cb</a> is called</li>
<li><a class="el" href="structopenavb__map__cb__t.html#a1b93f04a3b0c928fd8b1fd869ef8a6e6" title="General shutdown callback. ">openavb_map_cb_t::map_gen_end_cb</a> is called</li>
<li>Media Queue is deleted using the <a class="el" href="openavb__mediaq__pub_8h.html#adddaa9656fd7fcca39d54a3fdb8dc3a9">openavbMediaQDelete</a> function which frees the memory taken by all internal structures of Media Queue</li>
</ul>
<p><br/>
 </p>
<h1><a class="anchor" id="media_queue_usage_rules"></a>
Guidelines    </h1>
<ul>
<li>Calls to <b>Lock</b> functions must always be paired with their <b>Unlock</b> counterparts to avoid problems while working with MediaQueue. Push and Pull functions additional result in an unlock.</li>
<li>The current implementation Media Queue allows accessing two elements at the same time - one is head and second the tail</li>
<li>The number of Media Queue items and their sizes depends on configuration for the stream. The main driving factor is to make the data accessible for the next element that follows interface module. The size of the Media Queue item is a factor of the According to this Media Queue number of size of AVTP stream encapsulation payload multiplied by the packing factor. The number of Media Queue items required if different for a talker and listener. The talker usually needs minimal Media Queue items. However, the listener must have enough Media Queue items to buffer data until the AVTP presentation time. This is based on the maximum transit time for the SR Class in use. ring decoding</li>
<li>If there are not enough Media Queue items warnings will be logged to the implemented logging system for the port for debugging purposes.</li>
</ul>
<p>More implementation details might be find in <a class="el" href="openavb__mediaq__pub_8h.html">openavb_mediaq_pub.h</a> </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Oct 30 2015 08:29:35 for Open-AVB AVTP Pipeline SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
